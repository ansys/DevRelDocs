<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rocky solver SDK: IRockyContactScalarsModel Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Rocky solver SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.xhtml');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Introduction</span></a></li>
      <li><a href="getting_started.xhtml"><span>Getting&#160;started</span></a></li>
      <li><a href="module_specification.xhtml"><span>Module&#160;specification</span></a></li>
      <li><a href="solver_hooks.xhtml"><span>Solver&#160;hooks</span></a></li>
      <li><a href="macros_and_specifiers.xhtml"><span>Macros&#160;and&#160;specifiers</span></a></li>
      <li class="current"><a href="annotated.xhtml"><span>Class&#160;reference</span></a></li>
      <li><a href="usage_examples.xhtml"><span>Usage&#160;examples</span></a></li>
      <li><a href="glossary.xhtml"><span>Glossary</span></a></li>
      <li><a href="changelog.xhtml"><span>Changelog</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.xhtml"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.xhtml"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.xhtml"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.xhtml"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('structIRockyContactScalarsModel.xhtml',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">IRockyContactScalarsModel Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="rocky__contact__scalars_8hpp_source.xhtml">rocky_contact_scalars.hpp</a>&gt;</code></p>

<p>Inherits ScalarsModel&lt; rocky20::BaseContactScalarsController &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad35ceabceb6ec8d839a3e89086643f99" id="r_ad35ceabceb6ec8d839a3e89086643f99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad35ceabceb6ec8d839a3e89086643f99">find</a> (const char *name)</td></tr>
<tr class="separator:ad35ceabceb6ec8d839a3e89086643f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5066c63ea6e2b3b4791f4812b206a65f" id="r_a5066c63ea6e2b3b4791f4812b206a65f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5066c63ea6e2b3b4791f4812b206a65f">reset</a> (int scalar_index)</td></tr>
<tr class="separator:a5066c63ea6e2b3b4791f4812b206a65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95938d3b140e2fbf6b3f417ad88cefd8" id="r_a95938d3b140e2fbf6b3f417ad88cefd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95938d3b140e2fbf6b3f417ad88cefd8">set_dimension</a> (int scalar_index, double dimension_factor)</td></tr>
<tr class="separator:a95938d3b140e2fbf6b3f417ad88cefd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00693cfaa879794cda713e943549644f" id="r_a00693cfaa879794cda713e943549644f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00693cfaa879794cda713e943549644f">add</a> (const char *name, const char *unit, bool output=true)</td></tr>
<tr class="separator:a00693cfaa879794cda713e943549644f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295989b18e690130d92c31881a61ba76" id="r_a295989b18e690130d92c31881a61ba76"><td class="memTemplParams" colspan="2">template&lt;class data_type &gt; </td></tr>
<tr class="memitem:a295989b18e690130d92c31881a61ba76"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a295989b18e690130d92c31881a61ba76">add</a> (const char *name, const char *unit, bool output)</td></tr>
<tr class="separator:a295989b18e690130d92c31881a61ba76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6b2a12584b9aca0884eef45b372e1c" id="r_afd6b2a12584b9aca0884eef45b372e1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd6b2a12584b9aca0884eef45b372e1c">enable_variable_dynamic_friction_coefficient</a> ()</td></tr>
<tr class="separator:afd6b2a12584b9aca0884eef45b372e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8d067f500bb3b7d39f1cb96f993f78" id="r_a3a8d067f500bb3b7d39f1cb96f993f78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a8d067f500bb3b7d39f1cb96f993f78">enable_variable_static_friction_coefficient</a> ()</td></tr>
<tr class="separator:a3a8d067f500bb3b7d39f1cb96f993f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c098d6a1bb42017f323521a267459bd" id="r_a7c098d6a1bb42017f323521a267459bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c098d6a1bb42017f323521a267459bd">enable_variable_restitution_coefficient</a> ()</td></tr>
<tr class="separator:a7c098d6a1bb42017f323521a267459bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8fb75a47341a734ee04707a58f658f" id="r_a8e8fb75a47341a734ee04707a58f658f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e8fb75a47341a734ee04707a58f658f">enable_storage_sliding_distance</a> ()</td></tr>
<tr class="separator:a8e8fb75a47341a734ee04707a58f658f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a383fbe3de38c7aab855c0b775a293b" id="r_a2a383fbe3de38c7aab855c0b775a293b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a383fbe3de38c7aab855c0b775a293b">enable_storage_is_sliding_marker</a> ()</td></tr>
<tr class="separator:a2a383fbe3de38c7aab855c0b775a293b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a65f842ce3bea36ee46b346a2741911" id="r_a5a65f842ce3bea36ee46b346a2741911"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a65f842ce3bea36ee46b346a2741911">enable_storage_tangential_contact_force</a> ()</td></tr>
<tr class="separator:a5a65f842ce3bea36ee46b346a2741911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a72264168db13de798df7cdff440c5" id="r_a30a72264168db13de798df7cdff440c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30a72264168db13de798df7cdff440c5">enable_storage_normal_relative_velocity</a> ()</td></tr>
<tr class="separator:a30a72264168db13de798df7cdff440c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ba6db25bce594fbb62b415b0634a95" id="r_ad8ba6db25bce594fbb62b415b0634a95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8ba6db25bce594fbb62b415b0634a95">enable_storage_tangential_relative_velocity</a> ()</td></tr>
<tr class="separator:ad8ba6db25bce594fbb62b415b0634a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b773628077520e21f189ab64b8b1e69" id="r_a0b773628077520e21f189ab64b8b1e69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b773628077520e21f189ab64b8b1e69">enable_storage_normal_adhesion_force</a> ()</td></tr>
<tr class="separator:a0b773628077520e21f189ab64b8b1e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab390c75dee689878d04d1db89be3fb95" id="r_ab390c75dee689878d04d1db89be3fb95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab390c75dee689878d04d1db89be3fb95">enable_storage_tangential_adhesion_force</a> ()</td></tr>
<tr class="separator:ab390c75dee689878d04d1db89be3fb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a468305e9a49ba36de61846260c1f1" id="r_a36a468305e9a49ba36de61846260c1f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36a468305e9a49ba36de61846260c1f1">enable_storage_previous_normal_vector</a> ()</td></tr>
<tr class="separator:a36a468305e9a49ba36de61846260c1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2927b1c13fc4325a5bd28ba97e15230" id="r_ab2927b1c13fc4325a5bd28ba97e15230"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2927b1c13fc4325a5bd28ba97e15230">enable_previous_moment_vector</a> ()</td></tr>
<tr class="separator:ab2927b1c13fc4325a5bd28ba97e15230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e181ff7eef3349c42038e6b7f9541a" id="r_a29e181ff7eef3349c42038e6b7f9541a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29e181ff7eef3349c42038e6b7f9541a">mark_scalar_as_history_dependent</a> (int scalar_index)</td></tr>
<tr class="separator:a29e181ff7eef3349c42038e6b7f9541a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>During the setup phase of a module, an <code><a class="el" href="structIRockyContactScalarsModel.xhtml">IRockyContactScalarsModel</a></code> object allows users to add new contact scalars, find contact scalars created in other modules, or activate contact scalars known to Rocky. Contact scalars are special variables attached to contacts that store per-contact values preserved between time iterations during a simulation. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a295989b18e690130d92c31881a61ba76" name="a295989b18e690130d92c31881a61ba76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295989b18e690130d92c31881a61ba76">&#9670;&#160;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class data_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int IRockyContactScalarsModel::add </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>unit</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method creates a new scalar variable of type <code>data_type</code></dt><dd>for storing custom values during a simulation, preserving them between time iterations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name given to the scalar variable. The purpose of this name is twofold. First, it enables to find this scalar variable from other module, in order to share their values. Second, if the scalar variable can be displayed in a 3D window as a property, this name will identify it in the Rocky UI.</td></tr>
    <tr><td class="paramname">unit</td><td>A string specifying the unit in S.I. associated to the scalar variable.</td></tr>
    <tr><td class="paramname">output</td><td>Enables/disables the storage in disk at output times, for the visualization and post-processing of the scalar values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index that will uniquely identify the scalar variable during the execution of the simulation. </dd></dl>

</div>
</div>
<a id="a00693cfaa879794cda713e943549644f" name="a00693cfaa879794cda713e943549644f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00693cfaa879794cda713e943549644f">&#9670;&#160;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IRockyContactScalarsModel::add </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>unit</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>output</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method creates a new scalar variable of type <code>double</code></dt><dd>for storing custom values during a simulation, preserving them between time iterations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name given to the scalar variable. The purpose of this name is twofold. First, it enables to find this scalar variable from other module, in order to share their values. Second, if the scalar variable can be displayed in a 3D window as a property, this name will identify it in the Rocky UI.</td></tr>
    <tr><td class="paramname">unit</td><td>A string specifying the unit in S.I. associated to the scalar variable.</td></tr>
    <tr><td class="paramname">output</td><td>Enables/disables the storage in disk at output times, for the visualization and post-processing of the scalar values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index that will uniquely identify the scalar variable during the execution of the simulation. </dd></dl>

</div>
</div>
<a id="ab2927b1c13fc4325a5bd28ba97e15230" name="ab2927b1c13fc4325a5bd28ba97e15230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2927b1c13fc4325a5bd28ba97e15230">&#9670;&#160;</a></span>enable_previous_moment_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRockyContactScalarsModel::enable_previous_moment_vector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method is intended for modules implementing a custom rolling resistance model</dt><dd>in which the rolling resistance is updated on each time iteration. It enables a contact scalar that can be used by a module for storing the moment calculated at a given time iteration in order to make it available in the following iteration. It is highly recommended to use that contact scalar instead of a regular contact scalar, because the Rocky solver will correct the orientation of the stored vector automatically if the contact topology is altered because of an internal reorganization of the array of contacts (a regular contact scalar will not be corrected in such an event). </dd></dl>

</div>
</div>
<a id="a2a383fbe3de38c7aab855c0b775a293b" name="a2a383fbe3de38c7aab855c0b775a293b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a383fbe3de38c7aab855c0b775a293b">&#9670;&#160;</a></span>enable_storage_is_sliding_marker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRockyContactScalarsModel::enable_storage_is_sliding_marker </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method enables a known-scalar that will store a marker that indicates whether a contact</dt><dd>is sliding or not at a given moment. Normally this marker is used only internally in Rocky, but this method can make it available to custom models that may need that information. When that storage has been enabled, the value of the marker for sliding can be accessed by using the <code><a class="el" href="structIRockyContact.xhtml#a1acfe6d4f8e36c9fd417a658aac1c041">IRockyContact::get_is_sliding_marker</a></code> method. </dd></dl>

</div>
</div>
<a id="a0b773628077520e21f189ab64b8b1e69" name="a0b773628077520e21f189ab64b8b1e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b773628077520e21f189ab64b8b1e69">&#9670;&#160;</a></span>enable_storage_normal_adhesion_force()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRockyContactScalarsModel::enable_storage_normal_adhesion_force </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method enables a known-scalar that stores the value of the normal component of the</dt><dd>adhesion force. In this way, if an adhesive force model is active in a simulation, a custom module will have access to the value of that force. When that storage has been enabled, the value of the normal adhesion force can be accessed by using the <code><a class="el" href="structIRockyContact.xhtml#a21587a9de6f69f4af1d215c3879fca66">IRockyContact::get_normal_adhesion_force</a></code> method. </dd></dl>

</div>
</div>
<a id="a30a72264168db13de798df7cdff440c5" name="a30a72264168db13de798df7cdff440c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a72264168db13de798df7cdff440c5">&#9670;&#160;</a></span>enable_storage_normal_relative_velocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRockyContactScalarsModel::enable_storage_normal_relative_velocity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method enables a known-scalar that stores the value of the normal component of the </dt><dd>relative velocity at a contact. In this way that value, which is normally calculated internally by the Rocky solver and used on its own calculations, will be made available for custom modules as well. This can be preferable to the use of the <code><a class="el" href="structIRockyContact.xhtml#af05c086a0b75c761b13fa744061789e4">IRockyContact::calculate_relative_velocity</a></code> method, since that calculation may be expensive. When its storage has been enabled, the value of the normal relative velocity component can be accessed by using the <code><a class="el" href="structIRockyContact.xhtml#a379476b7b01576be8fc0eb3f0dde7a1e">IRockyContact::get_normal_relative_velocity</a></code> method. </dd></dl>

</div>
</div>
<a id="a36a468305e9a49ba36de61846260c1f1" name="a36a468305e9a49ba36de61846260c1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a468305e9a49ba36de61846260c1f1">&#9670;&#160;</a></span>enable_storage_previous_normal_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRockyContactScalarsModel::enable_storage_previous_normal_vector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method enables a known-scalar that stores automatically the value of the contact's</dt><dd>normal unit vector at the end of a time iteration, with the purpose of making it available during the next time iteration. If the storage of this vector has been enabled, it can be accessed during a simulation by using the <code><a class="el" href="structIRockyContact.xhtml#afa684887b3dcfad056850ccfdf399ec3">IRockyContact::get_previous_normal_vector</a></code> method. By comparing this vector to the current normal unit vector, a custom module will be able to determine if a change on the contact's normal direction has occurred between iterations. The Rocky solver will correct the orientation of this vector automatically if the contact topology is altered because of an internal reorganization of the array of contacts (a regular contact scalar will not be corrected in such an event). </dd></dl>

</div>
</div>
<a id="a8e8fb75a47341a734ee04707a58f658f" name="a8e8fb75a47341a734ee04707a58f658f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8fb75a47341a734ee04707a58f658f">&#9670;&#160;</a></span>enable_storage_sliding_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRockyContactScalarsModel::enable_storage_sliding_distance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method enables a known-scalar that stores the value calculated for the sliding </dt><dd>distance during the processing of the contact forces. In this way, that value will be accessible to custom models that may need it for their own calculations. The sliding distance is the distance that a contact point moves parallel to the tangential contact plane during a timestep. When its storage has been enabled, the value of the sliding distance can be accessed by using the <code><a class="el" href="structIRockyContact.xhtml#afe041153be8e43d3e5d7c7a500a49501">IRockyContact::get_sliding_distance</a></code> method. </dd></dl>

</div>
</div>
<a id="ab390c75dee689878d04d1db89be3fb95" name="ab390c75dee689878d04d1db89be3fb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab390c75dee689878d04d1db89be3fb95">&#9670;&#160;</a></span>enable_storage_tangential_adhesion_force()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRockyContactScalarsModel::enable_storage_tangential_adhesion_force </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method enables a known-scalar that stores the value of the tangential component of the</dt><dd>adhesion force. Only some external modules, such as the Liquid Bridge Model module, implement a model in which the adhesion force may have a tangential component. If one of such modules is active in a simulation, a custom module will have access to the value of that force when its storage has been enabled with this method. Then, during the simulation, the value of the tangential adhesion force can be accessed by using the <code><a class="el" href="structIRockyContact.xhtml#a20d7ffad55e1c1c28c848eb3b09c41f2">IRockyContact::get_tangential_adhesion_force</a></code> method. </dd></dl>

</div>
</div>
<a id="a5a65f842ce3bea36ee46b346a2741911" name="a5a65f842ce3bea36ee46b346a2741911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a65f842ce3bea36ee46b346a2741911">&#9670;&#160;</a></span>enable_storage_tangential_contact_force()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRockyContactScalarsModel::enable_storage_tangential_contact_force </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method enables a known-scalar that makes available to custom modules the tangential</dt><dd>force vector that is calculated by any contact tangential force model active in a simulation. The value of this force is not always automatically accessible by custom models. For instance, if users want to use the tangential force value when the Coulomb Limit or any other custom contact tangential force model is active, they will need to enable its storage using this method. When that storage has been enabled, the value of the tangential force vector can be accessed by using the <code><a class="el" href="structIRockyContact.xhtml#aca5aae0a4d0c2033bbad4da067657704">IRockyContact::get_tangential_contact_force</a></code> method. </dd></dl>

</div>
</div>
<a id="ad8ba6db25bce594fbb62b415b0634a95" name="ad8ba6db25bce594fbb62b415b0634a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ba6db25bce594fbb62b415b0634a95">&#9670;&#160;</a></span>enable_storage_tangential_relative_velocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRockyContactScalarsModel::enable_storage_tangential_relative_velocity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method enables a known-scalar that stores the value of the normal component of the</dt><dd>relative velocity at a contact. In this way that value, which is normally calculated internally by the Rocky solver and used on its own calculations, will be made available for custom modules as well. This can be preferable to the use of the <code><a class="el" href="structIRockyContact.xhtml#af05c086a0b75c761b13fa744061789e4">IRockyContact::calculate_relative_velocity</a></code> method, since that calculation may be expensive. When its storage has been enabled, the value of the tangential relative velocity vector can be accessed by using the <code><a class="el" href="structIRockyContact.xhtml#a9fab3f0e6f78ea64e96209fbbd540b85">IRockyContact::get_tangential_relative_velocity</a></code> method. </dd></dl>

</div>
</div>
<a id="afd6b2a12584b9aca0884eef45b372e1c" name="afd6b2a12584b9aca0884eef45b372e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6b2a12584b9aca0884eef45b372e1c">&#9670;&#160;</a></span>enable_variable_dynamic_friction_coefficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRockyContactScalarsModel::enable_variable_dynamic_friction_coefficient </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method enables the dynamic coefficient of friction as a variable property for contacts</dt><dd>that will override the constant values specified per material interaction in the Rocky UI. When a custom module enables this variable property, it becomes responsible for setting a custom value for every contact in the simulation by using the <code><a class="el" href="structIRockyContact.xhtml#aaa4594d0c921983edc1d1033661c6500">IRockyContact::set_dynamic_friction_coefficient</a></code> method. </dd></dl>

</div>
</div>
<a id="a7c098d6a1bb42017f323521a267459bd" name="a7c098d6a1bb42017f323521a267459bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c098d6a1bb42017f323521a267459bd">&#9670;&#160;</a></span>enable_variable_restitution_coefficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRockyContactScalarsModel::enable_variable_restitution_coefficient </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method enables a known-scalar that defines the restitution coefficient as a variable </dt><dd>property at contacts. When this scalar is enabled, a different value of the restitution coefficient can be specified for each contact that arises in a simulation, using the <code><a class="el" href="structIRockyContact.xhtml#ad5f45118ba3d4bdedd2194640fc4c79d">IRockyContact::set_restitution_coefficient</a></code> method. In this case, that value will override the constant values specified for this property through the Rocky UI. </dd></dl>

</div>
</div>
<a id="a3a8d067f500bb3b7d39f1cb96f993f78" name="a3a8d067f500bb3b7d39f1cb96f993f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8d067f500bb3b7d39f1cb96f993f78">&#9670;&#160;</a></span>enable_variable_static_friction_coefficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRockyContactScalarsModel::enable_variable_static_friction_coefficient </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method enables the static coefficient of friction as a variable property for contacts</dt><dd>that will override the constant values specified per material interaction in the Rocky UI. When a custom module enables this variable property, it becomes responsible for setting a custom value for every contact in the simulation by using the <code><a class="el" href="structIRockyContact.xhtml#a5a3233239461058a2f33a9f49494666c">IRockyContact::set_static_friction_coefficient</a></code> method. </dd></dl>

</div>
</div>
<a id="ad35ceabceb6ec8d839a3e89086643f99" name="ad35ceabceb6ec8d839a3e89086643f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35ceabceb6ec8d839a3e89086643f99">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IRockyContactScalarsModel::find </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method searches for a scalar variable already created by other modules,</dt><dd>in order to allow access to its values, or store new values on it, during the execution of the simulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name given to the scalar at the moment of its creation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index that uniquely identifies the wanted scalar if it was actually found. It returns -1 otherwise. </dd></dl>

</div>
</div>
<a id="a29e181ff7eef3349c42038e6b7f9541a" name="a29e181ff7eef3349c42038e6b7f9541a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e181ff7eef3349c42038e6b7f9541a">&#9670;&#160;</a></span>mark_scalar_as_history_dependent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRockyContactScalarsModel::mark_scalar_as_history_dependent </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>scalar_index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method must be used to inform Rocky that a given particle-to-particle contact</dt><dd>scalar stores a 3D vector whose value depends on the history of the contact. Typical cases are 3D vectors whose values are obtained incrementally over time, or a 3D vector whose value is stored for the next time iteration in order to approximate its time derivative. When such scalars are marked using this method, Rocky takes care of preserving the orientation of the vector whenever an internal reordering of the particle indices causes a topological reversal of the contact. If a particle-to-particle contact scalar depending on time is not marked with this method, contact reversals may destabilize the simulation or may lead to completely incorrect results.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar_index</td><td>The index that identifies the specific contact scalar that must be marked as dependent on history. Only particle-to-particle contact scalars of type <code>double3</code> are able to be marked with this method. Any other scalar type will not be affected by contact reversals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5066c63ea6e2b3b4791f4812b206a65f" name="a5066c63ea6e2b3b4791f4812b206a65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5066c63ea6e2b3b4791f4812b206a65f">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRockyContactScalarsModel::reset </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>scalar_index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>This method resets to zero all values stored in a scalar variable.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar_index</td><td>The index attributed to the scalar variable at the moment of its creation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95938d3b140e2fbf6b3f417ad88cefd8" name="a95938d3b140e2fbf6b3f417ad88cefd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95938d3b140e2fbf6b3f417ad88cefd8">&#9670;&#160;</a></span>set_dimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRockyContactScalarsModel::set_dimension </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>scalar_index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dimension_factor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>The purpose of this method is to associate a dimensional factor</dt><dd>to a scalar variable. This factor will be used to nondimensionalize their values. For instance, if the scalar represents a force, a force dimensional factor must be associated through this method. Dimensional factors for the fundamental magnitudes are provided by functions of a <code><a class="el" href="structIRockyModel.xhtml">IRockyModel</a></code> object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar_index</td><td>The index attributed to the scalar variable at the moment of its creation.</td></tr>
    <tr><td class="paramname">dimension_factor</td><td>The appropriate dimensional factor for the scalar variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structIRockyContactScalarsModel.xhtml">IRockyContactScalarsModel</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
