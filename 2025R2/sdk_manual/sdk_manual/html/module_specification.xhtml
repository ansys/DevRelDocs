<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rocky solver SDK: Module specification</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Rocky solver SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.xhtml');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Introduction</span></a></li>
      <li><a href="getting_started.xhtml"><span>Getting&#160;started</span></a></li>
      <li><a href="module_specification.xhtml"><span>Module&#160;specification</span></a></li>
      <li><a href="solver_hooks.xhtml"><span>Solver&#160;hooks</span></a></li>
      <li><a href="macros_and_specifiers.xhtml"><span>Macros&#160;and&#160;specifiers</span></a></li>
      <li><a href="annotated.xhtml"><span>Class&#160;reference</span></a></li>
      <li><a href="usage_examples.xhtml"><span>Usage&#160;examples</span></a></li>
      <li><a href="glossary.xhtml"><span>Glossary</span></a></li>
      <li><a href="changelog.xhtml"><span>Changelog</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('module_specification.xhtml',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Module specification</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs_2sdk__manual_2module__specification"></a></p>
<p>The way that a custom <a class="el" href="glossary.xhtml#module">module</a> must interact with the Rocky UI is specified by means of a Python file. From this file, Rocky extracts two primary kinds of information:</p>
<ul>
<li>The definition of the custom parameters that must be displayed at specific places within the Rocky UI.</li>
<li>Whether or not the module implements a custom model that will override a built-in model or will be added to the existing built-in models in Rocky.</li>
</ul>
<p>The way in which these specifications must be coded is described throughout this chapter. It is assumed that users have a basic knowledge of the Python language.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Structure of the specification file</h2>
<p>The first operation that must be made in the file is the importation of some utilities, most of them defined by the Rocky Solver SDK itself. The following block includes the most commonly needed utilities:</p>
<div class="fragment"><div class="line">from pathlib import Path</div>
<div class="line">from rocky20.addins.addin_models import data_model, container_model</div>
<div class="line">from rocky20.addins.addin_specs import RockyAddinSpecs</div>
<div class="line">from rocky20.addins.addin_types import (Boolean, Quantity, String, List,</div>
<div class="line">        ScalarProperties)</div>
<div class="line">from yapsy.IPlugin import IPlugin</div>
</div><!-- fragment --><p>The most important class that must be defined in the file is the one derived from the <code>IPlugin</code> class because it implements the method <code>get_addin_specs</code>. It is through the <code>get_addin_specs</code> method that Rocky will receive in runtime all the specifications for the module.</p>
<div class="fragment"><div class="line">class CustomModule(IPlugin):</div>
<div class="line">    def get_addin_specs(self):</div>
<div class="line">        return CustomModuleSpecs</div>
</div><!-- fragment --><p>In the example above, <code>CustomModuleSpecs</code> is a class that will contain all the specifications for the module. Its implementation can follow this general example:</p>
<div class="fragment"><div class="line">class CustomModuleSpecs(RockyAddinSpecs):</div>
<div class="line"> </div>
<div class="line">    name = NAME</div>
<div class="line"> </div>
<div class="line">    model = CustomGeneralParameters</div>
<div class="line"> </div>
<div class="line">    instantaneous_breakage_model = CustomModel</div>
<div class="line"> </div>
<div class="line">    material_properties = CustomMaterialProperties</div>
<div class="line"> </div>
<div class="line">    material_interaction_properties = CustomInteractionProperties</div>
<div class="line"> </div>
<div class="line">    geometry_properties = CustomGeometryProperties</div>
<div class="line"> </div>
<div class="line">    particle_group_properties = CustomParticleGroupProperties</div>
<div class="line"> </div>
<div class="line">    particle_input_properties = CustomParticleInputProperties</div>
<div class="line"> </div>
<div class="line">    def CreateAddin(cls):</div>
<div class="line">        return cls.CreateDynamicAddin(Path(__file__).parent, &#39;custom_module_name&#39;)</div>
</div><!-- fragment --><p>The only items whose inclusion is mandatory in this code block are the definition of the variables <code>name</code> and <code>model</code>, besides the definition of the method <code>CreateAddin</code>. The meaning of each one of the members in this class is described as follows:</p>
<ul>
<li><code>name</code> is the string label that will identify the module in the Rocky UI.</li>
<li><code>model</code> is the set of specifications for the module's general parameters. These parameters are not associated to specific entities of the Rocky UI.</li>
<li><code>instantaneous_breakage_model</code> is an example specification of a new custom model for an existing category of models in Rocky. In this case, the module is indicating that it implements a custom model for <a class="el" href="glossary.xhtml#instantaneous-breakage">instantaneous breakage</a>. All customizable models in the current version of Rocky are listed in Table 2.1</li>
<li><code>material_properties</code> is the set of specifications of the module's parameters that Rocky must associate to <a class="el" href="glossary.xhtml#material">materials</a>.</li>
<li><code>material_interaction_properties</code> is the set of specifications of the module's parameters that Rocky must associate to <a class="el" href="glossary.xhtml#material-interaction">materials interactions</a>.</li>
<li><code>geometry_properties</code> is the set of specifications of the module's parameters that Rocky must associate to <a class="el" href="glossary.xhtml#boundary">boundaries</a> (geometries).</li>
<li><code>particle_group_properties</code> is the set of specifications of the module's parameters that Rocky must associate to <a class="el" href="glossary.xhtml#particle-group">particle groups</a>.</li>
<li><code>particle_input_properties</code> is the set of specifications of particle <a class="el" href="glossary.xhtml#scalar">scalar</a> variables that need an initial value when particles enter into the solution domain.</li>
<li><code>CreateAddin</code> is a method that handles the loading of the compiled library file for the module when the simulation starts.</li>
</ul>
<p>For the specification of a module to be complete, each one of the variables in the block above must be properly defined. The simplest case is <code>NAME</code>, which is a simple string label, for instance:</p>
<div class="fragment"><div class="line">NAME = &#39;Custom Module&#39;</div>
</div><!-- fragment --><p>The other variables are in fact classes that contain the specification of each individual parameter needed by the module. Examples of the implementation of such classes are given in the following sections.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Module general properties</h2>
<p>Module general properties are not associated to specific entities in a Rocky UI as are the other types of properties described in the following sections. Therefore, these properties are displayed in the <b>Data Editors</b> panel associated to the module itself, when it is selected in the <b>Data</b> panel, as shown in the example of Figure 2.1.</p>
<div class="image">
<img src="model_param_1.png" alt="" width="30%"/>
</div>
    <p><em>Figure 2.1: General module parameters in the Data Editors panel of the Rocky UI</em></p>
<p>An example of the specification of general parameters for a fictitious module is shown below:</p>
<div class="fragment"><div class="line">@data_model(icon=None, caption=NAME)</div>
<div class="line">class CustomGeneralParameters:</div>
<div class="line">    custom_boolean = Boolean(value=True, caption=&#39;Custom Boolean Parameter&#39;)</div>
<div class="line">    custom_quantity = Quantity(value=0.0, unit=&#39;m&#39;, caption=&#39;Custom Quantity&#39;)</div>
<div class="line">    custom_string = String(value=&#39;string&#39;, caption=&#39;Custom String&#39;)</div>
</div><!-- fragment --><p>This class defines three parameters, each one of a different type. The first one is a boolean parameter, the second one is a numeric parameter, and the third one is a string. When the module is activated in the Rocky UI, these parameters are displayed in the <b>Data</b> panel, as shown in Figure 2.1. When setting up a project, users can define proper values for these parameters, and Rocky will deliver them to the module when the simulation starts. In the specification of the parameters, it must be indicated the default value (the first argument) and the caption that must displayed in the UI (the last argument). Additionally, the corresponding unit must be specified for numeric parameters (the second argument). Units must be specified as strings representing valid units. Although Rocky supports different unit systems, it is advisable that custom modules define parameters using only units from the SI system. Otherwise, all necessary unit conversions will have to be handled by the custom C++ code that implements the module's functionality.</p>
<p>Another possibility of specifying parameters is through lists, which are useful when a module must allow users to create a number of similar parameters. These lists are displayed in the UI as tables, as shown in the example of Figure 2.2. Rows in these tables can be added or removed interactively using the tools provided by the UI. In order to specify a list as the one in the example, the following code must be included:</p>
<div class="fragment"><div class="line">@data_model(icon=None, caption=NAME)</div>
<div class="line">class CustomGeneralParameters:</div>
<div class="line">    custom_list = List(item_class=CustomListSpecs, caption=&#39;Custom List&#39;)</div>
</div><!-- fragment --><div class="image">
<img src="model_param_2.png" alt="" width="30%"/>
</div>
    <p><em>Figure 2.2: General list displayed as a table in the Rocky UI.</em></p>
<p>Here, <code>CustomListSpecs</code> is a class that includes the specification of the parameters in a row of the table. It is possible to specify any number of parameters per row, belonging to any of the three simple types mentioned above: numeric, boolean or string. The parameters in the Figure 2.2 example are specified as follows:</p>
<div class="fragment"><div class="line">@data_model(caption=&#39;ListItem&#39;)</div>
<div class="line">class CustomListSpecs:</div>
<div class="line">    custom_list__boolean = Boolean(value=True, caption=&#39;Boolean&#39;)</div>
<div class="line">    custom_list_quantity_1 = Quantity(value=0.1, unit=&#39;s&#39;, caption=&#39;Quantity 1&#39;)</div>
<div class="line">    custom_list_quantity_2 = Quantity(value=0.2, unit=&#39;m&#39;, caption=&#39;Quantity 2&#39;)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md20"></a>
Module material properties</h2>
<p>A module can add custom properties to <a class="el" href="glossary.xhtml#material">materials</a> apart from the ones defined by default in Rocky. The specification of these new properties must follow the pattern described in the previous section for the general module parameters. The difference is that the custom material properties will be displayed in the <b>Data Editors</b> panel associated to each one of the materials defined in a project, as shown in the example of Figure 2.3.</p>
<div class="image">
<img src="mat_prop.png" alt="" width="30%"/>
</div>
    <p><em>Figure 2.3: Module material properties displayed in the Rocky UI</em></p>
<p>The specification of the parameters shown in the example is defined as follows:</p>
<div class="fragment"><div class="line">@container_model()</div>
<div class="line">class CustomMaterialProperties:</div>
<div class="line">    mat_prop_1 = Quantity(value=0.1, unit=&#39;m&#39;, caption=&#39;Custom Material Property 1&#39;)</div>
<div class="line">    mat_prop_2 = Quantity(value=300.0, unit=&#39;K&#39;, caption=&#39;Custom Material Property 2&#39;)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21"></a>
Module materials interactions properties</h2>
<p>Rocky can associate module parameters to <a class="el" href="glossary.xhtml#material-interaction">materials interactions</a> so that each pair of materials can have different values. The specification of these parameters is similar to the one described in section for the general parameters. In principle, it is possible to specify parameters of any of the types mentioned there.</p>
<p>The materials interactions parameters of a module are displayed as shown in Figure 2.4, below the built-in materials interactions parameters in the <b>Data Editors</b> panel.</p>
<div class="image">
<img src="mat_inter.png" alt="" width="30%"/>
</div>
    <p><em>Figure 2.4: Module materials interaction parameters displayed in the Rocky UI.</em></p>
<p>The specification of the parameters shown in the example is defined as follows:</p>
<div class="fragment"><div class="line">@container_model()</div>
<div class="line">class CustomInteractionProperties:</div>
<div class="line">    custom_mi_quantity_1 = Quantity(value=0.0, unit=&#39;Pa&#39;, caption=&#39;Custom Quantity 1&#39;)</div>
<div class="line">    custom_mi_quantity_2 = Quantity(value=7.0, unit=&#39;-&#39;, caption=&#39;Custom Quantity 2&#39;)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md22"></a>
Module geometry properties</h2>
<p>When Rocky associates module parameters to each one of the individual boundaries in a project, those parameters are called geometry properties. In the Rocky UI, they are displayed in the <b>Data Editors</b> panel as shown in Figure 2.5, when an individual geometry is selected in the <b>Data</b> panel.</p>
<div class="image">
<img src="geom_prop.png" alt="" width="30%"/>
</div>
    <p><em>Figure 2.5: Module geometry properties displayed in the Rocky UI.</em></p>
<p>Parameters of any of the types described in section Module General properties (numeric, boolean, string or list) can be defined. The corresponding specification of the parameter included in the example is defined as follows:</p>
<div class="fragment"><div class="line">@container_model()</div>
<div class="line">class CustomGeometryProperties:</div>
<div class="line">    custom_property = Quantity(value=0.0, unit=&#39;N&#39;, caption=&#39;Custom Geometry Property&#39;)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md23"></a>
Module particle group properties</h2>
<p>When this type of property is defined in a module, different values can be associated to every <a class="el" href="glossary.xhtml#particle-group">particle group</a> in a project. In the Rocky UI, when a specific particle group is selected in the <b>Data</b> panel, a new sub-tab <b>Modules</b> must appear in the <b>Data Editors</b> panel, including the custom particle group's properties defined for all active modules in the project. An example is shown in Figure 2.6. As with other cases, parameters of any of the basic types can be defined (numeric, string, boolean or list). The specification of the parameter in the example is defined as follows:</p>
<div class="fragment"><div class="line">@container_model()</div>
<div class="line">class CustomParticleGroupProperties:</div>
<div class="line">    custom_pg_property = Quantity(value=0.0, unit=&#39;K&#39;,</div>
<div class="line">                                  caption=&#39;Custom Particle Group Property&#39;)</div>
</div><!-- fragment --><div class="image">
<img src="pg_prop.png" alt="" width="30%"/>
</div>
    <p><em>Figure 2.6: Module particle group properties displayed in the Rocky UI</em></p>
<h2><a class="anchor" id="autotoc_md24"></a>
Module particle input properties</h2>
<p>Rocky supports the ability to associate custom values to every particle in a simulation. In Rocky, these values are associated to special variables called particle scalars. They can be used to store particle-related data calculated by the module during the execution of a simulation. When it is necessary to assign a specific initial value to those particle scalars at the moment particles enter the simulation, a particle input property can be defined. In this way, Rocky will include in the <b>Data Editors</b> panel corresponding to a <b>Input</b> an additional sub-tab for defining module-specific particle input data, as shown in Figure 2.7 for a <b>Continuous Injection</b>. An identical sub-tab will be included also for a <b>Volume Fill Input</b>. On the other hand, for a <b>Custom Input</b>, this same information will appear at the bottom of the corresponding tab, in a section labeled with the name of the module. The values of the parameters defined in that section will be applied to all particles in the associated particle group, since it is not possible to associate individual values per particle as it is done with the built-in particle properties.</p>
<div class="image">
<img src="input_prop_sc.png" alt="" width="30%"/>
</div>
    <p><em>Figure 2.7: Custom scalar displayed in the Rocky UI with the initial value set in the module’s particle-input properties sub-tab.</em></p>
<p>The corresponding specification of the particle input property for the example shown in Figure 2.7 is defined as follows:</p>
<div class="fragment"><div class="line">@container_model()</div>
<div class="line">class CustomParticleInputProperties:</div>
<div class="line">    custom_scalar = ScalarProperties(</div>
<div class="line">        value=1.0, unit=&#39;kg&#39;, caption=&#39;Custom Scalar&#39;, output=True, input=True</div>
<div class="line">    )</div>
</div><!-- fragment --><p>A specification like the one shown above defines both a new particle scalar variable and a custom particle input property. As shown in Figure 2.7, in this way users will be able to enter the initial value of the new particle scalar variable through the Rocky UI. The last argument <code>input=True</code> in the scalar variable specification enables that option. The other additional argument, <code>output=True</code>, instructs Rocky that the values of the new particle scalar must be stored in disk throughout a simulation, and be able to be displayed in a 3D view window at output times, as shown in Figure 2.7.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Specification of custom models</h2>
<p>One of the main motivations for developing custom modules is to add new models and capabilities to Rocky. Currently, most of the categories of models are customizable using the Rocky Solver SDK. Table 2.1 summarizes all categories of models that can be implemented in the current version of Rocky through custom modules.</p>
<p>As mentioned in section Structure of the specification file, the module specification file must inform Rocky which models the module is actually implementing. Based on this specification, Rocky will either override built-in models in some categories or add the implemented custom models to the list of available built-in models in other categories. In order to specify that a module will implement a custom model, the specification class must include an attribute member with a predefined name, which must correspond to a given model category. The second column of Table 2.1 lists all attribute names recognized by Rocky as model categories.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Model category   </th><th class="markdownTableHeadNone">Class attribute   </th><th class="markdownTableHeadNone">Behavior    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Contact force, normal component   </td><td class="markdownTableBodyNone">normal_force_model   </td><td class="markdownTableBodyNone">override    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Contact force, tangential component   </td><td class="markdownTableBodyNone">tangential_force_model   </td><td class="markdownTableBodyNone">override    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Impact energy for instantaneous breakage   </td><td class="markdownTableBodyNone">impact_energy_model   </td><td class="markdownTableBodyNone">override    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Rolling resistance moments   </td><td class="markdownTableBodyNone">rolling_resistance_model   </td><td class="markdownTableBodyNone">override    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Adhesion force   </td><td class="markdownTableBodyNone">adhesion_model   </td><td class="markdownTableBodyNone">override    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Joint mechanics in flexible particles 2   </td><td class="markdownTableBodyNone">joint_model   </td><td class="markdownTableBodyNone">addition    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Discrete breakage of flexible particles   </td><td class="markdownTableBodyNone">joint_breakage_model   </td><td class="markdownTableBodyNone">addition    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Instantaneous breakage of rigid polyhedral particles   </td><td class="markdownTableBodyNone">instantaneous_breakage_model   </td><td class="markdownTableBodyNone">addition    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Distribution of fragment sizes for instantaneous breakage   </td><td class="markdownTableBodyNone">fragments_size_distribution_model   </td><td class="markdownTableBodyNone">addition    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Wear of surfaces due particle collisions   </td><td class="markdownTableBodyNone">geometries_wear_model   </td><td class="markdownTableBodyNone">addition    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Conduction heat transfer rate at contacts   </td><td class="markdownTableBodyNone">heat_conduction_model   </td><td class="markdownTableBodyNone">override    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Integration of the particle energy equation 2   </td><td class="markdownTableBodyNone">thermal_integration_model   </td><td class="markdownTableBodyNone">override    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Custom kernel motion for moving geometries   </td><td class="markdownTableBodyNone">geometries_motion   </td><td class="markdownTableBodyNone">–    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CFD coupling, drag force   </td><td class="markdownTableBodyNone">cfd_drag_law_model   </td><td class="markdownTableBodyNone">addition    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CFD coupling, lift force   </td><td class="markdownTableBodyNone">cfd_lift_law_model   </td><td class="markdownTableBodyNone">addition    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CFD coupling, virtual mass force   </td><td class="markdownTableBodyNone">cfd_virtual_mass_law_model   </td><td class="markdownTableBodyNone">addition    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CFD coupling, flow-induced torque   </td><td class="markdownTableBodyNone">cfd_torque_law_model   </td><td class="markdownTableBodyNone">addition    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CFD coupling, convection heat transfer rate   </td><td class="markdownTableBodyNone">cfd_convection_law_model   </td><td class="markdownTableBodyNone">addition    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SPH heat transfer between fluid elements and between fluid elements and geometries   </td><td class="markdownTableBodyNone">sph_heat_transfer_model   </td><td class="markdownTableBodyNone">override    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">All SPH forces between fluid elements and between fluid elements and geometries   </td><td class="markdownTableBodyNone">sph_force_model   </td><td class="markdownTableBodyNone">override    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Only SPH viscous forces between fluid elements and between fluid elements and geometries   </td><td class="markdownTableBodyNone">sph_viscous_force_model   </td><td class="markdownTableBodyNone">override    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SPH forces due surface tension   </td><td class="markdownTableBodyNone">sph_surface_tension_model   </td><td class="markdownTableBodyNone">override   </td></tr>
</table>
<p><em>Table 2.1: Class attributes associated to customizable model categories in Rocky</em></p>
<p>The support of custom SPH forces through the <code>sph_force_model</code> specification was an experimental feature in previous versions of Rocky. It overrides all force values calculated internally, including for instance, pressure, viscous and surface tension forces. Therefore, a custom module including that specification is supposed to implement the calculation of all those forces.</p>
<p>The following is an example of the specification of a module that implements a custom contact model, including the normal and tangential components of the contact force:</p>
<div class="fragment"><div class="line">class CustomModuleSpecs(RockyAddinSpecs):</div>
<div class="line"> </div>
<div class="line">    name = &#39;Custom Module Example&#39;</div>
<div class="line"> </div>
<div class="line">    model = CustomGeneralParameters</div>
<div class="line"> </div>
<div class="line">    normal_force_model = CustomModel</div>
<div class="line"> </div>
<div class="line">    tangential_force_model = CustomModel</div>
<div class="line"> </div>
<div class="line">    def CreateAddin(cls):</div>
<div class="line">        return cls.CreateDynamicAddin(Path(__file__).parent, &#39;custom_module_name&#39;)</div>
</div><!-- fragment --><p>Currently it is not possible to associate properties to a custom model itself, therefore CustomModel in the example above can be an empty class, defined as:</p>
<div class="fragment"><div class="line">@container_model()</div>
<div class="line">class CustomModel:</div>
<div class="line">    pass</div>
</div><!-- fragment --><p>As mentioned earlier, there are two possible ways in which the Rocky UI may treat a custom model:</p>
<ul>
<li>For model categories with global scope, like contact force models, Rocky will override any other model in the category if a module that implements a custom model in that category is enabled in a project. In that situation, all calculations related to the model category will be performed by the code in the custom module. As an illustration, Figure 2.8 shows how the contact force model categories are displayed in the <b>Physics</b> panel when the module specified by the previous code example is turned on in the project. When this situation occurs, it won't be possible to select any other model in those categories until the referred module is turned off. All model categories that behave in this way are marked with the word "override" in the third column of Table 2.1</li>
</ul>
<div class="image">
<img src="mod_override.png" alt="" width="30%"/>
</div>
    <p><em>Figure 2.8: Example of custom models overriding other models in the Rocky UI.</em></p>
<ul>
<li>For model categories with scope per particle group or geometry, Rocky will add the custom model implemented by a module to the list of available models in the category. This can be observed in the example shown in Figure 2.9, in which a custom <a class="el" href="glossary.xhtml#joint">joint</a> model implemented by a module named <em>Custom Module Example</em> is listed along with the built-in joint models. All model categories that behave in this way are marked with the word "addition" in the third column of Table 2.1.</li>
</ul>
<div class="image">
<img src="mod_add.png" alt="" width="30%"/>
</div>
    <p><em>Figure 2.9: Example of a custom model being added to the available models in a category.</em></p>
<p>Although any module could be, in principle, include the implementation of several custom models, it is advisable to restrict only one custom model per module. The exception to this rule would be those models that have strong interdependence or that may share data between them. The typical example of the former case is the trio formed by the normal contact force, the tangential force and the impact energy models, in which the second one depends on the first, and the third one may depend on the other two. An example of the latter case is the pair of models instantaneous breakage and fragment size distribution, in which the first one can calculate custom data needed by the second one.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Specification of variable properties</h2>
<p>Since Rocky 2022R1, the Rocky Solver SDK gives developers the ability of setting values of selected physical properties during a simulation. In that way, properties that normally would have constant values during a whole simulation become variable properties that may depend on time, position or other simulation variables.</p>
<p>A module that will calculate and set values of such variable properties must indicate in the specification file which properties it will override. An example of how that specification must be done is shown in the following code snippet:</p>
<div class="fragment"><div class="line">class CustomModuleSpecs(RockyAddinSpecs):</div>
<div class="line"> </div>
<div class="line">    name = &#39;Custom Properties Example&#39;</div>
<div class="line"> </div>
<div class="line">    model = CustomGeneralParameters</div>
<div class="line"> </div>
<div class="line">    particle_material_properties = ParticleVariableProperties</div>
<div class="line"> </div>
<div class="line">    triangle_material_properties = TriangleVariableProperties</div>
<div class="line"> </div>
<div class="line">    def CreateAddin(cls):</div>
<div class="line">        return cls.CreateDynamicAddin(Path(__file__).parent, &#39;custom_module_name&#39;)</div>
</div><!-- fragment --><p>The two specification keys <code>particle_material_properties</code> and <code>triangle_material_properties</code> indicate that the module will override material properties affecting particles and boundary triangles. The Table 2.2 lists the four categories of properties whose values can be overridden by custom modules, indicating the corresponding specification keys that must be used.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Category of properties   </th><th class="markdownTableHeadNone">Specification key    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Material properties used by particles   </td><td class="markdownTableBodyNone">particle_material_properties    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Material properties used by boundaries   </td><td class="markdownTableBodyNone">triangle_material_properties    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Material interaction properties used in particle-to-particle contacts   </td><td class="markdownTableBodyNone">particle_material_interaction_properties    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Material interaction properties used in particle-to-boundary contacts   </td><td class="markdownTableBodyNone">triangle_material_interaction_properties    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Geometry properties   </td><td class="markdownTableBodyNone">geometry_triangle_properties   </td></tr>
</table>
<p><em>Table 2.2: Specification keys for different categories of properties.</em></p>
<p>Besides indicating the categories of properties, the module must specify which individual properties on each category will be overridden. This must be done by defining additional classes, as indicated in the following code snippets:</p>
<div class="fragment"><div class="line">@container_model()</div>
<div class="line">class ParticleVariableProperties:</div>
<div class="line">    thermal_conductivity = ThermalConductivity</div>
<div class="line">    specific_heat = SpecificHeat</div>
</div><!-- fragment --><p><br  />
</p>
<div class="fragment"><div class="line">@container_model()</div>
<div class="line">class TriangleVariableProperties:</div>
<div class="line">    thermal_conductivity = ThermalConductivity</div>
</div><!-- fragment --><p>Regarding the properties for particles, the first snippet code above indicates that the thermal conductivity and the specific heat will be overridden by values stored in particle scalars that Rocky will define internally. By specifying that, the module is taking responsibility for setting values of those properties for every particle in a simulation. That implies that values specified through the Rocky UI for those properties will be ignored by the Rocky solver. Table 2.3 lists all the material properties associated to particles that can be overridden by custom modules in the current version of Rocky.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type of property   </th><th class="markdownTableHeadNone">Specification key   </th><th class="markdownTableHeadNone">Rocky's internal scalar    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Thermal conductivity   </td><td class="markdownTableBodyNone">thermal_conductivity   </td><td class="markdownTableBodyNone">ThermalConductivity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Specific heat   </td><td class="markdownTableBodyNone">specific_heat   </td><td class="markdownTableBodyNone">SpecificHeat    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Poisson’s ratio   </td><td class="markdownTableBodyNone">poisson_ratio   </td><td class="markdownTableBodyNone">PoissonRatio   </td></tr>
</table>
<p><em>Table 2.3: Particle material properties whose values may be overridden by custom modules</em></p>
<p>Similarly, the second code snippet shown above indicates that the module will replace also the thermal conductivity values specified for materials associated to boundaries. In that way, the constant value specified normally for a whole boundary will be effectively replaced by a set of values, one for each triangle making up a boundary, that the module will have to specify within the C++ code associated to it. Rocky will use internally a triangle scalar for storing the values of each one of the properties that the module will override. Table 2.4 lists the boundary properties that a custom module can redefine as variable properties in the current version of Rocky.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type of property   </th><th class="markdownTableHeadNone">Specification key   </th><th class="markdownTableHeadNone">Rocky's internal scalar    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Thermal conductivity   </td><td class="markdownTableBodyNone">thermal_conductivity   </td><td class="markdownTableBodyNone">ThermalConductivity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Poisson’s ratio   </td><td class="markdownTableBodyNone">poisson_ratio   </td><td class="markdownTableBodyNone">PoissonRatio   </td></tr>
</table>
<p><em>Table 2.4: Boundary material properties that may be overridden by custom modules, setting values per boundary triangle</em></p>
<p>The Rocky Solver SDK also supports the substitution of the material interaction properties indicated in Table 2.5. In that case, the constant values originally specified for those properties are replaced by a set of values, each one for a particle-to-particle contact or a particle-to-boundary contact, which Rocky will store internally in contact scalars. The specification of the overriding of material interaction properties is equivalent to the one shown previously for material properties. The main difference is that it uses <code>particle_material_interaction_properties</code> or <code>triangle_material_interaction_properties</code> as specification key, as indicated in Table 2.2.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type of property   </th><th class="markdownTableHeadNone">Specification key   </th><th class="markdownTableHeadNone">Rocky's internal scalar    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Coefficient of restitution   </td><td class="markdownTableBodyNone">restitution_coefficient   </td><td class="markdownTableBodyNone">RestitutionCoefficient    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Coefficient of static friction   </td><td class="markdownTableBodyNone">static_friction   </td><td class="markdownTableBodyNone">StaticFriction    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Coefficient of dynamic friction   </td><td class="markdownTableBodyNone">dynamic_friction   </td><td class="markdownTableBodyNone">DynamicFriction   </td></tr>
</table>
<p><em>Table 2.5: Material interaction properties whose values may be overridden by custom modules, for both particle-to-particle and particle-to-boundary contacts.</em></p>
<p>The Rocky Solver SDK also allows developers to override the temperature prescribed per geometry, replacing it by a set of temperature values per triangle. As shown in Table 2.6, currently this is the only geometry property that is enabled to be replaced by a custom module. An example is presented later on in section <a class="el" href="usage_examples.xhtml#a-module-implementing-variable-properties">A module implementing variable properties</a> that shows how a module can perform that replacement.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type of property   </th><th class="markdownTableHeadNone">Specification key   </th><th class="markdownTableHeadNone">Rocky's internal scalar    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Temperature   </td><td class="markdownTableBodyNone">temperature   </td><td class="markdownTableBodyNone">Temperature   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md27"></a>
The .plugin file</h2>
<p>In addition to the Python file containing an <code>IPlugin</code> subclass, every module needs a <code>.plugin</code> file that contains metadata about the module itself. Most of this metadata is not used by Rocky and serves informational purposes for module users only. However, the file itself is necessary because it is how the application discovers the module at runtime.</p>
<p>The file is written in a configuration language similar to the INI format used in Microsoft Windows configuration files. Here's a sample of its contents and a description of the fields:</p>
<div class="fragment"><div class="line">[Core]</div>
<div class="line">Name = Sample Module</div>
<div class="line">Module = sample_module</div>
<div class="line"> </div>
<div class="line">[Documentation]</div>
<div class="line">Author = Module Author</div>
<div class="line">Version = 1.0</div>
<div class="line">Website = www.example.com</div>
<div class="line">Description = A short description of the module&#39;s functionalities.</div>
<div class="line">    You can span multiple lines by indenting after the first one, like this.</div>
</div><!-- fragment --><p>where:</p>
<ul>
<li><code>Name</code> is the human-readable name of the Module, and should match the value provided in the specification class (section Structure of the specification file).</li>
<li><code>Module</code> is the name of the Python file that contains the <code>IPlugin</code> subclass, without the <code>.py</code> extension.</li>
<li><code>Author</code> is the name of the module's author.</li>
<li><code>Version</code> is the version of the module itself, which is used when updating the module with new features and bug fixes (see section <a class="el" href="#module-version">Module version</a>).</li>
<li><code>Website</code> is the website or email, used as contact information.</li>
<li><code>Description</code> is a free-form short description of the module's purpose and features.</li>
</ul>
<p>See Section <a href="annotated.xhtml">Reference</a> for an example plugin file.</p>
<h2><a class="anchor" id="module-version"></a>
Module version</h2>
<p>Every module has two versions: one "explicit" version, defined by the module author in its <code>.plugin</code> file (section Plugin File), and the version of the Solver SDK for which the module was built. While Rocky doesn't impose any kind of semantics on the author-defined version, it can be used to convey to module users the expected stability and completeness of modules.</p>
<p>One suggestion is to use <a href="https://semver.org/">semantic versioning</a> when defining a module's version. Briefly, the module can follow a "X.Y.Z" format, where:</p>
<ul>
<li>Increment the major version <em>X</em> when your module changes in a way that is incompatible with previous versions;</li>
<li>Increment the minor version <em>Y</em> when your module gains new features in a backwards-compatible way;</li>
<li>Increment the patch version <em>Z</em> when your make backwards-compatible bug fixes only.</li>
</ul>
<h3><a class="anchor" id="autotoc_md28"></a>
Migrating between module versions</h3>
<p>When a module is changed in a way that makes the new specification incompatible with the old one, the author can write a function to <em>migrate</em> module properties defined in the old format to the new one. This can happen, for example, when a Rocky project containing data saved in the old specification is opened when the new specification is available.</p>
<p>The module author can indicate that the specification handles these migrations by implementing the following function in their specification subclass:</p>
<div class="fragment"><div class="line">@container_model()</div>
<div class="line">class CustomModuleSpecs(RockyAddinSpecs):</div>
<div class="line">    ...</div>
<div class="line">    @classmethod</div>
<div class="line">    def MigrateProperties(self, previous, current):</div>
</div><!-- fragment --><p>where <code>previous</code> and <code>current</code> contain data related to the previous and current versions of the module, respectively. Each object contains the following attributes:</p>
<ul>
<li><code>addin_version</code> is the version of the module;</li>
<li><code>sdk_version</code> is the version of the SDK;</li>
<li><code>snapshot</code> is a Python dictionary containing the user-provided values for the properties described by the module's specification.</li>
</ul>
<p>As an example: suppose that the author of <code>CustomModuleSpecs</code>'s module renamed a material property from <code>old_name</code> to <code>new_name</code> and updated the module's version from "1.0.0" to "2.0.0". When opening an existing project that was originally saved using version "1.0.0" of the module, the following code would copy the value of the property called <code>old_name</code> in the previous snapshot to the property called <code>new_name</code> in the current snapshot, for every material defined in the project that is being loaded:</p>
<div class="fragment"><div class="line">@container_model()</div>
<div class="line">class CustomModuleSpecs(RockyAddinSpecs):</div>
<div class="line">    ...</div>
<div class="line">    classmethod</div>
<div class="line">    def MigrateProperties(self, previous, current):</div>
<div class="line">        if previous.addin_version == &#39;1.0.0&#39; and current.addin_version == &#39;2.0.0&#39;:</div>
<div class="line">            previous_materials = previous.snapshot[&#39;material_properties&#39;]</div>
<div class="line">            current_materials = current.snapshot[&#39;material_properties&#39;]</div>
<div class="line"> </div>
<div class="line">            for previous_material, current_material in zip(</div>
<div class="line">                previous_materials.values(), current_materials.values()</div>
<div class="line">            ):</div>
<div class="line">                current_material[&#39;new_name&#39;] = previous_material[&#39;old_name&#39;]</div>
<div class="line"> </div>
<div class="line">            return True</div>
<div class="line">        return False</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
