<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rocky solver SDK: Usage examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Rocky solver SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.xhtml');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Introduction</span></a></li>
      <li><a href="getting_started.xhtml"><span>Getting&#160;started</span></a></li>
      <li><a href="module_specification.xhtml"><span>Module&#160;specification</span></a></li>
      <li><a href="solver_hooks.xhtml"><span>Solver&#160;hooks</span></a></li>
      <li><a href="macros_and_specifiers.xhtml"><span>Macros&#160;and&#160;specifiers</span></a></li>
      <li><a href="annotated.xhtml"><span>Class&#160;reference</span></a></li>
      <li><a href="usage_examples.xhtml"><span>Usage&#160;examples</span></a></li>
      <li><a href="glossary.xhtml"><span>Glossary</span></a></li>
      <li><a href="changelog.xhtml"><span>Changelog</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('usage_examples.xhtml',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Usage examples</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs_2sdk__manual_2usage__examples"></a></p>
<p>The first section of this chapter provides a step-by-step description of the implementation of a simple but fully functional module using the Rocky Solver SDK. The whole process is covered, from the implementation of all the required source files, until the execution of the compiled module. The second section describes the code associated to a custom module that implements a contact model.</p>
<h2><a class="anchor" id="autotoc_md117"></a>
A simple custom module</h2>
<p>This section describes the implementation of the code of a simple module in order to illustrate the use of the Rocky Solver SDK. The example module is called <code>Spherical Region</code>. Its only purpose is to allow users to define a region of spherical shape inside the simulation domain, and mark all particles located inside this region at any given time.</p>
<p>The source files detailed below should be saved in the following directory structure:</p>
<div class="fragment"><div class="line">spherical_region/</div>
<div class="line">    CMakeLists.txt</div>
<div class="line">    spherical_region.cu</div>
<div class="line">    spherical_region.plugin</div>
<div class="line">    spherical_region.py</div>
<div class="line">    spherical_region.pdf</div>
</div><!-- fragment --><p>The following sections reproduce and describe the content of each one of the four source files. For a walk-through example of setting up and using this simple custom module, refer to <em>Tutorial 23: Rocky Solver SDK</em>.</p>
<h3><a class="anchor" id="autotoc_md118"></a>
File spherical_region.plugin</h3>
<div class="fragment"><div class="line">[Core]</div>
<div class="line">Name = Spherical Region</div>
<div class="line">Module = spherical_region</div>
<div class="line"> </div>
<div class="line">[Documentation]</div>
<div class="line">Author = Rocky user</div>
<div class="line">Version = 1.0</div>
<div class="line">Website = user@domain.org</div>
<div class="line">Description = Marks particles inside a spherical region</div>
</div><!-- fragment --><p>The purpose of this file is to give Rocky general information about the module. For instance, line 2 defines the name of the module as it must be displayed in the Rocky UI. Similarly, line 3 gives the name of the compiled library file of the module in the filesystem. The data in the block between lines 5 and 9 is displayed within the <b>Info</b> tab associated to the module in the Rocky UI.</p>
<h3><a class="anchor" id="autotoc_md119"></a>
File spherical_region.py</h3>
<p>This is a Python file that specifies which are the module parameters that must be displayed in the Rocky UI*. When a project is set up in Rocky and the module is enabled, users will be able to enter values for all parameters defined in this file, through the Rocky UI. Refer to chapter Module specification for a complete description of how different types of data can be specified by means of this file.</p>
<div class="fragment"><div class="line">1   from pathlib import Path</div>
<div class="line">2</div>
<div class="line">3   from yapsy.IPlugin import IPlugin</div>
<div class="line">4</div>
<div class="line">5   from rocky20.addins.addin_models import container_model, data_model</div>
<div class="line">6   from rocky20.addins.addin_specs import RockyAddinSpecs</div>
<div class="line">7   from rocky20.addins.addin_types import Quantity</div>
<div class="line">8</div>
<div class="line">9   NAME = &#39;Spherical Region&#39;</div>
<div class="line">10</div>
<div class="line">11</div>
<div class="line">12  @data_model(icon=None, caption=NAME)</div>
<div class="line">13  class SphericalRegionModel:</div>
<div class="line">14      center_x = Quantity(value=0.0, unit=&#39;m&#39;, caption=&#39;Center Coordinate X&#39;)</div>
<div class="line">15      center_y = Quantity(value=0.0, unit=&#39;m&#39;, caption=&#39;Center Coordinate Y&#39;)</div>
<div class="line">16      center_z = Quantity(value=0.0, unit=&#39;m&#39;, caption=&#39;Center Coordinate Z&#39;)</div>
<div class="line">17      radius = Quantity(value=1.0, unit=&#39;m&#39;, caption=&#39;Sphere Radius&#39;)</div>
<div class="line">18</div>
<div class="line">19</div>
<div class="line">20  class SphericalRegionSpecs(RockyAddinSpecs):</div>
<div class="line">21</div>
<div class="line">22      name = NAME</div>
<div class="line">23</div>
<div class="line">24      model = SphericalRegionModel</div>
<div class="line">25</div>
<div class="line">26      @classmethod</div>
<div class="line">27      def CreateAddin(cls):</div>
<div class="line">28          return cls.CreateDynamicAddin(Path(__file__).parent, &#39;spherical_region&#39;)</div>
<div class="line">29</div>
<div class="line">30</div>
<div class="line">31  class SphericalRegionModule(IPlugin):</div>
<div class="line">32      def get_addin_specs(self):</div>
<div class="line">33          return SphericalRegionSpecs</div>
</div><!-- fragment --><p>SDK utilities necessary for specifying the module data are imported in the block between lines 1 and 5. Line 7 defines the name of the module that Rocky must show in the UI. Beginning at line 10, the auxiliary class <code>SphericalRegionModel</code> is defined, which includes the specification of the four parameters that the model needs. They are the three Cartesian coordinates of the sphere center and the sphere radius.</p>
<p>Between lines 18 and 26, the <code>SphericalRegionSpecs</code> class is defined, which in this case includes only the definition of the name of the module and the specification of the parameters previously included in the <code>SphericalRegionModel</code> class. Additionally, the <code>CreateAddin</code> method is defined, which handles the loading of the compiled library file for the module when the simulation starts.</p>
<p>Finally, at line 29, the definition of the <code>SphericalRegionModule</code> class is included. Only one method is implemented in this class, <code>get_addin_specs</code>, which makes available all the specifications made previously in the file.</p>
<h3><a class="anchor" id="autotoc_md120"></a>
File spherical_region.pdf</h3>
<p>This is an optional help file that may include usage instructions and/or technical details about the implementation of the module. If included, Rocky will automatically link it to a special icon displayed in the UI that will allow users of the module to open the file.</p>
<h3><a class="anchor" id="autotoc_md121"></a>
File CMakeLists.txt</h3>
<p>This file includes compilation, linkage and install instructions in the CMake language, needed to build the module. Several commands defined by the Rocky SDK are used in order to simplify this file. The content of this file must be practically the same reproduced below for any custom module implemented using the Rocky Solver SDK. Users only have to replace the actual name of the compiled library at line 3 and define the <code>ROCKY_PLUGINS_PATH</code> environment variable with the directory in which the compiled modules must be installed, if this definition has not been made previously.</p>
<div class="fragment"><div class="line">find_package(RockySDK REQUIRED)</div>
<div class="line"> </div>
<div class="line">set(PKG_NAME &quot;spherical_region&quot;)</div>
<div class="line"> </div>
<div class="line">cuda_add_library(${PKG_NAME} SHARED ${PKG_NAME}.cu)</div>
<div class="line">target_link_libraries(${PKG_NAME} ${RockySDK_LIBRARIES})</div>
<div class="line"> </div>
<div class="line">set(ASSETS_LIST &quot;${PKG_NAME}.plugin&quot; &quot;${PKG_NAME}.py&quot;)</div>
<div class="line"> </div>
<div class="line">install_rocky_plugin(${PKG_NAME} ASSETS_LIST)</div>
</div><!-- fragment --><p>If the module includes a help <code>pdf</code> file, the line 8 must include this file in the list of module assets, in the following way:</p>
<div class="fragment"><div class="line">set(ASSETS_LIST &quot;${PKG_NAME}.plugin&quot; &quot;${PKG_NAME}.py&quot; &quot;${PKG_NAME}.pdf&quot;)</div>
</div><!-- fragment --><p>On the other hand, if for some reason the module must be installed in a directory different from the one pointed to by the environment variable <code>ROCKY_PLUGINS_PATH</code>, the following additional line can be inserted between lines 3 and 5:</p>
<div class="fragment"><div class="line">set(ROCKY_PLUGIN_INSTALLATION_DIR ${CMAKE_CURRENT_SOURCE_DIR}/custom_path/)</div>
</div><!-- fragment --><p>where <code>custom_path</code> is the path of the folder where the module must be installed, relative to the source directory being processed.</p>
<h3><a class="anchor" id="autotoc_md122"></a>
File spherical_region.cu</h3>
<p>This file includes the C++ code that implements the intended functionality of the module during the execution of a simulation. Every function defined in this file must be executed at strategic points when a simulation is running in Rocky. These points are defined via the simulation <a class="el" href="glossary.xhtml#hook">hooks</a> described in the chapter <a class="el" href="solver_hooks.xhtml">Solver Hooks</a>, and must therefore be chosen carefully by taking into account what operations the module must perform and what information provided by Rocky will be necessary for their execution. In order to interact with Rocky, the Solver SDK classes and methods described in chapter <a href="annotated.xhtml">Class Reference</a> must be used.</p>
<div class="fragment"><div class="line">1   #define ROCKY_CUDA_API</div>
<div class="line">2</div>
<div class="line">3   #include &lt;rocky20/api/rocky_api.h&gt;</div>
<div class="line">4</div>
<div class="line">5   struct ModuleData</div>
<div class="line">6   {</div>
<div class="line">7       double3 sphere_center;</div>
<div class="line">8       double sphere_radius;</div>
<div class="line">9      int scalar_index;</div>
<div class="line">10  };</div>
<div class="line">11</div>
<div class="line">12  ROCKY_PLUGIN(&quot;Spherical Region&quot;, &quot;0.0.0&quot;)</div>
<div class="line">13</div>
<div class="line">14</div>
<div class="line">15  ROCKY_PLUGIN_CONFIGURE(input_data, data)</div>
<div class="line">16  {</div>
<div class="line">17      ModuleData* module_data = new ModuleData();</div>
<div class="line">18      auto model_properties = input_data.get_model();</div>
<div class="line">19      module_data-&gt;sphere_center.x = model_properties.get_double(&quot;center_x&quot;);</div>
<div class="line">20      module_data-&gt;sphere_center.y = model_properties.get_double(&quot;center_y&quot;);</div>
<div class="line">21      module_data-&gt;sphere_center.z = model_properties.get_double(&quot;center_z&quot;);</div>
<div class="line">22      module_data-&gt;sphere_radius = model_properties.get_double(&quot;radius&quot;);</div>
<div class="line">23      data = static_cast&lt;void*&gt;(module_data);</div>
<div class="line">24  }</div>
<div class="line">25</div>
<div class="line">26  ROCKY_PLUGIN_SETUP(model, data)</div>
<div class="line">27  {</div>
<div class="line">28      ModuleData* module_data = static_cast&lt;ModuleData*&gt;(data);</div>
<div class="line">29      auto scalars = model.get_particle_scalars();</div>
<div class="line">30      module_data-&gt;scalar_index = scalars.add(&quot;Inside Sphere Flag&quot;, &quot;-&quot;);</div>
<div class="line">31  }</div>
<div class="line">32</div>
<div class="line">33  ROCKY_PLUGIN_NON_DIMENSIONALIZE(model, data)</div>
<div class="line">34  {</div>
<div class="line">35      ModuleData* module_data = static_cast&lt;ModuleData*&gt;(data);</div>
<div class="line">36      module_data-&gt;sphere_center.x /= model.get_length_factor();</div>
<div class="line">37      module_data-&gt;sphere_center.y /= model.get_length_factor();</div>
<div class="line">38      module_data-&gt;sphere_center.z /= model.get_length_factor();</div>
<div class="line">39      module_data-&gt;sphere_radius /= model.get_length_factor();</div>
<div class="line">40  }</div>
<div class="line">41</div>
<div class="line">42  ROCKY_PLUGIN_INITIALIZE_CUDA(model, host_data, device_id, device_data)</div>
<div class="line">43  {</div>
<div class="line">44      auto h_data = static_cast&lt;ModuleData*&gt;(host_data);</div>
<div class="line">45</div>
<div class="line">46      ModuleData* d_data = nullptr;</div>
<div class="line">47      CUDA_MALLOC_TYPE(d_data, 1, ModuleData);</div>
<div class="line">48      CUDA_COPY_H2D(d_data, h_data, 1);</div>
<div class="line">49      device_data = static_cast&lt;void*&gt;(d_data);</div>
<div class="line">50  }</div>
<div class="line">51</div>
<div class="line">52  ROCKY_PLUGIN_POST_MOVE_PARTICLES(device_model, particle, data)</div>
<div class="line">53  {</div>
<div class="line">54      ModuleData* module_data = static_cast&lt;ModuleData*&gt;(data);</div>
<div class="line">55      auto scalars = particle.get_scalars();</div>
<div class="line">56      int scalar_index = module_data-&gt;scalar_index;</div>
<div class="line">57      double3 position = particle.get_centroid_position();</div>
<div class="line">58      double distance = get_norm(position - module_data-&gt;sphere_center);</div>
<div class="line">59</div>
<div class="line">60      if (distance &lt; module_data-&gt;sphere_radius)</div>
<div class="line">61          scalars.set_scalar(scalar_index, 1.0);</div>
<div class="line">62      else</div>
<div class="line">63          scalars.set_scalar(scalar_index, 0.0);</div>
<div class="line">64  }</div>
<div class="line">65  ROCKY_PLUGIN_POST_MOVE_PARTICLES_END()</div>
<div class="line">66</div>
<div class="line">67  ROCKY_PLUGIN_TEAR_DOWN(model, data)</div>
<div class="line">68  {</div>
<div class="line">69      delete static_cast&lt;ModuleData*&gt;(data);</div>
<div class="line">70  }</div>
<div class="line">71</div>
<div class="line">72  ROCKY_PLUGIN_TEAR_DOWN_CUDA(model, device_id, device_data)</div>
<div class="line">73  {</div>
<div class="line">74      auto d_data = static_cast&lt;ModuleData*&gt;(device_data);</div>
<div class="line">75      CUDA_FREE(d_data);</div>
<div class="line">76  }</div>
<div class="line">77</div>
<div class="line">78  ROCKY_PLUGIN_END</div>
</div><!-- fragment --><p>The directive in line 1 enables the execution of the module in single or multi-GPU configurations. When this line is included, the module must define a <code>ROCKY_PLUGIN_INITIALIZE_CUDA</code> function in order to allocate memory in the GPU and to copy the module data to the GPU, as described below.</p>
<p>In line 5, a custom data structure <code>ModuleData</code> is defined, that will be used to store the data needed by the module. In this case, the structure includes the coordinates of the center point*, the radius of the sphere and an index to identify the particle <a class="el" href="glossary.xhtml#scalar">scalar</a> that will be used to identify the particles inside the spherical region.</p>
<p>**In order to simplify the code, the Rocky Solver SDK provides the struct double3 for defining 3D points and 3D vectors. It includes as data members the three coordinates x, y and z. Special operators for this struct are also defined, for addition, subtraction, and multiplication by a scalar. Moreover, the functions dot, cross, and get_norm are also provided, for obtaining the dot product, the cross product, and the norm, respectively.*</p>
<p>In line 12, the name and the version of the module implemented by the code in the file are defined. Afterwards, between lines 14 and 23, the code associated to the hook <code>ROCKY_PLUGIN_CONFIGURE</code> is defined. Here, an instance of the custom <code>struct</code> is allocated and the corresponding pointer is named <code>module_data</code>. Next, the values of the four module parameters entered through the Rocky UI are retrieved from the function argument <code>input_data</code>, and assigned to the corresponding variables in the object pointed by <code>module_data</code>. Finally, in line 23, this pointer is converted to a void pointer in order to assign it to the function argument <code>data</code>, which Rocky will store and make available in subsequent stages of the simulation.</p>
<p>Between lines 26 and 31, the code associated to the hook <code>ROCKY_PLUGIN_SETUP</code> is defined. As in other preprocessing hooks, the arguments provided are an <code><a class="el" href="structIRockyModel.xhtml">IRockyModel</a></code> object, named simply <code>model</code>, and the void pointer that was defined previously in <code>ROCKY_PLUGIN_CONFIGURE</code>. In order to have access to the data stored previously, the void pointer must be converted back into a ModuleData pointer, as it is done in line 28. In this specific case, the only operation performed in this block is to define a particle scalar variable that will be used to mark particles inside the spherical region. In line 29, the object that handles operations with particle scalars is defined. Subsequently, in line 30 the custom particle scalar is specified. The two arguments in the <code>add</code> function are the label that must associated to the particle scalar in the Rocky UI, and the unit. After creating the particle scalar, the <code>add</code> function will return an integer index that, in this case, will be stored in <code>module_data-&gt;scalar_index</code>. Any subsequent operation involving that specific particle scalar will require the use of that index.</p>
<p>In order to avoid precision loss because of roundoff errors, Rocky works internally with dimensionless variables. Therefore, the module has to nondimensionalize all custom parameters previously defined, in order to use them in operations involving data coming from the Rocky solver. This operation is made in the block beginning at line 33, within the <code>ROCKY_PLUGIN_NON_DIMENSIONALIZE</code> hook. In this case all parameters are lengths, so they are nondimensionalized using the length factor provided by the corresponding method of the <code>model</code> object.</p>
<p>Between lines 42 and 50, the module data is copied to the GPU <a class="el" href="glossary.xhtml#device">devices</a>. This kind of operation is mandatory when a module is intended for execution in single or multi-GPU configurations. The hook <code>ROCKY_PLUGIN_INITIALIZE_CUDA</code> provides two generic pointers as arguments: <code>host_data</code> and <code>device_data</code>. The first one points to the object that currently stores the data defined in the previous pre-processing functions. The objective of this function is to allocate a memory block of the right size in the GPU devices, copy the module data pointed by <code>host_data</code> to that memory block, and finally assign to <code>device_data</code> the pointer that points to the beginning of that block. This is done in lines 47 (memory allocation), 48 (data copy) and 49 (conversion to a generic pointer and assigment <code>device_data</code>).</p>
<p>The only operation performed by the module during the time iterative process is the one implemented in the block beginning at line 52. This operation is associated to the <code>ROCKY_PLUGIN_POST_MOVE_PARTICLES</code> hook, which is executed inside a loop over the active particles in the simulation, after the position and velocities of the particles were updated in Rocky. In line 58, the distance between the centroid of the current particle and the center of the spherical region is calculated. If that distance is less than the region radius, the particle is considered to be inside the region. The scalar value associated to the particle is set be equal to 1 in that case, and equal to 0 otherwise. The block is closed by the <code>ROCKY_PLUGIN_POST_MOVE_PARTICLES_END</code> function call, during which Rocky takes care of some additional operations needed to execute the module code correctly. Note that any of the functions associated to a hook executed during the time iterative loop must be closed by a similar function.</p>
<p>Finally, the <code>ROCKY_PLUGIN_TEAR_DOWN</code> hook frees the memory allocated for the local data structure in the CPU memory area. The equivalent operation on the GPU memory area is made in the <code>ROCKY_PLUGIN_TEAR_DOWN_CUDA</code> hook.</p>
<h3><a class="anchor" id="autotoc_md123"></a>
Building procedures</h3>
<p>This section shows a way to compile the module <code>spherical_region</code> described in the previous section.</p>
<h4><a class="anchor" id="autotoc_md124"></a>
Building in Centos 7</h4>
<p>In the <code>conda</code> command prompt that was activated in section Build Tools - Linux, navigate to the <code>spherical_region</code> directory and execute the following commands:</p>
<div class="fragment"><div class="line">cmake source/plugins/spherical_region</div>
<div class="line">make install</div>
</div><!-- fragment --><p>On successful execution of the above commands, the compiled content of the <code>spherical_region</code> module is available in the folder pointed by the <code>ROCKY_PLUGINS_PATH</code> environment variable:</p>
<div class="fragment"><div class="line">24.2.0/</div>
<div class="line">    spherical_region/</div>
<div class="line">        libx_spherical_region.so</div>
<div class="line">        spherical_region.plugin</div>
<div class="line">        spherical_region.py</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md125"></a>
Building in Windows 10</h4>
<p>Open the <code>e x64 Native Tools Command Prompt for VS 2022</code>, navigate to the <code>spherical_region</code> directory and execute the following commands:</p>
<div class="fragment"><div class="line">cmake -DCMAKE_GENERATOR_PLATFORM=x64 source/plugins/spherical_region</div>
<div class="line">cmake --build . --config Release</div>
<div class="line">cmake -P cmake_install.cmake</div>
</div><!-- fragment --><p>On successful execution of the above commands, the compiled content of the <code>spherical_region</code> module is available in the folder pointed to by the <code>ROCKY_PLUGINS_PATH</code> environment variable:</p>
<div class="fragment"><div class="line">24.2.0/</div>
<div class="line">    spherical_region/</div>
<div class="line">        spherical_region.dll</div>
<div class="line">        spherical_region.lib</div>
<div class="line">        spherical_region.plugin</div>
<div class="line">        spherical_region.py</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md126"></a>
Running the module in Rocky</h3>
<p>After having completed successfully all the steps described in previous sections, the new module will be ready to be executed in a Rocky simulation. Restart the Rocky application in order for it to acknowledge the recently created module.</p>
<p>When selecting the <b>Modules</b> item in the <b>Data</b> panel, the name of the new module must appear in the list of modules recognized by Rocky, displayed in the <b>Data Editors</b> panel. The activation of the module in a simulation requires that the corresponding checkbox is turned on, as shown in Figure 5.1.</p>
<div class="image">
<img src="sim_modules.png" alt="" width="30%"/>
</div>
    <p><em>Figure 5.1: The new module displayed in the Data Editors panel.</em></p>
<p>After the module is activated, a new item with the module name will be added under the <b>Modules</b> item in the <b>Data</b> panel, as shown in Figure 5.2. The selection of this item gives access to the general custom parameters defined in the model section of the specifications file <code>spherical_region.py</code>. The default values displayed are those defined in that file. Users of the module can alter those values at their convenience. On the other hand, if the <b>Info</b> tab is selected, the reference data included in the <code>spherical_region.plugin</code> is displayed in the panel.</p>
<div class="image">
<img src="sim_params.png" alt="" width="30%"/>
</div>
    <p><em>Figure 5.2: The custom parameters for the module displayed in the Data Editors panel.</em></p>
<div class="image">
<img src="mod_info.png" alt="" width="30%"/>
</div>
    <p><em>Figure 5.3: The module's Info tab on the Data Editors panel</em></p>
<p>In order to test the module, any new project can be set up in Rocky and then the <b>Spherical Region</b> module must be enabled, defining the proper values for the module parameters. After processing the simulation, the <b>Inside Sphere</b> scalar can be selected in the list of particle properties in the <b>Properties</b> tab, and visualized in a 3D view window at any output time. All particles inside the specified spherical region will have an scalar value equal to 1, as depicted in the example of Figure 5.4, while particles outside it will have associated a zero value.</p>
<div class="image">
<img src="sim_scalar.png" alt="" width="30%"/>
</div>
    <p><em>Figure 5.4: Example of a simulation processed using the new module.</em></p>
<h2><a class="anchor" id="autotoc_md127"></a>
A module implementing a custom</h2>
<p>As an example of the implementation of a custom model using the Rocky Solver SDK, this section describes the code associated to a custom module that implements a contact model, including the calculation of both components of the contact force, as well as the calculation of the impact energy.</p>
<p>A contact model may include in the most general case the calculation of both components of the contact force, and, if necessary, the calculation of the impact energy during a collision. Usually the tangential component of the contact force depends on the normal component, and the impact energy on both of them. Because of that, they are calculated in a fixed sequence, as shown schematically in Figure 5.4.</p>
<div class="image">
<img src="contact_pipeline.png" alt="" width="30%"/>
</div>
    <p><em>Figure 5.5: Contact model pipeline in Rocky.</em></p>
<p>The Rocky Solver SDK gives some flexibility regarding the implementation of custom contact force models. For instance, users can choose to implement only the normal contact force, combining it with a built-in tangential force model in Rocky. Or, conversely, users may implement only the tangential contact force, using as input the normal contact force calculated by a built-in model in Rocky. In these cases, users only need to implement whichever force component they want to customize in their module, then in runtime, Rocky will calculate the other component with the respective model selected in the Rocky UI.</p>
<p>On the other hand, users may implement the calculation of both contact force components within a custom module, including the calculation of the impact energy as well. Impact energy is used in Rocky as the main input parameter for the built-in instantaneous breakage models; therefore, users will need to implement a custom impact energy calculation only if they intend to use a custom contact force model along with such breakage models. Even in that case, users may choose not to implement the calculation of the impact energy. Rocky will use in such situation a standard calculation based on the impact work, as defined in equation 4.10 of the DEM Technical Manual. Also, when a module implements only either a normal or a tangential force model, Rocky uses standard calculations for the other one.</p>
<p>The remainder of this chapter will describe the implementation of a custom module including the calculation of both components of the contact force and the calculation of the impact energy as well. The normal and tangential force models included in the module are simplified versions of two built-in models in Rocky, the Hysteretic Linear Spring and the Linear Spring Coulomb Limit, respectively. Moreover, the impact energy calculation included in the module is the one used in Rocky when the Hysteretic Linear Spring model is selected as normal contact force.</p>
<h3><a class="anchor" id="autotoc_md128"></a>
Module specification file</h3>
<p>The following listing reproduces the Python file that includes the specifications for the custom module, which is named simply as <code>Contact Model Example</code>. </p><div class="fragment"><div class="line">1   import sys</div>
<div class="line">2   from pathlib import Path</div>
<div class="line">3   from yapsy.IPlugin import IPlugin</div>
<div class="line">4   from rocky20.addins.addin_models import container_model, data_model</div>
<div class="line">5   from rocky20.addins.addin_specs import RockyAddinSpecs</div>
<div class="line">6   from rocky20.addins.addin_types import Quantity</div>
<div class="line">7</div>
<div class="line">8   NAME = &#39;Contact Model Example&#39;</div>
<div class="line">9</div>
<div class="line">10</div>
<div class="line">11  @data_model(icon=None, caption=NAME)</div>
<div class="line">12  class CustomGeneral:</div>
<div class="line">13      pass</div>
<div class="line">14</div>
<div class="line">15</div>
<div class="line">16  @container_model()</div>
<div class="line">17  class CustomModel:</div>
<div class="line">18      pass</div>
<div class="line">19</div>
<div class="line">20</div>
<div class="line">21  @container_model()</div>
<div class="line">22  class CustomMaterialInteraction:</div>
<div class="line">23      tangential_stiffness_ratio = Quantity(value=1.0, unit=&#39;-&#39;, caption=&#39;Tangential To Normal Stiffness Ratio&#39;)</div>
<div class="line">24      sliding_velocity_threshold = Quantity(value=0.001, unit=&#39;m/s&#39;, caption=&#39;Sliding Velocity Threshold&#39;)</div>
<div class="line">25</div>
<div class="line">26</div>
<div class="line">27   class ContactModelExampleSpecs(RockyAddinSpecs):</div>
<div class="line">28</div>
<div class="line">29      name = NAME</div>
<div class="line">30</div>
<div class="line">31      model = CustomGeneral</div>
<div class="line">32</div>
<div class="line">33      normal_force_model = CustomModel</div>
<div class="line">34</div>
<div class="line">35      tangential_force_model = CustomModel</div>
<div class="line">36</div>
<div class="line">37      impact_energy_model = CustomModel</div>
<div class="line">38</div>
<div class="line">39      material_interaction_properties = CustomMaterialInteraction</div>
<div class="line">40</div>
<div class="line">41      @classmethod</div>
<div class="line">42      def CreateAddin(cls):</div>
<div class="line">43          return cls.CreateDynamicAddin(Path(__file__).parent, &#39;contact_model_example&#39;)</div>
<div class="line">44</div>
<div class="line">45</div>
<div class="line">46  class ContactModelExamplePlugin(IPlugin):</div>
<div class="line">47      def get_addin_specs(self):</div>
<div class="line">48          return ContactModelExampleSpec</div>
</div><!-- fragment --><p>The only parameters added by the module are two material interaction properties defined between lines 21 and 24. Both of them are used in the tangential contact force calculation. The first one is the ratio of the tangential stiffness to the normal stiffness, while the second one is the value of the tangential relative velocity that marks the onset of the sliding between the colliding entities.</p>
<p>Between lines 33 and 37, the module specifies that it will implement a custom normal force model, a custom tangential force model and a custom impact energy calculation. In runtime, Rocky will read these specifications and will override those model categories, using instead the custom models implemented by the module, as explained in section Specification of custom models.</p>
<h3><a class="anchor" id="autotoc_md129"></a>
Implementation of the contact model</h3>
<p>This section describes the different parts that make up the <code>custom_model_example.cu</code> file that includes the C++ code that implements the custom models.</p>
<div class="fragment"><div class="line">1   #define ROCKY_CUDA_API</div>
<div class="line">2</div>
<div class="line">3   #include &lt;rocky20/api/rocky_api.h&gt;</div>
<div class="line">4</div>
<div class="line">5   struct ModuleMaterialInteraction</div>
<div class="line">6   {</div>
<div class="line">7       double tangential_stiffness_ratio;</div>
<div class="line">8       double sliding_velocity_threshold;</div>
<div class="line">9   };</div>
<div class="line">10</div>
<div class="line">11  struct ModuleData</div>
<div class="line">12  {</div>
<div class="line">13      int ppi_normal, pti_normal;</div>
<div class="line">14      int ppi_tangential_x, pti_tangential_x;</div>
<div class="line">15      int ppi_tangential_y, pti_tangential_y;</div>
<div class="line">16      int ppi_tangential_z, pti_tangential_z;</div>
<div class="line">17</div>
<div class="line">18      ModuleMaterialInteraction* material_interactions;</div>
<div class="line">19  };</div>
</div><!-- fragment --><p>The initial part of the file reproduced above includes the definition of the preprocessor name <code>ROCKY_CUDA_API</code> that enables the compilation of the module in CUDA and, in turn, enables the possibility of the module being used in a simulation processed on GPU. Subsequently, between lines 5 and 9, it is defined a local <code>struct</code> that will hold the values entered through the Rocky UI for the two material interaction parameters that the module uses. Then, between lines 11 and 19, another local <code>struct</code> is defined, that will store the indices attributed in runtime to the contact scalars that the module will create. Additionally, that <code>struct</code> includes an array to store the values of the custom properties associated to all material interactions in the project.</p>
<p><em>Note: Here ppi stands for particle-particle index, while pti stands for particle-triangle index.</em></p>
<div class="fragment"><div class="line">21  inline ROCKY_FUNCTIONS void create_contact_scalars(</div>
<div class="line">22      IRockyModel&amp; model, const char* name, const char* unit,</div>
<div class="line">23      int&amp; pp_scalar_index, int&amp; pt_scalar_index)</div>
<div class="line">24  {</div>
<div class="line">25      auto pp_scalars = model.get_particle_contact_scalars();</div>
<div class="line">26      auto pt_scalars = model.get_triangle_contact_scalars();</div>
<div class="line">27</div>
<div class="line">28      pp_scalar_index = pp_scalars.add(name, unit, false);</div>
<div class="line">29      pt_scalar_index = pt_scalars.add(name, unit, false);</div>
<div class="line">30  }</div>
<div class="line">31</div>
<div class="line">32  inline ROCKY_FUNCTIONS double get_contact_scalar_value(</div>
<div class="line">33      IRockyContact&amp; contact, int pp_scalar_index, int pt_scalar_index)</div>
<div class="line">34  {</div>
<div class="line">35      return contact.is_particle_particle_contact()</div>
<div class="line">36          ? contact.get_particle_contact_scalars().get_scalar(pp_scalar_index)</div>
<div class="line">37          : contact.get_triangle_contact_scalars().get_scalar(pt_scalar_index);</div>
<div class="line">38  }</div>
<div class="line">39</div>
<div class="line">40  inline ROCKY_FUNCTIONS void set_contact_scalar_value(</div>
<div class="line">41      IRockyContact&amp; contact, int pp_scalar_index, int pt_scalar_index, double value)</div>
<div class="line">42  {</div>
<div class="line">43      contact.is_particle_particle_contact()</div>
<div class="line">44          ? contact.get_particle_contact_scalars().set_scalar(pp_scalar_index, value)</div>
<div class="line">45          : contact.get_triangle_contact_scalars().set_scalar(pt_scalar_index, value);</div>
<div class="line">46  }</div>
</div><!-- fragment --><p>The code block above implements three utility functions that simplify the handling of contact scalars. They allow to treat in a unified way, with a single function, both types of contact scalars, namely particle-to-particle and particle-to-triangle contact scalars.</p>
<div class="fragment"><div class="line">48  ROCKY_PLUGIN(&quot;Contact Model Example&quot;, &quot;1.0.0&quot;)</div>
<div class="line">49</div>
<div class="line">50  ROCKY_PLUGIN_CONFIGURE(input_data, _data)</div>
<div class="line">51  {</div>
<div class="line">52      auto data = new ModuleData();</div>
<div class="line">53</div>
<div class="line">54      int n_material_interactions = input_data.get_number_material_interactions();</div>
<div class="line">55      data-&gt;material_interactions = new ModuleMaterialInteraction[n_material_interactions];</div>
<div class="line">56</div>
<div class="line">57      for (int i = 0; i &lt; n_material_interactions; ++i)</div>
<div class="line">58      {</div>
<div class="line">59          auto&amp; m_i = data-&gt;material_interactions[i];</div>
<div class="line">60          auto input_mi = input_data.get_material_interaction(i);</div>
<div class="line">61</div>
<div class="line">62          m_i.tangential_stiffness_ratio = input_mi.get_double(&quot;tangential_stiffness_ratio&quot;);</div>
<div class="line">63          m_i.sliding_velocity_threshold = input_mi.get_double(&quot;sliding_velocity_threshold&quot;);</div>
<div class="line">64      }</div>
<div class="line">65</div>
<div class="line">66      _data = static_cast&lt;void*&gt;(data);</div>
<div class="line">67  }</div>
<div class="line">68</div>
<div class="line">69  ROCKY_PLUGIN_SETUP(model, _data)</div>
<div class="line">70  {</div>
<div class="line">71      auto data = static_cast&lt;ModuleData *&gt;(_data);</div>
<div class="line">72</div>
<div class="line">73      create_contact_scalars(model, &quot;Previous Normal Force&quot;, &quot;N&quot;, data-&gt;ppi_normal, data-&gt;pti_normal);</div>
<div class="line">74      create_contact_scalars(model, &quot;Previous Tangential Force X&quot;, &quot;N&quot;,</div>
<div class="line">75                                                      data-&gt;ppi_tangential_x, data-&gt;pti_tangential_x);</div>
<div class="line">76      create_contact_scalars(model, &quot;Previous Tangential Force Y&quot;, &quot;N&quot;,</div>
<div class="line">77                                                      data-&gt;ppi_tangential_y, data-&gt;pti_tangential_y);</div>
<div class="line">78      create_contact_scalars(model, &quot;Previous Tangential Force Z&quot;, &quot;N&quot;,</div>
<div class="line">79                                                      data-&gt;ppi_tangential_z, data-&gt;pti_tangential_z);</div>
<div class="line">80  }</div>
<div class="line">81</div>
<div class="line">82  ROCKY_PLUGIN_INITIALIZE_CUDA(model, host_data, device_id, _device_data)</div>
<div class="line">83  {</div>
<div class="line">84      auto h_data = static_cast&lt;ModuleData*&gt;(host_data);</div>
<div class="line">85      auto d_data = *h_data;</div>
<div class="line">86</div>
<div class="line">87      int size = model.get_number_of_material_interactions();</div>
<div class="line">88      ModuleMaterialInteraction* d_material_interactions = nullptr;</div>
<div class="line">89      CUDA_MALLOC_TYPE(d_material_interactions, size, ModuleMaterialInteraction);</div>
<div class="line">90      CUDA_COPY_H2D(d_material_interactions, h_data-&gt;material_interactions, size);</div>
<div class="line">91      d_data.material_interactions = d_material_interactions;</div>
<div class="line">92</div>
<div class="line">93      ModuleData* device_data = nullptr;</div>
<div class="line">94      CUDA_MALLOC_TYPE(device_data, 1, ModuleData);</div>
<div class="line">95      CUDA_COPY_H2D(device_data, &amp;d_data, 1);</div>
<div class="line">96      _device_data = static_cast&lt;void*&gt;(device_data);</div>
<div class="line">97  }</div>
<div class="line">98</div>
<div class="line">99  ROCKY_PLUGIN_TEAR_DOWN_CUDA(model, device_id, device_data)</div>
<div class="line">100 {</div>
<div class="line">101     auto d_data = static_cast&lt;ModuleData*&gt;(device_data);</div>
<div class="line">102     ModuleData data_ptr;</div>
<div class="line">103     CUDA_COPY_D2H(&amp;data_ptr, d_data, 1);</div>
<div class="line">104     CUDA_FREE(data_ptr.material_interactions);</div>
<div class="line">105     CUDA_FREE(d_data);</div>
<div class="line">106 }</div>
<div class="line">107</div>
<div class="line">108 ROCKY_PLUGIN_TEAR_DOWN(model, _data)</div>
<div class="line">109 {</div>
<div class="line">110     auto data = static_cast&lt;ModuleData*&gt;(_data);</div>
<div class="line">111     delete[] data-&gt;material_interactions;</div>
<div class="line">112     delete data;</div>
<div class="line">113 }</div>
</div><!-- fragment --><p>The block above includes the associated code to the initialization and termination hooks. As most of these operations were covered in chapter Rocky module examples, they will be described here very briefly.</p>
<p>In the <code>ROCKY_PLUGIN_CONFIGURE</code> hook, the values for the two module parameters per material interaction, entered through the Rocky UI, are stored in the array within the module local <code>struct</code> defined previously. Subsequently, in the <code>ROCKY_PLUGIN_SETUP</code> hook, contact scalars are created for storing the values of the contact forces calculated in the module. This storage is necessary because both the normal and tangential force models being implemented depend upon the history; therefore, in order to calculate the force values at a given timestep, the values from the previous timestep are required to be available.</p>
<p>In the <code>ROCKY_PLUGIN_INITIALIZE_CUDA</code> hook, the local module data is copied to GPU devices after being allocated the required memory block there. On the other hand, that memory block is freed in the <code>ROCKY_PLUGIN_TEAR_DOWN_CUDA</code> hook. An equivalent operation for the memory allocated in CPU is made in the <code>ROCKY_PLUGIN_TEAR_DOWN</code> hook.</p>
<div class="fragment"><div class="line">115 ROCKY_PLUGIN_NORMAL_FORCE_ON_CONTACTS(contact, intermediate_data, output_data, _data)</div>
<div class="line">116 {</div>
<div class="line">117     auto data = static_cast&lt;ModuleData *&gt;(_data);</div>
<div class="line">118     const auto m_i = contact.get_material_interaction();</div>
<div class="line">119</div>
<div class="line">120     const double prev_normal_force = get_contact_scalar_value(contact, data-&gt;ppi_normal, data-&gt;pti_normal);</div>
<div class="line">121</div>
<div class="line">122     const double restitution_coeff = m_i.get_restitution_coefficient();</div>
<div class="line">123     const double loading_stiffness = contact.get_equivalent_stiffness() * m_i.get_stiffness_multiplier();</div>
<div class="line">124     const double unloading_stiffness = loading_stiffness / (restitution_coeff * restitution_coeff);</div>
<div class="line">125</div>
<div class="line">126     const double overlap = contact.get_overlap();</div>
<div class="line">127     const double delta_overlap = overlap - contact.get_previous_overlap();</div>
<div class="line">128</div>
<div class="line">129     const double elastic_force = overlap * loading_stiffness;</div>
<div class="line">130     const double plastic_force = prev_normal_force + delta_overlap * unloading_stiffness;</div>
<div class="line">131     const double new_normal_force = max(min(plastic_force, elastic_force), 0.0);</div>
<div class="line">132</div>
<div class="line">133     output_data.set_normal_force(new_normal_force);</div>
<div class="line">134</div>
<div class="line">135     set_contact_scalar_value(contact, data-&gt;ppi_normal, data-&gt;pti_normal, new_normal_force);</div>
<div class="line">136 }</div>
<div class="line">137 ROCKY_PLUGIN_NORMAL_FORCE_ON_CONTACTS_END()</div>
</div><!-- fragment --><p>The block of code above implements a simplified but functional form of the Hysteretic Linear Spring normal contact force. As this is a history-dependent model, the needed previous value of the normal contact force is retrieved from the corresponding contact scalar in line 120. Subsequently, the stiffnesses corresponding to the loading and unloading portions of the collision cycle are calculated using the equations in section 2.1.1.1 of the DEM Technical Manual. Both stiffness values are multiplied by the <b>Contact Stiffness Multiplier</b>, which is an advanced material interaction parameter that might be used to prevent large overlaps in certain specific situations. Also, The stiffness value returned by the get_equivalent_stiffness function is already multiplied by the <b>Numerical Softening Factor</b>, which is commonly used for increasing the simulation timestep. For more details about this factor, please refer to section 5.3.4 of the DEM Technical Manual.</p>
<p>Using the current overlap value and its variation during the timestep, two possible values of the normal contact force are calculated, one located on a loading path and other located on an unloading path. The new normal contact force will be the minimum between those two values, as long it is positive. If that minimum value is negative, the new normal contact force will be set to zero. In line 133 that new value is passed as argument to the <code>set_normal_force</code> method of the <code>output_data</code> object. This operation is mandatory, because only in that way Rocky will become aware of the new force value calculated by the module. From that point on, Rocky will use internally that force for solving the particles' motion equations and perform all the other operations that may need it.</p>
<p>As a final operation of the normal force calculation, the new normal contact force value is set also to the corresponding contact scalar in line 135, in order to preserve it and make it available during the next time iteration.</p>
<div class="fragment"><div class="line">139 ROCKY_PLUGIN_TANGENTIAL_FORCE_ON_CONTACTS(contact, intermediate_data, output_data, _data)</div>
<div class="line">140 {</div>
<div class="line">141     auto data = static_cast&lt;ModuleData*&gt;(_data);</div>
<div class="line">142     const auto m_i = contact.get_material_interaction();</div>
<div class="line">143     const auto&amp; module_m_i = data-&gt;material_interactions[contact.get_material_interaction_index()];</div>
<div class="line">144</div>
<div class="line">145     const double3 prev_tangential_force = contact.just_started_frictional() ?</div>
<div class="line">146         make_double3(0.0, 0.0, 0.0) :</div>
<div class="line">147         make_double3(get_contact_scalar_value(contact, data-&gt;ppi_tangential_x, data-&gt;pti_tangential_x),</div>
<div class="line">148                      get_contact_scalar_value(contact, data-&gt;ppi_tangential_y, data-&gt;pti_tangential_y),</div>
<div class="line">149                      get_contact_scalar_value(contact, data-&gt;ppi_tangential_z, data-&gt;pti_tangential_z));</div>
<div class="line">150</div>
<div class="line">151     const double3 tangential_relative_velocity = output_data.get_tangential_relative_velocity();</div>
<div class="line">152     const double3 tangential_displacement = tangential_relative_velocity * contact.get_timestep();</div>
<div class="line">153</div>
<div class="line">154     const double normal_stiffness = contact.get_equivalent_stiffness() * m_i.get_stiffness_multiplier();</div>
<div class="line">155     const double tangential_stiffness = normal_stiffness * module_m_i.tangential_stiffness_ratio;</div>
<div class="line">156</div>
<div class="line">157     double3 new_tangential_force = prev_tangential_force - tangential_stiffness * tangential_displacement;</div>
<div class="line">158     const double new_tangential_force_norm = get_norm(new_tangential_force);</div>
<div class="line">159     const double coulomb_limit = intermediate_data.get_friction_coefficient() * output_data.get_normal_force();</div>
<div class="line">160</div>
<div class="line">161     if (new_tangential_force_norm &gt; coulomb_limit)</div>
<div class="line">162     {</div>
<div class="line">163         new_tangential_force *= coulomb_limit / (new_tangential_force_norm + SMALL_VALUE);</div>
<div class="line">164         bool sliding = get_norm(tangential_relative_velocity) &gt; module_m_i.sliding_velocity_threshold;</div>
<div class="line">165         output_data.set_sliding(sliding);</div>
<div class="line">166     }</div>
<div class="line">167     else</div>
<div class="line">168     {</div>
<div class="line">169         output_data.set_sliding(false);</div>
<div class="line">170     }</div>
<div class="line">171</div>
<div class="line">172     output_data.set_tangential_force(new_tangential_force);</div>
<div class="line">173     set_contact_scalar_value(contact, data-&gt;ppi_tangential_x, data-&gt;pti_tangential_x, new_tangential_force.x);</div>
<div class="line">174     set_contact_scalar_value(contact, data-&gt;ppi_tangential_y, data-&gt;pti_tangential_y, new_tangential_force.y);</div>
<div class="line">175     set_contact_scalar_value(contact, data-&gt;ppi_tangential_z, data-&gt;pti_tangential_z, new_tangential_force.z);</div>
<div class="line">176 }</div>
<div class="line">177 ROCKY_PLUGIN_TANGENTIAL_FORCE_ON_CONTACTS_END()</div>
</div><!-- fragment --><p>The implementation of the Linear Spring Coulomb Limit tangential force model is made in the code reproduced above. The model needs material interaction properties defined by both Rocky and the module itself. Because of that, two material interaction objects are defined in lines 142 and 143 in order to retrieve those property values. Next, in line 145, the previous tangential force vector is defined as zero if the current timestep is the first one in the collision, or, otherwise, its components are retrieved from custom contact scalars. Subsequently, the tangential component of the relative velocity at the contact point, pre-calculated by Rocky, is retrieved, and with it the tangential relative displacement during the timestep is calculated.</p>
<p><em>Note: This is a simplified version of the model implemented in Rocky. Some additional operations are ignored for the sake of simplicity. For instance, Rocky introduces correction terms to take into account the change on the normal direction and a possible viscous dissipation, that this implementation does not address</em></p>
<p>In line 154, the normal stiffness value is retrieved, and with it and the tangential stiffness ratio, the tangential stiffness is determined in line 155. Then, in line 157, the possible new value of the tangential force vector is calculated using equation 2.18 of the DEM Technical Manual. As in this model the magnitude of the tangential contact force cannot exceed the so-called Coulomb limit, calculated in line 159, the tangential force is rescaled if that condition is not satisfied, in line</p><ol type="1">
<li>Additionally, the sliding condition is verified in line 164, comparing the magnitude of the relative tangential velocity with the sliding threshold value defined as a material interaction property. The boolean value indicating if the sliding condition is true or false is passed to Rocky using the <code>set_sliding</code> method of the <code>output_data</code> object, in line 165. In case that the Coulomb limit is not exceeded, the sliding condition is always false, and that value is set in line 169.</li>
</ol>
<p>The tangential contact force just calculated is passed also to Rocky by means of the <code>set_tangential_force</code> method of the <code>output_data</code> object, in line 172. The specification of both the sliding state and the tangential force vector is mandatory for a module implementing a tangential contact force model. As a final step, the components of the tangential force are stored in the contact scalars previously created, in order to make available those values in the next time iteration.</p>
<div class="fragment"><div class="line">179 ROCKY_PLUGIN_IMPACT_ENERGY_ON_CONTACTS(contact, intermediate_data, output_data, _data)</div>
<div class="line">180 {</div>
<div class="line">181     const double home_stiffness = contact.get_home_stiffness();</div>
<div class="line">182     const double near_stiffness = contact.get_near_stiffness();</div>
<div class="line">183     const double stiffness_multiplier = contact.get_material_interaction().get_stiffness_multiplier();</div>
<div class="line">184</div>
<div class="line">185     const double normal_force = output_data.get_normal_force();</div>
<div class="line">186     const double3 tangential_force = output_data.get_tangential_force();</div>
<div class="line">187     const double squared_force = normal_force * normal_force + dot(tangential_force);</div>
<div class="line">188</div>
<div class="line">189     output_data.set_home_impact_energy(0.5 * squared_force / (stiffness_multiplier * home_stiffness));</div>
<div class="line">190     output_data.set_near_impact_energy(0.5 * squared_force / (stiffness_multiplier * near_stiffness));</div>
<div class="line">191 }</div>
<div class="line">192 ROCKY_PLUGIN_IMPACT_ENERGY_ON_CONTACTS_END()</div>
</div><!-- fragment --><p>The module example presented in this chapter includes also the code for the calculation of the impact energy. This code reproduces the one implemented in Rocky and used when the Hysteretic Linear Spring model is active in a simulation. It is based on equation 4.11 of the DEM Technical Manual. Both the normal and the tangential contact force values calculated in previous steps, retrieved in lines 185 and 186, are needed in that expression. It actually represents the impact energy accumulated in the contact since the collision started. However, Rocky expects as output of the calculation the portions of that impact energy that are attributed to each colliding entity. Because of that, in lines 189 and 190, two values of impact energy are set using the <code>set_home_impact_energy</code> and <code>set_near_impact_energy</code> methods of the <code>output_data</code> object, respectively.</p>
<p>After the module is built following the steps given in section 5.1.6, the module will be available to be used in Rocky. When the <code>Contact Model Example</code> is enabled in a Rocky project, the models of normal and tangential forces, besides the impact energy model implemented on it will override built-in models in those categories. This will be indicated within the <b>Physics | Momentum</b> tab, which will appear as shown in Figure 5.5.</p>
<div class="image">
<img src="mod_phys.png" alt="" width="30%"/>
</div>
    <p><em>Figure 5.6: The normal force, tangential force and impact energy categories overriden by the models implemented in Contact Model Example.</em></p>
<h2><a class="anchor" id="a-module-implementing-variable-properties"></a>
A module implementing variable properties</h2>
<p>As an example of the implementation of modules that override built-in constant properties in Rocky, this section describes a module that converts the particle's thermal conductivity into a function of the temperature. Additionally, the module makes possible also to define the temperature of boundaries as a function of the position. The functional relation for the thermal conductivity that the module implements is the following: $$ K_p = K_O ( 1 + C_L T_p ) $$ where \(K_O\) and \(C_L\) are two module parameters and \(T_p\) is the particle temperature. On the other hand, the modules allows to define the temperature of boundary triangles as a quadratic function of the \(x\)-coordinate: $$ T_t = T_O ( 1 + C_Q \,x_t^2 ) $$ where \(T_O\) and \(C_Q\) are two module parameters and \(x_t\) is the \(x\)-coordinate of the triangle's centroid.</p>
<h3><a class="anchor" id="autotoc_md130"></a>
Module specification file</h3>
<p>The following listing reproduces the Python file with the specifications of the module, which is named as <code>Variable Properties Example</code>.</p>
<div class="fragment"><div class="line">1       from pathlib import Path</div>
<div class="line">2       from rocky20.addins.addin_models import container_model, data_model</div>
<div class="line">3       from rocky20.addins.addin_specs import RockyAddinSpecs</div>
<div class="line">4       from rocky20.addins.addin_types import Quantity, Temperature, ThermalConductivity</div>
<div class="line">5       from yapsy.IPlugin import IPlugin</div>
<div class="line">6</div>
<div class="line">7</div>
<div class="line">8       NAME = &#39;Variable Properties Example&#39;</div>
<div class="line">9</div>
<div class="line">10</div>
<div class="line">11      @data_model(icon=None, caption=NAME)</div>
<div class="line">12      class GeneralProperties:    </div>
<div class="line">13          pass</div>
<div class="line">14</div>
<div class="line">15</div>
<div class="line">16      @container_model()</div>
<div class="line">17      class MaterialProperties:          </div>
<div class="line">18          k_base_value = Quantity(value=1.0, unit=&#39;W/m.K&#39;, caption=&#39;Thermal Conductivity Base Value&#39;)</div>
<div class="line">19          k_linear_coefficient = Quantity(value=0.0, unit=&#39;1/K&#39;, caption=&#39;Linear Coefficient&#39;)</div>
<div class="line">20       </div>
<div class="line">21         </div>
<div class="line">22      @container_model()</div>
<div class="line">23      class GeometryProperties:          </div>
<div class="line">24          t_base_value = Quantity(value=300.0, unit=&#39;K&#39;, caption=&#39;Temperature Base Value&#39;)</div>
<div class="line">25          t_quadratic_coefficient = Quantity(value=0.0, unit=&#39;1/m2&#39;, caption=&#39;Quadratic Coefficient&#39;)</div>
<div class="line">26       </div>
<div class="line">27         </div>
<div class="line">28      @container_model()</div>
<div class="line">29      class ParticleMaterialVariableProperties:</div>
<div class="line">30          thermal_conductivity = ThermalConductivity</div>
<div class="line">31         </div>
<div class="line">32         </div>
<div class="line">33      @container_model()</div>
<div class="line">34      class TriangleVariableProperties:</div>
<div class="line">35          temperature = Temperature</div>
<div class="line">36</div>
<div class="line">37</div>
<div class="line">38      class ModuleSpecifications(RockyAddinSpecs):</div>
<div class="line">39</div>
<div class="line">40          name = NAME</div>
<div class="line">41</div>
<div class="line">42          model = GeneralProperties</div>
<div class="line">43         </div>
<div class="line">44          particle_material_properties = ParticleMaterialVariableProperties</div>
<div class="line">45         </div>
<div class="line">46          geometry_triangle_properties = TriangleVariableProperties</div>
<div class="line">47         </div>
<div class="line">48          material_properties = MaterialProperties</div>
<div class="line">49         </div>
<div class="line">50          geometry_properties = GeometryProperties</div>
<div class="line">51             </div>
<div class="line">52         </div>
<div class="line">53          @classmethod</div>
<div class="line">54          def CreateAddin(cls):</div>
<div class="line">55              return cls.CreateDynamicAddin(Path(__file__).parent, &#39;variable_properties_example&#39;)</div>
<div class="line">56</div>
<div class="line">57</div>
<div class="line">58      class VariablePropertiesExampleModule(IPlugin):</div>
<div class="line">59          def get_addin_specs(self):</div>
<div class="line">60              return ModuleSpecifications</div>
</div><!-- fragment --><p>Lines 18 and 19 of this file define the two parameters used in thermal conductivity equation as material properties. This means that different values can be entered through the Rocky UI for each one of the materials defined in a project. Similarly, lines 24 and 25 define the two parameters included in the boundary temperature equation as geometry properties. Therefore, different values of these parameters could be specified for each geometry in a project.</p>
<p><em>Note: However, since the module will define the thermal conductivity as a variable property for particles exclusively, only parameter values from materials associated to particles will be effectively used by the module.</em></p>
<p>The class defined in lines 28 to 30 specifies which material properties associated to particles will be overridden by the module. In this case, the thermal conductivity is the only property specified. That property is associated to an particle scalar variable defined internally in Rocky (<code>ThermalConductivity</code>) which the solver will use to store the values calculated by the module. A similar specification is made between lines 30 and 35 for the temperature of the boundary triangles. For more details about the specification of variable properties, please refer to section 2.9.</p>
<p>Since the module will define the thermal conductivity as a variable property for particles exclusively, only parameter values from materials associated to particles will be effectively used by the module.</p>
<h3><a class="anchor" id="autotoc_md131"></a>
Module implementation</h3>
<p>This section describes the C++ code of the main parts of the <code>variable_properties_example.cu</code> file. The code from initialization and termination hooks related to CUDA operations is omitted, since it was described in previous examples. This code implements the calculation of the property values per particle and per boundary triangle that the module must deliver to the Rocky solver. In turn, the Rocky solver will use these values internally in the thermal model calculations.</p>
<div class="fragment"><div class="line">1   #define ROCKY_CUDA_API</div>
<div class="line">2</div>
<div class="line">3   #include &lt;rocky20/api/rocky_api.h&gt;</div>
<div class="line">4</div>
<div class="line">5</div>
<div class="line">6   struct MaterialData</div>
<div class="line">7   {</div>
<div class="line">8       double k_base_value;</div>
<div class="line">9       double k_linear_coefficient;</div>
<div class="line">10  };</div>
<div class="line">11</div>
<div class="line">12  struct GeometryData</div>
<div class="line">13  {</div>
<div class="line">14      double t_base_value;</div>
<div class="line">15      double t_quadratic_coefficient;</div>
<div class="line">16  };</div>
<div class="line">17</div>
<div class="line">18  struct ModuleData</div>
<div class="line">19  {</div>
<div class="line">20      MaterialData* m_data;</div>
<div class="line">21      GeometryData* g_data;</div>
<div class="line">22      bool enabled;</div>
<div class="line">23  };</div>
</div><!-- fragment --><p>The code block above defines data structures for the module to store the parameter values that users of the module entered via the Rocky UI.</p>
<div class="fragment"><div class="line">26  ROCKY_PLUGIN_CONFIGURE(input_data, data)</div>
<div class="line">27  {</div>
<div class="line">28      auto* module_data = new ModuleData();</div>
<div class="line">29</div>
<div class="line">30      int n_materials = input_data.get_number_materials();</div>
<div class="line">31      module_data-&gt;m_data = new MaterialData[n_materials];</div>
<div class="line">32</div>
<div class="line">33      for (int i = 0; i &lt; n_materials; ++i)</div>
<div class="line">34      {</div>
<div class="line">35          auto input_m_data = input_data.get_material_data(i);</div>
<div class="line">36          module_data-&gt;m_data[i].k_base_value = input_m_data.get_double(&quot;k_base_value&quot;);</div>
<div class="line">37          module_data-&gt;m_data[i].k_linear_coefficient = input_m_data.get_double(&quot;k_linear_coefficient&quot;);</div>
<div class="line">38      }</div>
<div class="line">39</div>
<div class="line">40      int n_geometries = input_data.get_number_geometries();</div>
<div class="line">41      module_data-&gt;g_data = new GeometryData[n_geometries];</div>
<div class="line">42</div>
<div class="line">43      for (int i = 0; i &lt; n_geometries; ++i)</div>
<div class="line">44      {</div>
<div class="line">45          auto input_g_data = input_data.get_geometry_data(i);</div>
<div class="line">46          module_data-&gt;g_data[i].t_base_value = input_g_data.get_double(&quot;t_base_value&quot;);</div>
<div class="line">47          module_data-&gt;g_data[i].t_quadratic_coefficient = input_g_data.get_double(&quot;t_quadratic_coefficient&quot;);</div>
<div class="line">48      }</div>
<div class="line">49</div>
<div class="line">50      data = static_cast&lt;void*&gt;(module_data);</div>
<div class="line">51  }</div>
<div class="line">52</div>
<div class="line">53</div>
<div class="line">54  ROCKY_PLUGIN_SETUP(model, data)</div>
<div class="line">55  {</div>
<div class="line">56      auto* module_data = static_cast&lt;ModuleData*&gt;(data);</div>
<div class="line">57</div>
<div class="line">58      module_data-&gt;enabled = model.is_thermal_simulation();</div>
<div class="line">59  }</div>
<div class="line">60</div>
<div class="line">61</div>
<div class="line">62  ROCKY_PLUGIN_NON_DIMENSIONALIZE(model, data)</div>
<div class="line">63  {</div>
<div class="line">64      auto* module_data = static_cast&lt;ModuleData*&gt;(data);</div>
<div class="line">65</div>
<div class="line">66      if (!module_data-&gt;enabled) return;</div>
<div class="line">67</div>
<div class="line">68      double t_factor = model.get_temperature_factor();</div>
<div class="line">69      double l_factor = model.get_length_factor();</div>
<div class="line">70      double k_factor = model.get_energy_factor() / (model.get_time_factor() * l_factor * t_factor);</div>
<div class="line">71</div>
<div class="line">72      for (int i = 0; i &lt; model.get_number_of_materials(); i++)</div>
<div class="line">73      {</div>
<div class="line">74          module_data-&gt;m_data[i].k_base_value /= k_factor;</div>
<div class="line">75          module_data-&gt;m_data[i].k_linear_coefficient *= t_factor;</div>
<div class="line">76      }</div>
<div class="line">77</div>
<div class="line">78      for (int i = 0; i &lt; model.get_number_of_geometries(); i++)</div>
<div class="line">79      {</div>
<div class="line">80          module_data-&gt;g_data[i].t_base_value /= t_factor;</div>
<div class="line">81          module_data-&gt;g_data[i].t_quadratic_coefficient *= l_factor * l_factor;</div>
<div class="line">82      }</div>
<div class="line">83  }</div>
</div><!-- fragment --><p>The code associated to the <code>ROCKY_PLUGIN_CONFIGURE</code> hook receives the parameter values delivered by the Rocky UI, and then stores them in the data structures previously defined. On the other hand, the <code>ROCKY_PLUGIN_SETUP</code> hook is only used to verify if the project has the thermal model enabled. The module will perform its operations only if that is the case. Then the module parameters are non-dimensionalized, in order to be used in the calculations that must be made later on, during the simulation.</p>
<p>Since the module is intended to be used with static boundaries only, it needs to prescribe the temperature of the boundary triangles only once, during the initialization. In order to do that, the <code>ROCKY_PLUGIN_INITIALIZE_TRIANGLE</code> hook is used in the following way:</p>
<div class="fragment"><div class="line">86  ROCKY_PLUGIN_INITIALIZE_TRIANGLE(model, triangle, data)</div>
<div class="line">87  {</div>
<div class="line">88      auto* module_data = static_cast&lt;ModuleData*&gt;(data);</div>
<div class="line">89     </div>
<div class="line">90      if (!module_data-&gt;enabled) return;</div>
<div class="line">91</div>
<div class="line">92      int geometry_index = triangle.get_geometry_index();</div>
<div class="line">93      auto g_data = module_data-&gt;g_data[geometry_index];</div>
<div class="line">94</div>
<div class="line">95      double x = triangle.get_centroid().x;</div>
<div class="line">96      double temperature = g_data.t_base_value * (1.0 + g_data.t_quadratic_coefficient * x * x );</div>
<div class="line">97      triangle.set_temperature(temperature);</div>
<div class="line">98  }</div>
</div><!-- fragment --><div class="image">
<img src="ex_prop_temp.png" alt="" width="30%"/>
</div>
    <p><em>Figure 5.7: Example of the temperature distribution on a boundary specified by the module.</em></p>
<p>The code above applies boundary temperature equation shown above to the calculation of the temperature of every boundary triangle in the simulation. If the temperature distribution should be applied only to specific boundaries, the code above must be modified in order to filter the triangles belonging to those boundaries. Figure 5.7 shows an example of the resulting temperature distribution in a specific case.</p>
<p>The thermal conductivity as a function of the particle's temperature. Since this temperature is updated at every time iteration during the simulation, the module needs to update the conductivity values at every iteration as well. That update must be done within an iteration hook executed before the heat transfer calculation, which are made right afterwards the contact forces calculation. Therefore, the <code>ROCKY_PLUGIN_PRE_FORCE_ON_PARTICLES</code> hook is the most adequate for that task, as shown in the following code block:</p>
<div class="fragment"><div class="line">100 ROCKY_PLUGIN_PRE_FORCE_ON_PARTICLES(device_model, particle, data)</div>
<div class="line">101 {</div>
<div class="line">102     auto* module_data = static_cast&lt;ModuleData*&gt;(data);</div>
<div class="line">103</div>
<div class="line">104     if (!module_data-&gt;enabled) return;</div>
<div class="line">105</div>
<div class="line">106     int material_index = particle.get_material_index();</div>
<div class="line">107     auto&amp; m_data = module_data-&gt;m_data[material_index];</div>
<div class="line">108     double temperature = particle.get_scalars().get_temperature();</div>
<div class="line">109</div>
<div class="line">110     double conductivity = m_data.k_base_value * (1.0 + m_data.k_linear_coefficient * temperature);</div>
<div class="line">111     particle.set_thermal_conductivity(conductivity);</div>
<div class="line">112 }</div>
<div class="line">113 ROCKY_PLUGIN_PRE_FORCE_ON_PARTICLES_END()</div>
</div><!-- fragment --><p>This code calculates the thermal conductivity for all active particles at a given time, according to thermal conductivity equation mentioned previously. The conductivity value just calculated is passed to the Rocky solver in the line 111 using the <code>set_thermal_conductivity</code> method. The Rocky Solver SDK includes equivalent methods associated to particles, triangles and contacts, for every property that can be overridden by a custom module. Figure 5.8 shows an example of a particle bed in which the particles' thermal conductivity has been calculated by the module described in this section.</p>
<p>When a custom module that implements a variable property is active in a simulation, Rocky will issue a warning message, indicating which properties are being overridden by the module. Although the constant property values being replaced will remain editable in the Rocky UI, it is important to note that they will be ignored in all the calculations done by the Rocky solver.</p>
<div class="image">
<img src="ex_prop_cond.png" alt="" width="30%"/>
</div>
    <p><em>Figure 5.8: Example of the variable thermal conductivity on particles specified by the module</em></p>
<h2><a class="anchor" id="autotoc_md132"></a>
A module implementing a custom SPH model</h2>
<p>As an example of the implementation of a custom SPH model using the Rocky Solver SDK, this section describes the code associated to a custom module that implements simultaneously the Large Eddy Simulation (LES) turbulence model*, the Morris viscosity model and the Free Slip boundary condition type. Be aware that when implementing forces or parameters directly related to forces, a custom module must implement the calculation of all relevant forces, as it is being done in this example. Note that not all forces or options present in Rocky are replicated in this module example, but only the most important ones.</p>
<p>**For more information about the model implemented in this example, refer to "Numerical modelling of complex turbulent free-surface flows with the SPH
method: an overview", Violeau D., Issa, R., International Journal of Numerical Methods in Fluids, vol. 53, pp. 277-304, 2007.*</p>
<h3><a class="anchor" id="autotoc_md133"></a>
Module specification file</h3>
<p>The following listing reproduces the Python file that includes the specifications for the custom module, which is named simply as <code>LES Turbulence Model</code>.</p>
<div class="fragment"><div class="line">1   import sys</div>
<div class="line">2   from pathlib import Path</div>
<div class="line">3   from yapsy.IPlugin import IPlugin</div>
<div class="line">4   from rocky20.addins.addin_models import container_model, data_model</div>
<div class="line">5   from rocky20.addins.addin_specs import RockyAddinSpecs</div>
<div class="line">6   from rocky20.addins.addin_types import Quantity</div>
<div class="line">7</div>
<div class="line">8   NAME = &quot;SPH LES Turbulence Model&quot;</div>
<div class="line">9</div>
<div class="line">10  @data_model(icon=None, caption=NAME)</div>
<div class="line">11  class SPHModelAPIModel:</div>
<div class="line">12      les_smagorinsky_constant = Quantity(value=0.2, unit=&#39;-&#39;, caption=&#39;Les Smagorinsky Constant&#39;)</div>
<div class="line">13      les_distance_factor = Quantity(value=2, unit=&#39;-&#39;, caption=&#39;LES Distance Factor&#39;)</div>
<div class="line">14</div>
<div class="line">15  @data_model(icon=None, caption=NAME)</div>
<div class="line">16  class SPHForceModel:</div>
<div class="line">17      pass</div>
<div class="line">18     </div>
<div class="line">19  class SPHModelAPISpecs(RockyAddinSpecs):</div>
<div class="line">20</div>
<div class="line">21      name = NAME</div>
<div class="line">22</div>
<div class="line">23      model = SPHModelAPIModel</div>
<div class="line">24      sph_force_model = SPHForceModel</div>
<div class="line">25</div>
<div class="line">26      @classmethod</div>
<div class="line">27      def CreateAddin(cls):</div>
<div class="line">28          return cls.CreateDynamicAddin(Path(__file__).parent, &#39;sph_les_model&#39;)</div>
<div class="line">29</div>
<div class="line">30  class SPHAPIPlugin(IPlugin):</div>
<div class="line">31</div>
<div class="line">32      def get_addin_specs(self):</div>
<div class="line">33          return SPHModelAPISpecs</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md134"></a>
Implementation of the SPH LES turbulence model</h3>
<p>This section describes the different parts that make up the <code>sph_les_model.cu</code> file that includes the C++ code implementing the custom models.</p>
<div class="fragment"><div class="line">1   #define ROCKY_CUDA_API</div>
<div class="line">2</div>
<div class="line">3   #include &lt;rocky20/api/rocky_api.h&gt;</div>
<div class="line">4   #include &lt;rocky20/api/rocky_api_sph.h&gt;</div>
<div class="line">5   #include &lt;rocky20/api/device/api_backend.hpp&gt;</div>
<div class="line">6   #include &lt;rocky20/api/sph/api_cuda_sph.hpp&gt;</div>
<div class="line">7</div>
<div class="line">8   struct Data</div>
<div class="line">9   {</div>
<div class="line">10      int turbulent_viscosity_index { -1 };</div>
<div class="line">11      double les_smagorinsky_constant;</div>
<div class="line">12      double les_distance_factor;</div>
<div class="line">13  };</div>
</div><!-- fragment --><p>The initial part of the file reproduced above includes the definition of the preprocessor name <code>ROCKY_CUDA_API</code> that enables the compilation of the module in CUDA and, in turn, enables the module to be used in a simulation processed on GPU. Subsequently, between lines 8 and 13, it is defined a local <code>struct</code> that will be used to store the data needed by the module. In the current module, a parameter needed is the index <code>turbulent_viscosity_index</code> assigned to a scalar that stores the turbulent viscosity calculated during the simulation. The other two parameters are needed to store the data entered by the user via the Rocky UI.</p>
<div class="fragment"><div class="line">48  ROCKY_PLUGIN(&quot;SPH LES Turbulence Model&quot;, &quot;1.0.0&quot;)</div>
<div class="line">49  ROCKY_PLUGIN_SPH()</div>
<div class="line">50</div>
<div class="line">51  ROCKY_PLUGIN_CONFIGURE(input_data, module_data)</div>
<div class="line">52  {</div>
<div class="line">53      ROCKY_MESSAGE_LOG(&quot;SPHModelAPIAddin: configure&quot;);</div>
<div class="line">54      Data* data = new Data();</div>
<div class="line">55      auto model_properties = input_data.get_model();</div>
<div class="line">56      data-&gt;les_smagorinsky_constant = model_properties.get_double(&quot;les_smagorinsky_constant&quot;);</div>
<div class="line">57      data-&gt;les_distance_factor = model_properties.get_double(&quot;les_distance_factor&quot;);</div>
<div class="line">58      module_data = static_cast&lt;void*&gt;(data);</div>
<div class="line">59  }</div>
<div class="line">60</div>
<div class="line">61  ROCKY_PLUGIN_SETUP(model, _data)</div>
<div class="line">62  {</div>
<div class="line">63      ROCKY_MESSAGE_LOG(&quot;SPHModelAPIAddin: setup&quot;);</div>
<div class="line">64      auto data = static_cast&lt;Data*&gt;(_data);</div>
<div class="line">65</div>
<div class="line">66      auto sph_model = get_sph_model(model);</div>
<div class="line">67      auto sph_scalars = sph_model.get_sph_element_scalars();</div>
<div class="line">68      data-&gt;turbulent_viscosity_index = sph_scalars.add(&quot;Turbulent Viscosity&quot;, &quot;Pa.s&quot;);</div>
<div class="line">69      sph_scalars.set_operation(data-&gt;turbulent_viscosity_index, sphotReset, sphopPreForce);</div>
<div class="line">70      sph_scalars.set_operation(data-&gt;turbulent_viscosity_index, sphotSum, sphopPreForce);</div>
<div class="line">71      sph_scalars.set_operation(data-&gt;turbulent_viscosity_index, sphotUpdate, sphopPreForce);</div>
<div class="line">72      ROCKY_MESSAGE_LOG(</div>
<div class="line">73          &quot;Added scalar &quot; &lt;&lt; data-&gt;turbulent_viscosity_index &lt;&lt; &quot; reset/sum/update point &quot;</div>
<div class="line">74                          &lt;&lt; sphopPreForce);</div>
<div class="line">75  }</div>
<div class="line">76</div>
<div class="line">77  ROCKY_PLUGIN_INITIALIZE_CUDA(model, host_data, device_id, _device_data)</div>
<div class="line">78  {</div>
<div class="line">79      ROCKY_INFO_LOG(&quot;SPHModelAPIAddin: initialize_cuda&quot;);</div>
<div class="line">80      Data* device_copy = nullptr;</div>
<div class="line">81      CUDA_MALLOC_TYPE(device_copy, 1, Data);</div>
<div class="line">82      CUDA_COPY_H2D(device_copy, static_cast&lt;Data*&gt;(host_data), 1);</div>
<div class="line">83      _device_data = static_cast&lt;void*&gt;(device_copy);</div>
<div class="line">84  }</div>
</div><!-- fragment --><p>The block above includes the associated code to the initialization hooks. As most of these operations were covered in chapter Rocky module examples, they will be described here very briefly.</p>
<p>In the <code>ROCKY_PLUGIN_CONFIGURE</code> hook, the values for the module parameter are stored in the array within the module local <code>struct</code> defined previously. Subsequently, in the <code>ROCKY_PLUGIN_SETUP</code> hook, a scalar is created for storing the values of the turbulent viscosity calculated in the module. This scalar is needed as the values from neighbor elements must be accumulated in order to approximate the tensor of strain rate as a previous step for calculating the turbulent viscosity. In the lines 68-70, three operations made on the scalar that stores turbulent viscosity are made: reset values, sum of values associated to elements in the halo regions between GPUs, and copy of values of those elements between GPUs. The last two operations are done only when the module is being employed in simulations with multi GPU. According to the specification made, the order of operations in the module is the following: </p><pre class="fragment">1.  Reset of scalars

2.  Hook PRE_FORCE_ON_ELEMENT_INTERACTIONS

3.  Hook PRE_FORCE_ON_TRIANGLE_INTERACTIONS

4.  Sum of halo values between GPUs

5.  Hook PRE_FORCE_ON_ELEMENTS

6.  Copy of halo values between GPUs

7.  Hook FORCE_ON_ELEMENT_INTERACTIONS

8.  Hook FORCE_ON_TRIANGLE_INTERACTIONS
</pre><p> In the <code>ROCKY_PLUGIN_INITIALIZE_CUDA</code> hook, the local module data is copied to GPU devices after being allocated the required memory block there.</p>
<div class="fragment"><div class="line">115 // Pre-post force calls order: on_interactions -&gt; on_elements</div>
<div class="line">116 ROCKY_PLUGIN_PRE_FORCE_ON_SPH_ELEMENT_INTERACTIONS(device_model, sph_model, sph_interaction, _data)</div>
<div class="line">117 {</div>
<div class="line">118     auto data = static_cast&lt;Data*&gt;(_data);</div>
<div class="line">119</div>
<div class="line">120     // Density for interacting elements</div>
<div class="line">121     auto home_element = sph_interaction.get_home_element();</div>
<div class="line">122     auto near_element = sph_interaction.get_near_element();</div>
<div class="line">123     auto home_scalars = home_element.get_scalars();</div>
<div class="line">124     auto near_scalars = near_element.get_scalars();</div>
<div class="line">125     const float home_density = home_element.get_density();</div>
<div class="line">126     const float near_density = near_element.get_density();</div>
<div class="line">127</div>
<div class="line">128     // Distance &amp; velocity difference between elements</div>
<div class="line">129     const float3 d_diff = sph_interaction.calculate_elements_distance();</div>
<div class="line">130     const float3 v_diff = sph_interaction.calculate_elements_relative_velocity();</div>
<div class="line">131     float dd = get_norm(d_diff);</div>
<div class="line">132</div>
<div class="line">133     // Calculating the filtered strain rate per Violeau &amp; Issa (2007)</div>
<div class="line">134     const float kernel_derivative = sph_model.get_kernel_derivative(dd);</div>
<div class="line">135     dd = max(dd, sph_model.get_minimum_distance());</div>
<div class="line">136     const float d_strain_rate = -0.5f * sph_model.get_mass() * (home_density + near_density)</div>
<div class="line">137         / (home_density * near_density) * dot(v_diff) * kernel_derivative / dd;</div>
<div class="line">138</div>
<div class="line">139     // Accumulating strain rate contributions on the turbulent viscosity scalar</div>
<div class="line">140     home_scalars.add_scalar(data-&gt;turbulent_viscosity_index, d_strain_rate);</div>
<div class="line">141     near_scalars.add_scalar(data-&gt;turbulent_viscosity_index, d_strain_rate);</div>
<div class="line">142 }</div>
<div class="line">143 ROCKY_PLUGIN_PRE_FORCE_ON_SPH_ELEMENT_INTERACTIONS_END()</div>
</div><!-- fragment --><p>The block of code above implements the calculation of the rate of strain tensor for the SPH elements that are in contact, which is used to calculate the turbulent viscosity values in the following steps. The rate of strain tensor, <code>d_shear</code>, is calculated according to the equation available in section 2.4 of the SPH Technical Manual.</p>
<div class="fragment"><div class="line">115 ROCKY_PLUGIN_PRE_FORCE_ON_SPH_ELEMENTS(device_model, sph_model, sph_element, _data)</div>
<div class="line">116 {</div>
<div class="line">117 auto data = static_cast&lt;Data*&gt;(_data);</div>
<div class="line">118</div>
<div class="line">119 // Calculating turbulence coefficient</div>
<div class="line">120 float coeff = data-&gt;les_smagorinsky_constant * data-&gt;les_distance_factor</div>
<div class="line">121     * sph_model.get_initial_element_spacing();</div>
<div class="line">122 coeff *= coeff;</div>
<div class="line">123 coeff *= sph_model.get_fluid_density();</div>
<div class="line">124</div>
<div class="line">125 // Updating element turbulent viscosity</div>
<div class="line">126 auto element_scalars = sph_element.get_scalars();</div>
<div class="line">127 element_scalars.set_scalar(</div>
<div class="line">128     data-&gt;turbulent_viscosity_index,</div>
<div class="line">129     coeff * sqrt(2.0f * element_scalars.get_scalar(data-&gt;turbulent_viscosity_index)));</div>
<div class="line">130 }</div>
<div class="line">131 ROCKY_PLUGIN_PRE_FORCE_ON_SPH_ELEMENTS_END()</div>
</div><!-- fragment --><p>The block of code above implements the turbulence viscosity calculation, including the rate of strain tensor previously calculated and considering the Smagorinsky constant, the LES distance factor parameter and the initial SPH elements spacing. It represents exactly the same equation for the turbulent viscosty term calculation used in the LES model and available in section 2.3 of the SPH Technical Manual.</p>
<div class="fragment"><div class="line">115 ROCKY_PLUGIN_FORCE_ON_SPH_ELEMENT_INTERACTIONS(</div>
<div class="line">116     rocky_model, sph_model, sph_interaction, _data)</div>
<div class="line">117 {</div>
<div class="line">118     const float mass = sph_model.get_mass();</div>
<div class="line">119     auto data = static_cast&lt;Data*&gt;(_data);</div>
<div class="line">120</div>
<div class="line">121     // Interacting elements</div>
<div class="line">122     auto home_element = sph_interaction.get_home_element();</div>
<div class="line">123     auto near_element = sph_interaction.get_near_element();</div>
<div class="line">124     auto home_scalars = home_element.get_scalars();</div>
<div class="line">125     auto near_scalars = near_element.get_scalars();</div>
<div class="line">126</div>
<div class="line">127     // Distance &amp; relative velocity between interacting elements</div>
<div class="line">128     const float3 d_diff = sph_interaction.calculate_elements_distance();</div>
<div class="line">129     const float3 v_diff = sph_interaction.calculate_elements_relative_velocity();</div>
<div class="line">130     float dd = get_norm(d_diff);</div>
<div class="line">131     const float kernel_derivative = sph_model.get_kernel_derivative(dd);</div>
<div class="line">132</div>
<div class="line">133     // Pressures to density ratio</div>
<div class="line">134     const float home_density = home_element.get_density();</div>
<div class="line">135     const float near_density = near_element.get_density();</div>
<div class="line">136     const float home_pres_dens = home_element.get_pressure() / (home_density * home_density);</div>
<div class="line">137     const float near_pres_dens = near_element.get_pressure() / (near_density * near_density);</div>
<div class="line">138</div>
<div class="line">139     // Acceleration due to pressure forces</div>
<div class="line">140     float acc = kernel_derivative * mass * (home_pres_dens + near_pres_dens);</div>
<div class="line">141</div>
<div class="line">142     dd = max(dd, sph_model.get_minimum_distance());</div>
<div class="line">143     float3 acceleration = -acc * d_diff / dd;</div>
<div class="line">144</div>
<div class="line">145     // Viscous terms + LES turbulent model</div>
<div class="line">146     float home_viscosity = sph_model.get_fluid_viscosity();</div>
<div class="line">147     float near_viscosity = sph_model.get_fluid_viscosity();</div>
<div class="line">148     if (!home_element.is_dem_coupled() &amp;&amp; !near_element.is_dem_coupled())</div>
<div class="line">149     {</div>
<div class="line">150         home_viscosity += home_scalars.get_scalar(data-&gt;turbulent_viscosity_index);</div>
<div class="line">151         near_viscosity += near_scalars.get_scalar(data-&gt;turbulent_viscosity_index);</div>
<div class="line">152     }</div>
<div class="line">153</div>
<div class="line">154     /* Morris et al. (1997) approximation for the viscous term */</div>
<div class="line">155     float viscosity_coefficient = mass * (home_viscosity + near_viscosity) * kernel_derivative</div>
<div class="line">156         / (home_density * near_density) / dd;</div>
<div class="line">157     acceleration += viscosity_coefficient * v_diff;</div>
<div class="line">158</div>
<div class="line">159     // Setting accelerations</div>
<div class="line">160     sph_interaction.add_acceleration(acceleration);</div>
<div class="line">161 }</div>
<div class="line">162 ROCKY_PLUGIN_FORCE_ON_SPH_ELEMENT_INTERACTIONS_END()</div>
</div><!-- fragment --><p>The block of code above implements the LES turbulence SPH force model. The elements accelerations due to pressure and viscous forces are calculated, regarding Morris formulation for the laminar viscosity available in section 2.3.3.1 of the SPH Technical Manual. Bear in mind that this hook overrides all internal force calculations. Thus, the pressure forces are calculated besides the viscous ones, which are the only affected by the turbulent viscosity previously calculated.</p>
<div class="fragment"><div class="line">115 ROCKY_PLUGIN_FORCE_ON_SPH_TRIANGLE_INTERACTIONS(</div>
<div class="line">116     rocky_model, sph_model, sph_interaction, data)</div>
<div class="line">117 {</div>
<div class="line">118     auto home_element = sph_interaction.get_home_element();</div>
<div class="line">119     const float mass = sph_model.get_mass();</div>
<div class="line">120</div>
<div class="line">121     /* Boundary forces on free SPH elements only</div>
<div class="line">122         Viscous forces are not considered (Free Slip Boundary) */</div>
<div class="line">123</div>
<div class="line">124     if (home_element.is_enabled() &amp;&amp; !home_element.is_dem_coupled())</div>
<div class="line">125     {</div>
<div class="line">126         // Interaction distance and velocity</div>
<div class="line">127         const float distance = sph_interaction.get_distance_to_home();</div>
<div class="line">128         const float3 unit_vector = sph_interaction.get_unit_vector();</div>
<div class="line">129         const auto boundary_velocity = sph_interaction.get_boundary_velocity();</div>
<div class="line">130</div>
<div class="line">131         // Normal Acceleration</div>
<div class="line">132         float force = 0.0f;</div>
<div class="line">133         float dd = sph_model.get_boundary_distance_normal_factor()</div>
<div class="line">134             * sph_model.get_initial_element_spacing() - distance;</div>
<div class="line">135         float vnorm = 0.0f;</div>
<div class="line">136         const float3 home_velocity = sph_interaction.get_home_element_velocity();</div>
<div class="line">137         if (dd &gt; 0.0f)</div>
<div class="line">138         {</div>
<div class="line">139             // Elastic part</div>
<div class="line">140             force += sph_model.get_stiffness() * dd;</div>
<div class="line">141</div>
<div class="line">142             // Dissipation</div>
<div class="line">143             vnorm = dot(unit_vector, home_velocity - boundary_velocity);</div>
<div class="line">144             force -= sph_model.get_damping_coefficient() * vnorm;</div>
<div class="line">145             force = max(0.0f, force);</div>
<div class="line">146         }</div>
<div class="line">147</div>
<div class="line">148         // Setting forces</div>
<div class="line">149         sph_interaction.add_force(force * unit_vector);</div>
<div class="line">150     }</div>
<div class="line">151 }</div>
<div class="line">152 ROCKY_PLUGIN_FORCE_ON_SPH_TRIANGLE_INTERACTIONS_END()</div>
</div><!-- fragment --><p>The block of code above implements the normal boundary forces calculation regarding the free slip boundary condition, that uses the DEM-style interaction between the elements and the boundaries triangles. The normal repulsive forces are calculated for the SPH elements using the spring-dashpot model, with an elastic and a viscous terms, using the equations in section Specification of custom models of the SPH Technical Manual.</p>
<div class="fragment"><div class="line">115 ROCKY_PLUGIN_SPH_END()</div>
<div class="line">116 ROCKY_PLUGIN_END</div>
</div><!-- fragment --><p>After the module is built following the steps given in section Building Procedures, the module will be available to be used in Rocky. When the <code>SPH LES Turbulence Model</code> is enabled in a Rocky project, the models of turbulence, viscosity and boundary forces implemented on it will override built-in models in those categories. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
