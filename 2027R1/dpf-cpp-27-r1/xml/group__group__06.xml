<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.16.1" xml:lang="en-US">
  <compounddef id="group__group__06" kind="group">
    <compoundname>group_06</compoundname>
    <title>Debugging in DPF</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Debugging enables you to analyze how DPF runs and generates data so that you can find defects in your code. You can use the Watch window in Visual Studio to visualize any member of any object.<linebreak/>
<linebreak/>
<image type="html" name="debugger.png" inline="yes"></image>
<linebreak/>
</para>
<para><bold>Topics:</bold></para>
<para><itemizedlist>
<listitem><para>How the Debug View Works</para>
</listitem><listitem><para>Custom Views with Natvis Files</para>
</listitem><listitem><para>Combining Graph Visualization with Natvis Views</para>
</listitem><listitem><para>Usages for the CodeDV Property Sheet</para>
</listitem><listitem><para>Using the DebugTrace Function</para>
</listitem></itemizedlist>
</para>
<sect1 id="group__group__06_1autotoc_md59_1s1"><sect2 id="group__group__06_1autotoc_md59">
<title><anchor id="_1debug1"/>How the Debug View Works</title><para>The debugger can access any part of the debugged program&apos;s memory regardless of the compilation setting that you use (Debug/Release). To access the memory, the debugger uses information from a Program Database (.pdb) file. A PDB file is typically created from source files during compilation. It enables the debugger to easily navigate through objects using C++-like expressions.</para>
<para>The default debug view constructs a standard visualization for any class. However, you can define your own visualization using Natvis files.<linebreak/>
<linebreak/>
<image type="html" name="debug-views.png" inline="yes"></image>
<linebreak/>
</para>
</sect2></sect1>
<sect1 id="group__group__06_1autotoc_md60_1s1"><sect2 id="group__group__06_1autotoc_md60">
<title><anchor id="_1debug2"/>Custom Visualization with Natvis Files</title><para>The Visual Studio Natvis framework customizes the way types appear in the debug view. For more information, see <ulink url="https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects?view=vs-2022">Create custom views of C++ objects in the debugger using the Natvis framework</ulink>.</para>
<para>The comparison below provides an example of the customization that can be achieved with a .natvis file.</para>
<para><bold>Default view with no customization:</bold><linebreak/>
<linebreak/>
<image type="html" name="no-natvis.png" inline="yes"></image>
<linebreak/>
</para>
<para><bold>Custom Natvis view:</bold><linebreak/>
<linebreak/>
<image type="html" name="with-natvis.png" inline="yes"></image>
<linebreak/>
</para>
</sect2></sect1>
<sect1 id="group__group__06_1autotoc_md61_1s1"><sect2 id="group__group__06_1autotoc_md61">
<title><anchor id="_1debug3"/>Combining Graph Visualization with Natvis Views</title><para>In programming, graphs provide a visual map of your data structure and the relationships between different classes.</para>
<para>To enable graph visualization, workflows in DPF have a Graphviz export method:<linebreak/>
<linebreak/>
<image type="html" name="graphviz-export.png" inline="yes"></image>
<linebreak/>
</para>
<para>Graphviz is an open-source graph visualization tool that takes a text description of a graph and generates a diagram for you. For details see <ulink url="https://graphviz.org">https://graphviz.org</ulink>.</para>
<para>Many tools are available to render Graphviz diagrams in useful formats such as SVG images. For example,</para>
<para><itemizedlist>
<listitem><para>Notepad++ plugin</para>
</listitem><listitem><para><ulink url="https://dreampuf.github.io/GraphvizOnline">https://dreampuf.github.io/GraphvizOnline</ulink></para>
</listitem></itemizedlist>
</para>
<para>When you use a Graphviz diagram in combination with a Natvis view, you can see the content of each operator of a workflow (using their IDs).<linebreak/>
<linebreak/>
<image type="html" name="graph-combo.png" inline="yes"></image>
<linebreak/>
</para>
</sect2></sect1>
<sect1 id="group__group__06_1autotoc_md62_1s1"><sect2 id="group__group__06_1autotoc_md62">
<title><anchor id="_1debug4"/>Usages for the CodeDV Property Sheet</title><para>There are two main usages for CodeDV:DataProcessingHourglass.props:</para>
<para><itemizedlist>
<listitem><para><bold>Developing DPF for Ansys Mechanical</bold>:<itemizedlist>
<listitem><para>You compile DPF and have a DPF repository</para>
</listitem><listitem><para>You want to use your own binaries and API</para>
</listitem><listitem><para>By defining the environment variable <bold>DPF_DEV=true</bold>, the DPF repository is consumed</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><bold>Developing components that consume DPF</bold>:<itemizedlist>
<listitem><para>You do not compile DPF or have a DPF repository, but would find debugging helpful</para>
</listitem><listitem><para>By defining the environment variable <bold>DPF_COPY_DLL=true</bold>, the DLL and PDB from the DPF package are dropped into the program directory, enabling debug insight</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
</sect2></sect1>
<sect1 id="group__group__06_1autotoc_md63_1s1"><sect2 id="group__group__06_1autotoc_md63">
<title><anchor id="_1debug5"/>Using the DebugTrace Function</title><para>DebugTrace is a special mechanism that writes the input/output of each and every operator/workflow that runs within DPF.</para>
<para>There are two ways to turn on DebugTrace:</para>
<para><itemizedlist>
<listitem><para>Set the environment variable <bold>DATAPROCESSING_DEBUG</bold> to the path where you want your trace to be dumped</para>
</listitem><listitem><para>Directly within Ansys Mechanical, use <bold>Ans.DataProcessing.DataProcessing.ActivateDebugTraceâ€‹</bold></para>
</listitem></itemizedlist>
</para>
</sect2></sect1>
<sect1 id="group__group__06_1autotoc_md64_1s1"><sect2 id="group__group__06_1autotoc_md64">
<title><anchor id="_1debug6"/>Producing Chrome Trace Event traces</title><para>You can produce traces that follow the execution of operators and workflows in a format that can be interactively opened and explored. This approach does not carry any result data, unlike <bold>DATAPROCESSING_DEBUG</bold>.</para>
<para>To create the files:</para>
<para><orderedlist>
<listitem><para>Set the value of the <bold>DPF_CHROME_TRACES_ROOT</bold> environment variable to the folder where you want to create the file.</para>
</listitem><listitem><para>Run a DPF operator/workflow, a JSON file is created for each process using DPF and is stored in the folder selected in step 1.</para>
</listitem><listitem><para>Open any chrome-based browser (Edge, Chromium, Chrome, and so on).</para>
</listitem><listitem><para>Navigate to the special <computeroutput>about:tracing</computeroutput> URL.</para>
</listitem><listitem><para>Drop one of the files in this location.</para>
</listitem></orderedlist>
</para>
<para>This file also contains metrics for memory consumption of the process. While these metrics can be used to identify large memory allocation from operators, it does not provide an accurate representation of the memory allocated by DPF. Memory is allocated for the whole process, not just DPF. This may include memory mapped files and duplicates for shared memory between processes and do not accurately represent the time when memory is freed. They are not comparable between different DPF releases or different operating systems.</para>
<para>On Windows, the available measures are <computeroutput>WorkingSetSize</computeroutput> and <computeroutput>PrivateUsage</computeroutput> from <ulink url="https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-process_memory_counters_ex">PROCESS_MEMORY_COUNTERS_EX</ulink>, in bytes.</para>
<para>On Linux, the available measures are a subset of the <ulink url="https://www.kernel.org/doc/Documentation/filesystems/proc.txt">statm file</ulink> (Table 1-3), in bytes.<itemizedlist>
<listitem><para><bold>size</bold>: The total program size in memory (virtual memory, too), including all code, data, and shared libraries. Often referred to as the process&apos;s virtual memory size (VM size).</para>
</listitem><listitem><para><bold>resident_size</bold>: The Resident Set Size (RSS) is the amount of physical RAM directly allocated to the process. RSS = TRS + DRS + Shared</para>
</listitem><listitem><para><bold>trs</bold>: The Text Resident Size (TRS) is the amount of physical RAM that&apos;s occupied by code (text segment) of the current program. It&apos;s rarely used for debugging. The TRS is a subset of the RSS.</para>
</listitem><listitem><para><bold>drs</bold>: The Data Resident Size (DRS) is the amount of physical RAM that&apos;s occupied by data segment plus the heap. It&apos;s memory used for variables, dynamic allocations, and other non-code sections. The DRS is a subset of the RSS.</para>
</listitem><listitem><para><bold>shared</bold>: The amount of physical RAM that is shared with other processes. </para>
</listitem></itemizedlist>
</para>
</sect2></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
