\doxysubsection{Debugging in DPF }
\hypertarget{group__group__06}{}\label{group__group__06}\index{Debugging in DPF@{Debugging in DPF}}
Debugging enables you to analyze how DPF runs and generates data so that you can find defects in your code. You can use the Watch window in Visual Studio to visualize any member of any object.~\newline
~\newline
~\newline


{\bfseries{Topics:\+}}


\begin{DoxyItemize}
\item How the Debug View Works
\item Custom Views with Natvis Files
\item Combining Graph Visualization with Natvis Views
\item Usages for the Code\+DV Property Sheet
\item Using the Debug\+Trace Function
\end{DoxyItemize}\hypertarget{group__group__06_autotoc_md59}{}\doxysubsubsubsection{\texorpdfstring{\label{_debug1}%
How the Debug View Works}{\label{_debug1}%
How the Debug View Works}}\label{group__group__06_autotoc_md59}
The debugger can access any part of the debugged program\textquotesingle{}s memory regardless of the compilation setting that you use (Debug/\+\+Release). To access the memory, the debugger uses information from a Program Database (.pdb) file. A PDB file is typically created from source files during compilation. It enables the debugger to easily navigate through objects using C++-\/like expressions.

The default debug view constructs a standard visualization for any class. However, you can define your own visualization using Natvis files.~\newline
~\newline
~\newline
\hypertarget{group__group__06_autotoc_md60}{}\doxysubsubsubsection{\texorpdfstring{\label{_debug2}%
Custom Visualization with Natvis Files}{\label{_debug2}%
Custom Visualization with Natvis Files}}\label{group__group__06_autotoc_md60}
The Visual Studio Natvis framework customizes the way types appear in the debug view. For more information, see \href{https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects?view=vs-2022}{\texttt{Create custom views of C++ objects in the debugger using the Natvis framework}}.

The comparison below provides an example of the customization that can be achieved with a .natvis file.

{\bfseries{Default view with no customization:\+}}~\newline
~\newline
~\newline


{\bfseries{Custom Natvis view:\+}}~\newline
~\newline
~\newline
\hypertarget{group__group__06_autotoc_md61}{}\doxysubsubsubsection{\texorpdfstring{\label{_debug3}%
Combining Graph Visualization with Natvis Views}{\label{_debug3}%
Combining Graph Visualization with Natvis Views}}\label{group__group__06_autotoc_md61}
In programming, graphs provide a visual map of your data structure and the relationships between different classes.

To enable graph visualization, workflows in DPF have a Graphviz export method:\+~\newline
~\newline
~\newline


Graphviz is an open-\/source graph visualization tool that takes a text description of a graph and generates a diagram for you. For details see \href{https://graphviz.org}{\texttt{https:\+/\+/\+graphviz.\+org}}.

Many tools are available to render Graphviz diagrams in useful formats such as SVG images. For example,


\begin{DoxyItemize}
\item Notepad++ plugin
\item \href{https://dreampuf.github.io/GraphvizOnline}{\texttt{https:\+/\+/\+dreampuf.\+github.\+io/\+\+Graphviz\+Online}}
\end{DoxyItemize}

When you use a Graphviz diagram in combination with a Natvis view, you can see the content of each operator of a workflow (using their IDs).~\newline
~\newline
~\newline
\hypertarget{group__group__06_autotoc_md62}{}\doxysubsubsubsection{\texorpdfstring{\label{_debug4}%
Usages for the Code\+DV Property Sheet}{\label{_debug4}%
Usages for the Code\+DV Property Sheet}}\label{group__group__06_autotoc_md62}
There are two main usages for Code\+DV:\+Data\+Processing\+Hourglass.\+props:\+


\begin{DoxyItemize}
\item {\bfseries{Developing DPF for Ansys Mechanical}}:\+
\begin{DoxyItemize}
\item You compile DPF and have a DPF repository
\item You want to use your own binaries and API
\item By defining the environment variable {\bfseries{DPF\+\_\+\+DEV=true}}, the DPF repository is consumed
\end{DoxyItemize}
\item {\bfseries{Developing components that consume DPF}}:\+
\begin{DoxyItemize}
\item You do not compile DPF or have a DPF repository, but would find debugging helpful
\item By defining the environment variable {\bfseries{DPF\+\_\+\+COPY\+\_\+\+DLL=true}}, the DLL and PDB from the DPF package are dropped into the program directory, enabling debug insight
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{group__group__06_autotoc_md63}{}\doxysubsubsubsection{\texorpdfstring{\label{_debug5}%
Using the Debug\+Trace Function}{\label{_debug5}%
Using the Debug\+Trace Function}}\label{group__group__06_autotoc_md63}
Debug\+Trace is a special mechanism that writes the input/\+output of each and every operator/\+workflow that runs within DPF.

There are two ways to turn on Debug\+Trace:\+


\begin{DoxyItemize}
\item Set the environment variable {\bfseries{DATAPROCESSING\+\_\+\+DEBUG}} to the path where you want your trace to be dumped
\item Directly within Ansys Mechanical, use {\bfseries{Ans.\+Data\+Processing.\+Data\+Processing.\+Activate\+Debug\+Traceâ€‹}}
\end{DoxyItemize}\hypertarget{group__group__06_autotoc_md64}{}\doxysubsubsubsection{\texorpdfstring{\label{_debug6}%
Producing Chrome Trace Event traces}{\label{_debug6}%
Producing Chrome Trace Event traces}}\label{group__group__06_autotoc_md64}
You can produce traces that follow the execution of operators and workflows in a format that can be interactively opened and explored. This approach does not carry any result data, unlike {\bfseries{DATAPROCESSING\+\_\+\+DEBUG}}.

To create the files:\+


\begin{DoxyEnumerate}
\item Set the value of the {\bfseries{DPF\+\_\+\+CHROME\+\_\+\+TRACES\+\_\+\+ROOT}} environment variable to the folder where you want to create the file.
\item Run a DPF operator/\+workflow, a JSON file is created for each process using DPF and is stored in the folder selected in step 1.
\item Open any chrome-\/based browser (Edge, Chromium, Chrome, and so on).
\item Navigate to the special {\ttfamily about:\+tracing} URL.
\item Drop one of the files in this location.
\end{DoxyEnumerate}

This file also contains metrics for memory consumption of the process. While these metrics can be used to identify large memory allocation from operators, it does not provide an accurate representation of the memory allocated by DPF. Memory is allocated for the whole process, not just DPF. This may include memory mapped files and duplicates for shared memory between processes and do not accurately represent the time when memory is freed. They are not comparable between different DPF releases or different operating systems.

On Windows, the available measures are {\ttfamily Working\+Set\+Size} and {\ttfamily Private\+Usage} from \href{https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-process_memory_counters_ex}{\texttt{PROCESS\+\_\+\+MEMORY\+\_\+\+COUNTERS\+\_\+\+EX}}, in bytes.

On Linux, the available measures are a subset of the \href{https://www.kernel.org/doc/Documentation/filesystems/proc.txt}{\texttt{statm file}} (Table 1-\/3), in bytes.
\begin{DoxyItemize}
\item {\bfseries{size}}:\+ The total program size in memory (virtual memory, too), including all code, data, and shared libraries. Often referred to as the process\textquotesingle{}s virtual memory size (VM size).
\item {\bfseries{resident\+\_\+size}}:\+ The Resident Set Size (RSS) is the amount of physical RAM directly allocated to the process. RSS = TRS + DRS + Shared
\item {\bfseries{trs}}:\+ The Text Resident Size (TRS) is the amount of physical RAM that\textquotesingle{}s occupied by code (text segment) of the current program. It\textquotesingle{}s rarely used for debugging. The TRS is a subset of the RSS.
\item {\bfseries{drs}}:\+ The Data Resident Size (DRS) is the amount of physical RAM that\textquotesingle{}s occupied by data segment plus the heap. It\textquotesingle{}s memory used for variables, dynamic allocations, and other non-\/code sections. The DRS is a subset of the RSS.
\item {\bfseries{shared}}:\+ The amount of physical RAM that is shared with other processes. 
\end{DoxyItemize}