\doxysubsection{Writing a DPF operator }
\hypertarget{group__group__09}{}\label{group__group__09}\index{Writing a DPF operator@{Writing a DPF operator}}
\hypertarget{group__group__09_autotoc_md67}{}\doxysubsubsubsection{\texorpdfstring{Introduction}{Introduction}}\label{group__group__09_autotoc_md67}
The Data Processing Framework (DPF) provides numerical simulation users/\+engineers with a toolbox for accessing and transforming simulation data. It is used to handle complex pre-\/ or post-\/processing of simulation data within a simulation workflow.

In DPF, {\bfseries{Operators}} are the main object used to create, transform and stream the data. An operator is composed of a “core” that handles the calculation. It receives the data using input pins, applies a transformation and makes the data available through the output pins (think of an integrated circuit in electronics). {\bfseries{There are rules to follow to correctly write operators in a project which is already using DPF.}}

This section illustrates how to write an operator in a C++ project which is already using DPF capabilities. An operator could also be written in its own plugin.

For a set of instructions on how to create a project from scratch using DPF capabilities to define \& expose operators, refer to the \doxylink{group__group__06__2}{Creating a DPF custom operator\textquotesingle{}s library} section. For a set of instructions on how to integrate DPF capabilities in already existing project, refer to the \doxylink{group__group__06__1}{Using DPF capabilities in an existing project} section.\hypertarget{group__group__09_autotoc_md68}{}\doxysubsubsubsection{\texorpdfstring{Operator\textquotesingle{}s implementation example}{Operator\textquotesingle{}s implementation example}}\label{group__group__09_autotoc_md68}
\hypertarget{group__group__09_autotoc_md69}{}\doxysubsubsubsubsection{\texorpdfstring{Custom sort operator}{Custom sort operator}}\label{group__group__09_autotoc_md69}
In this example, an operator for custom sorting is implemented.

Note:\+ the corresponding implementation is only employed as an example. Existing "{}ascending\+\_\+sort"{} or "{}descending\+\_\+sort"{} operators are the best way to sort Field data.

Edit the file where the custom operator is implemented and add the following line if it is not already specified:\+


\begin{DoxyCode}{0}
\DoxyCodeLine{\#include\ "{}dpf\_api.h"{}}

\end{DoxyCode}


The custom operator implementation can now start.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ my\ custom\ operator\ }
\DoxyCodeLine{//\ -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{struct\ SortOperator}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ //\ identify\ the\ operator}
\DoxyCodeLine{\ \ \ \ static\ std::string\ name()\ \{\ return\ "{}custom\_sort"{};\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ describe\ the\ operator\ }
\DoxyCodeLine{\ \ \ \ static\ ansys::dpf::OperatorSpecification\ specification()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ansys::dpf::OperatorSpecification\ spec;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ spec.setDocumentation("{}This\ operator\ allows\ a\ custom\ sort\ of\ the\ input\ field\ data."{});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ spec.setInputPins(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ansys::dpf::PinDefinition(0)\ //\ set\ the\ input\ pin\ number}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .setName("{}field\_to\_sort"{})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .setAcceptedTypes(\{\ ansys::dpf::types::field\})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .setDoc("{}field\ on\ what\ must\ be\ applied\ the\ sorting"{}),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ spec.setOutputPins(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ansys::dpf::PinDefinition(0)\ //\ set\ the\ output\ pin\ number}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .setName("{}sorted\_field"{})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .setAcceptedTypes(\{\ ansys::dpf::types::field\ \})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .setDoc("{}field\ that\ has\ been\ sorted"{}),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ set\ the\ exposed\ properties\ of\ the\ operator,\ allowing\ documentation\ generation\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ spec.setProperty(ansys::dpf::spec::exposure::sExposure,\ ansys::dpf::spec::exposure::sPublic);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ spec.setProperty(ansys::dpf::spec::category::sCategory,\ "{}custom"{});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ spec.setProperty(ansys::dpf::spec::sUserName,\ "{}custom\ sort"{});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ Sets\ the\ operator\ as\ premium}
\DoxyCodeLine{\ \ \ \ \ \ \ \ spec.setProperty(ansys::dpf::spec::license::sLicense,\ ansys::dpf::spec::license::sDpf);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ return\ spec;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ define\ the\ data\ computation}
\DoxyCodeLine{\ \ \ \ static\ void\ run(ansys::dpf::OperatorMain\&\ main)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ get\ the\ input\ data}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ansys::dpf::Field\ to\_sort\ =\ main.getInputField(0);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ sort}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::vector<double>\ data;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ to\_sort.getData(data);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::sort(data.begin(),\ data.end());}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ set\ the\ output}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ansys::dpf::Field\ sorted\ =\ to\_sort.deep\_copy();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ sorted.setData(data);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ main.setOutput(0,\ sorted);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ main.setSuccessed();\ }
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\};}

\end{DoxyCode}


The {\bfseries{Sort\+Operator}} structure contains all the implementation related to the custom operator. It contains:\+
\begin{DoxyItemize}
\item a {\bfseries{name}} method (unique identifier):\+ "{}custom\+\_\+sort"{}
\item a {\bfseries{specification}} method which defines and describes the operator inputs, outputs and data computation. Here, the operator exposes one input named "{}field\+\_\+to\+\_\+sort"{} at pin 0:\+ when connecting data to this operator, the connect object should be of {\bfseries{Field}} type. It exposes one output named "{}sorted\+\_\+field"{} at pin 0, that is of {\bfseries{Field}} type.
\item a {\bfseries{run}} method which contains the data computation code. It first reads the input data, reading the {\bfseries{Field}} provided through input pin 0. It computes the data, sorting it. Then, it creates the output {\bfseries{Field}} and set it as output.
\end{DoxyItemize}

In the {\bfseries{specification}}, the "{}license"{} information is optional. If specified, the operator will require a license checkout using the specified increment while running. It will release the license increment once it has been run. Refer to the \doxylink{group__group__11}{Using DPF Context} section to learn more about licensing in DPF.\hypertarget{group__group__09_autotoc_md70}{}\doxysubsubsubsubsection{\texorpdfstring{Record the operator}{Record the operator}}\label{group__group__09_autotoc_md70}
The following code enables the operator to be accessible and must be run before any instantiation of this operator.

Working in an operator\textquotesingle{}s library (see \doxylink{group__group__06__2}{Creating a DPF custom operator\textquotesingle{}s library}), use the following code:\+


\begin{DoxyCode}{0}
\DoxyCodeLine{ansys::dpf::core::recordOperatorAtCore<SortOperator>(core\_ptr);\ }

\end{DoxyCode}


Working in an existing process (see \doxylink{group__group__06__1}{Using DPF capabilities in an existing project}), use the following code:\+


\begin{DoxyCode}{0}
\DoxyCodeLine{ansys::dpf::core::recordOperator<SortOperator>();\ }

\end{DoxyCode}
\hypertarget{group__group__09_autotoc_md71}{}\doxysubsubsubsubsection{\texorpdfstring{Instantiate the operator}{Instantiate the operator}}\label{group__group__09_autotoc_md71}
Once the operator is recorded in the process, it can be instantiated using the following code:\+


\begin{DoxyCode}{0}
\DoxyCodeLine{ansys::dpf::Operator\ my\_custom\_operator("{}custom\_sort"{});}

\end{DoxyCode}


The following can be used to check if the operator is correctly instantiated:\+


\begin{DoxyCode}{0}
\DoxyCodeLine{bool\ bIsInstantiated\ =\ !my\_custom\_operator.empty();}

\end{DoxyCode}


If b\+Is\+Instantiated value is false, either the plugin that contains the operator has not been correctly loaded, or the record is not correctly done. The spelling also must be checked. ~\newline
\hypertarget{group__group__09_autotoc_md72}{}\doxysubsubsubsubsection{\texorpdfstring{Use the operator to compute data}{Use the operator to compute data}}\label{group__group__09_autotoc_md72}
The following shows how to create a {\bfseries{Field}} containing the data to be sorted:\+


\begin{DoxyCode}{0}
\DoxyCodeLine{ansys::dpf::FieldDefinition\ fieldDef(ansys::dpf::Location("{}CustomLocation"{}),\ \{\ 1\ \});}
\DoxyCodeLine{ansys::dpf::Field\ field\_to\_sort;}
\DoxyCodeLine{field\_to\_sort.setFieldDefinition(fieldDef);}
\DoxyCodeLine{std::vector<double>\ data1(\{\ 2.1,\ 1.5,\ 4.0\ \});}
\DoxyCodeLine{std::vector<double>\ data2(\{\ 10.9,\ 9.5\ \});}
\DoxyCodeLine{field\_to\_sort.push\_back(3,\ data1);}
\DoxyCodeLine{field\_to\_sort.push\_back(7,\ data2);}

\end{DoxyCode}


Once the operator is instantied and the {\bfseries{Field}} containing the data to sort, is create. The operator can then read the input data and perform the necessary computations.


\begin{DoxyCode}{0}
\DoxyCodeLine{my\_custom\_operator.connect(0,\ field\_to\_sort);}

\end{DoxyCode}


The output can be requested. It triggers the execution of the operator and provides a {\bfseries{Field}} containing sorted data.


\begin{DoxyCode}{0}
\DoxyCodeLine{ansys::dpf::Field\ sorted\_vector\ =\ my\_custom\_operator.getOutputField(0);}
\DoxyCodeLine{double*\ sorted\_data\ =\ sorted\_vector.data().data();}

\end{DoxyCode}


{\ttfamily sorted\+\_\+data} should contain the following values with the following order:\+ 1.\+5, 2.\+1, 4.\+0, 9.\+5, 10.\+9.

See the {\bfseries{Field}} documentation to learn how to access the data.\hypertarget{group__group__09_autotoc_md73}{}\doxysubsubsubsection{\texorpdfstring{Best practices}{Best practices}}\label{group__group__09_autotoc_md73}

\begin{DoxyItemize}
\item Documentation generation uses Java\+Script, {\bfseries{\textquotesingle{}js\textquotesingle{} or \textquotesingle{}JS\textquotesingle{} chain of characters must be avoided}} in any string object of the operator specification. If this rule is not followed, the documentation generation fails.
\item Operator\textquotesingle{}s name should not contain white space and should be written in snake case.
\item Use lower case in specification\textquotesingle{}s strings, except for description.
\item Spaces must not be used in specification\textquotesingle{}s strings, except for description.
\end{DoxyItemize}\hypertarget{group__group__09_autotoc_md74}{}\doxysubsubsubsection{\texorpdfstring{Example full code compiled with Visual Studio on Windows}{Example full code compiled with Visual Studio on Windows}}\label{group__group__09_autotoc_md74}
The following is the complete code showing how to write an operator in an existing process and use it.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ DPF\ include\ files\ to\ access\ capabilities\ without\ linking\ step}
\DoxyCodeLine{\#include\ "{}dpf\_api.h"{}}
\DoxyCodeLine{\#include\ "{}dpf\_api\_i.cpp"{}}
\DoxyCodeLine{}
\DoxyCodeLine{\#include\ <iostream>}
\DoxyCodeLine{}
\DoxyCodeLine{//\ initialization\ of\ DPF\ capabilities}
\DoxyCodeLine{struct\ staticData\ \{}
\DoxyCodeLine{\ \ \ \ static\ ansys::dpf::LibraryHandle*\ \_dpfLibraryHandle;}
\DoxyCodeLine{\};}
\DoxyCodeLine{ansys::dpf::LibraryHandle*\ staticData::\_dpfLibraryHandle\ =\ new\ ansys::dpf::LibraryHandle(ansys::dpf::Context::premiumContext());}
\DoxyCodeLine{}
\DoxyCodeLine{//\ my\ custom\ operator\ }
\DoxyCodeLine{//\ -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{struct\ SortOperator}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ //\ identify\ the\ operator}
\DoxyCodeLine{\ \ \ \ static\ std::string\ name()\ \{\ return\ "{}custom\_sort"{};\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ describe\ the\ operator\ }
\DoxyCodeLine{\ \ \ \ static\ ansys::dpf::OperatorSpecification\ specification()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ansys::dpf::OperatorSpecification\ spec;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ spec.setDocumentation("{}This\ operator\ allows\ a\ custom\ sort\ of\ the\ input\ field\ data."{});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ spec.setInputPins(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ansys::dpf::PinDefinition(0)\ //\ set\ the\ input\ pin\ number}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .setName("{}field\_to\_sort"{})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .setAcceptedTypes(\{\ ansys::dpf::types::field\})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .setDoc("{}field\ on\ what\ must\ be\ applied\ the\ sorting"{}),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ spec.setOutputPins(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ansys::dpf::PinDefinition(0)\ //\ set\ the\ output\ pin\ number}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .setName("{}sorted\_field"{})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .setAcceptedTypes(\{\ ansys::dpf::types::field\ \})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .setDoc("{}field\ that\ has\ been\ sorted"{}),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ set\ the\ exposed\ properties\ of\ the\ operator,\ allowing\ documentation\ generation\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ spec.setProperty(ansys::dpf::spec::exposure::sExposure,\ ansys::dpf::spec::exposure::sPublic);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ spec.setProperty(ansys::dpf::spec::category::sCategory,\ "{}custom"{});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ spec.setProperty(ansys::dpf::spec::sUserName,\ "{}custom\ sort"{});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ Sets\ the\ operator\ as\ premium}
\DoxyCodeLine{\ \ \ \ \ \ \ \ spec.setProperty(ansys::dpf::spec::license::sLicense,\ ansys::dpf::spec::license::sDpf);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ return\ spec;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ define\ the\ data\ computation}
\DoxyCodeLine{\ \ \ \ static\ void\ run(ansys::dpf::OperatorMain\&\ main)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ get\ the\ input\ data}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ansys::dpf::Field\ to\_sort\ =\ main.getInputField(0);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ sort}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::vector<double>\ data;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ to\_sort.getData(data);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::sort(data.begin(),\ data.end());}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ set\ the\ output}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ansys::dpf::Field\ sorted\ =\ to\_sort.deep\_copy();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ sorted.setData(data);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ main.setOutput(0,\ sorted);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ main.setSuccessed();}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{int\ main()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ ansys::dpf::core::recordOperator<SortOperator>();\ //\ record\ the\ operator\ to\ make\ it\ accessible}
\DoxyCodeLine{\ \ \ \ ansys::dpf::Operator\ my\_custom\_operator("{}custom\_sort"{});}
\DoxyCodeLine{\ \ \ \ bool\ bIsInstantiated\ =\ !my\_custom\_operator.empty();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ ansys::dpf::FieldDefinition\ fieldDef(ansys::dpf::Location("{}CustomLocation"{}),\ \{\ 1\ \});}
\DoxyCodeLine{\ \ \ \ ansys::dpf::Field\ field\_to\_sort;}
\DoxyCodeLine{\ \ \ \ field\_to\_sort.setFieldDefinition(fieldDef);}
\DoxyCodeLine{\ \ \ \ std::vector<double>\ data1(\{\ 2.1,\ 1.5,\ 4.0\ \});}
\DoxyCodeLine{\ \ \ \ std::vector<double>\ data2(\{\ 10.9,\ 9.5\ \});}
\DoxyCodeLine{\ \ \ \ field\_to\_sort.push\_back(3,\ data1);}
\DoxyCodeLine{\ \ \ \ field\_to\_sort.push\_back(7,\ data2);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ my\_custom\_operator.connect(0,\ field\_to\_sort);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ ansys::dpf::Field\ sorted\_vector\ =\ my\_custom\_operator.getOutputField(0);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ double*\ sorted\_data\ =\ sorted\_vector.data().data();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ for\ (int\ i\ =\ 0;\ i\ <\ sorted\_vector.dataSize();\ i++)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::cout\ <<\ std::to\_string(sorted\_data[i]).c\_str()\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::cout\ <<\ "{}\ "{}\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


It can be compiled on Visual Studio using the VCXPROJ file in \doxylink{group__group__06__1}{Using DPF capabilities in an existing project} section. 