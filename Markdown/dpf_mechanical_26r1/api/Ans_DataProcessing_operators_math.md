---
uid: Ans.DataProcessing.operators.math
---

# Ans.DataProcessing.operators.math Namespace

## Classes

| Class | Description |
|-------|-------------|
| [absolute_value_by_component](Ans_DataProcessing_operators_math_absolute_value_by_component.md) | absolute_value_by_component() |
| [absolute_value_by_component_fc](Ans_DataProcessing_operators_math_absolute_value_by_component_fc.md) | Computes the absolute value of each data value in the input field component-wise, without performing vector norm operations.   ///available inputs: fields_container (FieldsContainer) |
| [accumulate](Ans_DataProcessing_operators_math_accumulate.md) | Sums all the elementary data of a field to produce one elementary data point.   ///available inputs: fieldA (Field, FieldsContainer), weights (Field) (optional), time_scoping (Scoping) (optional) |
| [accumulate_fc](Ans_DataProcessing_operators_math_accumulate_fc.md) | Sums all the elementary data of a field to produce one elementary data point.   ///available inputs: fields_container (FieldsContainer), weights (Field) (optional), time_scoping (Scoping) (optional) |
| [accumulate_level_over_label_fc](Ans_DataProcessing_operators_math_accumulate_level_over_label_fc.md) | Compute the component-wise sum over all the fields that have the same ID as the label set as input in the fields container and apply 10.0xlog10(data/10xx-12) on the result. This computation can be incremental. If the input fields container is connected and the operator is run multiple times, the output field will be on all the connected inputs.   ///available inputs: fields_container (FieldsContainer), label (string) (optional) |
| [accumulate_min_over_label_fc](Ans_DataProcessing_operators_math_accumulate_min_over_label_fc.md) | Compute the component-wise sum over all the fields that have the same ID as the label set as input in the fields container and take its opposite. This computation can be incremental. If the input fields container is connected and the operator is run multiple times, the output field will be on all the connected inputs.   ///available inputs: fields_container (FieldsContainer), label (string) (optional) |
| [accumulate_over_label_fc](Ans_DataProcessing_operators_math_accumulate_over_label_fc.md) | Compute the component-wise sum over all the fields that have the same ID as the label set as input in the fields container. This computation can be incremental. If the input fields container is connected and the operator is run multiple times, the output field will be on all the connected inputs.   ///available inputs: fields_container (FieldsContainer), label (string) (optional) |
| [accumulation_per_scoping](Ans_DataProcessing_operators_math_accumulation_per_scoping.md) | This operator calculates the sum and the percentage of total sum of the input fields container for each scoping of the scopings container.   ///available inputs: fields_container (FieldsContainer), mesh_scoping (Scoping) (optional), streams_container (StreamsContainer), data_sources (DataSources), scopings_container (ScopingsContainer) |
| [add](Ans_DataProcessing_operators_math_add.md) | add() |
| [add_constant](Ans_DataProcessing_operators_math_add_constant.md) | add_constant() |
| [add_constant_fc](Ans_DataProcessing_operators_math_add_constant_fc.md) | add_constant_fc() |
| [add_fc](Ans_DataProcessing_operators_math_add_fc.md) | add_fc() |
| [amplitude](Ans_DataProcessing_operators_math_amplitude.md) | Computes amplitude of a real and an imaginary field.   ///available inputs: fieldA (Field, FieldsContainer), fieldB (Field, FieldsContainer) |
| [amplitude_fc](Ans_DataProcessing_operators_math_amplitude_fc.md) | Computes the amplitude of a real and an imaginary field.   ///available inputs: fields_container (FieldsContainer) |
| [average_over_label_fc](Ans_DataProcessing_operators_math_average_over_label_fc.md) | Compute the component-wise average over all the fields that have the same ID as the label set as input in the fields container. This computation can be incremental. If the input fields container is connected and the operator is run multiple times, the output field will be on all the connected inputs.   ///available inputs: fields_container (FieldsContainer), label (string) (optional) |
| [centroid](Ans_DataProcessing_operators_math_centroid.md) | Computes centroid of field1 and field2, using fieldOut = field1*(1.-fact)+field2*(fact). Only works by index.   ///available inputs: fieldA (Field, FieldsContainer), fieldB (Field, FieldsContainer), factor (double) |
| [centroid_fc](Ans_DataProcessing_operators_math_centroid_fc.md) | Computes the centroid of all the matching fields of a fields container at a given time or frequency, using fieldOut = field1*(1.-fact)+field2*(fact).   ///available inputs: fields_container (FieldsContainer), time_freq (double), step (Int32) (optional), time_freq_support (TimeFreqSupport) (optional) |
| [component_wise_divide](Ans_DataProcessing_operators_math_component_wise_divide.md) | Computes component-wise fraction between two fields of same dimensionality. If one field's scoping has an 'overall' location, then this field's values are applied on the other field entirely. When using a constant or 'work_by_index', you can use 'inplace' to reuse one of the fields.   ///available inputs: fieldA (Field, FieldsContainer), fieldB (Field, FieldsContainer) |
| [component_wise_divide_fc](Ans_DataProcessing_operators_math_component_wise_divide_fc.md) | For every two fields with the same label space (from the two input fields containers), computes component-wise fraction between two fields of same dimensionality. If one field's scoping has an 'overall' location, then this field's values are applied on the other field entirely.   ///available inputs: fields_containerA (FieldsContainer), fields_containerB (FieldsContainer) |
| [component_wise_product](Ans_DataProcessing_operators_math_component_wise_product.md) | Computes component-wise product between two fields of same dimensionality. If one field's scoping has an 'overall' location, then this field's values are applied on the other field entirely. When using a constant or 'work_by_index', you can use 'inplace' to reuse one of the fields.   ///available inputs: fieldA (Field, FieldsContainer), fieldB (Field, FieldsContainer) |
| [component_wise_product_fc](Ans_DataProcessing_operators_math_component_wise_product_fc.md) | Computes component-wise product between two fields of same dimensionality. If one field's scoping has an 'overall' location, then this field's values are applied on the other field entirely. When using a constant or 'work_by_index', you can use 'inplace' to reuse one of the fields.   ///available inputs: fields_container (FieldsContainer), fieldB (Field, FieldsContainer) |
| [compute_residual_and_error](Ans_DataProcessing_operators_math_compute_residual_and_error.md) | Computes the Lp-norm of a field or a field container. |
| [conjugate](Ans_DataProcessing_operators_math_conjugate.md) | Computes element-wise conjugate of field containers containing complex fields.   ///available inputs: fields_container (FieldsContainer) |
| [correlation](Ans_DataProcessing_operators_math_correlation.md) | correlation() |
| [cos](Ans_DataProcessing_operators_math_cos.md) | Computes element-wise cosine function on field data: cos(field[i]).   ///available inputs: field (Field, FieldsContainer) |
| [cos_fc](Ans_DataProcessing_operators_math_cos_fc.md) | Computes element-wise cosine function on field data: cos(field[i]).   ///available inputs: fields_container (FieldsContainer) |
| [cplx_derive](Ans_DataProcessing_operators_math_cplx_derive.md) | Derives field containers containing complex fields.   ///available inputs: fields_container (FieldsContainer) |
| [cplx_divide](Ans_DataProcessing_operators_math_cplx_divide.md) | Computes division between two field containers containing complex fields.   ///available inputs: fields_containerA (FieldsContainer), fields_containerB (FieldsContainer) |
| [cplx_dot](Ans_DataProcessing_operators_math_cplx_dot.md) | Computes product between two field containers containing complex fields.   ///available inputs: fields_containerA (FieldsContainer), fields_containerB (FieldsContainer) |
| [cplx_multiply](Ans_DataProcessing_operators_math_cplx_multiply.md) | Computes multiplication between two field containers containing complex fields.   ///available inputs: fields_containerA (FieldsContainer), fields_containerB (FieldsContainer) |
| [cross_product](Ans_DataProcessing_operators_math_cross_product.md) | cross_product() |
| [cross_product_fc](Ans_DataProcessing_operators_math_cross_product_fc.md) | cross_product_fc() |
| [dot](Ans_DataProcessing_operators_math_dot.md) | DEPRECATED, PLEASE USE GENERALIZED INNER PRODUCT. Computes element - wise dot product between two vector fields. If one field's scoping has an 'overall' location, then this field's values are applied on the other field entirely.When using a constant or 'work_by_index', you can use 'inplace' to reuse one of the fields, but only in the case where both fields are scalar.   ///available inputs: fieldA (Field, FieldsContainer), fieldB (Field, FieldsContainer) |
| [dot_tensor](Ans_DataProcessing_operators_math_dot_tensor.md) | DEPRECATED, PLEASE USE GENERALIZED INNER PRODUCT. Computes element-wise dot product between two tensor fields.   ///available inputs: fieldA (Field, FieldsContainer), fieldB (Field, FieldsContainer) |
| [entity_extractor](Ans_DataProcessing_operators_math_entity_extractor.md) | Extracts an entity from a field, based on its ID.   ///available inputs: fieldA (Field), scalar_int (Int32) |
| [expansion_psd](Ans_DataProcessing_operators_math_expansion_psd.md) | Computes the PSD response for one-sigma solution.   ///available inputs: mode_shapes (FieldsContainer), static_shapes (FieldsContainer) (optional), rel_rel_covar_matrix (FieldsContainer), stat_stat_covar_matrix (FieldsContainer) (optional), rel_stat_covar_matrix (FieldsContainer) (optional) |
| [exponential](Ans_DataProcessing_operators_math_exponential.md) | exponential() |
| [exponential_fc](Ans_DataProcessing_operators_math_exponential_fc.md) | Computes element-wise exponential function on field data: exp(field[i]).   ///available inputs: fields_container (FieldsContainer) |
| [fft_approx](Ans_DataProcessing_operators_math_fft_approx.md) | Computes the fitting curve using FFT filtering and cubic fitting in space (node i: x=time, y=data), with the possibility to compute the first and the second derivatives of the curve.   ///available inputs: time_scoping (IList int, Scoping, System.Collections.IEnumerable) (optional), mesh_scoping (Scoping, ScopingsContainer) (optional), entity_to_fit (FieldsContainer), component_number (Int32), first_derivative (bool), second_derivative (bool), fit_data (bool), cutoff_fr (double, Int32) (optional) |
| [fft_eval](Ans_DataProcessing_operators_math_fft_eval.md) | Evaluate the fast fourier transforms at a given set of fields.   ///available inputs: field_t (Field), time_scoping (Scoping) (optional) |
| [fft_gradient_eval](Ans_DataProcessing_operators_math_fft_gradient_eval.md) | Evaluate min max based on the fast fourier transform at a given field, using gradient method for adaptative time step.   ///available inputs: fields_container (FieldsContainer), time_scoping (Scoping) (optional), fs_ratio (Int32) (optional) |
| [fft_multi_harmonic_minmax](Ans_DataProcessing_operators_math_fft_multi_harmonic_minmax.md) | Evaluate min max fields on multi harmonic solution. min and max fields are calculated based on evaluating a fourier series sum wrt rpms and using the gradient method for adaptive time steping   ///available inputs: fields_container (FieldsContainer), rpm_scoping (Scoping) (optional), fs_ratio (Int32) (optional), num_subdivisions (Int32) (optional), max_num_subdivisions (Int32) (optional), num_cycles (Int32) (optional), use_harmonic_zero (bool) (optional), calculate_time_series (bool) (optional), substeps_selector (IList int, System.Collections.IEnumerable) (optional) |
| [generalized_inner_product](Ans_DataProcessing_operators_math_generalized_inner_product.md) | generalized_inner_product() |
| [generalized_inner_product_fc](Ans_DataProcessing_operators_math_generalized_inner_product_fc.md) | generalized_inner_product_fc() |
| [img_part](Ans_DataProcessing_operators_math_img_part.md) | Extracts element-wise imaginary part of field containers containing complex fields.   ///available inputs: fields_container (FieldsContainer) |
| [invert](Ans_DataProcessing_operators_math_invert.md) | DEPRECATED, PLEASE USE DIVIDE. Computes the element-wise and component-wise inverse of a field (1./x).   ///available inputs: field (Field, FieldsContainer) |
| [invert_fc](Ans_DataProcessing_operators_math_invert_fc.md) | DEPRECATED, PLEASE USE DIVIDE. Computes the element-wise and component-wise inverse of a field (1./x).   ///available inputs: fields_container (FieldsContainer) |
| [kronecker_prod](Ans_DataProcessing_operators_math_kronecker_prod.md) | Computes element-wise Kronecker product between two tensor fields.   ///available inputs: fieldA (Field, FieldsContainer), fieldB (Field, FieldsContainer) |
| [linear_combination](Ans_DataProcessing_operators_math_linear_combination.md) | Computes aXY + bZ where a,b (in 0, in 3) are scalar and X,Y,Z (in 1,2,4) are complex numbers.   ///available inputs: a (double), fields_containerA (FieldsContainer), fields_containerB (FieldsContainer), b (double), fields_containerC (FieldsContainer) |
| [ln](Ans_DataProcessing_operators_math_ln.md) | ln() |
| [ln_fc](Ans_DataProcessing_operators_math_ln_fc.md) | Computes element-wise ln(field[i]).   ///available inputs: fields_container (FieldsContainer) |
| [mac](Ans_DataProcessing_operators_math_mac.md) | Computes MAC Matrix between two fields container, both for real and complex cases. For mixed cases (real-complex and complex) only the real part is considered. Providing inputs with the same component scoping is an user responsability.   ///available inputs: fields_containerA (FieldsContainer), fields_containerB (FieldsContainer), weights (Field) |
| [make_one_on_comp](Ans_DataProcessing_operators_math_make_one_on_comp.md) | Takes the input field's scoping and creates a field full of zeros, except for the indexes from pin 1 that will hold 1.0.   ///available inputs: fieldA (Field), scalar_int (Int32) |
| [matrix_inverse](Ans_DataProcessing_operators_math_matrix_inverse.md) | Computes the complex matrix inverse for each field in the given fields container.   ///available inputs: fields_container (FieldsContainer) |
| [minus](Ans_DataProcessing_operators_math_minus.md) | minus() |
| [minus_fc](Ans_DataProcessing_operators_math_minus_fc.md) | minus_fc() |
| [modal_damping_ratio](Ans_DataProcessing_operators_math_modal_damping_ratio.md) | modal_damping_ratio() |
| [modal_participation](Ans_DataProcessing_operators_math_modal_participation.md) | Compute the modal participation factor for a given vector field V, defined as  sum_i ( V .dot. mode_shape_i * ponderation ).   ///available inputs: v_real (Field), v_imag (Field), mode_shapes (FieldsContainer), ponderation (Field) (optional), force_label_space (LabelSpace) (optional) |
| [modal_superposition](Ans_DataProcessing_operators_math_modal_superposition.md) | Computes the solution in the time/frequency space from a modal solution by multiplying a modal basis (in 0)by the solution in this modal space (coefficients for each mode for each time/frequency) (in 1).   ///available inputs: modal_basis (FieldsContainer), solution_in_modal_space (FieldsContainer), incremental_fc (FieldsContainer) (optional), time_scoping (Scoping, IList int, System.Collections.IEnumerable) (optional), mesh_scoping (Scoping, ScopingsContainer) (optional) |
| [modulus](Ans_DataProcessing_operators_math_modulus.md) | Computes element-wise modulus of field containers containing complex fields.   ///available inputs: fields_container (FieldsContainer) |
| [norm](Ans_DataProcessing_operators_math_norm.md) | Computes the element-wise Lp norm of the field elementary data. Default Lp=L2   ///available inputs: field (Field, FieldsContainer), scalar_int (Int32) (optional) |
| [norm_fc](Ans_DataProcessing_operators_math_norm_fc.md) | Computes the element-wise L2 norm of the field elementary data. This process is applied on each field of the input fields container.   ///available inputs: fields_container (FieldsContainer), scalar_int (Int32) (optional) |
| [outer_product](Ans_DataProcessing_operators_math_outer_product.md) | outer_product() |
| [overall_dot](Ans_DataProcessing_operators_math_overall_dot.md) | Computes a dot product between two fields (fields are seen like a single large vector) and returns a scalar.   ///available inputs: fieldA (Field), fieldB (Field) |
| [phase](Ans_DataProcessing_operators_math_phase.md) | Computes the phase (in rad) between a real and an imaginary field.   ///available inputs: fieldA (Field, FieldsContainer), fieldB (Field, FieldsContainer) |
| [phase_fc](Ans_DataProcessing_operators_math_phase_fc.md) | Computes phase (in rad) between real and imaginary fields.   ///available inputs: fields_container (FieldsContainer) |
| [polar_to_cplx](Ans_DataProcessing_operators_math_polar_to_cplx.md) | Converts a complex number from polar form to complex.   ///available inputs: fields_container (FieldsContainer) |
| [pow](Ans_DataProcessing_operators_math_pow.md) | Computes element-wise field[i]^p.   ///available inputs: field (Field), factor (double) |
| [pow_fc](Ans_DataProcessing_operators_math_pow_fc.md) | Computes element-wise field[i]^p.   ///available inputs: fields_container (FieldsContainer), factor (double) |
| [qr_solve](Ans_DataProcessing_operators_math_qr_solve.md) | Computes the solution using QR factorization.   ///available inputs: fields_container (FieldsContainer), rhs (FieldsContainer) |
| [real_part](Ans_DataProcessing_operators_math_real_part.md) | Extracts element-wise real part of field containers containing complex fields.   ///available inputs: fields_container (FieldsContainer) |
| [relative_error](Ans_DataProcessing_operators_math_relative_error.md) | relative_error() |
| [scale](Ans_DataProcessing_operators_math_scale.md) | scale() |
| [scale_by_field](Ans_DataProcessing_operators_math_scale_by_field.md) | DEPRECATED, PLEASE USE SCALE. Scales a field (in 0) by a scalar field (in 1). If one field's scoping has an 'overall' location, then this field's values are applied on the other field entirely.   ///available inputs: fieldA (Field, FieldsContainer), fieldB (Field, FieldsContainer) |
| [scale_by_field_fc](Ans_DataProcessing_operators_math_scale_by_field_fc.md) | DEPRECATED, PLEASE USE SCALE. Scales a field (in 0) by a scalar field (in 1). If one field's scoping has an 'overall' location, then this field's values are applied on the other field entirely.   ///available inputs: field_or_fields_container_A (Field, FieldsContainer), field_or_fields_container_B (Field, FieldsContainer) |
| [scale_fc](Ans_DataProcessing_operators_math_scale_fc.md) | scale_fc() |
| [sin](Ans_DataProcessing_operators_math_sin.md) | Computes element-wise sine function on field data: sin(field[i]).   ///available inputs: field (Field) |
| [sin_fc](Ans_DataProcessing_operators_math_sin_fc.md) | Computes element-wise sine function on field data: sin(field[i]).   ///available inputs: fields_container (FieldsContainer) |
| [sqr](Ans_DataProcessing_operators_math_sqr.md) | Computes element-wise field[i]^2.   ///available inputs: field (Field, FieldsContainer) |
| [sqr_fc](Ans_DataProcessing_operators_math_sqr_fc.md) | Computes element-wise field[i]^2.   ///available inputs: fields_container (FieldsContainer) |
| [sqrt](Ans_DataProcessing_operators_math_sqrt.md) | Computes element-wise square root function on field data: sqrt(field[i]).   ///available inputs: field (Field, FieldsContainer) |
| [sqrt_fc](Ans_DataProcessing_operators_math_sqrt_fc.md) | Computes element-wise square root function on field data: sqrt(field[i]).   ///available inputs: fields_container (FieldsContainer) |
| [svd](Ans_DataProcessing_operators_math_svd.md) | Computes the matrix singular value decomposition (SVD) for each field in the given fields container.   ///available inputs: fields_container (FieldsContainer) |
| [sweeping_phase](Ans_DataProcessing_operators_math_sweeping_phase.md) | Shifts the phase of a real and an imaginary field (in 0 and 1) of a given angle (in 3) of a unit (in 4). The resulting field is computed as field_out = real_field`*`cos(angle) - imaginary_field`*`sin(angle).   ///available inputs: real_field (Field, FieldsContainer), imaginary_field (Field, FieldsContainer), angle (double), unit_name (string) (optional), abs_value (bool), imaginary_part_null (bool) |
| [sweeping_phase_fc](Ans_DataProcessing_operators_math_sweeping_phase_fc.md) | Shifts the phase of all the corresponding real and imaginary fields of a fields container for a given angle (in 2) of a unit (in 4). An output field is computed for each pair of real and imaginary fields in the input fields_container as field_out = real_field`*`cos(angle) - imaginary_field`*`sin(angle).   ///available inputs: fields_container (FieldsContainer), angle (double), unit_name (string) (optional), abs_value (bool) |
| [time_derivation](Ans_DataProcessing_operators_math_time_derivation.md) | Derives a field of time varying quantities with respect to time   ///available inputs: field (Field), spline_fitting (bool) (optional) |
| [time_freq_interpolation](Ans_DataProcessing_operators_math_time_freq_interpolation.md) | time_freq_interpolation() |
| [time_integration](Ans_DataProcessing_operators_math_time_integration.md) | Integrates a field of time varying quantities over time   ///available inputs: field (Field), resample_output (bool) (optional), absolute_error (double) (optional), minimum_step_size (double) (optional), integration_constant (double) (optional) |
| [unit_convert](Ans_DataProcessing_operators_math_unit_convert.md) | Converts an input field/fields container or mesh of a given unit to another unit.   ///available inputs: entity_to_convert (Field, FieldsContainer, MeshedRegion, MeshesContainer), unit_name (string, Int32, Field) |
| [unit_convert_fc](Ans_DataProcessing_operators_math_unit_convert_fc.md) | Converts an input fields container of a given unit to another unit.   ///available inputs: fields_container (FieldsContainer), unit_name (string) |
| [window_bartlett](Ans_DataProcessing_operators_math_window_bartlett.md) | Apply bartlett windowing on a given FieldsContainer having time label or a Field located on time. Assume that time sampling is evenly spaced (use time_freq_interpolation before otherwise).   ///available inputs: field (Field, FieldsContainer) |
| [window_bartlett_fc](Ans_DataProcessing_operators_math_window_bartlett_fc.md) | Apply bartlett windowing on a given FieldsContainer having time label or a Field located on time. Assume that time sampling is evenly spaced (use time_freq_interpolation before otherwise).   ///available inputs: fields_container (FieldsContainer) |
| [window_blackman](Ans_DataProcessing_operators_math_window_blackman.md) | Apply blackman windowing on a given FieldsContainer having time label or a Field located on time. Assume that time sampling is evenly spaced (use time_freq_interpolation before otherwise).   ///available inputs: field (Field, FieldsContainer) |
| [window_blackman_fc](Ans_DataProcessing_operators_math_window_blackman_fc.md) | Apply blackman windowing on a given FieldsContainer having time label or a Field located on time. Assume that time sampling is evenly spaced (use time_freq_interpolation before otherwise).   ///available inputs: fields_container (FieldsContainer) |
| [window_hamming](Ans_DataProcessing_operators_math_window_hamming.md) | Apply hamming windowing on a given FieldsContainer having time label or a Field located on time. Assume that time sampling is evenly spaced (use time_freq_interpolation before otherwise).   ///available inputs: field (Field, FieldsContainer) |
| [window_hamming_fc](Ans_DataProcessing_operators_math_window_hamming_fc.md) | Apply hamming windowing on a given FieldsContainer having time label or a Field located on time. Assume that time sampling is evenly spaced (use time_freq_interpolation before otherwise).   ///available inputs: fields_container (FieldsContainer) |
| [window_hanning](Ans_DataProcessing_operators_math_window_hanning.md) | Apply hanning windowing on a given FieldsContainer having time label or a Field located on time. Assume that time sampling is evenly spaced (use time_freq_interpolation before otherwise).   ///available inputs: field (Field, FieldsContainer) |
| [window_hanning_fc](Ans_DataProcessing_operators_math_window_hanning_fc.md) | Apply hanning windowing on a given FieldsContainer having time label or a Field located on time. Assume that time sampling is evenly spaced (use time_freq_interpolation before otherwise).   ///available inputs: fields_container (FieldsContainer) |
| [window_triangular](Ans_DataProcessing_operators_math_window_triangular.md) | Apply triangular windowing on a given FieldsContainer having time label or a Field located on time. Assume that time sampling is evenly spaced (use time_freq_interpolation before otherwise).   ///available inputs: field (Field, FieldsContainer) |
| [window_triangular_fc](Ans_DataProcessing_operators_math_window_triangular_fc.md) | Apply triangular windowing on a given FieldsContainer having time label or a Field located on time. Assume that time sampling is evenly spaced (use time_freq_interpolation before otherwise).   ///available inputs: fields_container (FieldsContainer) |
| [window_welch](Ans_DataProcessing_operators_math_window_welch.md) | Apply welch windowing on a given FieldsContainer having time label or a Field located on time. Assume that time sampling is evenly spaced (use time_freq_interpolation before otherwise).   ///available inputs: field (Field, FieldsContainer) |
| [window_welch_fc](Ans_DataProcessing_operators_math_window_welch_fc.md) | Apply welch windowing on a given FieldsContainer having time label or a Field located on time. Assume that time sampling is evenly spaced (use time_freq_interpolation before otherwise).   ///available inputs: fields_container (FieldsContainer) |
