# Example Test001.cpp undefined

<a id="_test001_8cpp-example"></a>

Lighted textured box.





This example creates a simple box object that is colored by a randomized texture coordinate that ranges from -5 to +5. The texture coordinate is applied to TEXCOORD0 so that the ANSYSViewer can show the texture coordinate value in the tooltip. This simulates coloring a mesh by a variable value.





Two lights are added to the scene to provide feature enhancement as the scene is transformed in the [ANSYS](namespace_a_n_s_y_s.md#namespace_a_n_s_y_s) Viewer.





An orthographic camera is added to the scene with a default identity transformation. Because of this identity transformation, the simple box is not initially positioned in the most optimal location in the scene.





The shaders for this example are automatically generated by the GLTFWriter API. 
```
/*
 * Copyright 2018-2021 ANSYS, Inc. Unauthorized use, distribution, or duplication is prohibited.
 * 
 * Restricted Rights Legend
 *
 * Use, duplication, or disclosure of this
 * software and its documentation by the
 * Government is subject to restrictions as
 * set forth in subdivision [(b)(3)(ii)] of
 * the Rights in Technical Data and Computer
 * Software clause at 52.227-7013.
 */
#include <vector>

#include "GLTFWriter.h"
#include "test.h"

using namespace ANSYS::AVZ;

// Lighted textured box
TESTFUNC(LightedTextured)
{
    GLTFWriter::GLTF *gltf = GLTFWriter::GLTF::Create("MyApp", "1.0", functionName.c_str(), type);
    if (!gltf)
        throw std::runtime_error("Can't create GLTF");

    // SCENE
    GLTFWriter::Scene *scene = GLTFWriter::Scene::Create(gltf, "TestScene", "m", 1.0, GLTFWriter::Scene::BT_SOLID, 0.5, 0.5, 0.5);
    if (!scene) {
        GLTFWriter::GLTF::Destroy(gltf);
        throw std::runtime_error("Can't create scene");
    }

    // LIGHTS
    {
        // LIGHT NODE
        GLTFWriter::Node *lightNode = GLTFWriter::Node::CreateLight(gltf);
        if (!lightNode || !scene->SetLight(lightNode)) {
            GLTFWriter::GLTF::Destroy(gltf);
            throw std::runtime_error("Can't create light");
        }

        // LIGHTS
        GLTFWriter::Light *light1 = GLTFWriter::Light::CreateAmbient(gltf);
        if (!light1 || !lightNode->AppendLight(light1)) {
            GLTFWriter::GLTF::Destroy(gltf);
            throw std::runtime_error("Can't create ambient light");
        }

        GLTFWriter::Light *light2 = GLTFWriter::Light::CreateDirectional(gltf, 1, 1, 1, -1, -1, -1);
        if (!light2 || !lightNode->AppendLight(light2)) {
            GLTFWriter::GLTF::Destroy(gltf);
            throw std::runtime_error("Can't create directional light");
        }
    }

    // CAMERA
    {
        // CAMERA
        GLTFWriter::Camera *camera = GLTFWriter::Camera::CreateOrthographic(gltf);
        if (!camera) {
            GLTFWriter::GLTF::Destroy(gltf);
            throw std::runtime_error("Can't create orthographic camera");
        }

        // CAMERA NODE
        std::vector<double> mat(16);
        mat[0] = 5.196278945;
        mat[1] = -4.840306463;
        mat[2] = 4.029489439;
        mat[3] = 0;
        mat[4] = -5.359816103;
        mat[5] = -0.655435923;
        mat[6] = 6.124495225;
        mat[7] = 0;
        mat[8] = -3.307222875;
        mat[9] = -6.54282078;
        mat[10] = -3.594501324;
        mat[11] = 0;
        mat[12] = 0.124828378;
        mat[13] = 0.10487708;
        mat[14] = 0.152340059;
        mat[15] = 1;

        GLTFWriter::Node *cameraNode = GLTFWriter::Node::CreateCamera(gltf, camera, "TestCamera", &mat[0]);
        if (!cameraNode || !scene->SetCamera(cameraNode)) {
            GLTFWriter::GLTF::Destroy(gltf);
            throw std::runtime_error("Can't set camera");
        }
    }

    // MESH NODE
    {
        // NODE
        std::vector<double> mat(16);
        mat[0] = 1;
        mat[1] = 0;
        mat[2] = 0;
        mat[3] = 0;
        mat[4] = 0;
        mat[5] = 1;
        mat[6] = 0;
        mat[7] = 0;
        mat[8] = 0;
        mat[9] = 0;
        mat[10] = 1;
        mat[11] = 0;
        mat[12] = 1;
        mat[13] = 1;
        mat[14] = 1;
        mat[15] = 1;

        GLTFWriter::Node *node = GLTFWriter::Node::CreateMesh(gltf, "3D Box", true, &mat[0]);
        if (!node || !scene->AppendMesh(node)) {
            GLTFWriter::GLTF::Destroy(gltf);
            throw std::runtime_error("Can't create mesh node");
        }

        // MESH
        GLTFWriter::Mesh *mesh = GLTFWriter::Mesh::Create(gltf);
        if (!mesh || !node->AppendMesh(mesh)) {
            GLTFWriter::GLTF::Destroy(gltf);
            throw std::runtime_error("Can't create mesh");
        }

        // TEXTURE
        std::vector<unsigned char> colors;
        colors.push_back(0); colors.push_back(0); colors.push_back(255); // blue
        colors.push_back(0); colors.push_back(255); colors.push_back(255); // cyan
        colors.push_back(0); colors.push_back(255); colors.push_back(0); // green
        colors.push_back(255); colors.push_back(255); colors.push_back(0); // yellow
        colors.push_back(255); colors.push_back(0); colors.push_back(0); // red
        colors.push_back(255); colors.push_back(0); colors.push_back(255); // magenta
        GLTFWriter::Texture *rainbowGradientTexture = GLTFWriter::Texture::Create(gltf, GLTFWriter::Texture::TF_RGB, (unsigned int)colors.size() / 3, &colors[0], true);
        if (!rainbowGradientTexture) {
            GLTFWriter::GLTF::Destroy(gltf);
            throw std::runtime_error("Can't create texture");
        }

        GLTFWriter::Test::PrimMat pm = GLTFWriter::Test::CreateTexturedBoxPrimitive(gltf, rainbowGradientTexture, 0, 0, 0, 2, 4, 6);
        mesh->AppendPrimitive(pm.first);
    }

    if (!gltf->Write()) {
        GLTFWriter::GLTF::Destroy(gltf);
        throw std::runtime_error("Error creating file");
    }

    GLTFWriter::GLTF::GLTFError error = gltf->GetError();

    GLTFWriter::GLTF::Destroy(gltf);

    if (error != GLTFWriter::GLTF::GLTF_ERROR_NONE)
        throw std::runtime_error("Error creating file");
}
```

[public]: https://img.shields.io/badge/-public-brightgreen (public)
[protected]: https://img.shields.io/badge/-protected-yellow (protected)
[static]: https://img.shields.io/badge/-static-lightgrey (static)
[C++]: https://img.shields.io/badge/language-C%2B%2B-blue (C++)
[Python]: https://img.shields.io/badge/language-Python-blue (Python)
[private]: https://img.shields.io/badge/-private-red (private)
[const]: https://img.shields.io/badge/-const-lightblue (const)
[Markdown]: https://img.shields.io/badge/language-Markdown-blue (Markdown)