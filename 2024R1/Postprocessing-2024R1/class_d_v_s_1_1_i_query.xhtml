<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Veronica: DVS::IQuery Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="veronica_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Veronica
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.xhtml');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Introduction</span></a></li>
      <li><a href="modules.xhtml"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.xhtml"><span>Classes</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
      <li><a href="examples.xhtml"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.xhtml"><span>Class&#160;List</span></a></li>
      <li><a href="classes.xhtml"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.xhtml"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.xhtml"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>DVS</b></li><li class="navelem"><a class="el" href="class_d_v_s_1_1_i_query.xhtml">IQuery</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_d_v_s_1_1_i_query-members.xhtml">List of all members</a>  </div>
  <div class="headertitle"><div class="title">DVS::IQuery Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="dvs__query__interface_8h_source.xhtml">dvs_query_interface.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1d09babef55223dfb491ee9294c6e4c8"><td class="memItemLeft" align="right" valign="top"><a id="a1d09babef55223dfb491ee9294c6e4c8" name="a1d09babef55223dfb491ee9294c6e4c8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IQuery</b> ()=default</td></tr>
<tr class="separator:a1d09babef55223dfb491ee9294c6e4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5427e50031b1599477846464cb025283"><td class="memItemLeft" align="right" valign="top"><a id="a5427e50031b1599477846464cb025283" name="a5427e50031b1599477846464cb025283"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~IQuery</b> ()=default</td></tr>
<tr class="separator:a5427e50031b1599477846464cb025283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed55ea32809b9f41a7d8b870e7e6f2e"><td class="memItemLeft" align="right" valign="top"><a id="a3ed55ea32809b9f41a7d8b870e7e6f2e" name="a3ed55ea32809b9f41a7d8b870e7e6f2e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IQuery</b> (<a class="el" href="class_d_v_s_1_1_i_query.xhtml">IQuery</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a3ed55ea32809b9f41a7d8b870e7e6f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ec70d8a25eca733cc353625b446a19"><td class="memItemLeft" align="right" valign="top"><a id="a54ec70d8a25eca733cc353625b446a19" name="a54ec70d8a25eca733cc353625b446a19"></a>
<a class="el" href="class_d_v_s_1_1_i_query.xhtml">IQuery</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_d_v_s_1_1_i_query.xhtml">IQuery</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a54ec70d8a25eca733cc353625b446a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d66aa7947f611ff10ed32cfcccfe43"><td class="memItemLeft" align="right" valign="top"><a id="af5d66aa7947f611ff10ed32cfcccfe43" name="af5d66aa7947f611ff10ed32cfcccfe43"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IQuery</b> (const <a class="el" href="class_d_v_s_1_1_i_query.xhtml">IQuery</a> &amp;)=default</td></tr>
<tr class="separator:af5d66aa7947f611ff10ed32cfcccfe43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214fdde5a18f2eb2853bf56eb7354280"><td class="memItemLeft" align="right" valign="top"><a id="a214fdde5a18f2eb2853bf56eb7354280" name="a214fdde5a18f2eb2853bf56eb7354280"></a>
<a class="el" href="class_d_v_s_1_1_i_query.xhtml">IQuery</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_d_v_s_1_1_i_query.xhtml">IQuery</a> &amp;)=default</td></tr>
<tr class="separator:a214fdde5a18f2eb2853bf56eb7354280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257f79d7de21658c07dc602dfa6bbf34"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a257f79d7de21658c07dc602dfa6bbf34">release</a> ()=0</td></tr>
<tr class="separator:a257f79d7de21658c07dc602dfa6bbf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ce54c68281ea1676af650ebc5716a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#ab6ce54c68281ea1676af650ebc5716a0">set_logger</a> (<a class="el" href="class_d_v_s_1_1_i_logger.xhtml">DVS::ILogger</a> *logger)=0</td></tr>
<tr class="separator:ab6ce54c68281ea1676af650ebc5716a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b22e6a7c4f0c76ade9105f30d1bc2d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#ae1b22e6a7c4f0c76ade9105f30d1bc2d">add_uri</a> (const char *uri)=0</td></tr>
<tr class="separator:ae1b22e6a7c4f0c76ade9105f30d1bc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dc766c5d6789ca3dcbab72cf4ca4e9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a05dc766c5d6789ca3dcbab72cf4ca4e9">get_num_servers</a> (const char *uri, uint32_t &amp;num_servers)=0</td></tr>
<tr class="separator:a05dc766c5d6789ca3dcbab72cf4ca4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfefd0ed3856da6599599f15109ece9a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#acfefd0ed3856da6599599f15109ece9a">set_server_mod</a> (uint32_t server_num, uint32_t server_mod)=0</td></tr>
<tr class="separator:acfefd0ed3856da6599599f15109ece9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a810da09342690eb371b324079f206e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_d_v_s_1_1_i_query.xhtml">DVS::IQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a8a810da09342690eb371b324079f206e">filter</a> (const char *filter)=0</td></tr>
<tr class="separator:a8a810da09342690eb371b324079f206e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09b8c2d9204f66e88b1ac56b3e0e40d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#ab09b8c2d9204f66e88b1ac56b3e0e40d">get_num_ranks</a> (uint32_t &amp;num_ranks)=0</td></tr>
<tr class="separator:ab09b8c2d9204f66e88b1ac56b3e0e40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469f214b6c9976e81d93510410c00b70"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a469f214b6c9976e81d93510410c00b70">get_ranks</a> (uint32_t *ranks)=0</td></tr>
<tr class="separator:a469f214b6c9976e81d93510410c00b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae39d1931433b35162c3b37dc82c4f1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#aaae39d1931433b35162c3b37dc82c4f1">get_num_chunks_per_rank</a> (uint32_t &amp;num_chunks)=0</td></tr>
<tr class="separator:aaae39d1931433b35162c3b37dc82c4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1a83603bec00bdebc8430a5c48e742"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a4d1a83603bec00bdebc8430a5c48e742">get_chunks_per_rank</a> (uint32_t *chunks)=0</td></tr>
<tr class="separator:a4d1a83603bec00bdebc8430a5c48e742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48165c3147ae5d084577b9b8acb05638"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a48165c3147ae5d084577b9b8acb05638">get_num_datasets</a> (uint32_t &amp;num_datasets)=0</td></tr>
<tr class="separator:a48165c3147ae5d084577b9b8acb05638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574de84a9a4d7a5e3e777a35b1b6c2bc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_d_v_s_1_1_i_dataset.xhtml">DVS::IDataset</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a574de84a9a4d7a5e3e777a35b1b6c2bc">get_dataset</a> (uint32_t index)=0</td></tr>
<tr class="separator:a574de84a9a4d7a5e3e777a35b1b6c2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dab5f63a6c619a1ee6d3138679c9eac"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a2dab5f63a6c619a1ee6d3138679c9eac">get_num_parts</a> (uint32_t &amp;num_parts)=0</td></tr>
<tr class="separator:a2dab5f63a6c619a1ee6d3138679c9eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ec579c40465ee2aebf87ac60dc90fb"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_d_v_s_1_1_i_object.xhtml">DVS::IObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a53ec579c40465ee2aebf87ac60dc90fb">get_part</a> (uint32_t index)=0</td></tr>
<tr class="separator:a53ec579c40465ee2aebf87ac60dc90fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f64cb2c3a336c0d86fb0b3799c13e5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#ab2f64cb2c3a336c0d86fb0b3799c13e5">get_num_plots</a> (uint32_t &amp;num_plots)=0</td></tr>
<tr class="separator:ab2f64cb2c3a336c0d86fb0b3799c13e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590a1eff5cb7906028f736810e079ed6"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_d_v_s_1_1_i_object.xhtml">DVS::IObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a590a1eff5cb7906028f736810e079ed6">get_plot</a> (uint32_t index)=0</td></tr>
<tr class="separator:a590a1eff5cb7906028f736810e079ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec063e869d5ef051a276b0b0fab0f42"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a8ec063e869d5ef051a276b0b0fab0f42">get_variable_data</a> (const <a class="el" href="class_d_v_s_1_1_i_object.xhtml">DVS::IObject</a> *object, const <a class="el" href="class_d_v_s_1_1_i_var.xhtml">DVS::IVar</a> *var, float time, float *values)=0</td></tr>
<tr class="separator:a8ec063e869d5ef051a276b0b0fab0f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336a2553eb96266550f737539e85b2a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a336a2553eb96266550f737539e85b2a8">get_num_variables</a> (uint32_t &amp;num_vars)=0</td></tr>
<tr class="separator:a336a2553eb96266550f737539e85b2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ca725d3c7e7354ab38b4b3e971e2b3"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_d_v_s_1_1_i_var.xhtml">DVS::IVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#ac1ca725d3c7e7354ab38b4b3e971e2b3">get_variable</a> (uint32_t index)=0</td></tr>
<tr class="separator:ac1ca725d3c7e7354ab38b4b3e971e2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43880c6392208deb0a4685fb05cd55e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a43880c6392208deb0a4685fb05cd55e0">get_num_timesteps</a> (uint32_t &amp;num_timesteps)=0</td></tr>
<tr class="separator:a43880c6392208deb0a4685fb05cd55e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d56e910ffc40d8f432152a1028d53b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#ad1d56e910ffc40d8f432152a1028d53b">get_timesteps</a> (float *timesteps)=0</td></tr>
<tr class="separator:ad1d56e910ffc40d8f432152a1028d53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4ef2e5ffb8a6e3cfe1d1841ef4007b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a0e4ef2e5ffb8a6e3cfe1d1841ef4007b">get_num_mesh_chunks</a> (uint32_t &amp;num_mesh_chunks)=0</td></tr>
<tr class="separator:a0e4ef2e5ffb8a6e3cfe1d1841ef4007b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a3a6962690c69ea8cef8815a72c011"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_d_v_s_1_1_i_mesh_chunk.xhtml">DVS::IMeshChunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a00a3a6962690c69ea8cef8815a72c011">get_mesh_chunk</a> (uint32_t index)=0</td></tr>
<tr class="separator:a00a3a6962690c69ea8cef8815a72c011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955bed02a8706e13c972f45c9263f84e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a955bed02a8706e13c972f45c9263f84e">get_num_plot_chunks</a> (uint32_t &amp;num_plot_chunks)=0</td></tr>
<tr class="separator:a955bed02a8706e13c972f45c9263f84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074055c68ba05d544d653095683405c7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_d_v_s_1_1_i_plot_chunk.xhtml">DVS::IPlotChunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a074055c68ba05d544d653095683405c7">get_plot_chunk</a> (uint32_t index)=0</td></tr>
<tr class="separator:a074055c68ba05d544d653095683405c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818f3065fbaa299112d3efa4257bbfec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_v_s_1_1_i_query.xhtml#a818f3065fbaa299112d3efa4257bbfec">get_hash_available</a> (const char *hash, bool &amp;available)=0</td></tr>
<tr class="separator:a818f3065fbaa299112d3efa4257bbfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An instance of this object can be initially created by calling <a class="el" href="dvs__query__interface_8h.xhtml#ac614cf475eca0727cdb5b42faabcca7d" title="Create a query interface object.">DVS::CREATE_QUERY_INSTANCE()</a>. A URI must then be added via <a class="el" href="class_d_v_s_1_1_i_query.xhtml#ae1b22e6a7c4f0c76ade9105f30d1bc2d" title="Add a URI for the reader API to iterate over.">DVS::IQuery::add_uri()</a>. Then you can either start querying the dataset or you can add filters by chaining queries via <a class="el" href="class_d_v_s_1_1_i_query.xhtml#a8a810da09342690eb371b324079f206e" title="The filter method will allocate a new chained query with the passed in filter appended to it.">DVS::IQuery::filter()</a>. When finished to clean up memory call <a class="el" href="class_d_v_s_1_1_i_query.xhtml#a257f79d7de21658c07dc602dfa6bbf34" title="Release the memory of the query.">DVS::IQuery::release()</a>.</p>
<p><b>IMPORTANT</b>: Calling <a class="el" href="class_d_v_s_1_1_i_query.xhtml#a257f79d7de21658c07dc602dfa6bbf34" title="Release the memory of the query.">DVS::IQuery::release()</a> destroys all chained queries as well and any object references retrieved from the query from calls such as <a class="el" href="class_d_v_s_1_1_i_query.xhtml#a53ec579c40465ee2aebf87ac60dc90fb" title="Get the part based on the index.">DVS::IQuery::get_part()</a></p>
<p>The overall intended usage would be something like: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_d_v_s_1_1_i_query.xhtml">DVS::IQuery</a>* my_query = <a class="code hl_function" href="dvs__query__interface_8h.xhtml#ac614cf475eca0727cdb5b42faabcca7d">DVS::CREATE_QUERY_INSTANCE</a>(); <span class="comment">//Create an instance of a query</span></div>
<div class="line">my_query-&gt;<a class="code hl_function" href="class_d_v_s_1_1_i_query.xhtml#ae1b22e6a7c4f0c76ade9105f30d1bc2d">add_uri</a>(<span class="stringliteral">&quot;hdf5://localhost/D:/my/cache/location&quot;</span>); <span class="comment">//Add a cache URI for the query to open</span></div>
<div class="line"><a class="code hl_class" href="class_d_v_s_1_1_i_query.xhtml">DVS::IQuery</a>* dataset_query = my_query-&gt;<a class="code hl_function" href="class_d_v_s_1_1_i_query.xhtml#a8a810da09342690eb371b324079f206e">filter</a>(<span class="stringliteral">&quot;/dataset.id/eq/my+dataset+name&quot;</span>); <span class="comment">// Create chained query filtering on a specific dataset name</span></div>
<div class="line"><a class="code hl_class" href="class_d_v_s_1_1_i_query.xhtml">DVS::IQuery</a>* part_query = dataset_query-&gt;<a class="code hl_function" href="class_d_v_s_1_1_i_query.xhtml#a8a810da09342690eb371b324079f206e">filter</a>(<span class="stringliteral">&quot;/part.id/eq/my+part+name&quot;</span>); <span class="comment">// Create chained query filtering on a specific part name</span></div>
<div class="line"><span class="comment">//Loop over all th mesh chunks for part: my part name in dataset: my dataset name</span></div>
<div class="line"><span class="keywordflow">for</span> (uint32_t i = 0; i &lt; part_query-&gt;<a class="code hl_function" href="class_d_v_s_1_1_i_query.xhtml#a0e4ef2e5ffb8a6e3cfe1d1841ef4007b">get_num_mesh_chunks</a>(); i++ )</div>
<div class="line">{</div>
<div class="line">     <a class="code hl_class" href="class_d_v_s_1_1_i_mesh_chunk.xhtml">DVS::IMeshChunk</a>* mesh_chunk = part_query-&gt;<a class="code hl_function" href="class_d_v_s_1_1_i_query.xhtml#a00a3a6962690c69ea8cef8815a72c011">get_mesh_chunk</a>(i);</div>
<div class="line">     <span class="comment">//Do important things</span></div>
<div class="line">}</div>
<div class="line">my_query-&gt;<a class="code hl_function" href="class_d_v_s_1_1_i_query.xhtml#a257f79d7de21658c07dc602dfa6bbf34">release</a>(); <span class="comment">// Release top level query and all child queries and their objects</span></div>
<div class="ttc" id="aclass_d_v_s_1_1_i_mesh_chunk_xhtml"><div class="ttname"><a href="class_d_v_s_1_1_i_mesh_chunk.xhtml">DVS::IMeshChunk</a></div><div class="ttdoc">Mesh Chunk Interface for DVS Reader API.</div><div class="ttdef"><b>Definition:</b> <a href="dvs__mesh__chunk__interface_8h_source.xhtml#l00048">dvs_mesh_chunk_interface.h:49</a></div></div>
<div class="ttc" id="aclass_d_v_s_1_1_i_query_xhtml"><div class="ttname"><a href="class_d_v_s_1_1_i_query.xhtml">DVS::IQuery</a></div><div class="ttdoc">The query interface for the DVS Reader API.</div><div class="ttdef"><b>Definition:</b> <a href="dvs__query__interface_8h_source.xhtml#l00076">dvs_query_interface.h:77</a></div></div>
<div class="ttc" id="aclass_d_v_s_1_1_i_query_xhtml_a00a3a6962690c69ea8cef8815a72c011"><div class="ttname"><a href="class_d_v_s_1_1_i_query.xhtml#a00a3a6962690c69ea8cef8815a72c011">DVS::IQuery::get_mesh_chunk</a></div><div class="ttdeci">virtual DVS::IMeshChunk * get_mesh_chunk(uint32_t index)=0</div><div class="ttdoc">Get the mesh chunk based on the index.</div></div>
<div class="ttc" id="aclass_d_v_s_1_1_i_query_xhtml_a0e4ef2e5ffb8a6e3cfe1d1841ef4007b"><div class="ttname"><a href="class_d_v_s_1_1_i_query.xhtml#a0e4ef2e5ffb8a6e3cfe1d1841ef4007b">DVS::IQuery::get_num_mesh_chunks</a></div><div class="ttdeci">virtual dvs_ret get_num_mesh_chunks(uint32_t &amp;num_mesh_chunks)=0</div><div class="ttdoc">Get the number of mesh chunks for this query.</div></div>
<div class="ttc" id="aclass_d_v_s_1_1_i_query_xhtml_a257f79d7de21658c07dc602dfa6bbf34"><div class="ttname"><a href="class_d_v_s_1_1_i_query.xhtml#a257f79d7de21658c07dc602dfa6bbf34">DVS::IQuery::release</a></div><div class="ttdeci">virtual void release()=0</div><div class="ttdoc">Release the memory of the query.</div></div>
<div class="ttc" id="aclass_d_v_s_1_1_i_query_xhtml_a8a810da09342690eb371b324079f206e"><div class="ttname"><a href="class_d_v_s_1_1_i_query.xhtml#a8a810da09342690eb371b324079f206e">DVS::IQuery::filter</a></div><div class="ttdeci">virtual DVS::IQuery * filter(const char *filter)=0</div><div class="ttdoc">The filter method will allocate a new chained query with the passed in filter appended to it.</div></div>
<div class="ttc" id="aclass_d_v_s_1_1_i_query_xhtml_ae1b22e6a7c4f0c76ade9105f30d1bc2d"><div class="ttname"><a href="class_d_v_s_1_1_i_query.xhtml#ae1b22e6a7c4f0c76ade9105f30d1bc2d">DVS::IQuery::add_uri</a></div><div class="ttdeci">virtual dvs_ret add_uri(const char *uri)=0</div><div class="ttdoc">Add a URI for the reader API to iterate over.</div></div>
<div class="ttc" id="advs__query__interface_8h_xhtml_ac614cf475eca0727cdb5b42faabcca7d"><div class="ttname"><a href="dvs__query__interface_8h.xhtml#ac614cf475eca0727cdb5b42faabcca7d">DVS::CREATE_QUERY_INSTANCE</a></div><div class="ttdeci">DVS_DLL_EXPORT IQuery * CREATE_QUERY_INSTANCE()</div><div class="ttdoc">Create a query interface object.</div></div>
</div><!-- fragment --><p> See <a class="el" href="group__group__dvs__uri.xhtml#dvs_cache_uri">Cache URIs</a> and <a class="el" href="group__group__dvs__filtering.xhtml#dvs_query_stanzas">Query Stanzas</a> for more information on cache URIs and queries. </p>

<p class="definition">Definition at line <a class="el" href="dvs__query__interface_8h_source.xhtml#l00076">76</a> of file <a class="el" href="dvs__query__interface_8h_source.xhtml">dvs_query_interface.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae1b22e6a7c4f0c76ade9105f30d1bc2d" name="ae1b22e6a7c4f0c76ade9105f30d1bc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b22e6a7c4f0c76ade9105f30d1bc2d">&#9670;&#160;</a></span>add_uri()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a> DVS::IQuery::add_uri </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a URI for the reader API to iterate over. </p>
<p>This method will only "set" the current URI. In the future we will support multiple URIs queried at once.</p>
<p><b>IMPORTANT</b>: Calling this will invalidate any objects returned from the query and any chained queries.</p>
<p>Errors:</p><ul>
<li>DVS_NONE: Success</li>
<li>DVS_PARAM_NULL: uri passed in was nullptr</li>
<li>DVS_QUERY_HAS_CHILDREN: Cannot add a uri to a query which already has children</li>
<li>DVS_QUERY_INVALID_URI: URI passed in did not parse, invalid uri</li>
<li>DVS_QUERY_INVALID_FILTER: Filter in URI did not parse, invalid filter</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uri</td><td>URI of a cache. See <a class="el" href="group__group__dvs__uri.xhtml#dvs_cache_uri">Cache URIs</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dvs_ret DVS_NONE on success, otherwise see method description </dd></dl>

</div>
</div>
<a id="a8a810da09342690eb371b324079f206e" name="a8a810da09342690eb371b324079f206e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a810da09342690eb371b324079f206e">&#9670;&#160;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_d_v_s_1_1_i_query.xhtml">DVS::IQuery</a> * DVS::IQuery::filter </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The filter method will allocate a new chained query with the passed in filter appended to it. </p>
<p>The filter method allocates a new chained query with the passed in filter appended to it. The current query is not modified. This query however is a chained child of the current query meaning that any changes to the parent will invalidate the objects of the child. <a class="el" href="class_d_v_s_1_1_i_query.xhtml#a257f79d7de21658c07dc602dfa6bbf34" title="Release the memory of the query.">IQuery::release()</a> will release any child chained queries created from the it.</p>
<p>This lets a user create a top level query, say for a specific dataset name. Then have multiple chained queries that filter for specific parts etc which can be iterated over in parallel.</p>
<p><b>IMPORTANT</b>: Chained queries will have all of their objects destroyed when a parent query changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>the filter to append to the new chained child query. See <a class="el" href="group__group__dvs__filtering.xhtml#dvs_query_stanzas">Query Stanzas</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_d_v_s_1_1_i_query.xhtml" title="The query interface for the DVS Reader API.">DVS::IQuery</a>* a pointer to a newly allocated chained child query </dd></dl>

</div>
</div>
<a id="a4d1a83603bec00bdebc8430a5c48e742" name="a4d1a83603bec00bdebc8430a5c48e742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1a83603bec00bdebc8430a5c48e742">&#9670;&#160;</a></span>get_chunks_per_rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a> DVS::IQuery::get_chunks_per_rank </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>chunks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an array of the number of chunks for every rank for this query. </p>
<p>This method will return an array of max number of chunks for every rank. The size of the buffer needed can be retrieved from <a class="el" href="class_d_v_s_1_1_i_query.xhtml#aaae39d1931433b35162c3b37dc82c4f1" title="Get the number of chunks for each rank.">IQuery::get_num_chunks_per_rank()</a>. These values correspond to the ranks returned from <a class="el" href="class_d_v_s_1_1_i_query.xhtml#a469f214b6c9976e81d93510410c00b70" title="Get the unique ranks for this filtered query.">IQuery::get_ranks()</a>. Since there might be multiple datasets in the query this will return the max for each rank across the datasets and parts.</p>
<p>This call will return all of the chunk information for every rank returned from <a class="el" href="class_d_v_s_1_1_i_query.xhtml#a469f214b6c9976e81d93510410c00b70" title="Get the unique ranks for this filtered query.">IQuery::get_ranks()</a>.</p>
<p>Errors:</p><ul>
<li>DVS_NONE: Success</li>
<li>DVS_PARAM_NULL: chunks passed in is nullptr</li>
<li>DVS_INVALID_CACHE: Problem accessing cache</li>
<li>DVS_DATA_FAILED_LOAD: Problem reading cache, data bad/corrupt</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">chunks</td><td>buffer to save chunk information in, an array of the chunks for each rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dvs_ret DVS_NONE if success, otherwise see method description </dd></dl>

</div>
</div>
<a id="a574de84a9a4d7a5e3e777a35b1b6c2bc" name="a574de84a9a4d7a5e3e777a35b1b6c2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574de84a9a4d7a5e3e777a35b1b6c2bc">&#9670;&#160;</a></span>get_dataset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_d_v_s_1_1_i_dataset.xhtml">DVS::IDataset</a> * DVS::IQuery::get_dataset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dataset object. </p>
<p><b>IMPORTANT</b>: This object will be destroyed if this query or parent queries' filters are modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of the dataset to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_d_v_s_1_1_i_dataset.xhtml" title="Interface for datasets for the DVS Reader API.">DVS::IDataset</a>* dataset for the index, or nullptr if not found </dd></dl>

</div>
</div>
<a id="a818f3065fbaa299112d3efa4257bbfec" name="a818f3065fbaa299112d3efa4257bbfec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818f3065fbaa299112d3efa4257bbfec">&#9670;&#160;</a></span>get_hash_available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a> DVS::IQuery::get_hash_available </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get if the hash is available in the blobstore. </p>
<p>Checks the blobstore to see if the hash is available or not. This is mainly used for validation purposes.</p>
<p>Errors:</p><ul>
<li>DVS_NONE: Success</li>
<li>DVS_PARAM_NULL: hash passed in nullptr</li>
<li>DVS_INVALID_CACHE: Invalid cache, bad data</li>
<li>DVS_INVALID_HASH: Hash passed in invalid</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>hash to check availability of, retrieved via <a class="el" href="class_d_v_s_1_1_i_hash.xhtml#a51eaee86a6e2db4dda7f4326daa33874" title="Get the hash of the data.">DVS::IHash::get_hash()</a> or <a class="el" href="class_d_v_s_1_1_i_var_hash.xhtml#a17fff1548eb276edd326a0af08f6a7c4" title="Get the hash of the variable data.">DVS::IVarHash::get_var_hash()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">available</td><td>if success, returns true if found in blobstore, else false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dvs_ret DVS_NONE on success, else see method description </dd></dl>

</div>
</div>
<a id="a00a3a6962690c69ea8cef8815a72c011" name="a00a3a6962690c69ea8cef8815a72c011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a3a6962690c69ea8cef8815a72c011">&#9670;&#160;</a></span>get_mesh_chunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_d_v_s_1_1_i_mesh_chunk.xhtml">DVS::IMeshChunk</a> * DVS::IQuery::get_mesh_chunk </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the mesh chunk based on the index. </p>
<p><b>IMPORTANT</b>: This object will be destroyed if this query or parent queries' filters are modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index of the mesh chunk to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_d_v_s_1_1_i_mesh_chunk.xhtml" title="Mesh Chunk Interface for DVS Reader API.">DVS::IMeshChunk</a>* the mesh chunk for the index, or nullptr if not found </dd></dl>

</div>
</div>
<a id="aaae39d1931433b35162c3b37dc82c4f1" name="aaae39d1931433b35162c3b37dc82c4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae39d1931433b35162c3b37dc82c4f1">&#9670;&#160;</a></span>get_num_chunks_per_rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a> DVS::IQuery::get_num_chunks_per_rank </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>num_chunks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of chunks for each rank. </p>
<p>This method returns the size of the buffer needed to pass in for get_chunks_per_rank. This will be of the same size as <a class="el" href="class_d_v_s_1_1_i_query.xhtml#ab09b8c2d9204f66e88b1ac56b3e0e40d" title="Get the number of ranks for this filtered query.">IQuery::get_num_ranks()</a>.</p>
<p>This call will return all of the chunk information for every rank returned from <a class="el" href="class_d_v_s_1_1_i_query.xhtml#a469f214b6c9976e81d93510410c00b70" title="Get the unique ranks for this filtered query.">IQuery::get_ranks()</a>.</p>
<p>Errors:</p><ul>
<li>DVS_NONE: Success</li>
<li>DVS_INVALID_CACHE: Problem accessing cache</li>
<li>DVS_DATA_FAILED_LOAD: Problem reading cache, data bad/corrupt</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num_chunks</td><td>if success returns the size of the buffer to allocate for <a class="el" href="class_d_v_s_1_1_i_query.xhtml#a4d1a83603bec00bdebc8430a5c48e742" title="Get an array of the number of chunks for every rank for this query.">IQuery::get_chunks_per_rank()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dvs_ret DVS_NONE on success, otherwise see method description </dd></dl>

</div>
</div>
<a id="a48165c3147ae5d084577b9b8acb05638" name="a48165c3147ae5d084577b9b8acb05638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48165c3147ae5d084577b9b8acb05638">&#9670;&#160;</a></span>get_num_datasets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a> DVS::IQuery::get_num_datasets </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>num_datasets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of datasets objects. </p>
<p><b>IMPORTANT</b>: The number of datasets will be invalid if this query or any parent queries' filters are modified.</p>
<p>Errors:</p><ul>
<li>DVS_NONE: Success</li>
<li>DVS_INVALID_CACHE: Problem accessing cache</li>
<li>DVS_DATA_FAILED_LOAD: Problem reading cache, data bad/corrupt</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num_datasets</td><td>if success, returns the number of datasets for this query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DVS_NONE on success, else see method description </dd></dl>

</div>
</div>
<a id="a0e4ef2e5ffb8a6e3cfe1d1841ef4007b" name="a0e4ef2e5ffb8a6e3cfe1d1841ef4007b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4ef2e5ffb8a6e3cfe1d1841ef4007b">&#9670;&#160;</a></span>get_num_mesh_chunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a> DVS::IQuery::get_num_mesh_chunks </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>num_mesh_chunks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of mesh chunks for this query. </p>
<p>NOT YET IMPLEMENTED</p>
<p><b>IMPORTANT</b>: The number of mesh chunks will be invalid if this query or any parent queries' filters are modified.</p>
<p>Errors:</p><ul>
<li>DVS_NONE: Success</li>
<li>DVS_INVALID_CACHE: Problem accessing cache</li>
<li>DVS_DATA_FAILED_LOAD: Problem reading cache, data bad/corrupt</li>
<li>DVS_QUERY_INVALID_FILTER: Invalid filter for query</li>
<li>DVS_METADATA_ERROR: Error loading metadata</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num_mesh_chunks</td><td>if success, returns the number of mesh chunks for this query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dvs_ret dvs_ret DVS_NONE on success, else see method description </dd></dl>

</div>
</div>
<a id="a2dab5f63a6c619a1ee6d3138679c9eac" name="a2dab5f63a6c619a1ee6d3138679c9eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dab5f63a6c619a1ee6d3138679c9eac">&#9670;&#160;</a></span>get_num_parts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a> DVS::IQuery::get_num_parts </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>num_parts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of parts for this query. </p>
<p><b>IMPORTANT</b>: The number of parts will be invalid if this query or any parent queries' filters are modifed.</p>
<p>Errors:</p><ul>
<li>DVS_NONE: Success</li>
<li>DVS_INVALID_CACHE: Problem accessing cache</li>
<li>DVS_DATA_FAILED_LOAD: Problem reading cache, data bad/corrupt</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num_parts</td><td>if success, returns the number of parts for this query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dvs_ret DVS_NONE on success, else see method description </dd></dl>

</div>
</div>
<a id="a955bed02a8706e13c972f45c9263f84e" name="a955bed02a8706e13c972f45c9263f84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955bed02a8706e13c972f45c9263f84e">&#9670;&#160;</a></span>get_num_plot_chunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a> DVS::IQuery::get_num_plot_chunks </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>num_plot_chunks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of plot chunks for this query. </p>
<p>NOT YET IMPLEMENTED</p>
<p><b>IMPORTANT</b>: The number of plot chunks will be invalid if this query or any parent queries' filters are modified.</p>
<p>Errors:</p><ul>
<li>DVS_NONE: Success</li>
<li>DVS_INVALID_CACHE: Problem accessing cache</li>
<li>DVS_DATA_FAILED_LOAD: Problem reading cache, data bad/corrupt</li>
<li>DVS_QUERY_INVALID_FILTER: Invalid filter for query</li>
<li>DVS_METADATA_ERROR: Error loading metadata</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num_plot_chunks</td><td>if success, returns the number of plot chunks for this query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dvs_ret dvs_ret DVS_NONE on success, else see method description </dd></dl>

</div>
</div>
<a id="ab2f64cb2c3a336c0d86fb0b3799c13e5" name="ab2f64cb2c3a336c0d86fb0b3799c13e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f64cb2c3a336c0d86fb0b3799c13e5">&#9670;&#160;</a></span>get_num_plots()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a> DVS::IQuery::get_num_plots </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>num_plots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of plots for this query. </p>
<p><b>IMPORTANT</b>: The number of plots will be invalid if this query or any parent queries' filters are modifed.</p>
<p>Errors:</p><ul>
<li>DVS_NONE: Success</li>
<li>DVS_INVALID_CACHE: Problem accessing cache</li>
<li>DVS_DATA_FAILED_LOAD: Problem reading cache, data bad/corrupt</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num_plots</td><td>if success, returns the number of plots for this query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dvs_ret dvs_ret DVS_NONE on success, else see method description </dd></dl>

</div>
</div>
<a id="ab09b8c2d9204f66e88b1ac56b3e0e40d" name="ab09b8c2d9204f66e88b1ac56b3e0e40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09b8c2d9204f66e88b1ac56b3e0e40d">&#9670;&#160;</a></span>get_num_ranks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a> DVS::IQuery::get_num_ranks </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>num_ranks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of ranks for this filtered query. </p>
<p>This call will return all of the unique ranks across all datasets. I.E. if you are loading 2 datasets one with ranks: 0, 1, 2 and one with 0, 1, 2, 3, 4, this will return 5 representing 0,1,2,3,4.</p>
<p>Errors:</p><ul>
<li>DVS_NONE: Success</li>
<li>DVS_INVALID_CACHE: Problem accessing cache</li>
<li>DVS_DATA_FAILED_LOAD: Problem reading cache, data bad/corrupt</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num_ranks</td><td>the size of the buffer to allocate for <a class="el" href="class_d_v_s_1_1_i_query.xhtml#a469f214b6c9976e81d93510410c00b70" title="Get the unique ranks for this filtered query.">IQuery::get_ranks()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dvs_ret DVS_NONE on success, otherwise see method description </dd></dl>

</div>
</div>
<a id="a05dc766c5d6789ca3dcbab72cf4ca4e9" name="a05dc766c5d6789ca3dcbab72cf4ca4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dc766c5d6789ca3dcbab72cf4ca4e9">&#9670;&#160;</a></span>get_num_servers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a> DVS::IQuery::get_num_servers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>num_servers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the num servers object. </p>
<p>Get the number of servers the cache in the uri was written with.</p>
<p>Errors:</p><ul>
<li>DVS_NONE: Success</li>
<li>DVS_PARAM_NULL: uri passed in was nullptr</li>
<li>DVS_INVALID_CACHE: uri passed in was invalid or cache isn't accessible</li>
<li>DVS_CACHE_MISSING_SERVERS: Cache has a gap in the number of servers, bad cache?</li>
<li>DVS_CACHE_EMPTY: No server folders in cache</li>
<li>DVS_UNKNOWN: Internal unhandled case</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uri</td><td>URI of a cache. See <a class="el" href="group__group__dvs__uri.xhtml#dvs_cache_uri">Cache URIs</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">num_servers</td><td>number of servers this cache was written with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dvs_ret DVS_NONE on success, otherwise see method description </dd></dl>

</div>
</div>
<a id="a43880c6392208deb0a4685fb05cd55e0" name="a43880c6392208deb0a4685fb05cd55e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43880c6392208deb0a4685fb05cd55e0">&#9670;&#160;</a></span>get_num_timesteps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a> DVS::IQuery::get_num_timesteps </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>num_timesteps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of timesteps. </p>
<p>NOT YET IMPLEMENTED</p>
<p><b>IMPORTANT</b>: The number of timesteps will be invalid if this query or any parent queries' filters are modified.</p>
<p>Errors:</p><ul>
<li>DVS_NONE: Success</li>
<li>DVS_INVALID_CACHE: Problem accessing cache</li>
<li>DVS_DATA_FAILED_LOAD: Problem reading cache, data bad/corrupt</li>
<li>DVS_QUERY_INVALID_FILTER: Invalid filter for query</li>
<li>DVS_METADATA_ERROR: Error loading metadata</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num_timesteps</td><td>if success, returns the number of timesteps to allocate for <a class="el" href="class_d_v_s_1_1_i_query.xhtml#ad1d56e910ffc40d8f432152a1028d53b" title="Get the timesteps object.">IQuery::get_timesteps()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dvs_ret dvs_ret DVS_NONE on success, else see method description </dd></dl>

</div>
</div>
<a id="a336a2553eb96266550f737539e85b2a8" name="a336a2553eb96266550f737539e85b2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336a2553eb96266550f737539e85b2a8">&#9670;&#160;</a></span>get_num_variables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a> DVS::IQuery::get_num_variables </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>num_vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of variables for this query. </p>
<p><b>IMPORTANT</b>: The number of variables will be invalid if this query or any parent queries' filters are modifed.</p>
<p>Errors:</p><ul>
<li>DVS_NONE: Success</li>
<li>DVS_INVALID_CACHE: Problem accessing cache</li>
<li>DVS_DATA_FAILED_LOAD: Problem reading cache, data bad/corrupt</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num_vars</td><td>if success, returns the number of variables for this query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dvs_ret dvs_ret DVS_NONE on success, else see method description </dd></dl>

</div>
</div>
<a id="a53ec579c40465ee2aebf87ac60dc90fb" name="a53ec579c40465ee2aebf87ac60dc90fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ec579c40465ee2aebf87ac60dc90fb">&#9670;&#160;</a></span>get_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_d_v_s_1_1_i_object.xhtml">DVS::IObject</a> * DVS::IQuery::get_part </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the part based on the index. </p>
<p><b>IMPORTANT</b>: This object will be destroyed if this query or parent queries' filters are modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of the part to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_d_v_s_1_1_i_object.xhtml" title="Interface for part/plot objects for DVS Reader API.">DVS::IObject</a>* part based on the index, or nullptr if not found </dd></dl>

</div>
</div>
<a id="a590a1eff5cb7906028f736810e079ed6" name="a590a1eff5cb7906028f736810e079ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590a1eff5cb7906028f736810e079ed6">&#9670;&#160;</a></span>get_plot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_d_v_s_1_1_i_object.xhtml">DVS::IObject</a> * DVS::IQuery::get_plot </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the plot object based on the index. </p>
<p><b>IMPORTANT</b>: This object will be destroyed if this query or parent queries' filters are modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the plot to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_d_v_s_1_1_i_object.xhtml" title="Interface for part/plot objects for DVS Reader API.">DVS::IObject</a>* plot based on the index, or nullptr if not found </dd></dl>

</div>
</div>
<a id="a074055c68ba05d544d653095683405c7" name="a074055c68ba05d544d653095683405c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074055c68ba05d544d653095683405c7">&#9670;&#160;</a></span>get_plot_chunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_d_v_s_1_1_i_plot_chunk.xhtml">DVS::IPlotChunk</a> * DVS::IQuery::get_plot_chunk </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the plot chunk based on the index. </p>
<p><b>IMPORTANT</b>: This object will be destroyed if this query or parent queries' filters are modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of the plot chunk to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_d_v_s_1_1_i_plot_chunk.xhtml" title="Plot Chunk Interface for DVS Reader API.">DVS::IPlotChunk</a>* the plot chunk based on the index, or nullptr if not found </dd></dl>

</div>
</div>
<a id="a469f214b6c9976e81d93510410c00b70" name="a469f214b6c9976e81d93510410c00b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469f214b6c9976e81d93510410c00b70">&#9670;&#160;</a></span>get_ranks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a> DVS::IQuery::get_ranks </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ranks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the unique ranks for this filtered query. </p>
<p>This call will return all of the unique ranks across all datasets. I.E. if you are loading 2 datasets one with ranks: 0, 1, 2 and one with 0, 1, 2, 3, 4, this will return 5 representing 0,1,2,3,4.</p>
<p>Errors:</p><ul>
<li>DVS_NONE: Success</li>
<li>DVS_PARAM_NULL: ranks passed in is nullptr</li>
<li>DVS_INVALID_CACHE: Problem accessing cache</li>
<li>DVS_DATA_FAILED_LOAD: Problem reading cache, data bad/corrupt</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ranks</td><td>an array of the unique ranks for this query, call <a class="el" href="class_d_v_s_1_1_i_query.xhtml#ab09b8c2d9204f66e88b1ac56b3e0e40d" title="Get the number of ranks for this filtered query.">IQuery::get_num_ranks()</a> for buffer size to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dvs_ret DVS_NONE on success, otherwise see method description </dd></dl>

</div>
</div>
<a id="ad1d56e910ffc40d8f432152a1028d53b" name="ad1d56e910ffc40d8f432152a1028d53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d56e910ffc40d8f432152a1028d53b">&#9670;&#160;</a></span>get_timesteps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a> DVS::IQuery::get_timesteps </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>timesteps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the timesteps object. </p>
<p>NOT YET IMPLEMENTED</p>
<p><b>IMPORTANT</b>: The timesteps will be invalid if this query or any parent queries' filters are modified.</p>
<p>Errors:</p><ul>
<li>DVS_NONE: Success</li>
<li>DVS_PARAM_NULL: timesteps param is nullptr</li>
<li>DVS_INVALID_CACHE: Problem accessing cache</li>
<li>DVS_DATA_FAILED_LOAD: Problem reading cache, data bad/corrupt</li>
<li>DVS_QUERY_INVALID_FILTER: Invalid filter for query</li>
<li>DVS_METADATA_ERROR: Error loading metadata</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">timesteps</td><td>buffer for timesteps to be saved in, call <a class="el" href="class_d_v_s_1_1_i_query.xhtml#a43880c6392208deb0a4685fb05cd55e0" title="Get the number of timesteps.">IQuery::get_num_timesteps()</a> to determine size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dvs_ret DVS_NONE on success, else see method description </dd></dl>

</div>
</div>
<a id="ac1ca725d3c7e7354ab38b4b3e971e2b3" name="ac1ca725d3c7e7354ab38b4b3e971e2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ca725d3c7e7354ab38b4b3e971e2b3">&#9670;&#160;</a></span>get_variable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_d_v_s_1_1_i_var.xhtml">DVS::IVar</a> * DVS::IQuery::get_variable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the variable object based on the index. </p>
<p><b>IMPORTANT</b>: This object will be destroyed if this query or parent queries' filters are modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of the variable to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_d_v_s_1_1_i_var.xhtml" title="Interface for variables for the DVS Reader API.">DVS::IVar</a>* variable based on the index, or nullptr if not found </dd></dl>

</div>
</div>
<a id="a8ec063e869d5ef051a276b0b0fab0f42" name="a8ec063e869d5ef051a276b0b0fab0f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec063e869d5ef051a276b0b0fab0f42">&#9670;&#160;</a></span>get_variable_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="dynamic__visualization__store__error__codes_8h.xhtml#a1d7466ae72e89fe36cbf2408b4f7d9c1">dvs_ret</a> DVS::IQuery::get_variable_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_v_s_1_1_i_object.xhtml">DVS::IObject</a> *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_d_v_s_1_1_i_var.xhtml">DVS::IVar</a> *&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get variable values for dataset and part objects. </p>
<p>Dataset (Case) or part objects can have variable values per timestep. This method retrieves those values or returns if they do not exist. There does not need to be a value set for every part variable on every part. DVS_NO_DATA will be returned in this case.</p>
<p>Error Codes:</p><ul>
<li>DVS_NONE: No error</li>
<li>DVS_PARAM_NULL: Null param passed in</li>
<li>DVS_PARAM_INVALID_VAR: Invalid variable passed in, should not be possible</li>
<li>DVS_PARAM_INVALID_VAR_LOC: Variable passed in not a case or part variable</li>
<li>DVS_PARAM_INVALID_OBJECT_TYPE: Object passed in not a case or part object</li>
<li>DVS_PARAM_INVALID_OBJECT: Invalid object passed in, should not be possible</li>
<li>DVS_PARAM_INVALID_TIME: Timestep does not exist for the dataset the object belongs to</li>
<li>DVS_PARAM_OBJECT_DATASET_MISMATCH: Object and variable are from different datasets</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>The case/dataset or part object to find values for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">var</td><td>the variable to retrieve the data for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>the time value to retrieve the variable data for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>the array of data to return, should be of size <a class="el" href="class_d_v_s_1_1_i_var.xhtml#a9dbdd84e6f6342deae82ede6dcf2156e" title="Get the number of floats per value.">DVS::IVar::get_float_count_per_value()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dvs_ret DVS_NONE if no errors, DVS_NO_DATA if no data found, otherwise see method description </dd></dl>

</div>
</div>
<a id="a257f79d7de21658c07dc602dfa6bbf34" name="a257f79d7de21658c07dc602dfa6bbf34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257f79d7de21658c07dc602dfa6bbf34">&#9670;&#160;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DVS::IQuery::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the memory of the query. </p>
<p>This will release the memory of the query, any objects returned from it (i.e. parts/plots/variables) and release the memory of any chained queries. </p>

</div>
</div>
<a id="ab6ce54c68281ea1676af650ebc5716a0" name="ab6ce54c68281ea1676af650ebc5716a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ce54c68281ea1676af650ebc5716a0">&#9670;&#160;</a></span>set_logger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DVS::IQuery::set_logger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_v_s_1_1_i_logger.xhtml">DVS::ILogger</a> *&#160;</td>
          <td class="paramname"><em>logger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the logger object. </p>
<p>Set a logger interface for the client to use. This object will have <a class="el" href="class_d_v_s_1_1_i_logger.xhtml#a753d496b0ca488a74e6209f330b13458" title="Release the memory of the object.">DVS::ILogger::release()</a> invoked on it. If <a class="el" href="class_d_v_s_1_1_i_query.xhtml#a257f79d7de21658c07dc602dfa6bbf34" title="Release the memory of the query.">release()</a> is not implemented the memory should be destroyed by the caller after the query is released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">logger</td><td>logger to use, will be released if <a class="el" href="class_d_v_s_1_1_i_logger.xhtml#a753d496b0ca488a74e6209f330b13458" title="Release the memory of the object.">DVS::ILogger::release()</a> is implemented </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfefd0ed3856da6599599f15109ece9a" name="acfefd0ed3856da6599599f15109ece9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfefd0ed3856da6599599f15109ece9a">&#9670;&#160;</a></span>set_server_mod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DVS::IQuery::set_server_mod </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>server_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>server_mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a filter based on the server number and a modulus. </p>
<p>Data in DVS is normally splitup between multiple servers. This method lets you setup the parallelism paradigm for reading in the server data. I.E. if the data was written with 4 servers but you want to read it back in with 2 servers you should have one reader use set_server_mod(0, 2) and the other use set_server_mod(1, 2). This will round robin the data so reader "0" will reader the data from 0 and 2 and server "1" will read the data from 1 and 3. To set it so that a server will read only its data set server_mod=0.</p>
<p>Use <a class="el" href="class_d_v_s_1_1_i_query.xhtml#a05dc766c5d6789ca3dcbab72cf4ca4e9" title="Get the num servers object.">get_num_servers()</a> to determine the number of servers to use</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">server_num</td><td>the base server number to read from the cache </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">server_mod</td><td>the modulus for round-robining server data between queries/readers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>D:/Product-src/ensight/user_defined_src/readers/dvs/include/<a class="el" href="dvs__query__interface_8h_source.xhtml">dvs_query_interface.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/>
<small>&#160;&#160;&copy; <script type="text/javascript">document.write(new Date().getFullYear());</script> ANSYS Inc. All rights reserved.</small>
 <span style="float:right"><small>Generated by <a href="http://www.doxygen.org/index.html">doxygen</a>&nbsp;&nbsp;</small></span>
