/*
 * Copyright 2018-2024 ANSYS, Inc. Unauthorized use, distribution, or duplication is prohibited.
 *
 * Restricted Rights Legend
 *
 * Use, duplication, or disclosure of this
 * software and its documentation by the
 * Government is subject to restrictions as
 * set forth in subdivision [(b)(3)(ii)] of
 * the Rights in Technical Data and Computer
 * Software clause at 52.227-7013.
 */
/*
 * Copyright 2018-2024 ANSYS, Inc. Unauthorized use, distribution, or duplication is prohibited.
 *
 * Restricted Rights Legend
 *
 * Use, duplication, or disclosure of this
 * software and its documentation by the
 * Government is subject to restrictions as
 * set forth in subdivision [(b)(3)(ii)] of
 * the Rights in Technical Data and Computer
 * Software clause at 52.227-7013.
 */
///////////////////////////////////////
//
// for EKM coming from HTTP server use "GLTF"
// normally this can be determined from URL, but if URL contains parameters after name it could mess things up
//
//  Note: can only disable with options, cannot enable
//  options = {
//      showLogo: false, // defaults to true
//      showFileOpen: false, // default to true (standalone), false (embedded)
//      showFit: false, // defaults to true
//      callback: function, // callback function called when model initially loaded
//      lazyLoad: false, // defaults to true
//  }
/** @constructor */
function GLTFViewer(containerID, url, urlType, contextPath, options, viewportNumber, controllingViewer) {
    this.document = document;
    this.body = $("body");
    this._option = [];
    var vN = GLTFViewer.Utils.IsNull(viewportNumber) ? 0 : viewportNumber;
    var gui;
    try {
        gui = require('nw.gui');
        this.hasNodeJS = true;
    } catch (e) {
    }
    if (vN === 0) {
        if (this.hasNodeJS) {
            // process command line arguments        
            var argv = gui.App.argv;
            var argc = argv.length;
            for (var i = 0; i < argc; ++i) {
                if (argv[i] === "-p")
                    this._option["p"] = true;
                else if (argv[i] === "-t")
                    this._option["t"] = true;
                else if (argv[i].substring(0, 2) === "-w")
                    this._option["w"] = argv[i].substring(2) * 1;
                else if (argv[i].substring(0, 2) === "-h")
                    this._option["h"] = argv[i].substring(2) * 1;
                else if (argv[i] === "-tn")
                    this._option["tn"] = true;
            }
        }
        if (this._option["tn"]) {
            this._option["w"] = this._option["h"] = 256;
            this._option["p"] = true;
            this.wantLogo = false;
        } else if (!this._option["p"] && this.hasNodeJS) {
            var win = gui.Window.get();
            win.show();
        }
    }
    //setTimeout(this._Main.bind(this, containerID, url, urlType, contextPath, options, viewportNumber, controllingViewer), 0);
    this._Main(containerID, url, urlType, contextPath, options, viewportNumber, controllingViewer);
}
GLTFViewer.prototype = Object.create(null, {
    _resizeReadyEvent: { writable: true, value: null },
    _option: { writable: true, value: null },

    wantLazyLoad: { writable: true, value: true }, // only read object data if object visible
    wantLogo: { writable: true, value: true }, // show ANSYS logo
    wantBeta: { writable: true, value: false }, // show beta flag

    wantFile: { writable: true, value: true }, // open local file menu
    wantOptions: { writable: true, value: true }, // options menu
    wantSave: { writable: true, value: false }, // save menu
    wantZoom: { writable: true, value: true }, // zoom to fit menu
    wantSelection: { writable: true, value: true }, // highlighting menu
    wantClip: { writable: true, value: true }, // clip menu
    wantMarkup: { writable: true, value: true }, // markup menu
    wantExplode: { writable: true, value: true }, // explode menu
    wantViewport: { writable: true, value: true }, // viewport menu
    wantFull: { writable: true, value: true }, // full menu
    wantAbout: { writable: true, value: true }, // help/about menu
    wantAnimation: { writable: true, value: true }, // animation panel
    wantMultiFile: { writable: true, value: true }, // multiple file panel
    _wantPropertyEdit: { writable: true, value: true }, // edit property context
    _wantSTLExport: { writable: true, value: true }, // export stl file
    wantPrint: { writable: true, value: false },
    loadAndExit: { writable: true, value: false },

    _helpSystem: { writable: true, value: null },
    _helpHTML: { writable: true, value: null },
    _legalHTML: { writable: true, value: null },
    _titles: { writable: true, value: null },
    _backButton: { writable: true, value: null },
    _printButton: { writable: true, value: null },
    _iFrame: { writable: true, value: null },
    _iFrameMenu: { writable: true, value: null },
    messageHandler: { writable: true, value: null },
    containerID: { writable: true, value: null },
    controllingViewer: { writable: true, value: null },
    viewportNumber: { writable: true, value: 0 },
    _viewportLayout: { writable: true, value: 1 },
    _viewportLock: { writable: true, value: false },
    isServed: { writable: true, value: false },
    isEKM: { writable: true, value: false },
    tmpDir: { writable: true, value: null },
    imageDir: { writable: true, value: null },
    scene: { writable: true, value: null },
    hasNodeJS: { writable: true, value: false },
    isReport: { writable: true, value: false },

    _state: { writable: true, value: null },
    mobile: { writable: true, value: false },
    popup1: { writable: true, value: null },
    popup2: { writable: true, value: null },
    contextMenuContainer: { writable: true, value: null },
    contextMenuMarkup: { writable: true, value: null },

    viewport02: { writable: true, value: null },
    viewport13: { writable: true, value: null },
    viewport0: { writable: true, value: null },
    viewport1: { writable: true, value: null },
    viewer1: { writable: true, value: null },
    viewport2: { writable: true, value: null },
    viewer2: { writable: true, value: null },
    viewport3: { writable: true, value: null },
    viewer3: { writable: true, value: null },
    body: { writable: true, value: null },
    bodyOverflow: { writable: true, value: null },
    imageContainer: { writable: true, value: null },
    container: { writable: true, value: null }, // user specified html element in which to embed viewerContainer
    _rootContainer: { writable: true, value: null }, // container + file manager panel
    _fullContainer: { writable: true, value: null }, // html element, on body element, in which to embed viewerContainer when it is full window
    _nonFullContainer: { writable: true, value: null },
    shield: { writable: true, value: null },

    // viewerContainer
    viewerContainer: { writable: true, value: null }, // html element into which all of viewer goes
    viewer: { writable: true, value: null }, // html element into which webGL goes
    viewerWidth: { writable: true, value: 0 },
    viewerHeight: { writable: true, value: 0 },

    blkLogo: { writable: true, value: null },
    whtLogo: { writable: true, value: null },

    inputFile: { writable: true, value: null },
    outputFile: { writable: true, value: null },
    c3d: { writable: true, value: null },
    overlay: { writable: true, value: null },
    progress: { writable: true, value: null },

    // main horizontal menu
    menu: { writable: true, value: null },
    // file menu item
    fileBtn: { writable: true, value: null },
    // options menu item
    optionsBtn: { writable: true, value: null },
    // viewport menu item
    viewportBtn: { writable: true, value: null },
    viewportMenu: { writable: true, value: null },
    viewportMenuBtns: { writable: true, value: null },
    // save menu item
    saveBtn: { writable: true, value: null },
    saveMUPName: { writable: true, value: null },
    saveViewName: { writable: true, value: null },
    // ...MenuItemsHelp.length defines number of ...MenuItems that get created
    // visibility menu
    FileManagerBtn: { writable: true, value: null },
    // zoom menu item
    zoom: { writable: true, value: null },
    // full window menu item
    fullBtn: { writable: true, value: null },
    isFull: { writable: true, value: false },
    // clipping menu item
    selectionBtn: { writable: true, value: null },
    selectionMenu: { writable: true, value: null },
    selectionMenuBtns: { writable: true, value: null },
    selectionMenuItemSelected: { writable: true, value: null },
    // clipping menu item
    clipBtn: { writable: true, value: null },
    clipMenu: { writable: true, value: null },
    clipMenuBtns: { writable: true, value: null },
    clipMenuItemSelected: { writable: true, value: null },
    // markup
    markupBtn: { writable: true, value: null },
    markupMenu: { writable: true, value: null },
    markupMenuBtns: { writable: true, value: null },
    markupMenuMenus: { writable: true, value: null },
    markupLineShapeMenuBtns: { writable: true, value: null },
    markupTextArea: { writable: true, value: null },
    markupFontSize: { writable: true, value: null },
    colorPickerPanel: { writable: true, value: null },
    // explode
    explodeBtn: { writable: true, value: null },
    explodeMenu: { writable: true, value: null },
    explodePanel: { writable: true, value: null },
    // about
    AboutBtnState: { writable: true, value: null },
    AboutBtnStateIframe: { writable: true, value: null },
    _aboutDialog: { writable: true, value: null },
    //
    animationDialog: { writable: true, value: null },
    multiFileDialog: { writable: true, value: null },

    _fileManager: { writable: true, value: null },

    _activeViewer: { writable: true, value: null },

    // methods
    _Main: {
        value: function (containerID, url, urlType, contextPath, options, viewportNumber, controllingViewer) {
            this.AboutBtnState = this.NoopBtnState.bind(this);
            this.AboutBtnStateIframe = this.NoopBtnState.bind(this);

            this.containerID = GLTFViewer.Utils.IsNull(controllingViewer) ? containerID : controllingViewer.containerID;
            this.viewportNumber = GLTFViewer.Utils.IsNull(viewportNumber) ? 0 : viewportNumber;
            this.controllingViewer = (this.viewportNumber === 0) ? this : controllingViewer;
            if (this.viewportNumber === 0) {
                this.controllingViewer.activeViewer = this;
            }

            var win = window;
            var container = $("#" + containerID);
            if (window.frames && window.frames["ANSYSViewerFrame"]) {
                var iFrame = window.frames["ANSYSViewerFrame"];
                var doc = iFrame.contentDocument;
                win = iFrame.contentWindow;
                this.body = $(doc.body);
                container = $("#" + containerID, this.body);
                this.document = doc;
            }
            container.css("overflow", "hidden");

            function CB(callback, wantPrint, status) {
                function CB2(data, callback, wantPrint, status) {
                    ++data.fileNum;
                    data.status = data.status ? status : false;
                    if (data.fileNum >= 4 || data.fileNum >= data.numFiles) {
                        if (this.hasNodeJS) {
                            if (wantPrint) {
                                if (data.status)
                                    this.wantPrint = true;
                                else
                                    process.exit(1);
                            } else if (this.loadAndExit)
                                process.exit(!data.status);
                        }
                    }
                }

                var numFiles = this.NumFiles();
                var data = {
                    numFiles: 1,
                    fileNum: 0,
                    status: true
                };
                if (this.wantViewport && numFiles > 1) {
                    data.numFiles = numFiles;
                    if (numFiles > 2)
                        this.SetupViewports(4);
                    else
                        this.SetupViewports(2);
                    this.SelectFile(0, CB2.bind(this, data, callback, wantPrint));
                    this.viewer1.SelectFile(1, CB2.bind(this, data, callback, wantPrint));
                    if (numFiles > 2)
                        this.viewer2.SelectFile(2, CB2.bind(this, data, callback, wantPrint));
                    if (numFiles > 3)
                        this.viewer3.SelectFile(3, CB2.bind(this, data, callback, wantPrint));
                } else if (this.hasNodeJS)
                    CB2.call(this, data, callback, wantPrint, status);
                else if (callback)
                    callback(status);
            }

            //if (!GLTFViewer.Utils.IsNull(contextPath))
            //    this.isEKM = true;

            /* don't do this
            // split url on ','
            if (!GLTFViewer.Utils.IsNull(url) && !(url instanceof Array)) {
                var u = url.split(',');
                if (u.length > 1)
                    url = u;
            }
            */

            //  RJF - disabled help for the present, given current use-cases
            if (!this.isEKM && window.location.protocol !== "file:" && !1) {
                var helpURL = "help/ans_viewer/ans_viewer.html";
                var http = new XMLHttpRequest();
                http.open('HEAD', helpURL, false);
                http.send();
                if (http.status === 200)
                    this._helpHTML = helpURL;
                helpURL = "help/ans_viewer/ans_viewer_legal.html";
                http = new XMLHttpRequest();
                http.open('HEAD', helpURL, false);
                http.send();
                if (http.status === 200)
                    this._legalHTML = helpURL;
            }

            this.mobile = GLTFViewer.Utils.IsMobile();
            if (this.mobile)
                this.wantOptions = false;
            if (this.hasNodeJS) {
                if (!GLTFViewer.Utils.IsNull(url)) {
                    if (url instanceof Array) {
                        for (var i = 0; i < url.length; ++i) {
                            if (!GLTFViewer.Utils.IsAbsolutePath(url[i]))
                                url[i] = GLTFViewer.Utils.ResolvePath(win.location.pathname + "/../" + url[i]).substr(1);
                        }
                    } else if (!GLTFViewer.Utils.IsAbsolutePath(url))
                        url = GLTFViewer.Utils.ResolvePath(win.location.pathname + "/../" + url).substr(1);
                }
            }
            var wantPrint = false;
            if (!this.hasNodeJS) {
                if (window.location.protocol !== "file:")
                    this.isServed = true;
            } else {
                wantPrint = this._option["p"];
                this.loadAndExit = this._option["t"];
                if (wantPrint || this.loadAndExit) {
                    if (wantPrint)
                        this.loadAndExit = true;
                    else
                        this.wantViewport = false;
                }
                if (this.loadAndExit)
                    __DONTSHOWALERT__ = true;
                this.wantSave = true;
                try {
                    this._helpSystem = new GLTFViewer.Utils.Help();
                } catch (err) {
                }
            }

            var callback = null;
            if (options) {
                // FILE
                if (!GLTFViewer.Utils.IsNull(options.showFileOpen) && !options.showFileOpen)
                    this.wantFile = false;
                // OPTIONS
                if (!GLTFViewer.Utils.IsNull(options.showOptions) && !options.showOptions)
                    this.wantOptions = false;
                // SAVE
                if (!GLTFViewer.Utils.IsNull(options.allowEdit) && !options.allowEdit)
                    this.wantSave = false;
                // ZOOM
                if (!GLTFViewer.Utils.IsNull(options.showFit) && !options.showFit)
                    this.wantZoom = false;
                // SELECTION
                if (!GLTFViewer.Utils.IsNull(options.showHighlight) && !options.showHighlight)
                    this.wantSelection = false;
                // CLIP
                if (!GLTFViewer.Utils.IsNull(options.showClip) && !options.showClip)
                    this.wantClip = false;
                // MARKUP
                if (!GLTFViewer.Utils.IsNull(options.showMarkup) && !options.showMarkup)
                    this.wantMarkup = false;
                // EXPLODE
                if (!GLTFViewer.Utils.IsNull(options.showExplode) && !options.showExplode)
                    this.wantExplode = false;
                // VIEWPORT
                if (!GLTFViewer.Utils.IsNull(options.showViewport) && !options.showViewport)
                    this.wantViewport = false;
                // FULL
                if (!GLTFViewer.Utils.IsNull(options.showFull) && !options.showFull)
                    this.wantFull = false;
                // ABOUT
                if (!GLTFViewer.Utils.IsNull(options.showAbout) && !options.showAbout)
                    this.wantAbout = false;
                // LOGO
                if (!GLTFViewer.Utils.IsNull(options.showLogo) && !options.showLogo)
                    this.wantLogo = false;
                if (!GLTFViewer.Utils.IsNull(options.lazyLoad) && !options.lazyLoad)
                    this.wantLazyLoad = false;
                if (!GLTFViewer.Utils.IsNull(options.callback) && options.callback instanceof Function)
                    callback = options.callback;

                if (!GLTFViewer.Utils.IsNull(options.report) && options.report) {
                    this.isReport = true;
                    this.wantFile = false;
                    this.wantSave = false;
                    this.wantAbout = false;
                    this.wantViewport = false;
                }
            }

            if (!GLTFViewer.Utils.IsNull(contextPath))
                this.imageDir = contextPath + "images/";
            else if (this.hasNodeJS && this.isReport)
                this.imageDir = "../images/"; // if we are loading a report, the image directory might be wrong
            else
                this.imageDir = "/ansys/nexus/images/";

            if (this.mobile)
                this.wantSelection = false;

            this.messageHandler = new GLTFViewer.Utils.MessageHandler(this);

            if (this.viewportNumber === 0) {
                this._nonFullContainer = container;

                // build canvas for compositing images
                // makding this visible screws up EKM
                container.append("<canvas style='position:absolute;top:0;left:0;width:100%;height:100%;background:transparent;visibility:hidden;'></canvas>");
                this.imageContainer = $("canvas", container).last();

                // about dialog box
                if (this.wantAbout)
                    this._aboutDialog = this.BuildAboutDialog(this.body);

                // full window container
                if (this.wantFull) {
                    this.body.append("<div style='position:fixed;padding:0;margin:0;border:0;left:0;top:0;width:100%;height:100%;visibility:hidden;z-index:99990;overflow:hidden;'></div>");
                    this._fullContainer = $("div", this.body).last();
                }

                // create a container to contain file manager panel and viewports
                container.append("<div style='position:relative;padding:0;margin:0;border:0;left:0;top:0;width:100%;height:100%;display:flex;display:-webkit-flex;flex-direction:row;-webkit-flex-direction:row;'></div>");
                this._rootContainer = $("div", container).last();

                if (this._option["p"]) {
                    if (this._option["w"]) {
                        this._rootContainer.width(this._option["w"]);
                    }
                    if (this._option["h"]) {
                        this._rootContainer.height(this._option["h"]);
                    }
                }

                this._fileManager = new GLTFViewer.FileManager(this, this.wantViewport ? 4 : 1, this._rootContainer);

                // viewports
                this._rootContainer.append("<div style='position:relative;padding:0;margin:0;border:0;width:100%;height:100%;flex:1;-webkit-flex:1;'></div>");
                container = $("div", this._rootContainer).last();

                if (this.wantViewport) {
                    // build viewports in original viewer
                    container.append("<div style='position:absolute;padding:0;margin:0;border:0;left:0;top:0;width:50%;height:100%;overflow:hidden;'></div>");
                    this.viewport02 = $("div", container).last();
                    container.append("<div style='position:absolute;padding:0;margin:0;border:0;left:50%;top:0;width:50%;height:100%;overflow:hidden;'></div>");
                    this.viewport13 = $("div", container).last();

                    this.viewport02.append("<div id='" + containerID + "__viewer0__' style='position:absolute;padding:0;margin:0;border:0;left:0;top:0;width:100%;height:50%;overflow:hidden;'></div>");
                    container = this.viewport0 = $("div", this.viewport02).last();
                    this.viewport02.append("<div id='" + containerID + "__viewer2__' style='position:absolute;padding:0;margin:0;border:0;left:0;top:50%;width:100%;height:50%;overflow:hidden;'></div>");
                    this.viewport2 = $("div", this.viewport02).last();
                    this.viewport13.append("<div id='" + containerID + "__viewer1__' style='position:absolute;padding:0;margin:0;border:0;left:0;top:0;width:100%;height:50%;overflow:hidden;'></div>");
                    this.viewport1 = $("div", this.viewport13).last();
                    this.viewport13.append("<div id='" + containerID + "__viewer3__' style='position:absolute;padding:0;margin:0;border:0;left:0;top:50%;width:100%;height:50%;overflow:hidden;'></div>");
                    this.viewport3 = $("div", this.viewport13).last();

                    this.viewer1 = new GLTFViewer(containerID + "__viewer1__", null, null, null, options, 1, this);
                    this.viewer2 = new GLTFViewer(containerID + "__viewer2__", null, null, null, options, 2, this);
                    this.viewer3 = new GLTFViewer(containerID + "__viewer3__", null, null, null, options, 3, this);
                }
            } else
                this.wantViewport = false;
            this.container = container; // container for viewer

            // container for viewer and bottom slider
            if (this.wantAnimation || this.wantMultiFile)
                this.container.append("<div style='position:relative;padding:0;margin:0;border:0;width:100%;height:100%;display:flex;display:-webkit-flex;flex-direction:column;-webkit-flex-direction:column;'></div>");
            else
                this.container.append("<div style='position:relative;padding:0;margin:0;border:0;width:100%;height:100%;'></div>");
            this.viewerContainer = $("div", this.container).last();

            // 3d viewer container
            this.viewerContainer.append("<div tabindex=1 style='touch-action:none;position:relative;padding:0;margin:0;border:0;width:100%;height:100%;overflow:hidden;flex:1;-webkit-flex:1;'></div>");
            this.viewer = $("div", this.viewerContainer).last();
            this.viewer.css("background", "url('" + this.imageDir + "back.png')");
            this.viewer.css("background-size", "100% 100%");
            // We will use this object later as the background for potential image saves
            this.backgroundImage = new Image();
            this.backgroundImage.src = this.imageDir + 'back.png';

            if (this.wantAnimation)
                this.animationDialog = this.BuildAnimationDialog(this.viewerContainer);
            if (this.wantMultiFile)
                this.multiFileDialog = this.BuildMultiFileDialog(this.viewerContainer);

            this.BuildHTML(this.viewerContainer);
            if (this.viewer && this.c3d && this.overlay && this.progress) {
                try {
                    this.scene = GLTFViewer.Utils.Scene.Create(this, this.viewer[0], this.c3d[0], this.overlay[0], this.progress[0]);
                    // No clip menu unless we have full float support
                    if (!this.scene.gl.getExtension('OES_texture_float')) {
                        this.ClipBtnState(null, GLTFViewer.MENUHIDE);
                        this.wantClip = false;
                    }
                } catch (err) {
                    GLTFViewer.Utils.WriteErr(err);
                    this.scene = null;
                    this.FileBtnState(null, GLTFViewer.MENUHIDE);
                    this.wantFile = false; // no scene, so cannot load files
                    this.SaveBtnState(null, GLTFViewer.MENUHIDE);
                    this.wantSave = false;
                }
            }

            if (GLTFViewer.Utils.IsNull(this.scene)) {
                this.Reset();
                GLTFViewer.Utils.WriteErr("ERROR(GLTFViewer): Can't create scene");
                return;
            }

            if (this.inputFile) {
                function _InputFileSelect(e) {
                    if (e.target.files.length === 0)
                        return;
                    if (this.scene)
                        this.scene.navigator.ClearKeys();
                    var loadType = GLTFViewer.LT_REPLACE;
                    if (this.inputFile._ctrlKey)
                        loadType = GLTFViewer.LT_APPEND;
                    else if (this.inputFile._shiftKey)
                        loadType = GLTFViewer.LT_UPDATE;
                    this.AddFiles(null, e.target.files, null, loadType);
                    e.target.value = ""; // this will allow selecting same files
                }
                this.inputFile.bind('change', _InputFileSelect.bind(this));
            }
            if (this.hasNodeJS) {
                if (this.viewportNumber === 0 && !(window.frames && window.frames["ANSYSViewerFrame"])) {
                    function Print(frame) {
                        frame.contentWindow.print();
                    }

                    // menu
                    this.body.append("<div class='AVDontPrint' style='z-index:99990;position:absolute;padding-top:" + GLTFViewer.CONTAINER_INNER_MARGIN + "px;padding-left:" + (GLTFViewer.CONTAINER_INNER_MARGIN - GLTFViewer.ICONSEPARATION) + "px;'><ul style='display:none;list-style:none;margin:0;padding:0;border:0;'></ul></div>");
                    this._iFrameMenu = $("ul", this.body).last();

                    // adding this stops menu from disappearing in nwjs when window gets too large
                    this._iFrameMenu.append("<li style='width:1px;height:1px;'><a></a><ul style='list-style:none;'><li><a></a></li></ul></li>");

                    this.body.append("<iframe id='ANSYSViewerFrame' style='display:none;width:100%;height:100%;margin:0;border:0;padding:0;' frameborder=0></iframe>");
                    this._iFrame = $("iframe", this.body).last();

                    // file
                    //var ret = this.AppendBtns(this._iFrameMenu, 1);
                    //var fileBtn = ret.btns[0];
                    //this.SetUpMenuBtn(fileBtn, GLTFViewer.ICONFILE, GLTFViewer.fileHelp, null, this.FileBtnState, GLTFViewer.ICONSEPARATION);

                    // print
                    ret = this.AppendBtns(this._iFrameMenu, 1);
                    var printBtn = ret.btns[0];
                    this.SetUpMenuBtn(printBtn, GLTFViewer.ICONPRINT, GLTFViewer.printHelp, null, Print.bind(this, this._iFrame[0]), GLTFViewer.ICONSEPARATION);

                    // about
                    ret = this.AppendBtns(this._iFrameMenu, 1);
                    var aboutBtn = ret.btns[0];
                    var aboutMenu = ret.menus[0];
                    ret = this.AppendBtns(aboutMenu, GLTFViewer.aboutMenuBtnsHelp.length);
                    var aboutMenuBtns = ret.btns;
                    this.AboutBtnStateIframe = this._AboutBtnState.bind(this, aboutBtn, aboutMenuBtns, aboutMenu, this._AboutMenuBtnState.bind(this));
                    var AboutMenuBtnStateIframe = this._AboutMenuBtnState.bind(this, aboutMenuBtns, aboutMenu, this.AboutBtnStateIframe);

                    this.SetUpMenuBtn(aboutBtn, GLTFViewer.ICONABOUT, GLTFViewer.aboutHelp, null, this.AboutBtnStateIframe, GLTFViewer.ICONSEPARATION);
                    this.SetUpMenuBtns(aboutMenu, aboutMenuBtns, GLTFViewer.ICONABOUTHELP, GLTFViewer.aboutMenuBtnsHelp, null, AboutMenuBtnStateIframe);

                    if (!this._helpSystem && !this._helpHTML)
                        AboutMenuBtnStateIframe(0, null, GLTFViewer.MENUDISABLE);

                    // close
                    ret = this.AppendBtns(this._iFrameMenu, 1);
                    var closeBtn = ret.btns[0];
                    this.SetUpMenuBtn(closeBtn, GLTFViewer.ICONCLOSE, GLTFViewer.closeHelp, null, this.HideARZ.bind(this), GLTFViewer.ICONSEPARATION);
                }

                function _OutputFileSelect(e) {
                    this.OutputSaveFile(e.target.value);
                    e.target.value = ""; // this will allow selecting same file
                }
                this.outputFile.bind('change', _OutputFileSelect.bind(this));
            }

            this.Reset();
            if (this.viewportNumber === 0)
                this.SetupViewports(1);
            this.shield = GLTFViewer.Utils.CreateModalShield();

            if (this.viewer)
                this.viewer[0].addEventListener('keydown', this.ContainerKeyDown.bind(this), false);

            // drag and drop on viewer
            if (this.viewerContainer) {
                this.viewerContainer.on('mouseleave', (function (e) {
                    this.MenuFade(true);
                }).bind(this));
                this.viewerContainer.on('drag', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                });
                this.viewerContainer.on('dragover', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                });
                this.viewerContainer.on('dragenter', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                });
                this.viewerContainer.on('drop', (function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (GLTFViewer.GetElementVisible(this.fileBtn) && e.originalEvent.dataTransfer.files.length) {
                        var loadType = GLTFViewer.LT_REPLACE;
                        if (e.ctrlKey)
                            loadType = GLTFViewer.LT_APPEND;
                        else if (e.shiftKey)
                            loadType = GLTFViewer.LT_UPDATE;
                        this.AddFiles(null, e.originalEvent.dataTransfer.files, null, loadType);
                    }
                }).bind(this));
            }

            this._resizeReadyEvent = function () {
                setTimeout(this.UpdateLayout.bind(this), 0);
            }
            this._boundResizeFunction = this._resizeReadyEvent.bind(this);
            $(window).on("resize", this._boundResizeFunction);
            $(document).on("ready", this._boundResizeFunction);

            if (this.viewportNumber === 0 && !GLTFViewer.Utils.IsNull(url))
                this.AddFiles(null, url, urlType, GLTFViewer.LT_REPLACE, true, CB.bind(this, callback, wantPrint));
            this.MenuFade(true);
            this.messageHandler.AddListener(GLTFViewer.MSGLOCK, this._Synchronize.bind(this));
            this.messageHandler.AddListener(GLTFViewer.MSGIMAGE, this._Image.bind(this));
            this.messageHandler.AddListener(GLTFViewer.MSGTITLE, this.SetTitle.bind(this, "READ"));
        }
    },
    activeViewer: {
        get: function () {
            return this.controllingViewer._activeViewer;
        },
        set: function (val) {
            this.controllingViewer._activeViewer = val;
        }
    },
    fileManager: {
        get: function () {
            return this.controllingViewer._fileManager;
        }
    },
    rootContainer: {
        get: function () {
            return this.controllingViewer._rootContainer;
        }
    },
    fullContainer: {
        get: function () {
            return this.controllingViewer._fullContainer;
        }
    },
    nonFullContainer: {
        get: function () {
            return this.controllingViewer._nonFullContainer;
        }
    },
    iFrame: {
        get: function () {
            return this.controllingViewer._iFrame;
        }
    },
    iFrameMenu: {
        get: function () {
            return this.controllingViewer._iFrameMenu;
        }
    },
    aboutDialog: {
        get: function () {
            return this.controllingViewer._aboutDialog;
        }
    },
    viewportLayout: {
        get: function () {
            return this.controllingViewer._viewportLayout;
        },
        set: function (val) {
            this.controllingViewer._viewportLayout = val;
        }
    },
    wantPropertyEdit: {
        get: function () {
            var haveBeta = this.wantBeta && this.controllingViewer.viewerState["Beta"];
            return this._wantPropertyEdit && haveBeta;
        }
    },
    wantSTLExport: {
        get: function () {
            var haveBeta = this.wantBeta && this.controllingViewer.viewerState["Beta"];
            return this._wantSTLExport && haveBeta && this.hasNodeJS;
        }
    },
    canSave: {
        get: function () {
            return this.wantSave && !this.isReport;
        }
    },
    viewportLock: {
        get: function () {
            return this._viewportLock;
        },
        set: function (v) {
            if (this._viewportLock === v)
                return;
            this._viewportLock = v;
            if (this.viewportNumber === 0)
                this.messageHandler.SendMessage(GLTFViewer.MSGLOCK, v);
        }
    },
    OutputSaveFile: {
        value: function (fileName, callback) {
            this.Enable(false);
            try {
                var type = this.outputFile._type;

                if (type === "PNG") {
                    this.WriteImage(fileName, this.outputFile._imageData);
                    this.Enable(true);
                } else if (type === "AVZ") {
                    var didMarkup = false;
                    var didView = false;
                    if (!this._option["tn"]) {
                        // create mup file in extracted zip file directory
                        var mupFileName = this.saveMUPName ? (GLTFViewer.Utils.RemoveExt(this.saveMUPName) + "_.mup") : this.outputFile._zipFolder + '/file.mup';
                        didMarkup = this.scene.handler.SaveMarkups(mupFileName);
                        // create view file in extracted zip file directory
                        var viewFileName = this.saveViewName ? (GLTFViewer.Utils.RemoveExt(this.saveViewName) + "_.view") : this.outputFile._zipFolder + '/file.view';
                        didView = this.scene.handler.SaveViews(viewFileName);
                    }
                    var fs = require('fs');
                    var archiver = require('archiver');
                    var archive = archiver('zip', { level: 8 });
                    var output = fs.createWriteStream(fileName);
                    output.on('close', (function (fs, didMarkup, mupFileName, didView, viewFileName, callback) {
                        if (didMarkup) {
                            try {
                                fs.unlinkSync(mupFileName);
                            } catch (err) { }
                        }
                        if (didView) {
                            try {
                                fs.unlinkSync(viewFileName);
                            } catch (err) { }
                        }
                        if (callback)
                            callback();
                        this.Enable(true);
                    }).bind(this, fs, didMarkup, mupFileName, didView, viewFileName, callback));
                    archive.pipe(output);
                    var fileNames = fs.readdirSync(this.outputFile._zipFolder);
                    for (var i = 0; i < fileNames.length; ++i) {
                        var path = this.outputFile._zipFolder + '/' + fileNames[i];
                        var ext = GLTFViewer.Utils.GetExtension(fileNames[i]);
                        if (!this._option["tn"] && ext === "mup") {
                            if (didMarkup && fileNames[i] === GLTFViewer.Utils.GetFileName(mupFileName))
                                archive.append(fs.readFileSync(path), { name: fileNames[i] });
                        } else if (!this._option["tn"] && ext === "view") {
                            if (didView && fileNames[i] === GLTFViewer.Utils.GetFileName(viewFileName))
                                archive.append(fs.readFileSync(path), { name: fileNames[i] });
                        } else
                            archive.append(fs.readFileSync(path), { name: fileNames[i] });
                    }
                    archive.finalize();
                } else if (type === "STL" || type === "STLBIN") {
                    var fs = require('fs');
                    var fh = fs.openSync(fileName, "w+");
                    this.scene.handler.Export(fh, type);
                    fs.closeSync(fh);
                    this.Enable(true);
                }
            } catch (err) {
                GLTFViewer.Utils.WriteErr("ERROR(OutputFileSelect): Can't create '" + fileName + "'");
                this.Enable(true);
            }
            this.outputFile._imageData = null;
            this.outputFile._zipFolder = null;
        }
    },
    _Image: {
        value: function (from, messageID, viewer) {
            if (this.viewportNumber)
                return;

            function Callback(viewer, imageData) {
                if (GLTFViewer.Utils.IsNull(imageData))
                    return;

                var fileObj = viewer.ActiveFileObj();
                var fileName = (this.viewportLayout === 1 || viewer.isFull) ? (GLTFViewer.Utils.RemoveExt(fileObj._name) + ".png") : "ANSYSViewer.png";

                if (this.hasNodeJS) {
                    this.outputFile._imageData = imageData;
                    this.outputFile._zipFolder = null;
                    this.outputFile._type = "PNG";
                    var path = require('path');
                    if (fileObj._isURL || this.isReport)
                        fileName = path.join(process.env.USERPROFILE, fileName); // store file in user directory
                    else
                        fileName = path.join(path.dirname(fileObj._path), fileName);
                    if (this._option["tn"]) {
                        function CB(retVal) {
                            process.exit(retVal ? 0 : 1);
                        }
                        fileName = path.join(this.tmpDir.name, "thumbnail.png");
                        var retVal = this.WriteImage(fileName, imageData);
                        this.wantPrint = false;
                        this.SaveAVZ(CB.bind(this, retVal));
                    } else if (this.wantPrint) {
                        var retVal = this.WriteImage(fileName, imageData);
                        this.wantPrint = false;
                        process.exit(retVal ? 0 : 1);
                    } else {
                        this.outputFile.prop("nwsaveas", fileName);
                        this.outputFile.prop("accept", ".png");
                        this.outputFile.click();
                    }
                } else if (window.navigator.msSaveBlob) {
                    function dataURItoBlob(dataURI) {
                        var byteString;
                        if (dataURI.split(',')[0].indexOf('base64') >= 0)
                            byteString = atob(dataURI.split(',')[1]);
                        else
                            byteString = unescape(dataURI.split(',')[1]);
                        var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
                        var ia = new Uint8Array(byteString.length);
                        for (var i = 0; i < byteString.length; i++) {
                            ia[i] = byteString.charCodeAt(i);
                        }
                        return new Blob([ia], { type: mimeString });
                    }
                    var blob = dataURItoBlob(imageData);
                    window.navigator.msSaveBlob(blob, fileName);
                } else {
                    function destroyClickedElement(e) {
                        e.stopPropagation();
                        document.body.removeChild(e.target);
                    }
                    var a = document.createElement("a");
                    a.download = fileName;
                    a.href = imageData;
                    a.onclick = destroyClickedElement;
                    a.style.display = "none";
                    document.body.appendChild(a);
                    a.click();
                }
            }

            this.GetImage(Callback.bind(this, viewer));
        }
    },
    _Synchronize: {
        value: function (from, messageID, data) {
            if (this.viewportNumber)
                this.viewportLock = data;
        }
    },
    Reset: {
        value: function (dontResetScene) {
            if (this.popup1) {
                this.popup1.callback();
                this.popup1 = null;
                if (this.popup2) {
                    this.popup2.callback();
                    this.popup2 = null;
                }
            }

            if (!dontResetScene)
                this.SetMultiFileSlider(0, true);
            this.SetAnimationSlider(0, true);
            this.SetAnimationMinMaxSpeed(0, 5);
            this.ShowSceneAnimation(false);
            this.saveMUPName = null;
            this.saveViewName = null;
            this.SetTitle("WRITE", "");
            GLTFViewer.Utils.ShowAlert = true;
            if (!dontResetScene && this.scene)
                this.scene.Reset();

            // Full
            //this.FullBtnState(null, GLTFViewer.MENURESET);
            // Viewport
            this.ViewportBtnState(null, GLTFViewer.MENURESET);
            //this.ViewportBtnState(null, GLTFViewer.MENUHIDE); // only enabled when have scene
            // File
            this.FileBtnState(null, GLTFViewer.MENURESET);
            if (this.scene)
                this.FileBtnState(null, GLTFViewer.MENUSHOW);
            // Options
            this.OptionsBtnState(null, GLTFViewer.MENURESET);
            if (this.viewportNumber === 0)
                this.OptionsBtnState(null, GLTFViewer.MENUSHOW);
            // Save
            this.SaveBtnState(null, GLTFViewer.MENURESET);
            // Zoom
            this.ZoomBtnState(null, GLTFViewer.MENUHIDE); // only enabled when have scene
            // Selection
            this.SelectionBtnState(null, GLTFViewer.MENURESET);
            this.SelectionBtnState(null, GLTFViewer.MENUHIDE); // only enabled when have scene
            // Clip
            this.ClipBtnState(null, GLTFViewer.MENUHIDE);
            // Markup
            this.MarkupBtnState(null, GLTFViewer.MENUHIDE);
            // Explode
            this.ExplodeBtnState(null, GLTFViewer.MENURESET);
            this.ExplodeBtnState(null, GLTFViewer.MENUHIDE);
            // About
            this.AboutBtnStateIframe(null, GLTFViewer.MENURESET);
            this.AboutBtnState(null, GLTFViewer.MENUHIDE);
            if (this.viewportNumber === 0)
                this.AboutBtnState(null, GLTFViewer.MENUSHOW);
        }
    },
    Clear: {
        value: function () {
            GLTFViewer.prototype.Reset.call(this);
            $(window).off("resize", this._boundResizeFunction);
            $(document).off("ready", this._boundResizeFunction);
            if (this._helpSystem) {
                this._helpSystem.Clear();
                this._helpSystem = null;
            }
            this._titles = null;
            if (this.messageHandler) {
                this.messageHandler.Clear();
                this.messageHandler = null;
            }
            this._resizeReadyEvent = null;
            if (this.scene) {
                this.scene.Clear();
                this.scene = null;
            }
            if (this.viewportNumber === 0 && this._aboutDialog) {
                if (this._aboutDialog.box)
                    this._aboutDialog.box.remove();
                this._aboutDialog = null;
            }
            if (this.viewportNumber === 0 && this._fullContainer) {
                this._fullContainer.remove();
                this._fullContainer = null;
            }
            if (this.viewportNumber === 0 && this._nonFullContainer) {
                this._nonFullContainer.remove();
                this._nonFullContainer = null;
            }
            if (this.viewportNumber === 0 && this._fileManager) {
                this._fileManager.Clear();
                this._fileManager = null;
            }
            this.tmpDir = null;
            this.imageDir = null;
            //this.hasNodeJS = false;
            this.popup1 = null;
            this.popup2 = null;
            this.contextMenuContainer = null;
            this.contextMenuMarkup = null;
            this.body = null;
            this.bodyOverflow = null;
            this.viewerContainer = null;
            this.viewer = null;
            if (this.shield) {
                this.shield.remove();
                this.shield = null;
            }
            this.blkLogo = null;
            this.whtLogo = null;
            this.inputFile = null;
            this.outputFile = null;
            this.c3d = null;
            this.overlay = null;
            this.progress = null;
            this.FileManagerBtn = null;
            this.menu = null;
            this.fileBtn = null;
            this.optionsBtn = null;
            this.viewportBtn = null;
            this.viewportMenu = null;
            this.viewportMenuBtns = null;
            this.saveBtn = null;
            this.fullBtn = null;
            this.zoomBtn = null;
            this.clipBtn = null;
            this.clipMenu = null;
            this.clipMenuBtns = null;
            this.clipMenuItemSelected = null;
            this.selectionBtn = null;
            this.selectionMenu = null;
            this.selectionMenuBtns = null;
            this.selectionMenuItemSelected = null;
            this.markupBtn = null;
            this.markupMenu = null;
            this.markupMenuBtns = null;
            this.markupMenuMenus = null;
            this.markupLineShapeMenuBtns = null;
            this.markupTextArea = null;
            this.markupFontSize = null;
            this.colorPickerPanel = null;
            this.explodeBtn = null;
            this.explodeMenu = null;
            this.explodePanel = null;
            this.animationDialog = null;
            this.multFileDialog = null;
            this.container = null;
            this._rootContainer = null;
            this.imageContainer = null;

            if (this.viewer1) {
                this.viewer1.Clear();
                this.viewer1 = null;
            }
            if (this.viewer2) {
                this.viewer2.Clear();
                this.viewer2 = null;
            }
            if (this.viewer3) {
                this.viewer3.Clear();
                this.viewer3 = null;
            }
            this.viewport0 = null;
            this.viewport1 = null;
            this.viewport2 = null;
            this.viewport3 = null;
            this.viewport02 = null;
            this.viewport13 = null;
            this.containerID = null;
            this.controllingViewer = null;
        }
    },
    GetCookie: {
        value: function (name) {
            // try local storage
            if (!GLTFViewer.Utils.IsNull(localStorage)) {
                var data = localStorage[name];
                if (GLTFViewer.Utils.IsNull(data))
                    return null;
                return decodeURIComponent(localStorage[name]);
            }

            // else try cookie            
            var n = name + "=";
            var decodedCookie = decodeURIComponent(document.cookie);
            var ca = decodedCookie.split(';');
            for (var i = 0; i < ca.length; ++i) {
                var c = ca[i];
                while (c.charAt(0) === ' ')
                    c = c.substring(1);
                if (c.indexOf(n) === 0)
                    return c.substring(n.length, c.length);
            }

            // not found
            return null;
        }
    },
    SetCookie: {
        value: function (name, value) {
            // try local storage
            if (!GLTFViewer.Utils.IsNull(localStorage)) {
                localStorage[name] = encodeURIComponent(value);
                return;
            }

            // else try cookie
            document.cookie = name + "=" + encodeURIComponent(value) + "; expires=Tue, 19 Jan 2038 03:14:07 UTC; path=/";
        }
    },
    Enable: {
        value: function (enable) {
            // This function blocks interaction with the web page during loading, etc
            // The 'return' was added to allow interaction during load operations.
            return;
            if (!enable) {
                document.body.style.cursor = "wait";
                this.shield.css("display", "inline");
                this.shield.css("width", GLTFViewer.Utils.GetBrowserWidth() + "px");
                this.shield.css("height", GLTFViewer.Utils.GetBrowserHeight() + "px");
                this.shield.focus();
            } else {
                document.body.style.cursor = "default";
                this.shield.css("display", "none");
            }
        }
    },
    Options: {
        value: function () {
            function DeCase(str) {
                var strs = str.split("+");
                var ret = "";
                for (var i = 0; i < strs.length; ++i) {
                    var s = strs[i][0].toUpperCase() + strs[i].substr(1).toLowerCase();

                    if (i > 0)
                        ret = ret + "+";
                    ret = ret + s;
                }

                return ret;
            }
            function ApplyCallback(ok, data) {
                if (!ok)
                    return;

                // Mouse Button Assignment
                var state = {};
                state["Beta"] = data[1];
                var key = 3;
                for (var i = 0; i < GLTFViewer.MOUSEBUTTONS.length; ++i, ++key)
                    state[GLTFViewer.MOUSEBUTTONS[i]] = data[key];
                this.viewerState = state;
            }
            function reset(resetCallback) {
                var data = ConstructData.call(this, this.defaultState);
                if (resetCallback)
                    resetCallback(data);
            }
            function ConstructData(state) {
                var data = [];
                // ANSYS Viewer State
                data.push(["ANSYS Viewer State", GLTFViewer.Utils.Dialog.DATALABEL]);
                if (this.wantBeta)
                    data.push(["Beta Features (Restart required)", GLTFViewer.Utils.Dialog.DATACHECKBOX, state["Beta"] ? 1 : 0]);
                else
                    data.push(["", GLTFViewer.Utils.Dialog.DATALABEL]);
                //DATACHECKBOX
                // Mouse Button Assignment
                data.push(["Mouse Button Assignment", GLTFViewer.Utils.Dialog.DATALABEL]);
                data.push([DeCase(GLTFViewer.MOUSEBUTTONS[0]), GLTFViewer.Utils.Dialog.DATALIST, state[GLTFViewer.MOUSEBUTTONS[0]], ["None", "Zoom"]]);
                for (var i = 1; i < GLTFViewer.MOUSEBUTTONS.length; ++i)
                    data.push([DeCase(GLTFViewer.MOUSEBUTTONS[i]), GLTFViewer.Utils.Dialog.DATALIST, state[GLTFViewer.MOUSEBUTTONS[i]], ["None", "RotateXY", "RotateZ", "PanXY", "Zoom", "ZoomBox"]]);
                return data;
            }

            var data = ConstructData.call(this, this.viewerState);
            var dialog = new GLTFViewer.Utils.Dialog("Options", data, true, ApplyCallback.bind(this), reset.bind(this), true, false);
        }
    },
    defaultState: {
        get: function () {
            var state = {};
            state["Beta"] = 0;
            state[GLTFViewer.MOUSEBUTTONS[0]] = "Zoom";
            state[GLTFViewer.MOUSEBUTTONS[1]] = "RotateXY";
            state[GLTFViewer.MOUSEBUTTONS[2]] = "Zoom";
            state[GLTFViewer.MOUSEBUTTONS[3]] = "PanXY";
            state[GLTFViewer.MOUSEBUTTONS[4]] = "ZoomBox";
            state[GLTFViewer.MOUSEBUTTONS[5]] = "RotateXY";
            state[GLTFViewer.MOUSEBUTTONS[6]] = "RotateXY";
            state[GLTFViewer.MOUSEBUTTONS[7]] = "Zoom";
            state[GLTFViewer.MOUSEBUTTONS[8]] = "RotateXY";
            state[GLTFViewer.MOUSEBUTTONS[9]] = "RotateXY";
            state[GLTFViewer.MOUSEBUTTONS[10]] = "RotateZ";
            state[GLTFViewer.MOUSEBUTTONS[11]] = "RotateXY";
            state[GLTFViewer.MOUSEBUTTONS[12]] = "RotateXY";
            return state;
        }
    },
    viewerState: {
        get: function () {
            if (GLTFViewer.Utils.IsNull(this.controllingViewer._state)) {
                var str = this.GetCookie("State");
                if (!GLTFViewer.Utils.IsNull(str))
                    return JSON.parse(str);
                return this.defaultState;
            }
            return this.controllingViewer._state;
        },
        set: function (state) {
            this.controllingViewer._state = state;
            // save to cookie or file
            this.SetCookie("State", JSON.stringify(state));
        }
    },
    PostChanges: {
        value: function () {
            // post markup to server
            this.scene.handler.PostMarkups();
            // post view to server
            this.scene.handler.PostViews();
        }
    },
    GetViewerByNumber: {
        value: function (viewportNumber) {
            switch (viewportNumber) {
                case 1:
                    return this.controllingViewer.viewer1;
                    break;
                case 2:
                    return this.controllingViewer.viewer2;
                    break;
                case 3:
                    return this.controllingViewer.viewer3;
                    break;
                default:
                    return this.controllingViewer;
                    break;
            }
        }
    },
    GetViewer: {
        value: function (windowNum) {
            if (!GLTFViewer.Utils.IsNull(windowNum))
                return this.GetViewerByNumber(windowNum);
            if (this.controllingViewer.viewer1 && this.controllingViewer.viewer1.isFull)
                return this.controllingViewer.viewer1;
            if (this.controllingViewer.viewer2 && this.controllingViewer.viewer2.isFull)
                return this.controllingViewer.viewer2;
            if (this.controllingViewer.viewer3 && this.controllingViewer.viewer3.isFull)
                return this.controllingViewer.viewer3;
            return this;
        }
    },
    GetMainUIViewer: {
        value: function () {
            if (this.controllingViewer.viewer1 && this.controllingViewer.viewer1.isFull)
                return this.controllingViewer.viewer1;
            if (this.controllingViewer.viewer2 && this.controllingViewer.viewer2.isFull)
                return this.controllingViewer.viewer2;
            if (this.controllingViewer.viewer3 && this.controllingViewer.viewer3.isFull)
                return this.controllingViewer.viewer3;
            return this.controllingViewer;
        }
    },
    //////////////////////////////////
    OnlyOne: {
        value: function (func) {
            func.call(this.controllingViewer);
        }
    },
    NumFiles: {
        value: function () {
            return this.fileManager.numFiles;
        }
    },
    Files: {
        value: function () {
            return this.fileManager.files;
        }
    },
    FileNames: {
        value: function () {
            return this.fileManager.fileNames;
        }
    },
    FilePaths: {
        value: function () {
            return this.fileManager.filePaths;
        }
    },
    AddFile: {
        value: function (file, fileType, loadType, resources, containerFile, multiFile) {
            return this.fileManager.AddFile(this, file, fileType, loadType, resources, containerFile, multiFile);
        }
    },
    FindFile: {
        value: function (file, containerFile) {
            return this.fileManager.FindFile(file, containerFile);
        }
    },
    RemoveFile: {
        value: function (fileObj) {
            this.fileManager.RemoveFile(this, fileObj);
        }
    },
    SelectFile: {
        value: function (fileObj, callback, loadTypeOverride) {
            this.fileManager.SelectFile(this, fileObj, callback, loadTypeOverride);
        }
    },
    ActiveFileObj: {
        value: function () {
            return this.fileManager.ActiveFileObj(this);
        }
    },
    CloseFile: {
        value: function (dontResetScene) {
            this.HideARZ();
            this.fileManager.CloseFile(this, dontResetScene);
        }
    },
    ClearVisibilityList: {
        value: function () {
            this.fileManager.RemoveAllEntries(this);
        }
    },
    DeleteEntryVisibilityList: {
        value: function (entry) {
            this.fileManager.RemoveEntry(this, entry);
        }
    },
    AddEntryVisibilityList: {
        value: function (name, visible, visCallback, editCallback, parentVisList, onlyGroups) {
            return this.fileManager.AddEntry(this, name, visible, visCallback, editCallback, parentVisList, onlyGroups);
        }
    },
    DeleteEntrySceneList: {
        value: function (li) {
            if (!li)
                return;
            this.fileManager.RemoveScene(this, li);
        }
    },
    SetSelectionSceneList: {
        value: function (li) {
            this.fileManager.SelectScene(this, li);
        }
    },
    AddEntrySceneList: {
        value: function (sceneItem, callback) {
            return this.fileManager.AddScene(this, sceneItem, callback);
        }
    },
    //////////////////////////////////
    WriteImage: {
        value: function (fileName, imageData) {
            if (!this.hasNodeJS || GLTFViewer.Utils.IsNull(fileName) || !imageData)
                return false;

            try {
                var fs = require('fs');
                var base64Data = imageData.replace(/^data:image\/png;base64,/, "");
                fs.writeFileSync(fileName, base64Data, 'base64');
            } catch (err) {
                GLTFViewer.Utils.WriteErr("ERROR(WriteImage): Can't create '" + fileName + "'");
                return false;
            }

            return true;
        }
    },
    GetRenderedImage: {
        value: function () {
            // The final rendered image is the background <img>, overlaid by
            // the 3D scene canvas content and the 2D scene overlay.
            let width = this.scene.navigator.canvasWidth;
            let height = this.scene.navigator.canvasHeight;
            let scene3d = this.scene.canvas;
            let overlay = this.scene.overlay;
            // temporary rendering canvas
            let canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            let gx = canvas.getContext('2d');
            gx.clearRect(0, 0, width, height);
            // Normally, the background image is in the css of the div
            // we'll just draw (and scale) it directly here.
            gx.drawImage(this.backgroundImage, 0, 0, width, height);
            gx.drawImage(scene3d, 0, 0, width, height);
            gx.drawImage(overlay, 0, 0, width, height);
            let datauri = canvas.toDataURL('image/png');
            canvas.remove();
            return datauri;
        }
    },
    GetImage: {
        value: function (callback) {
            if (GLTFViewer.Utils.IsNull(this.scene)) {
                callback(null);
                return;
            }

            // determine what scenes need to be captured
            var data = { image: [false, false, false, false],
                numImages: 0
            };
            if (this.viewportLayout === 1 ||
                (this.viewportLayout === 2 && !this.viewer1.isFull) ||
                (this.viewportLayout === 4 && !this.viewer1.isFull && !this.viewer2.isFull && !this.viewer3.isFull)) {
                data.image[0] = true;
                ++data.numImages;
            }
            if ((this.viewportLayout === 2 && !this.isFull) ||
                (this.viewportLayout === 4 && !this.isFull && !this.viewer2.isFull && !this.viewer3.isFull)) {
                data.image[1] = true;
                ++data.numImages;
            }
            if (this.viewportLayout === 4 && !this.isFull && !this.viewer1.isFull && !this.viewer3.isFull) {
                data.image[2] = true;
                ++data.numImages;
            }
            if (this.viewportLayout === 4 && !this.isFull && !this.viewer1.isFull && !this.viewer2.isFull) {
                data.image[3] = true;
                ++data.numImages;
            }

            if (data.numImages === 1) {
                if (data.image[0])
                    this.scene.GetImage(callback);
                else if (data.image[1])
                    this.viewer1.scene.GetImage(callback);
                else if (data.image[2])
                    this.viewer2.scene.GetImage(callback);
                else if (data.image[3])
                    this.viewer3.scene.GetImage(callback);
                return;
            }

            // going to have to composite some images, layout must be 2 or 4

            function Compositor(_callback, _data, num, img) {
                _data.image[num] = img;
                if (--_data.numImages <= 0) {

                    function ImgCompositor(cb, d) {
                        if (--d.numImages > 0)
                            return;

                        // if we get here, we need to combine images into 1
                        var gx = this.imageContainer[0].getContext('2d');

                        // composite them
                        var width = this.viewerWidth + this.viewer1.viewerWidth;
                        var height = this.viewerHeight + (this.viewportLayout === 2 ? 0 : this.viewer2.viewerHeight);
                        // set size of imageContainer
                        this.imageContainer[0].width = width;
                        this.imageContainer[0].height = height;
                        gx.clearRect(0, 0, width, height);

                        if (this.viewportLayout === 2) {
                            gx.drawImage(d.image[0], 0, 0, this.viewerWidth, height);
                            gx.drawImage(d.image[1], this.viewerWidth, 0, this.viewer1.viewerWidth, height);
                        } else { // this.viewportLayout === 4
                            gx.drawImage(d.image[0], 0, 0, this.viewerWidth, this.viewerHeight);
                            gx.drawImage(d.image[1], this.viewerWidth, 0, this.viewer1.viewerWidth, this.viewer1.viewerHeight);
                            gx.drawImage(d.image[2], 0, this.viewerHeight, this.viewer2.viewerWidth, this.viewer2.viewerHeight);
                            gx.drawImage(d.image[3], this.viewerWidth, this.viewerHeight, this.viewer2.viewerWidth, this.viewer2.viewerHeight);
                        }

                        var uri = this.imageContainer[0].toDataURL();
                        this.scene.Invalidate(true);
                        cb(uri);
                    }
                    function loadImage(d, n, src, cb) {
                        d.image[n] = new Image();
                        d.image[n].onload = cb;
                        d.image[n].src = src;
                    }

                    var d = { image: [],
                        numImages: 0
                    };
                    if (this.viewportLayout === 2) {
                        d.numImages = 2;
                        loadImage(d, 0, _data.image[0], ImgCompositor.bind(this, callback, d));
                        loadImage(d, 1, _data.image[1], ImgCompositor.bind(this, callback, d));
                    } else { // this.viewportLayout === 4
                        d.numImages = 4;
                        loadImage(d, 0, _data.image[0], ImgCompositor.bind(this, callback, d));
                        loadImage(d, 1, _data.image[1], ImgCompositor.bind(this, callback, d));
                        loadImage(d, 2, _data.image[2], ImgCompositor.bind(this, callback, d));
                        loadImage(d, 3, _data.image[3], ImgCompositor.bind(this, callback, d));
                    }
                }
            }

            if (data.image[0])
                this.scene.GetImage(Compositor.bind(this, callback, data, 0));
            if (data.image[1])
                this.viewer1.scene.GetImage(Compositor.bind(this, callback, data, 1));
            if (data.image[2])
                this.viewer2.scene.GetImage(Compositor.bind(this, callback, data, 2));
            if (data.image[3])
                this.viewer3.scene.GetImage(Compositor.bind(this, callback, data, 3));
        }
    },
    Export: {
        value: function (type) {
            if (!this.hasNodeJS)
                return;

            var fileObj = this.ActiveFileObj();
            var fileName = GLTFViewer.Utils.RemoveExt(fileObj._name);

            var path = require('path');
            fileName = path.join(path.dirname(fileObj._path), fileName);

            var ext;
            switch (type) {
                case "STL":
                case "STLBIN":
                    ext = ".stl";
                    break;
                default:
                    return;
            }
            fileName = fileName + ext;

            this.outputFile._imageData = null;
            this.outputFile._zipFolder = null;
            this.outputFile._type = type;
            this.outputFile.prop("nwsaveas", fileName);
            this.outputFile.prop("accept", ext);
            this.outputFile.click();
        }
    },
    SaveAVZ: {
        value: function (callback) {
            if (!this.hasNodeJS || !this.scene || !this.scene.handler)
                return;

            var fileObj = this.ActiveFileObj();
            var path = require('path');
            var fileName = path.join(path.dirname(fileObj._path), fileObj._name);

            // create AVZ file
            this.outputFile._imageData = null;
            this.outputFile._zipFolder = this.tmpDir.name;
            this.outputFile._type = "AVZ";
            this.outputFile.prop("nwsaveas", fileName);
            this.outputFile.prop("accept", ".avz");
            if (callback)
                this.OutputSaveFile(fileName, callback);
            else
                this.outputFile.click();
        }
    },
    SaveImage: {
        value: function () {
            this.messageHandler.SendMessage(GLTFViewer.MSGIMAGE, this);
        }
    },
    SaveSTL: {
        value: function () {
            this.Export("STLBIN");
        }
    },
    SetUpMenuBtn: {
        value: function (elem, icon, help, color, onClick, marginL) {
            elem.css("width", (GLTFViewer.ICONSIZE - 2) + "px"); // 2 for 1px border
            elem.css("height", (GLTFViewer.ICONSIZE - 2) + "px");
            var mL = marginL ? marginL : 0;
            if (mL)
                elem.css("margin-left", mL + "px");
            if (help)
                elem.prop("title", help);
            if (icon >= 0) {
                var _color = "";
                if (color)
                    _color = "rgba(" + Math.round(color.r) + "," + Math.round(color.g) + "," + Math.round(color.b) + "," + (Math.round(color.a) ? 1 : 0) + ") ";
                elem.css("background", _color + "url('" + this.imageDir + "Icons.png') -0px -" + GLTFViewer.ICONSIZE * icon + "px");
            }
            if (!color)
                GLTFViewer.SetElemColor(elem, GLTFViewer.MODENORMAL);
            elem.css("border", "1px solid " + GLTFViewer.BORDERCOLOR);
            elem.css("border-radius", "4px");
            if (onClick) {
                elem.click((function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.CloseContextMenus();
                    if (this.scene)
                        this.scene.navigator.ClearKeys();
                    if (GLTFViewer.GetElementEnable(elem))
                        onClick.call(this, e, GLTFViewer.MENUCLICK);
                }).bind(this));
                elem.on("mousedown mousemove mouseover mouseout", function (e) {
                    if (GLTFViewer.GetElementEnable(elem))
                        e.stopPropagation();
                });
                if (window.navigator.pointerEnabled) {
                    elem.on('pointerdown pointermove pointerup', function (e) {
                        if (GLTFViewer.GetElementEnable(elem))
                            e.stopPropagation();
                    });
                } else {
                    elem.on('touchstart touchmove touchend', function (e) {
                        if (GLTFViewer.GetElementEnable(elem))
                            e.stopPropagation();
                    });
                }
            }
            var a = $('a', elem).first();
            elem.hover((function () {
                if (this.scene && this.scene.navigator._touchHandler.Touches.Count() === 0) {
                    if (GLTFViewer.GetElementEnable(elem)) {
                        this.MenuFade(false, 250);
                        elem.css("border-color", GLTFViewer.HOVERCOLOR);
                    }
                }
            }).bind(this), (function () {
                if (GLTFViewer.GetElementEnable(elem)) {
                    elem.css("border-color", GLTFViewer.BORDERCOLOR);
                    this.MenuFade(true, 5000, true);
                }
            }).bind(this));
            GLTFViewer.Utils.NoContext(this, elem);
        }
    },
    SetUpMenuBtns: {
        value: function (menu, elemList, icon0, helpList, colorList, onClick, offsetAt, btnsPerLine) {
            if (!GLTFViewer.Utils.IsNull(btnsPerLine)) {
                var width = btnsPerLine * (GLTFViewer.ICONSIZE + 0) + (!GLTFViewer.Utils.IsNull(offsetAt) ? GLTFViewer.ICONSEPARATION : 0) + 0;
                menu.css("width", width + "px");
            }
            for (var i = 0; i < elemList.length; ++i) {
                var _help = null;
                if (helpList && i < helpList.length)
                    _help = helpList[i];
                var _color = null;
                if (colorList && i < colorList.length)
                    _color = colorList[i];
                var _onClick = null;
                if (onClick) {
                    //_onClick = (function (n) {
                    //    return function (e, state) {
                    //        onClick.call(this, e, n, state);
                    //    };
                    //})(i);

                    _onClick = onClick.bind(this, i);
                }
                var icon = (icon0 instanceof Array) ? icon0[i] : icon0 + i;
                var mL = (i === offsetAt) ? GLTFViewer.ICONSEPARATION : 0;
                this.SetUpMenuBtn(elemList[i], icon, _help, _color, _onClick, mL);
            }
        }
    },
    AppendBtns: {
        value: function (parent, numBtns) {
            var btns = [];
            var menus = [];
            for (var i = 0; i < numBtns; ++i) {
                parent.append("<li style='float:left;'><div style='padding-top:" + GLTFViewer.ICONSIZE + "px;'></div><ul style='position:absolute;list-style:none;margin:0;padding:0;border:0;'></ul></li>");
                var li = $("li", parent).last();
                btns.push(li);
                var ul = $("ul", li).last();
                menus.push(ul);
            }

            return { btns: btns, menus: menus };
        }
    },
    BuildHTML: {
        value: function (container) {
            // inputfile
            if (this.wantFile) {
                if (this.hasNodeJS)
                //                    this.viewer.append("<div><input type='file' accept='.scdoc,.json,.gltf,.bin,.glsl,.png,.avz,.avzm,.arz' multiple=1 style='display:none;'></input></div>");
                    this.viewer.append("<div><input type='file' accept='.scdoc,.avz,.avzm,.arz' multiple style='display:none;'></input></div>");
                else
                //                    this.viewer.append("<div><input type='file' accept='.scdoc,.json,.gltf,.bin,.glsl,.png,.avz,.avzm' multiple=1 style='display:none;'></input></div>");
                    this.viewer.append("<div><input type='file' accept='.scdoc,.avz,.avzm' multiple style='display:none;'></input></div>");
                this.inputFile = $("input", this.viewer).last();
            }
            if (this.hasNodeJS) {
                this.viewer.append("<div><input type='file' style='display:none;'></input></div>");
                this.outputFile = $("input", this.viewer).last();
            }

            // c3d, has to be 100% size
            this.viewer.append("<canvas style='position:absolute;top:0;left:0;width:100%;height:100%;background:transparent;'></canvas>");
            this.c3d = $("canvas", this.viewer).last();

            // overlay, has to be 100% size
            this.viewer.append("<canvas style='position:absolute;top:0;left:0;width:100%;height:100%;background:transparent;'></canvas>");
            this.overlay = $("canvas", this.viewer).last();

            // progress
            this.viewer.append("<progress max=1 style='position:absolute;top:50%;left:50%;width:150px;height:20px;margin-top:-10px;margin-left:-75px;visibility:hidden;'></progress>");
            this.progress = $("progress", this.viewer).last();

            // logo
            // -19px and -20px is hack to get these particular logos to be at top of screen right of screen with 5px margin
            if (this.wantLogo) {
                this.viewer.append("<img src='" + this.imageDir + "ANSYS_blk_lrg.png' style='visible:hidden;position:absolute;padding:0;margin:0;border:0;right:" + GLTFViewer.LOGORIGHTMARGIN + "px;top:" + GLTFViewer.LOGOTOPMARGIN + "px;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:-moz-none;-ms-user-select:none;-o-user-select:none;user-select:none;'></img>");
                this.blkLogo = $("img", this.viewer).last();
                this.viewer.append("<img src='" + this.imageDir + "ANSYS_wht_lrg.png' style='visible:hidden;position:absolute;padding:0;margin:0;border:0;right:" + GLTFViewer.LOGORIGHTMARGIN + "px;top:" + GLTFViewer.LOGOTOPMARGIN + "px;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:-moz-none;-ms-user-select:none;-o-user-select:none;user-select:none;'></img>");
                this.whtLogo = $("img", this.viewer).last();
            }

            // menu
            this.viewer.append("<div class='AVDontPrint' style='position:relative;padding-top:" + GLTFViewer.CONTAINER_INNER_MARGIN + "px;padding-left:" + (GLTFViewer.CONTAINER_INNER_MARGIN - GLTFViewer.ICONSEPARATION) + "px;'><ul style='list-style:none;margin:0;padding:0;border:0;'></ul></div>");
            this.menu = $("ul", this.viewer).last();

            // adding this stops menu from disappearing in nwjs when window gets too large
            this.menu.append("<li style='width:1px;height:1px;'><a></a><ul style='list-style:none;'><li><a></a></li></ul></li>");

            if (this.wantFile) {
                // file
                var ret = this.AppendBtns(this.menu, 1);
                this.fileBtn = ret.btns[0];

                this.SetUpMenuBtn(this.fileBtn, GLTFViewer.ICONFILE, GLTFViewer.fileHelp, null, this.FileBtnState, GLTFViewer.ICONSEPARATION);
            }

            if (this.wantSave) {
                // save
                var ret = this.AppendBtns(this.menu, 1);
                this.saveBtn = ret.btns[0];

                this.SetUpMenuBtn(this.saveBtn, GLTFViewer.ICONSAVE, this.isServed ? GLTFViewer.saveHelpServed : GLTFViewer.saveHelpLocal, null, this.SaveBtnState, GLTFViewer.ICONSEPARATION);
            }

            // FileManager
            {
                var ret = this.AppendBtns(this.menu, 1);
                this.FileManagerBtn = ret.btns[0];

                this.SetUpMenuBtn(this.FileManagerBtn, GLTFViewer.ICONVIS, GLTFViewer.FileManagerBtnHelp, null, this.FileManagerBtnState, GLTFViewer.ICONSEPARATION);
                if (this.viewportNumber)
                    this.FileManagerBtnState(null, GLTFViewer.MENUHIDE);
            }

            // zoom
            if (this.wantZoom) {
                var ret = this.AppendBtns(this.menu, 1);
                this.zoomBtn = ret.btns[0];

                this.SetUpMenuBtn(this.zoomBtn, GLTFViewer.ICONZOOM, GLTFViewer.zoomHelp, null, this.ZoomBtnState, GLTFViewer.ICONSEPARATION);
            }
            if (this.wantSelection) {
                // selection
                var ret = this.AppendBtns(this.menu, 1);
                this.selectionBtn = ret.btns[0];
                this.selectionMenu = ret.menus[0];
                ret = this.AppendBtns(this.selectionMenu, GLTFViewer.selectionMenuBtnsHelp.length);
                this.selectionMenuBtns = ret.btns;

                this.SetUpMenuBtn(this.selectionBtn, GLTFViewer.ICONSELECTIONBODY, GLTFViewer.selectionHelp, null, this.SelectionBtnState, GLTFViewer.ICONSEPARATION);
                this.SetUpMenuBtns(this.selectionMenu, this.selectionMenuBtns, GLTFViewer.ICONSELECTIONEDGE, GLTFViewer.selectionMenuBtnsHelp, null, this.SelectionMenuBtnState);
            }
            if (this.wantClip) {
                // clip
                var ret = this.AppendBtns(this.menu, 1);
                this.clipBtn = ret.btns[0];
                this.clipMenu = ret.menus[0];
                ret = this.AppendBtns(this.clipMenu, GLTFViewer.clipMenuBtnsHelp.length);
                this.clipMenuBtns = ret.btns;

                this.SetUpMenuBtn(this.clipBtn, GLTFViewer.ICONCLIP, GLTFViewer.clipHelp, null, this.ClipBtnState, GLTFViewer.ICONSEPARATION);
                this.SetUpMenuBtns(this.clipMenu, this.clipMenuBtns, GLTFViewer.ICONCLIP0, GLTFViewer.clipMenuBtnsHelp, null, this.ClipMenuBtnState, GLTFViewer.clipMenuBtnsHelp.length - 1);
            }
            if (this.wantMarkup) {
                function contextMarkupCallback(val, other) {
                    var item = val[0];
                    switch (item) {
                        case GLTFViewer.CM_MARKUP_DELETE_MARKUP:
                            if (this.scene)
                                this.scene.MarkupDelete(other);
                            break;
                    }
                }
                this.contextMenuMarkup = new GLTFViewer.Utils.SimpleContextMenu(this, this.controllingViewer.body, [GLTFViewer.CM_MARKUP_DELETE_MARKUP], null, contextMarkupCallback.bind(this));

                // markup
                var ret = this.AppendBtns(this.menu, 1);
                this.markupBtn = ret.btns[0];
                this.markupMenu = ret.menus[0];
                this.colorPickerPanel = this.BuildColorPickerPanel();
                ret = this.AppendBtns(this.markupMenu, GLTFViewer.markupMenuBtnsHelp.length);
                this.markupMenuBtns = ret.btns;
                this.markupMenuMenus = ret.menus;

                this.markupMenuBtns[GLTFViewer.markupMenuBtnsFontSize].append("<textarea maxlength=2 style='resize:none;position:absolute;top:0;padding-top:6px;text-align:center;overflow:hidden;font-size:14px;font-family:Segoe UI,Arial,Helvetica,sans-serif;'></textarea>");
                this.markupFontSize = $("textarea", this.markupMenuBtns[GLTFViewer.markupMenuBtnsFontSize]).last();
                this.markupMenuBtns[GLTFViewer.markupMenuBtnsFontSize] = this.markupFontSize;

                ret = this.AppendBtns(this.markupMenuMenus[GLTFViewer.markupMenuBtnsLineShape], GLTFViewer.markupLineShapeMenuBtnsHelp.length);
                this.markupLineShapeMenuBtns = ret.btns;

                this.viewer.append("<textarea style='visibility:hidden;position:absolute;top:0;left:0;width:10px;height:10px;overflow:hidden;font-size:16px;font-family:Segoe UI,Arial,Helvetica,sans-serif;'></textarea>");
                this.markupTextArea = $("textarea", this.viewer).last();

                this.markupTextArea[0].addEventListener("blur", (function (e) {
                    if (this.scene)
                        this.scene.MarkupTextEvent("blur", e);
                }).bind(this), false);
                this.markupTextArea[0].addEventListener("keydown", (function (e) {
                    if (this.scene)
                        this.scene.MarkupTextEvent("keydown", e);
                }).bind(this), false);
                this.markupTextArea[0].addEventListener("keyup", (function (e) {
                    if (this.scene)
                        this.scene.MarkupTextEvent("keyup", e);
                }).bind(this), false);
                this.markupTextArea[0].addEventListener("paste", (function (e) {
                    if (this.scene)
                        this.scene.MarkupTextEvent("paste", e);
                }).bind(this), false);
                this.markupTextArea[0].addEventListener("mousedown", (function (e) {
                    if (this.scene)
                        this.scene.MarkupTextEvent("mousedown", e);
                }).bind(this), true);
                if (window.navigator.pointerEnabled) {
                    this.markupTextArea[0].addEventListener("pointerdown", (function (e) {
                        if (this.scene)
                            this.scene.MarkupTextEvent("mousedown", e);
                    }).bind(this), true);
                } else {
                    this.markupTextArea[0].addEventListener("touchstart", (function (e) {
                        if (this.scene)
                            this.scene.MarkupTextEvent("mousedown", e);
                    }).bind(this), true);
                }
                this.markupTextArea[0].addEventListener("mousemove", (function (e) {
                    if (this.scene)
                        this.scene.MarkupTextEvent("mousedown", e);
                }).bind(this), true);
                if (window.navigator.pointerEnabled) {
                    this.markupTextArea[0].addEventListener("pointermove", (function (e) {
                        if (this.scene)
                            this.scene.MarkupTextEvent("mousemove", e);
                    }).bind(this), true);
                } else {
                    this.markupTextArea[0].addEventListener("touchmove", (function (e) {
                        if (this.scene)
                            this.scene.MarkupTextEvent("mousemove", e);
                    }).bind(this), true);
                }
                this.markupTextArea[0].addEventListener("mouseup", (function (e) {
                    if (this.scene)
                        this.scene.MarkupTextEvent("mouseup", e);
                }).bind(this), false);
                if (window.navigator.pointerEnabled) {
                    this.markupTextArea[0].addEventListener("pointerup", (function (e) {
                        if (this.scene)
                            this.scene.MarkupTextEvent("mouseup", e);
                    }).bind(this), true);
                } else {
                    this.markupTextArea[0].addEventListener("touchend", (function (e) {
                        if (this.scene)
                            this.scene.MarkupTextEvent("mousedown", e);
                    }).bind(this), true);
                }

                this.SetUpMenuBtn(this.markupBtn, GLTFViewer.ICONMARKUP, GLTFViewer.markupHelp, null, this.MarkupBtnState, GLTFViewer.ICONSEPARATION);
                this.SetUpMenuBtns(this.markupMenu, this.markupMenuBtns, [GLTFViewer.ICONMARKUP2D, GLTFViewer.ICONMARKUP3D, GLTFViewer.ICONMARKUPLINE, GLTFViewer.ICONLINECOLOR, GLTFViewer.ICONFONTCOLOR, GLTFViewer.ICONBACKCOLOR, GLTFViewer.ICONFONTSIZE], GLTFViewer.markupMenuBtnsHelp, null, this.MarkupMenuBtnState, 2);

                this.markupFontSize.css("background", "white");
                this.markupFontSize.css("width", (GLTFViewer.ICONSIZE - 4) + "px");
                this.markupFontSize.css("height", (GLTFViewer.ICONSIZE - 9) + "px");

                this.SetUpMenuBtns(this.markupMenuMenus[GLTFViewer.markupMenuBtnsLineShape], this.markupLineShapeMenuBtns, GLTFViewer.ICONMARKUPLINE, GLTFViewer.markupLineShapeMenuBtnsHelp, null, this.MarkupLineShapeBtnState, null, 1);

                this.markupFontSize[0].addEventListener("keydown", (function (e) {
                    e.stopPropagation();
                    //                    if (e.keyCode === 8 || e.keyCode === 46 || (e.keyCode >= 48 && e.keyCode <= 57) || (e.keyCode >= 96 && e.keyCode <= 105))
                    //                        return;
                    //                    e.preventDefault();
                    if (e.keyCode === 13) {
                        e.preventDefault();
                        this.MarkupMenuBtnState(GLTFViewer.markupMenuBtnsFontSize, null, GLTFViewer.MENUCLICK, this.markupFontSize[0].value);
                    }
                }).bind(this), false);
                this.markupFontSize[0].addEventListener("blur", (function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    this.MarkupMenuBtnState(GLTFViewer.markupMenuBtnsFontSize, null, GLTFViewer.MENUCLICK, this.markupFontSize[0].value);
                }).bind(this), false);
            }

            if (this.wantExplode) {
                // explode
                var ret = this.AppendBtns(this.menu, 1);
                this.explodeBtn = ret.btns[0];
                this.explodeMenu = ret.menus[0];

                this.SetUpMenuBtn(this.explodeBtn, GLTFViewer.ICONEXPLODE, GLTFViewer.explodeBtnHelp, null, this.ExplodeBtnState, GLTFViewer.ICONSEPARATION);
                this.explodeMenu.css("background", "transparent");
                this.explodeMenu.css("border", "1px solid " + GLTFViewer.BORDERCOLOR);
                this.explodeMenu.css("padding", "0"); // TRBL
                this.explodeMenu.css("width", "auto");
                GLTFViewer.Utils.NoContext(this, this.explodeMenu);
                this.explodePanel = this.BuildExplodePanel();
            }

            if (this.wantViewport) {
                // viewports
                var ret = this.AppendBtns(this.menu, 1);
                this.viewportBtn = ret.btns[0];
                this.viewportMenu = ret.menus[0];
                ret = this.AppendBtns(this.viewportMenu, GLTFViewer.viewportMenuBtnsHelp.length);
                this.viewportMenuBtns = ret.btns;

                this.SetUpMenuBtn(this.viewportBtn, GLTFViewer.ICONVP4, GLTFViewer.viewportHelp, null, this.ViewportBtnState, GLTFViewer.ICONSEPARATION);
                this.SetUpMenuBtns(this.viewportMenu, this.viewportMenuBtns, GLTFViewer.ICONVP1, GLTFViewer.viewportMenuBtnsHelp, null, this.ViewportMenuBtnState, GLTFViewer.viewportMenuBtnsHelp.length - 1);
            }

            if (this.wantFull) {
                // full window
                var ret = this.AppendBtns(this.menu, 1);
                this.fullBtn = ret.btns[0];

                this.SetUpMenuBtn(this.fullBtn, GLTFViewer.ICONFULL, GLTFViewer.fullHelp, null, this.FullBtnState, GLTFViewer.ICONSEPARATION);
            }

            if (this.wantOptions) {
                // options
                var ret = this.AppendBtns(this.menu, 1);
                this.optionsBtn = ret.btns[0];

                this.SetUpMenuBtn(this.optionsBtn, GLTFViewer.ICONOPTIONS, GLTFViewer.optionsHelp, null, this.OptionsBtnState, GLTFViewer.ICONSEPARATION);
            }

            if (this.wantAbout) {
                // about
                var ret = this.AppendBtns(this.menu, 1);
                var aboutBtn = ret.btns[0];
                var aboutMenu = ret.menus[0];
                ret = this.AppendBtns(aboutMenu, GLTFViewer.aboutMenuBtnsHelp.length);
                var aboutMenuBtns = ret.btns;
                this.AboutBtnState = this._AboutBtnState.bind(this, aboutBtn, aboutMenuBtns, aboutMenu, this._AboutMenuBtnState.bind(this));
                var AboutMenuBtnState = this._AboutMenuBtnState.bind(this, aboutMenuBtns, aboutMenu, this.AboutBtnState);

                this.SetUpMenuBtn(aboutBtn, GLTFViewer.ICONABOUT, GLTFViewer.aboutHelp, null, this.AboutBtnState, GLTFViewer.ICONSEPARATION);
                this.SetUpMenuBtns(aboutMenu, aboutMenuBtns, GLTFViewer.ICONABOUTHELP, GLTFViewer.aboutMenuBtnsHelp, null, AboutMenuBtnState);

                if (!this._helpSystem && !this._helpHTML)
                    AboutMenuBtnState(0, null, GLTFViewer.MENUDISABLE);
            }

            $("<style>@media print { .AVDontPrint { display: none; } }</style>").appendTo($("head", this.document));

            //GLTFViewer.MakeUnselectable(this.viewer[0]);  // screws up markups
        }
    },
    ///////////////////////////////////////
    DrawBorder: {
        value: function () {
            //    
            //   +---+
            //   |   | 2
            //   +---+
            //     4
            if (!this.IsVisible() || this.isFull || this.viewportLayout === 1)
                return [0, 0, 0];
            // container
            var width = this.viewer.parent().width();
            var height = this.viewer.parent().height();
            if (this.viewportLayout === 2) {
                if (this.viewportNumber === 0)
                    return [2, width, height];
            } else {
                // must be layout = 4
                if (this.viewportNumber === 0)
                    return [6, width, height];
                else if (this.viewportNumber === 1)
                    return [4, width, height];
                else if (this.viewportNumber === 2)
                    return [2, width, height];
            }
            return [0, 0, 0];
        }
    },
    IsVisible: {
        value: function () {
            return GLTFViewer.GetElementVisible(this.container);
        }
    },
    SetupViewports: {
        value: function (n) {
            this.viewportLayout = n;
            if (this.controllingViewer.wantViewport) {
                switch (n) {
                    case 2:
                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport02, true);
                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport13, true);

                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport0, true);
                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport1, true);
                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport2, false);
                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport3, false);

                        this.controllingViewer.viewport02.css("width", "50%");
                        this.controllingViewer.viewport02.css("height", "100%");
                        this.controllingViewer.viewport13.css("width", "50%");
                        this.controllingViewer.viewport13.css("height", "100%");
                        this.controllingViewer.viewport13.css("left", "50%");

                        this.controllingViewer.viewport0.css("height", "100%");
                        this.controllingViewer.viewport1.css("height", "100%");
                        break;
                    case 4:
                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport02, true);
                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport13, true);

                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport0, true);
                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport1, true);
                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport2, true);
                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport3, true);

                        this.controllingViewer.viewport02.css("width", "50%");
                        this.controllingViewer.viewport02.css("height", "100%");
                        this.controllingViewer.viewport13.css("width", "50%");
                        this.controllingViewer.viewport13.css("height", "100%");
                        this.controllingViewer.viewport13.css("left", "50%");

                        this.controllingViewer.viewport0.css("height", "50%");
                        this.controllingViewer.viewport1.css("height", "50%");
                        this.controllingViewer.viewport2.css("height", "50%");
                        this.controllingViewer.viewport2.css("top", "50%");
                        this.controllingViewer.viewport3.css("height", "50%");
                        this.controllingViewer.viewport3.css("top", "50%");
                        break;
                    default:
                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport02, true);
                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport13, false);

                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport0, true);
                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport1, false);
                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport2, false);
                        GLTFViewer.SetElementVisible(this.controllingViewer.viewport3, false);

                        this.controllingViewer.viewport02.css("width", "100%");
                        this.controllingViewer.viewport02.css("height", "100%");

                        this.controllingViewer.viewport0.css("height", "100%");
                        break;
                }
            }
            this.UpdateLayout();
            this.controllingViewer.SetTitle("REFRESH");
        }
    },
    SetupFullViewport: {
        value: function (n) {
            if (this.controllingViewer.wantViewport) {
                switch (n) {
                    case 0:
                        this.controllingViewer.viewport02.css("display", "flex");
                        this.controllingViewer.viewport02.css("display", "-webkit-flex");
                        this.controllingViewer.viewport13.css("display", "none");

                        this.controllingViewer.viewport0.css("display", "flex");
                        this.controllingViewer.viewport0.css("display", "-webkit-flex");
                        this.controllingViewer.viewport1.css("display", "none");
                        this.controllingViewer.viewport2.css("display", "none");
                        this.controllingViewer.viewport3.css("display", "none");

                        this.controllingViewer.viewport02.css("width", "100%");
                        this.controllingViewer.viewport02.css("height", "100%");

                        this.controllingViewer.viewport0.css("height", "100%");
                        break;
                    case 1:
                        this.controllingViewer.viewport02.css("display", "none");
                        this.controllingViewer.viewport13.css("display", "flex");
                        this.controllingViewer.viewport13.css("display", "-webkit-flex");

                        this.controllingViewer.viewport0.css("display", "none");
                        this.controllingViewer.viewport1.css("display", "flex");
                        this.controllingViewer.viewport1.css("display", "-webkit-flex");
                        this.controllingViewer.viewport2.css("display", "none");
                        this.controllingViewer.viewport3.css("display", "none");

                        this.controllingViewer.viewport13.css("width", "100%");
                        this.controllingViewer.viewport13.css("height", "100%");
                        this.controllingViewer.viewport13.css("left", "0");

                        this.controllingViewer.viewport1.css("height", "100%");
                        break;
                    case 2:
                        this.controllingViewer.viewport02.css("display", "flex");
                        this.controllingViewer.viewport02.css("display", "-webkit-flex");
                        this.controllingViewer.viewport13.css("display", "none");

                        this.controllingViewer.viewport0.css("display", "none");
                        this.controllingViewer.viewport1.css("display", "none");
                        this.controllingViewer.viewport2.css("display", "flex");
                        this.controllingViewer.viewport2.css("display", "-webkit-flex");
                        this.controllingViewer.viewport3.css("display", "none");

                        this.controllingViewer.viewport02.css("width", "100%");
                        this.controllingViewer.viewport02.css("height", "100%");

                        this.controllingViewer.viewport2.css("height", "100%");
                        this.controllingViewer.viewport2.css("top", "0");
                        break;
                    case 3:
                        this.controllingViewer.viewport02.css("display", "none");
                        this.controllingViewer.viewport13.css("display", "flex");
                        this.controllingViewer.viewport13.css("display", "-webkit-flex");

                        this.controllingViewer.viewport0.css("display", "none");
                        this.controllingViewer.viewport1.css("display", "none");
                        this.controllingViewer.viewport2.css("display", "none");
                        this.controllingViewer.viewport3.css("display", "flex");
                        this.controllingViewer.viewport3.css("display", "-webkit-flex");

                        this.controllingViewer.viewport13.css("width", "100%");
                        this.controllingViewer.viewport13.css("height", "100%");
                        this.controllingViewer.viewport13.css("left", "0");

                        this.controllingViewer.viewport3.css("height", "100%");
                        this.controllingViewer.viewport3.css("top", "0");
                        break;
                }
            }
            this.UpdateLayout();
            this.controllingViewer.SetTitle("REFRESH");
        }
    },
    CloseContextMenus: {
        value: function () {
            if (this.fileManager)
                this.fileManager.CloseContextMenus();
            for (var i = 0; i < 4; ++i) {
                var viewer = this.GetViewerByNumber(i);
                if (GLTFViewer.Utils.IsNull(viewer))
                    break;
                if (viewer.contextMenuContainer)
                    viewer.contextMenuContainer.Show(false);
                if (viewer.contextMenuMarkup)
                    viewer.contextMenuMarkup.Show(false);
                // not sure why this was added to fix DE139593
                //if (viewer.scene)
                //    viewer.scene.MarkupEsc();
            }
        }
    },
    ///////////////////////////////////////
    BuildColorPickerPanel: {
        value: function () {
            var sin30 = 0.5;
            var cos30 = 0.8660254;

            function GenerateHexCoords(x, y, r, gx, color) {
                var c = "rgba(" + color.r + "," + color.g + "," + color.b + ", " + color.a / 255 + ")";

                var _x1 = Math.round(x - cos30 * r);
                var _x2 = Math.round(x);
                var _x3 = Math.round(x + cos30 * r);

                var _y1 = Math.round(y - r);
                var _y2 = Math.round(y - sin30 * r);
                var _y3 = Math.round(y + sin30 * r);
                var _y4 = Math.round(y + r);

                var coords = "";
                coords += _x3 + ',' + _y2;
                coords += ',' + _x2 + ',' + _y1;
                coords += ',' + _x1 + ',' + _y2;
                coords += ',' + _x1 + ',' + _y3;
                coords += ',' + _x2 + ',' + _y4;
                coords += ',' + _x3 + ',' + _y3;

                if (color.a === 0) {
                    gx.strokeStyle = "rgba(0, 0, 0, 1)";
                    gx.lineWidth = 1;
                } else {
                    gx.fillStyle = c;
                    gx.lineWidth = 0;
                }


                gx.beginPath();
                gx.moveTo(_x3, _y2);
                gx.lineTo(_x2, _y1);
                gx.lineTo(_x1, _y2);
                gx.lineTo(_x1, _y3);
                gx.lineTo(_x2, _y4);
                gx.lineTo(_x3, _y3);
                if (color.a === 0) {
                    gx.closePath();
                    gx.stroke();
                } else
                    gx.fill();

                return coords;
            }
            var HEXRADIUS = 7;
            var PANELLAYERS = 6;

            var width = Math.round((2 * PANELLAYERS + 1) * 2 * cos30 * HEXRADIUS);
            var height = Math.round((3 * PANELLAYERS + 2) * 2 * sin30 * HEXRADIUS);
            var _panel = $("<div style='display:block;margin-left:-" + ((width - GLTFViewer.ICONSIZE) / 2) + "px;width:" + width + "px;height:" + height + "px;background:transparent;'></div>");

            _panel.append("<map name='imgmap'></map>");
            var _map = $("map", _panel).last();
            _panel.append("<canvas style='position:absolute:top:0;left:0;width:" + width + "px;height:" + height + "px;background:transparent;'></canvas>");
            var canvas = $("canvas", _panel).last();
            canvas[0].width = canvas.width();
            canvas[0].height = canvas.height();
            _panel.__canvas__ = canvas;
            var gx = canvas[0].getContext('2d');
            gx.clearRect(0, 0, width, height);

            var hsl = new GLTFViewer.Utils.HSL(0, 1, 0, 1);
            var x0 = width / 2;
            var y0 = height / 2;
            var lMax = PANELLAYERS * 2 * cos30 * HEXRADIUS;

            function AreaClick(area, e) {
                e.preventDefault();
                e.stopPropagation();
                if (_panel.__callback__)
                    _panel.__callback__(area.__color__);
            }

            // layer 0
            var color = new GLTFViewer.Utils.RGBA(255, 255, 255, 255);
            var coords = GenerateHexCoords(x0, y0, HEXRADIUS, gx, color);
            _map.append("<area style='cursor:pointer;' shape='poly' coords='" + coords + "'></area>");
            var _area = $("area", _map).last();
            _area.__color__ = color;
            _area.click(AreaClick.bind(this, _area));

            // layer 1...
            for (var layer = 1; layer <= PANELLAYERS; ++layer) {
                var _x = x0 + layer * 2 * cos30 * HEXRADIUS;
                var _y = y0;
                for (var i = 0; i < 6 * layer; ++i) {
                    var dx = _x - x0;
                    var dy = _y - y0;
                    var L = Math.abs((lMax - Math.sqrt(dx * dx + dy * dy)) / lMax);
                    if (L < 0.5)
                        L = Math.sqrt(2 * L) / 2;
                    hsl.l = L;
                    var H = Math.atan2(dy, dx);
                    if (H < 0)
                        H += 2 * Math.PI;
                    hsl.h = H / (2 * Math.PI);
                    color = GLTFViewer.Utils.RGBA.CreateFromHSL(hsl);
                    if (layer === PANELLAYERS && (i % (2 * layer)) === 0)
                        color.a = 0;
                    coords = GenerateHexCoords(_x, _y, HEXRADIUS, gx, color);
                    _map.append("<area style='cursor:pointer;' shape='poly' coords='" + coords + "'></area>");
                    var _area = $("area", _map).last();
                    _area.__color__ = color;
                    _area.click(AreaClick.bind(this, _area));

                    switch (Math.floor(i / layer)) {
                        case 0:
                            _x -= cos30 * HEXRADIUS;
                            _y -= 3 * sin30 * HEXRADIUS;
                            break;
                        case 1:
                            _x -= 2 * cos30 * HEXRADIUS;
                            break;
                        case 2:
                            _x -= cos30 * HEXRADIUS;
                            _y += 3 * sin30 * HEXRADIUS;
                            break;
                        case 3:
                            _x += cos30 * HEXRADIUS;
                            _y += 3 * sin30 * HEXRADIUS;
                            break;
                        case 4:
                            _x += 2 * cos30 * HEXRADIUS;
                            break;
                        case 5:
                            _x += cos30 * HEXRADIUS;
                            _y -= 3 * sin30 * HEXRADIUS;
                            break;
                    }
                }
            }

            _panel.append("<img width=" + width + " height=" + height + " usemap='#imgmap'></img>");
            var img = $("img", _panel).last();
            img[0].src = canvas[0].toDataURL();
            canvas.remove();

            return _panel;
        }
    },
    AttachColorPickerPanel: {
        value: function (parent, callback) {
            this.colorPickerPanel.detach();
            parent.append(this.colorPickerPanel);

            this.colorPickerPanel.__callback__ = callback;
        }
    },
    //////////////////////////////////
    AnyAnnimationRunning: {
        value: function () {
            if (this.controllingViewer && this.controllingViewer.scene && !this.controllingViewer.scene.AnimationStopped())
                return true;
            if (this.controllingViewer.viewer1 && this.controllingViewer.viewer1.scene && !this.controllingViewer.viewer1.scene.AnimationStopped())
                return true;
            if (this.controllingViewer.viewer2 && this.controllingViewer.viewer2.scene && !this.controllingViewer.viewer2.scene.AnimationStopped())
                return true;
            if (this.controllingViewer.viewer3 && this.controllingViewer.viewer3.scene && !this.controllingViewer.viewer3.scene.AnimationStopped())
                return true;
            return false;
        }
    },
    ShowSceneAnimation: {
        value: function (show) {
            if (GLTFViewer.Utils.IsNull(this.animationDialog) || GLTFViewer.Utils.IsNull(this.scene))
                return;
            if (!show || !this.scene || !this.scene.HasAnimation() || this.NumMultiFiles() > 1) {
                this.scene.AnimationStop();
                if (GLTFViewer.GetElementVisible(this.animationDialog.controls)) {
                    this.animationDialog.controls.css("display", "none");
                    this.UpdateLayout();
                }
            } else {
                this.animationDialog.minTime = this.scene.AnimationMinTime();
                this.animationDialog.maxTime = this.scene.AnimationMaxTime();
                GLTFViewer.SetElementCheck(this.animationDialog.loopButton, this.scene.AnimationLoop);
                if (!GLTFViewer.GetElementVisible(this.animationDialog.controls)) {
                    this.animationDialog.controls.css("display", "flex");
                    this.animationDialog.controls.css("display", "-webkit-flex");
                    this.UpdateLayout();
                }
            }
        }
    },
    SetAnimationSlider: {
        value: function (time, updateSlider) {
            if (GLTFViewer.Utils.IsNull(this.animationDialog))
                return;
            this.CloseContextMenus();
            // sets text label and updates slider
            var t = parseInt(time * 10) / 10;
            this.animationDialog.label.text(t.toFixed(1) + "s");
            if (GLTFViewer.Utils.IsNull(updateSlider) || updateSlider) {
                var f = GLTFViewer.Utils.IsNull(this.animationDialog.minTime) ? 0 : this.animationDialog.max * (time - this.animationDialog.minTime) / (this.animationDialog.maxTime - this.animationDialog.minTime);
                this.animationDialog.slider.val(f);
                this.animationDialog.slider.toggle().toggle();
            }
        }
    },
    SetAnimationMinMaxSpeed: {
        value: function (minTime, maxTime) {
            if (GLTFViewer.Utils.IsNull(this.animationDialog) || GLTFViewer.Utils.IsNull(this.scene) || maxTime < minTime || maxTime === minTime)
                return;
            // sets range and resets slider
            var range = maxTime - minTime;
            if (range === 0)
                return;
            var mx = (range > 5) ? 5 : range;
            var mn = mx / 25;
            var mxl = parseInt(Math.ceil(Math.log(mx) / Math.LN10 * 1000)) / 1000;
            var mnl = parseInt(Math.floor(Math.log(mn) / Math.LN10 * 1000)) / 1000;
            this.animationDialog.speed.prop("min", mnl);
            this.animationDialog.speed.prop("max", mxl);

            if (mxl < 0) {
                var speed = Math.pow(10, mxl);
                var t = parseInt(speed * 100 + 0.5) / 100;
                this.animationDialog.speedLabel.text(t.toFixed(2) + "X");
                this.animationDialog.speed.val(mxl);
                this.scene.AnimationSpeed(speed);
            } else {
                this.animationDialog.speedLabel.text("1.00X");
                this.animationDialog.speed.val(0);
                this.scene.AnimationSpeed(1);
            }
            this.animationDialog.speed.toggle().toggle();
        }
    },
    BuildAnimationDialog: {
        value: function (container) {
            function ButtonClickFunc(name, button, button1, button2) {
                button.hover(function () {
                    button.css('border-color', GLTFViewer.HOVERCOLOR);
                    button.css('cursor', 'pointer');
                }, function () {
                    button.css('border-color', GLTFViewer.BORDERCOLOR);
                    button.css('cursor', '');
                });
                return (function (e) {
                    this.CloseContextMenus();
                    e.stopPropagation();
                    if (name === "PLAY") {
                        this.scene.AnimationPlay();
                        button.css("display", "none");
                        button1.css("display", "inline");
                    } else if (name === "PAUSE") {
                        this.scene.AnimationPause();
                        button.css("display", "none");
                        button1.css("display", "inline");
                    } else if (name === "STOP") {
                        this.scene.AnimationStop();
                        button1.css("display", "none");
                        button2.css("display", "inline");
                    } else if (name === "LOOP") {
                        var loop = !this.scene.AnimationLoop;
                        this.scene.AnimationLoop = loop;
                        GLTFViewer.SetElementCheck(button, loop);
                    }
                }).bind(this);
            }
            function SliderChange(dialog, elem, e) {
                this.CloseContextMenus();
                if (this.scene) {
                    var time = elem.val() * (dialog.maxTime - dialog.minTime) / dialog.max + dialog.minTime;
                    setTimeout(this.scene.AnimationPlayOneFrame(time, false), 0);
                }
            }
            function SpeedChange(dialog, elem) {
                this.CloseContextMenus();
                if (this.scene) {
                    var speed = Math.pow(10, elem.val());
                    var t = parseInt(speed * 100 + 0.5) / 100;
                    dialog.speedLabel.text(t.toFixed(2) + "X");
                    setTimeout(this.scene.AnimationSpeed(speed), 0);
                }
            }

            var animation = {};

            var MaxRange = 1000;
            var Margin = 5;
            var ButtonSize = 32;
            var BallSize = 16;
            var SpeedBallSize = 12;
            var Height = ButtonSize + 2 * Margin;

            container.append("<div style='-webkit-print-color-adjust:exact;width:100%;height:" + Height + "px;background:linear-gradient(#34485D,#283849);display:none;flex-direction:row;-webkit-flex-direction:row;'></div>");
            animation.controls = $("div", container).last();

            // buttons
            animation.controls.append("<div style='left:0;background:transparent;width:" + (ButtonSize + Margin) + "px;'></div>");
            var buttonContainer00 = $("div", animation.controls).last();
            buttonContainer00.append("<button id='loopButton' title='Loop' type='button' style='margin:" + Margin + "px;padding:0;width:" + ButtonSize + "px;height:" + ButtonSize + "px;position:relative;border:1px solid " + GLTFViewer.BORDERCOLOR + ";border-radius:16px;'></button>");
            animation.loopButton = $("button", buttonContainer00).last();
            animation.loopButton.css("background", "url('" + this.imageDir + "Icons.png') -0px -" + GLTFViewer.ICONSIZE * GLTFViewer.ICONLOOP + "px");
            animation.loopButton.css("background-color", GLTFViewer.BUTTONCOLOR);
            // for chrome
            $("<style>button[id='loopButton']:focus {outline:none;}</style>").appendTo($("head", this.document));

            animation.controls.append("<div style='left:0;background:transparent;width:" + (ButtonSize + Margin) + "px;'></div>");
            var buttonContainer0 = $("div", animation.controls).last();
            buttonContainer0.append("<button id='stopButton' title='Stop' type='button' style='margin:" + Margin + "px;padding:0;width:" + ButtonSize + "px;height:" + ButtonSize + "px;position:relative;border:1px solid " + GLTFViewer.BORDERCOLOR + ";border-radius:16px;'></button>");
            animation.stopButton = $("button", buttonContainer0).last();
            animation.stopButton.css("background", "url('" + this.imageDir + "Icons.png') -0px -" + GLTFViewer.ICONSIZE * GLTFViewer.ICONSTOP + "px");
            animation.stopButton.css("background-color", GLTFViewer.BUTTONCOLOR);
            // for chrome
            $("<style>button[id='stopButton']:focus {outline:none;}</style>").appendTo($("head", this.document));

            animation.controls.append("<div style='background:transparent;width:" + Height + "px;'></div>");
            var buttonContainer = $("div", animation.controls).last();
            buttonContainer.append("<button id='playButton' title='Play' type='button' style='margin:" + Margin + "px;padding:0;width:" + ButtonSize + "px;height:" + ButtonSize + "px;position:relative;border:1px solid " + GLTFViewer.BORDERCOLOR + ";border-radius:16px;'></button>");
            animation.playButton = $("button", buttonContainer).last();
            animation.playButton.css("background", "url('" + this.imageDir + "Icons.png') -0px -" + GLTFViewer.ICONSIZE * GLTFViewer.ICONPLAY + "px");
            animation.playButton.css("background-color", GLTFViewer.BUTTONCOLOR);
            // for chrome
            $("<style>button[id='playButton']:focus {outline:none;}</style>").appendTo($("head", this.document));

            buttonContainer.append("<button id='pauseButton' title='Pause' type='button' style='margin:" + Margin + "px;padding:0;width:" + ButtonSize + "px;height:" + ButtonSize + "px;position:relative;border:1px solid " + GLTFViewer.BORDERCOLOR + ";border-radius:16px;display:none;'></button>");
            animation.pauseButton = $("button", buttonContainer).last();
            animation.pauseButton.css("background", "url('" + this.imageDir + "Icons.png') -0px -" + GLTFViewer.ICONSIZE * GLTFViewer.ICONPAUSE + "px");
            animation.pauseButton.css("background-color", GLTFViewer.BUTTONCOLOR);
            // for chrome
            $("<style>button[id='pauseButton']:focus {outline:none;}</style>").appendTo($("head", this.document));

            animation.playButton.click(ButtonClickFunc.call(this, "PLAY", animation.playButton, animation.pauseButton));
            animation.pauseButton.click(ButtonClickFunc.call(this, "PAUSE", animation.pauseButton, animation.playButton));
            animation.stopButton.click(ButtonClickFunc.call(this, "STOP", animation.stopButton, animation.pauseButton, animation.playButton));
            animation.loopButton.click(ButtonClickFunc.call(this, "LOOP", animation.loopButton));

            ///////////////////////////
            // speed
            animation.controls.append("<div style='background:transparent;text-align:center;'></div>");
            var sliderContainer = $("div", animation.controls).last();
            var heightForLine = (Height - 2 * Margin - SpeedBallSize) / 2;
            sliderContainer.append("<label style='display:block;border:0;padding:0;margin:0;margin-top:2px;color:white;text-align:center;height:" + (heightForLine - 1) + "px;line-height:10px;font-size:10px;font-family:Segoe UI,Arial,Helvetica,sans-serif;'></label>");
            animation.speedLabel = $("label", sliderContainer).last();
            animation.speedLabel.text("1");

            animation.speed = GLTFViewer.Utils.BuildSlider(this, sliderContainer, "slider1", 100, SpeedBallSize, Margin - 1, SpeedBallSize, 3, -0.7, 0.7, 0.001);
            animation.speed.css("display", "block"); // it defaults to inline and we want it block

            sliderContainer.append("<p style='border:0;padding:0;margin:0;margin-top:-3px;color:white;height:" + heightForLine + "px;line-height:10px;font-size:10px;font-family:Segoe UI,Arial,Helvetica,sans-serif;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:-moz-none;-ms-user-select:none;-o-user-select:none;user-select:none;cursor:default;'>Speed</p>");
            animation.speed.on("input change", SpeedChange.bind(this, animation, animation.speed));
            //
            ///////////////////////////

            ///////////////////////////
            // slider
            animation.controls.append("<div style='background:transparent;flex:1;-webkit-flex:1;display:flex;display:-webkit-flex;flex-direction:row;-webkit-flex-direction:row;'></div>");
            sliderContainer = $("div", animation.controls).last();

            animation.slider = GLTFViewer.Utils.BuildSlider(this, sliderContainer, "slider2", null, ButtonSize, Margin, BallSize, 5, 0, MaxRange, 1);

            animation.max = MaxRange;
            animation.minTime = 0;
            animation.maxTime = 1;
            animation.slider.on("input change", SliderChange.bind(this, animation, animation.slider));
            //
            ///////////////////////////

            // label
            sliderContainer.append("<label style='padding:0;margin:0;border:0;display:inline;background:transparent;color:white;height:" + BallSize + "px;margin:" + Margin + "px;margin-top:13px;line-height:" + BallSize + "px;width:40px;font-size:14px;font-family:Segoe UI,Arial,Helvetica,sans-serif;'></label>");
            animation.label = $("label", sliderContainer).last();
            animation.label.text("0.0s");

            return animation;
        }
    },
    ///////////////////////////////////////
    NumMultiFiles: {
        value: function () {
            var fileObj = this.fileManager.ActiveFileObj(this);
            if (GLTFViewer.Utils.IsNull(fileObj))
                return 0;
            return fileObj.NumMultiFiles();
        }
    },
    GetMultiFiles: {
        value: function () {
            var fileObj = this.fileManager.ActiveFileObj(this);
            if (GLTFViewer.Utils.IsNull(fileObj))
                return [];
            return fileObj.GetMultiFiles();
        }
    },
    GetLoadedIdx: {
        value: function () {
            var multiFiles = this.GetMultiFiles();
            if (multiFiles.length <= 0)
                return -1;
            return multiFiles.indexOf(this.fileManager.ActiveFileObj(this));
        }
    },
    ShowMultiFile: {
        value: function (show) {
            if (GLTFViewer.Utils.IsNull(this.multiFileDialog))
                return;
            var n = this.NumMultiFiles();
            if (n > 1 && show) {
                if (GLTFViewer.GetElementVisible(this.multiFileDialog.controls))
                    return;
                this.multiFileDialog.controls.css("display", "flex");
                this.multiFileDialog.controls.css("display", "-webkit-flex");
            } else {
                if (!GLTFViewer.GetElementVisible(this.multiFileDialog.controls))
                    return;
                this.multiFileDialog.controls.css("display", "none");
            }
            this.UpdateLayout();
        }
    },
    SetMultiFileSlider: {
        value: function (idx, updateSlider) {
            if (GLTFViewer.Utils.IsNull(idx)) {
                idx = this.GetLoadedIdx();
                if (idx < 0) {
                    this.ShowMultiFile(false);
                    return;
                }
            } else
                idx = parseInt(idx);
            var n = this.NumMultiFiles();
            if (n < 2 || GLTFViewer.Utils.IsNull(this.multiFileDialog) || idx < 0 || idx >= n) {
                this.ShowMultiFile(false);
                return;
            }
            // sets text label and updates slider
            this.multiFileDialog.val = idx;
            var fileObj = this.GetMultiFiles()[idx];
            var help = fileObj._containerFile ? (fileObj._path + " : " + fileObj._name) : fileObj._name;
            this.multiFileDialog.label.prop("title", help);
            var fileName = fileObj._name;
            var label = (idx + 1) + "/" + n + " " + fileName;
            var gx = this.overlay[0].getContext('2d');
            gx.font = "14px sans-serif";
            for (var i = fileName.length - 1; i >= 0; --i) {
                var w = GLTFViewer.Utils.TextWidth(gx, label);
                if (w < this.multiFileDialog.labelWidth)
                    break;
                label = (idx + 1) + "/" + n + " " + fileName.substring(0, i) + "...";
            }
            this.multiFileDialog.label.text(label);

            if (GLTFViewer.Utils.IsNull(updateSlider) || updateSlider) {
                this.ShowMultiFile(true);
                this.multiFileDialog.max = n - 1;
                this.multiFileDialog.slider.prop("max", this.multiFileDialog.max);
                this.multiFileDialog.loaded = idx;
                this.multiFileDialog.slider.val(idx);
                this.multiFileDialog.slider.toggle().toggle();
            }
        }
    },
    LoadMultiFileFile: {
        value: function (idx) {
            function Callback(idx, state) {
                if (state)
                    this.SetMultiFileSlider(idx);
            }
            idx = parseInt(idx);
            if (idx > this.multiFileDialog.max)
                idx = this.multiFileDialog.max;
            else if (idx < 0)
                idx = 0;
            if (idx !== this.multiFileDialog.loaded)
                this.SelectFile(this.GetMultiFiles()[idx], Callback.bind(this, idx), GLTFViewer.LT_UPDATE);
        }
    },
    BuildMultiFileDialog: {
        value: function (container) {
            function ButtonClickFunc(name, button) {
                button.hover(function () {
                    button.css('border-color', GLTFViewer.HOVERCOLOR);
                    button.css('cursor', 'pointer');
                }, function () {
                    button.css('border-color', GLTFViewer.BORDERCOLOR);
                    button.css('cursor', '');
                });
                return (function (e) {
                    this.CloseContextMenus();
                    e.stopPropagation();
                    if (name === "FF")
                        this.LoadMultiFileFile(this.multiFileDialog.val + 1);
                    else if (name === "REW")
                        this.LoadMultiFileFile(this.multiFileDialog.val - 1);
                }).bind(this);
            }
            function SliderNameChange(dialog, elem) {
                if (this.scene)
                    this.SetMultiFileSlider(elem.val(), false);
            }
            function SliderChange(dialog, elem) {
                if (this.scene)
                    this.LoadMultiFileFile(elem.val());
            }

            var multiFile = {};

            var Margin = 5;
            var ButtonSize = 32;
            var BallSize = 16;
            var Height = ButtonSize + 2 * Margin;

            container.append("<div style='width:100%;height:" + Height + "px;background:linear-gradient(#34485D,#283849);display:none;flex-direction:row;-webkit-flex-direction:row;'></div>");
            multiFile.controls = $("div", container).last();

            // buttons
            multiFile.controls.append("<div style='left:0;background:transparent;width:" + (ButtonSize + Margin) + "px;'></div>");
            var buttonContainerRew = $("div", multiFile.controls).last();
            //
            buttonContainerRew.append("<button id='mfrewButton' title='Back' type='button' style='margin:" + Margin + "px;padding:0;width:" + ButtonSize + "px;height:" + ButtonSize + "px;position:relative;border:1px solid " + GLTFViewer.BORDERCOLOR + ";border-radius:16px;'></button>");
            multiFile.rewButton = $("button", buttonContainerRew).last();
            multiFile.rewButton.css("background", "url('" + this.imageDir + "Icons.png') -0px -" + GLTFViewer.ICONSIZE * GLTFViewer.ICONREW + "px");
            multiFile.rewButton.css("background-color", GLTFViewer.BUTTONCOLOR);
            // for chrome
            $("<style>button[id='mfrewButton']:focus {outline:none;}</style>").appendTo("head");

            multiFile.controls.append("<div style='left:0;background:transparent;width:" + (ButtonSize + Margin) + "px;'></div>");
            var buttonContainerFF = $("div", multiFile.controls).last();
            //
            buttonContainerFF.append("<button id='mfffButton' title='Forward' type='button' style='margin:" + Margin + "px;padding:0;width:" + ButtonSize + "px;height:" + ButtonSize + "px;position:relative;border:1px solid " + GLTFViewer.BORDERCOLOR + ";border-radius:16px;'></button>");
            multiFile.ffButton = $("button", buttonContainerFF).last();
            multiFile.ffButton.css("background", "url('" + this.imageDir + "Icons.png') -0px -" + GLTFViewer.ICONSIZE * GLTFViewer.ICONFF + "px");
            multiFile.ffButton.css("background-color", GLTFViewer.BUTTONCOLOR);
            // for chrome
            $("<style>button[id='mfffButton']:focus {outline:none;}</style>").appendTo("head");

            multiFile.rewButton.click(ButtonClickFunc.call(this, "REW", multiFile.rewButton));
            multiFile.ffButton.click(ButtonClickFunc.call(this, "FF", multiFile.ffButton));

            // slider
            multiFile.controls.append("<div style='background:transparent;flex:1;-webkit-flex:1;display:flex;display:-webkit-flex;flex-direction:row;-webkit-flex-direction:row;'></div>");
            var sliderContainer = $("div", multiFile.controls).last();

            multiFile.slider = GLTFViewer.Utils.BuildSlider(this, sliderContainer, "slider3", null, ButtonSize, Margin, BallSize, 5, 0, 1, 1);

            multiFile.slider.on("input change", SliderNameChange.bind(this, multiFile, multiFile.slider));
            multiFile.slider.on("mouseup", SliderChange.bind(this, multiFile, multiFile.slider));

            // label
            multiFile.labelWidth = 120;
            //sliderContainer.append("<label style='padding:0;margin:0;border:0;display:inline;background:transparent;color:white;height:" + BallSize + "px;margin:" + Margin + "px;margin-top:13px;line-height:" + BallSize + "px;width:" + multiFile.labelWidth + "px;font-size:14px;font-family:Segoe UI,Arial,Helvetica,sans-serif;'></label>");
            //multiFile.label = $("label", sliderContainer).last();

            sliderContainer.append("<div style='padding:0;margin:0;border:0;display:inline;background:transparent;height:" + BallSize + "px;margin:" + Margin + "px;margin-top:13px;width:" + multiFile.labelWidth + "px;'></div>");
            var div = $("div", sliderContainer).last();
            div.append("<label style='padding:0;margin:0;border:0;margin:0;background:transparent;color:white;line-height:" + BallSize + "px;font-size:14px;font-family:Segoe UI,Arial,Helvetica,sans-serif;white-space:nowrap;'></label>");
            multiFile.label = $("label", div).last();

            multiFile.label.text("<unknown>");

            return multiFile;
        }
    },
    ///////////////////////////////////////
    SetExplodeSlider: {
        value: function (val) {
            if (GLTFViewer.Utils.IsNull(this.explodePanel))
                return;
            this.explodePanel.val(val);
            this.explodePanel.toggle().toggle();
        }
    },
    BuildExplodePanel: {
        value: function () {
            if (!this.wantExplode)
                return;

            function SpeedChange(elem) {
                if (this.scene) {
                    var val = elem.val() * 1;
                    this.scene.SetExplosion(val, false);
                }
            }

            var Margin = 5;
            var SpeedBallSize = 12;

            this.explodeMenu.append("<div style='background:linear-gradient(#34485D,#283849);'></div>");
            var sliderContainer = $("div", this.explodeMenu).last();

            var speedSlider = GLTFViewer.Utils.BuildSlider(this, sliderContainer, "slider4", 100, 16, Margin, SpeedBallSize, 3, 0, 2, 0.1);

            speedSlider.on("input change", SpeedChange.bind(this, speedSlider));
            speedSlider.on("click", (function (e) {
                // stop click from going to explodeBtn
                e.stopPropagation();
            }).bind(this));

            return speedSlider;
        }
    },

    ///////////////////////////////////////
    BuildAboutDialog: {
        value: function (container) {
            var about = {};

            var AboutWidth = 418;
            var AboutHeight = 272;
            var CloseImageHeight = 15;
            var CloseButtonWidth = 70;
            var CloseButtonHeight = 19;
            var BottomHeight = 60;

            var hasGLTFViewer_About = typeof GLTFViewer_About !== 'undefined' && GLTFViewer_About !== null;
            var buildDate = hasGLTFViewer_About ? GLTFViewer_About.build_date : "unknown";
            var release = hasGLTFViewer_About ? GLTFViewer_About.extern_release_id : "Release unknown";
            var buildYear = "";
            if (hasGLTFViewer_About) {
                var search = /(20[0-9][0-9])/;
                var match = search.exec(buildDate);
                if (match && match.length === 2)
                    buildYear = match[1] + " ";
            }

            about.box = GLTFViewer.Utils.CreateModalShield();
            about.box.append("<div style='width:" + (AboutWidth - 2) + "px;height:" + (AboutHeight - 2) + "px;position:relative;border:1px solid " + GLTFViewer.BORDERCOLOR + ";margin:10% auto;background:white;'></div>");
            about.dialog = $("div", about.box).last();
            about.dialog.append("<div style='width:100%;height:" + (GLTFViewer.TITLEHEIGHT - 1) + "px;position:relative;border-bottom:1px solid " + GLTFViewer.BORDERCOLOR + ";background:linear-gradient(#34485D,#283849);'></div>");
            var titleBar = $("div", about.dialog).last();
            titleBar.append("<p style='position:absolute;left:15px;top:-6px;color:white;font-size:12px;font-weight:600;font-family:Segoe UI,Arial,Helvetica,sans-serif;'>About ANSYS Viewer</p>");
            titleBar.append("<img src='" + this.imageDir + "close.png' title='Close' style='position:absolute;right:10px;top:" + ((GLTFViewer.TITLEHEIGHT - 1 - CloseImageHeight) / 2) + "px;background:transparent;border-radius:" + ((CloseImageHeight + 1) / 2) + "px;'></img>");
            var closeImg = $("img", titleBar).last();
            closeImg.hover(function () {
                closeImg.css('background', GLTFViewer.HOVERCOLOR);
                closeImg.css('cursor', 'pointer');
            }, function () {
                closeImg.css('background', 'transparent');
                closeImg.css('cursor', '');
            });
            function ClickFunc(box) {
                return function (e) {
                    e.stopPropagation();
                    box.css("display", "none");
                };
            }
            closeImg.click(ClickFunc(about.box));

            about.dialog.append("<div style='width:100%;height:" + (AboutHeight - GLTFViewer.TITLEHEIGHT - BottomHeight - 3 - 12) + "px;position:relative;border-bottom:1px solid " + GLTFViewer.BORDERCOLOR + ";background:white;'></div>");
            about.content = $("div", about.dialog).last();

            about.content.append("<p style='padding:5px 8px 8px 8px;font-size:12px;font-family:Segoe UI,Arial,Helvetica,sans-serif;'>ANSYS<sup>&reg;</sup> Viewer<br>" + release + "<br>Build date: " + buildDate + " <br><br>&copy; 2015-" + buildYear + " ANSYS, Inc. All rights reserved. Unauthorized use, distribution or duplication is prohibited. This product is subject to U.S. laws governing export and re-export. For full Legal Notice, see documentation.<br><br></p>");
            var p = $("p", about.content).last();
            if (this._helpSystem) {
                p.append("<a href='javascript:void(0);' target='_blank'>Legal Notices</a>");
                var a = $("a", p).last();
                a.click((function (e) {
                    e.stopPropagation();
                    if (this._helpSystem)
                        this._helpSystem.Open("HLP:file:ans_viewer/ans_viewer_legal.html");
                }).bind(this));
            } else if (this._legalHTML)
                p.append("<a href='" + this._legalHTML + "' target='_blank'>Legal Notices</a>");

            about.dialog.append("<button type='button' style='width:" + CloseButtonWidth + "px;height:" + CloseButtonHeight + "px;position:relative;background:" + GLTFViewer.BUTTONCOLOR + ";color:black;margin:" + ((BottomHeight - CloseButtonHeight) / 2) + "px " + ((AboutWidth - 2 - CloseButtonWidth) / 2) + "px;border:1px solid " + GLTFViewer.BORDERCOLOR + ";border-radius:5px;'>OK</button>");
            var closeButton = $("button", about.dialog).last();
            closeButton.hover(function () {
                closeButton.css('border-color', GLTFViewer.HOVERCOLOR);
                closeButton.css('cursor', 'pointer');
            }, function () {
                closeButton.css('border-color', GLTFViewer.BORDERCOLOR);
                closeButton.css('cursor', '');
            });
            closeButton.click(ClickFunc(about.box));

            $(window).resize((function (about) {
                if (GLTFViewer.GetElementVisible(about.box))
                    this.ShowAboutDialog(true);
            }).bind(this, about));

            about.box[0].addEventListener('keydown', (function (about, e) {
                if (e.keyCode === 27)
                    about.box.css("display", "none");
            }).bind(this, about), false);

            GLTFViewer.MakeUnselectable(about.box[0]);

            return about;
        }
    },
    ShowAboutDialog: {
        value: function (show) {
            if (GLTFViewer.Utils.IsNull(show) || show) {
                this.aboutDialog.box.css("display", "inline");
                this.aboutDialog.box.css("width", GLTFViewer.Utils.GetBrowserWidth() + "px");
                this.aboutDialog.box.css("height", GLTFViewer.Utils.GetBrowserHeight() + "px");
                var left = (this.body.width() - this.aboutDialog.dialog.width()) / 2;
                var top = (this.body.height() - this.aboutDialog.dialog.height()) / 2;
                this.aboutDialog.dialog.css("margin-top", top + "px");
                this.aboutDialog.dialog.css("margin-left", left + "px");
                this.aboutDialog.box.focus();
            } else
                this.aboutDialog.box.css("display", "none");
        }
    },
    ShowHelp: {
        value: function () {
            if (this._helpSystem)
                this._helpSystem.Open("HLP:file:ans_viewer/ans_viewer_help.html");
            else if (this._helpHTML)
                window.open(this._helpHTML);
        }
    },
    ///////////////////////////////////////
    UpdateLayout: {
        value: function () {
            if (this.controllingViewer.IsVisible())
                this.controllingViewer._UpdateLayout();
            if (this.viewportLayout !== 1) {
                if (this.controllingViewer.viewer1 && this.controllingViewer.viewer1.IsVisible())
                    this.controllingViewer.viewer1._UpdateLayout();
                if (this.controllingViewer.viewer2 && this.controllingViewer.viewer2.IsVisible())
                    this.controllingViewer.viewer2._UpdateLayout();
                if (this.controllingViewer.viewer3 && this.controllingViewer.viewer3.IsVisible())
                    this.controllingViewer.viewer3._UpdateLayout();
            }
        }
    },
    _UpdateLayout: {
        value: function () {
            var width = 0;
            var height = 0;
            if (this.IsVisible()) {
                width = this.viewer.width();
                height = this.viewer.height();
            }
            //if ((width === this.viewerWidth && height === this.viewerHeight) || !this.c3d || !this.overlay)
            //    return;
            this.viewerWidth = width;
            this.viewerHeight = height;
            // size overlay and c3d canvas
            this.c3d[0].width = width;
            this.c3d[0].height = height;
            this.c3d[0].style.width = width + "px";
            this.c3d[0].style.height = height + "px";
            this.overlay[0].width = width;
            this.overlay[0].height = height;
            this.overlay[0].style.width = width + "px";
            this.overlay[0].style.height = height + "px";
            if (this.scene)
                this.scene.Invalidate(true);
        }
    },
    ///////////////////////////////////////
    // menu
    MenuFade: {
        value: function (fade, t, onlyIframe) {
            //return;
            var elems;
            if (!GLTFViewer.Utils.IsNull(this.iFrame) && GLTFViewer.GetElementVisible(this.iFrame)) {
                if (!this.iFrameMenu)
                    return;
                elems = $([]).add(this.iFrameMenu);
            } else if (!onlyIframe) {
                if (fade && this.popup2)
                    this.popup2.callback();
                elems = $([]).add(this.menu);
                if (this.popup1)
                    elems = elems.add(this.popup1.menu);
                // this.popup2 is included in this.popup1
                //            elems.fadeTo(t ? t : 1000, fade ? 0.2 : 1.0);
            }
            if (elems) {
                elems.stop();
                elems.fadeTo(t ? t : 0, fade ? 0.2 : 1.0);
            }
        }
    },
    ///////////////////////////////////////
    NoopBtnState: {
        value: function () {
        }
    },
    ///////////////////////////////////////
    // DOES NOT OPEN A MENU
    FullBtnState: {
        value: function (e, state) {
            if (!this.wantFull)
                return;

            switch (state) {
                case GLTFViewer.MENURESET:
                    if (this.isFull)
                        this.FullBtnState(e, GLTFViewer.MENUCLICK);
                    //this.FullBtnState(e, GLTFViewer.MENUHIDE);
                    break;
                case GLTFViewer.MENUCLICK:
                    // action to perform
                    //this.FileManagerBtnState(e, GLTFViewer.MENUCLOSE);
                    if (this.isFull) {
                        this.isFull = false;
                        this.rootContainer.detach();
                        this.rootContainer.appendTo(this.nonFullContainer);
                        //this.nonFullContainer.css("visibility", "visible");
                        this.fullContainer.css("visibility", "hidden");
                        this.body.css("overflow", this.bodyOverflow);

                        this.ViewportBtnState(e, GLTFViewer.MENUENABLE);
                        if (this.viewportNumber !== 0) {
                            this.FileManagerBtnState(e, GLTFViewer.MENUHIDE);
                            this.OptionsBtnState(e, GLTFViewer.MENUHIDE);
                            this.AboutBtnState(e, GLTFViewer.MENUHIDE);
                        }
                        this.controllingViewer.FileManagerBtnState(e, GLTFViewer.MENUSHOW);

                        this.SetupViewports(this.viewportLayout);
                    } else {
                        this.isFull = true;
                        this.rootContainer.detach();
                        this.rootContainer.appendTo(this.fullContainer);
                        //this.nonFullContainer.css("visibility", "hidden"); <- screws up about box
                        this.fullContainer.css("visibility", "visible");
                        this.bodyOverflow = this.body.css("overflow");
                        this.body.css("overflow", "hidden");

                        if (this.viewportNumber !== 0)
                            this.controllingViewer.FileManagerBtnState(e, GLTFViewer.MENUHIDE);
                        this.ViewportBtnState(e, GLTFViewer.MENUDISABLE);
                        this.FileManagerBtnState(e, GLTFViewer.MENUSHOW);
                        this.OptionsBtnState(e, GLTFViewer.MENUSHOW);
                        this.AboutBtnState(e, GLTFViewer.MENUSHOW);

                        this.SetupFullViewport(this.viewportNumber);
                    }
                    break;
                case GLTFViewer.MENUENABLE:
                    GLTFViewer.SetElementEnable(this.fullBtn, true);
                    break;
                case GLTFViewer.MENUDISABLE:
                    GLTFViewer.SetElementEnable(this.fullBtn, false);
                    break;
                case GLTFViewer.MENUSHOW:
                    GLTFViewer.SetElementVisible(this.fullBtn, true);
                    break;
                case GLTFViewer.MENUHIDE:
                    GLTFViewer.SetElementVisible(this.fullBtn, false);
                    break;
            }
        }
    },
    ///////////////////////////////////////
    // DOES NOT OPEN A MENU
    FileBtnState: {
        value: function (e, state) {
            if (!this.wantFile)
                return;

            switch (state) {
                case GLTFViewer.MENURESET:
                    this.FileBtnState(e, GLTFViewer.MENUHIDE);
                    break;
                case GLTFViewer.MENUCLICK:
                    // action to perform
                    this.inputFile._ctrlKey = e.ctrlKey;
                    this.inputFile._shiftKey = e.shiftKey;
                    this.inputFile._altKey = e.altKey;
                    this.inputFile.click();
                    break;
                case GLTFViewer.MENUSHOW:
                    GLTFViewer.SetElementVisible(this.fileBtn, true);
                    break;
                case GLTFViewer.MENUHIDE:
                    GLTFViewer.SetElementVisible(this.fileBtn, false);
                    break;
            }
        }
    },
    ///////////////////////////////////////
    // DOES NOT OPEN A MENU
    OptionsBtnState: {
        value: function (e, state) {
            if (!this.wantOptions)
                return;

            switch (state) {
                case GLTFViewer.MENURESET:
                    this.OptionsBtnState(e, GLTFViewer.MENUHIDE);
                    break;
                case GLTFViewer.MENUCLICK:
                    // action to perform
                    this.controllingViewer.Options();
                    break;
                case GLTFViewer.MENUSHOW:
                    GLTFViewer.SetElementVisible(this.optionsBtn, true);
                    break;
                case GLTFViewer.MENUHIDE:
                    GLTFViewer.SetElementVisible(this.optionsBtn, false);
                    break;
            }
        }
    },
    ///////////////////////////////////////
    // Handles click on viewportBtn which opens/closes viewportMenu
    ViewportBtnState: {
        value: function (e, state) {
            if (!this.wantViewport)
                return;

            switch (state) {
                case GLTFViewer.MENURESET:
                    this.ViewportMenuBtnState(null, e, GLTFViewer.MENURESET);
                    this.ViewportBtnState(e, GLTFViewer.MENUCLOSE);
                    break;
                case GLTFViewer.MENUCLICK:
                    if (GLTFViewer.GetElementVisible(this.viewportMenu))
                        this.ViewportBtnState(e, GLTFViewer.MENUCLOSE);
                    else
                        this.ViewportBtnState(e, GLTFViewer.MENUOPEN);
                    break;
                case GLTFViewer.MENUOPEN:
                    if (!GLTFViewer.GetElementVisible(this.viewportMenu)) {
                        if (this.popup1)
                            this.popup1.callback();
                        this.popup1 = { menu: this.viewportMenu, callback: this.ViewportBtnState.bind(this, null, GLTFViewer.MENUCLOSE) };
                        GLTFViewer.SetElementVisible(this.viewportMenu, true);
                        // action to perform
                    }
                    break;
                case GLTFViewer.MENUCLOSE:
                    if (GLTFViewer.GetElementVisible(this.viewportMenu)) {
                        if (this.popup1 && this.popup1.menu === this.viewportMenu)
                            this.popup1 = null;
                        GLTFViewer.SetElementVisible(this.viewportMenu, false);
                        // action to perform
                    }
                    break;
                case GLTFViewer.MENUENABLE:
                    GLTFViewer.SetElementEnable(this.viewportBtn, true);
                    break;
                case GLTFViewer.MENUDISABLE:
                    GLTFViewer.SetElementEnable(this.viewportBtn, false);
                    break;
                case GLTFViewer.MENUSHOW:
                    this.ViewportBtnState(e, GLTFViewer.MENURESET);
                    GLTFViewer.SetElementVisible(this.viewportBtn, true);
                    break;
                case GLTFViewer.MENUHIDE:
                    this.ViewportBtnState(e, GLTFViewer.MENURESET);
                    GLTFViewer.SetElementVisible(this.viewportBtn, false);
                    break;
            }
        }
    },
    // viewportMenu which handles click on viewportMenuBtns which opens/closes viewportMenuMenus
    ViewportMenuBtnState: {
        value: function (btn, e, state) {
            if (!this.wantViewport || !this.viewportMenuBtns)
                return;
            switch (state) {
                case GLTFViewer.MENURESET:
                    //this.SetupViewports(1);
                    break;
                case GLTFViewer.MENUCLICK:
                    if (GLTFViewer.GetElementVisible(this.viewportMenu))
                        this.ViewportBtnState(e, GLTFViewer.MENUCLOSE);
                    else
                        this.ViewportBtnState(e, GLTFViewer.MENUOPEN);
                    if (this.scene) {
                        switch (btn) {
                            case 0: // 1 Viewport
                                this.SetupViewports(1);
                                break;
                            case 1: // 2 Viewports
                                this.SetupViewports(2);
                                break;
                            case 2: // 4 Viewports
                                this.SetupViewports(4);
                                break;
                            case 3: // lock
                                this.ViewportMenuBtnState(btn, null, this.viewportLock ? GLTFViewer.MENUUNCHECK : GLTFViewer.MENUCHECK);
                                break;
                        }
                    }
                    break;
                case GLTFViewer.MENUSHOW:
                    GLTFViewer.SetElementVisible(this.viewportMenuBtns[btn], true);
                    break;
                case GLTFViewer.MENUHIDE:
                    GLTFViewer.SetElementVisible(this.viewportMenuBtns[btn], false);
                    break;
                case GLTFViewer.MENUCHECK:
                    GLTFViewer.SetElementCheck(this.viewportMenuBtns[btn], true);
                    if (btn === 3)
                        this.viewportLock = true;
                    break;
                case GLTFViewer.MENUUNCHECK:
                    GLTFViewer.SetElementCheck(this.viewportMenuBtns[btn], false);
                    if (btn === 3)
                        this.viewportLock = false;
                    break;
                case GLTFViewer.MENUUNCHECKALL:
                    this.viewportMenuBtns.forEach((function (elem, index) {
                        this.ViewportMenuBtnState(index, null, GLTFViewer.MENUUNCHECK);
                    }).bind(this));
                    break;
            }
        }
    },
    ///////////////////////////////////////
    // DOES NOT OPEN A MENU
    SaveBtnState: {
        value: function (e, state) {
            if (!this.wantSave)
                return;

            switch (state) {
                case GLTFViewer.MENURESET:
                    this.SaveBtnState(e, GLTFViewer.MENUHIDE);
                    break;
                case GLTFViewer.MENUCLICK:
                    // action to perform
                    if (this.hasNodeJS)
                        this.SaveAVZ();
                    else if (this.isServed)
                        this.PostChanges();
                    break;
                case GLTFViewer.MENUENABLE:
                    if (this.canSave)
                        GLTFViewer.SetElementEnable(this.saveBtn, true);
                    break;
                case GLTFViewer.MENUDISABLE:
                    GLTFViewer.SetElementEnable(this.saveBtn, false);
                    break;
                case GLTFViewer.MENUSHOW:
                    if (this.canSave)
                        GLTFViewer.SetElementVisible(this.saveBtn, true);
                    break;
                case GLTFViewer.MENUHIDE:
                    GLTFViewer.SetElementVisible(this.saveBtn, false);
                    break;
            }
        }
    },
    ///////////////////////////////////////
    // Handles click on FileManagerBtn which opens/closes FileManagerPanel
    FileManagerBtnState: {
        value: function (e, state) {
            switch (state) {
                case GLTFViewer.MENURESET:
                    this.FileManagerBtnState(e, GLTFViewer.MENUCLOSE);
                    break;
                case GLTFViewer.MENUCLICK:
                    if (!this.fileManager.IsPanelVisible())
                        this.FileManagerBtnState(e, GLTFViewer.MENUOPEN);
                    else
                        this.FileManagerBtnState(e, GLTFViewer.MENUCLOSE);
                    break;
                case GLTFViewer.MENUOPEN:
                    this.fileManager.ShowPanel(true);
                    GLTFViewer.SetElementVisible(this.FileManagerBtn, false);
                    // action to perform
                    break;
                case GLTFViewer.MENUCLOSE:
                    if (this.fileManager.IsPanelVisible()) {
                        this.fileManager.ShowPanel(false);
                        GLTFViewer.SetElementVisible(this.FileManagerBtn, true);
                    }
                    // action to perform
                    break;
                case GLTFViewer.MENUENABLE:
                    GLTFViewer.SetElementEnable(this.FileManagerBtn, true);
                    break;
                case GLTFViewer.MENUDISABLE:
                    GLTFViewer.SetElementEnable(this.FileManagerBtn, false);
                    break;
                case GLTFViewer.MENUSHOW:
                    //this.FileManagerBtnState(e, GLTFViewer.MENURESET);
                    if (!this.fileManager.IsPanelVisible(true))
                        GLTFViewer.SetElementVisible(this.FileManagerBtn, true);
                    break;
                case GLTFViewer.MENUHIDE:
                    //this.FileManagerBtnState(e, GLTFViewer.MENURESET);
                    GLTFViewer.SetElementVisible(this.FileManagerBtn, false);
                    break;
            }
        }
    },
    ///////////////////////////////////////
    // Handles click on zoomBtn
    ZoomBtnState: {
        value: function (e, state) {
            if (!this.wantZoom)
                return;

            switch (state) {
                case GLTFViewer.MENUCLICK:
                    // action to perform
                    if (this.scene)
                        this.scene.navigator.ZoomExtents(true);
                    break;
                case GLTFViewer.MENUSHOW:
                    GLTFViewer.SetElementVisible(this.zoomBtn, true);
                    break;
                case GLTFViewer.MENUHIDE:
                    GLTFViewer.SetElementVisible(this.zoomBtn, false);
                    break;
            }
        }
    },
    ///////////////////////////////////////
    // Handles click on selectionBtn which opens/closes selectionMenu
    SelectionBtnState: {
        value: function (e, state, val) {
            if (!this.wantSelection)
                return;

            switch (state) {
                case GLTFViewer.MENURESET:
                    this.SelectionMenuBtnState(null, e, GLTFViewer.MENURESET);
                    if (this.scene)
                        this.scene.SetSelectionMode(GLTFViewer.SELECTION_NONE);
                    GLTFViewer.SetElementCheck(this.selectionBtn, false);
                    this.SelectionBtnState(e, GLTFViewer.MENUCLOSE);
                    break;
                case GLTFViewer.MENUICON:
                    this.SetUpMenuBtn(this.selectionBtn, val);
                    break;
                case GLTFViewer.MENUCLICK:
                    if (GLTFViewer.GetElementVisible(this.selectionMenu))
                        this.SelectionBtnState(e, GLTFViewer.MENUCLOSE);
                    else
                        this.SelectionBtnState(e, GLTFViewer.MENUOPEN);
                    break;
                case GLTFViewer.MENUOPEN:
                    if (!GLTFViewer.GetElementVisible(this.selectionMenu)) {
                        if (this.popup1)
                            this.popup1.callback();
                        this.popup1 = { menu: this.selectionMenu, callback: this.SelectionBtnState.bind(this, null, GLTFViewer.MENUCLOSE) };
                        GLTFViewer.SetElementVisible(this.selectionMenu, true);
                        // action to perform
                        if (this.scene) {
                            // this will set up UI correctly
                            this.scene.SetSelectionMode(this.scene.GetSelectionMode());
                        }
                    }
                    break;
                case GLTFViewer.MENUCLOSE:
                    if (GLTFViewer.GetElementVisible(this.selectionMenu)) {
                        if (this.popup1 && this.popup1.menu === this.selectionMenu)
                            this.popup1 = null;
                        GLTFViewer.SetElementVisible(this.selectionMenu, false);
                        // action to perform
                    }
                    break;
                case GLTFViewer.MENUSHOW:
                    this.SelectionBtnState(e, GLTFViewer.MENURESET);
                    GLTFViewer.SetElementVisible(this.selectionBtn, true);
                    break;
                case GLTFViewer.MENUHIDE:
                    this.SelectionBtnState(e, GLTFViewer.MENURESET);
                    GLTFViewer.SetElementVisible(this.selectionBtn, false);
                    break;
                case GLTFViewer.MENUCHECK:
                    GLTFViewer.SetElementCheck(this.selectionBtn, true);
                    break;
                case GLTFViewer.MENUUNCHECK:
                    GLTFViewer.SetElementCheck(this.selectionBtn, false);
                    break;
            }
        }
    },
    // selectionMenu which handles click on selectionMenuBtns which opens/closes selectionMenuMenus
    SelectionMenuBtnState: {
        value: function (btn, e, state) {
            if (!this.wantSelection)
                return;
            switch (state) {
                case GLTFViewer.MENUCLICK:
                    if (this.scene) {
                        if (btn === this.scene.GetSelectionMode())
                            this.scene.SetSelectionMode(GLTFViewer.SELECTION_NONE);
                        else
                            this.SetSelectionMode(btn);
                    }
                    this.SelectionBtnState(e, GLTFViewer.MENUCLOSE);
                    break;
                case GLTFViewer.MENUENABLE:
                    GLTFViewer.SetElementEnable(this.selectionMenuBtns[btn], true);
                    break;
                case GLTFViewer.MENUDISABLE:
                    GLTFViewer.SetElementEnable(this.selectionMenuBtns[btn], false);
                    break;
                case GLTFViewer.MENUCHECK:
                    GLTFViewer.SetElementCheck(this.selectionMenuBtns[btn], true);
                    break;
                case GLTFViewer.MENUUNCHECK:
                    GLTFViewer.SetElementCheck(this.selectionMenuBtns[btn], false);
                    break;
                case GLTFViewer.MENUUNCHECKALL:
                    this.selectionMenuBtns.forEach((function (elem, index) {
                        this.SelectionMenuBtnState(index, null, GLTFViewer.MENUUNCHECK);
                    }).bind(this));
                    break;
            }
        }
    },
    ///////////////////////////////////////
    // Handles click on clipBtn which opens/closes clipMenu
    ClipBtnState: {
        value: function (e, state) {
            if (!this.wantClip)
                return;

            switch (state) {
                case GLTFViewer.MENURESET:
                    this.ClipMenuBtnState(null, e, GLTFViewer.MENURESET);
                    this.ClipBtnState(e, GLTFViewer.MENUCLOSE);
                    break;
                case GLTFViewer.MENUCLICK:
                    if (GLTFViewer.GetElementVisible(this.clipMenu))
                        this.ClipBtnState(e, GLTFViewer.MENUCLOSE);
                    else
                        this.ClipBtnState(e, GLTFViewer.MENUOPEN);
                    break;
                case GLTFViewer.MENUOPEN:
                    if (!GLTFViewer.GetElementVisible(this.clipMenu)) {
                        if (this.popup1)
                            this.popup1.callback();
                        this.popup1 = { menu: this.clipMenu, callback: this.ClipBtnState.bind(this, null, GLTFViewer.MENUCLOSE) };
                        GLTFViewer.SetElementVisible(this.clipMenu, true);
                        // action to perform
                        if (this.scene) {
                            // this will set up UI correctly
                            this.scene.ClipState = this.scene.ClipState;
                            this.scene.ClipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_DONE;
                        }
                    }
                    break;
                case GLTFViewer.MENUCLOSE:
                    if (GLTFViewer.GetElementVisible(this.clipMenu)) {
                        if (this.popup1 && this.popup1.menu === this.clipMenu)
                            this.popup1 = null;
                        GLTFViewer.SetElementVisible(this.clipMenu, false);
                        // action to perform
                        if (this.scene) {
                            if (this.scene.ClipDrawMode !== GLTFViewer.Utils.Clip.DRAWMODE_DONE && this.scene.ClipDrawMode !== GLTFViewer.Utils.Clip.DRAWMODE_MOVE)
                                this.scene.ClipState = GLTFViewer.Utils.Clip.STATE_DISABLED;
                            this.scene.ClipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_DONE;
                        }
                    }
                    break;
                case GLTFViewer.MENUSHOW:
                    this.ClipBtnState(e, GLTFViewer.MENURESET);
                    GLTFViewer.SetElementVisible(this.clipBtn, true);
                    break;
                case GLTFViewer.MENUHIDE:
                    this.ClipBtnState(e, GLTFViewer.MENURESET);
                    GLTFViewer.SetElementVisible(this.clipBtn, false);
                    break;
                case GLTFViewer.MENUCHECK:
                    GLTFViewer.SetElementCheck(this.clipBtn, true);
                    break;
                case GLTFViewer.MENUUNCHECK:
                    GLTFViewer.SetElementCheck(this.clipBtn, false);
                    break;
            }
        }
    },
    // clipMenu which handles click on clipMenuBtns which opens/closes clipMenuMenus
    ClipMenuBtnState: {
        value: function (btn, e, state) {
            if (!this.wantClip || !this.clipMenuBtns)
                return;
            switch (state) {
                case GLTFViewer.MENURESET:
                    if (this.scene) {
                        this.scene.ClipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_DONE;
                        this.scene.ClipState = GLTFViewer.Utils.Clip.STATE_DISABLED;
                    }
                    this.ClipMenuBtnState(3, e, GLTFViewer.MENUHIDE); // by default the 1PT option is not available 
                    break;
                case GLTFViewer.MENUCLICK:
                    if (this.scene) {
                        switch (btn) {
                            case 0: // Z
                            case 1: // X
                            case 2: // Y
                            case 3: // 1PT
                            case 4: // 3PTS
                                if (btn === this.scene.ClipState - GLTFViewer.Utils.Clip.STATE_Z)
                                    this.scene.ClipState = GLTFViewer.Utils.Clip.STATE_DISABLED;
                                else
                                    this.scene.ClipState = btn + GLTFViewer.Utils.Clip.STATE_Z;
                                break;
                            case 5: // MOVE
                                if (this.scene.ClipDrawMode === GLTFViewer.Utils.Clip.DRAWMODE_MOVE)
                                    this.scene.ClipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_DONE;
                                else
                                    this.scene.ClipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_MOVE;
                                break;
                        }
                    }
                    break;
                case GLTFViewer.MENUSHOW:
                    GLTFViewer.SetElementVisible(this.clipMenuBtns[btn], true);
                    break;
                case GLTFViewer.MENUHIDE:
                    GLTFViewer.SetElementVisible(this.clipMenuBtns[btn], false);
                    break;
                case GLTFViewer.MENUENABLE:
                    GLTFViewer.SetElementEnable(this.clipMenuBtns[btn], true);
                    break;
                case GLTFViewer.MENUDISABLE:
                    GLTFViewer.SetElementEnable(this.clipMenuBtns[btn], false);
                    break;
                case GLTFViewer.MENUCHECK:
                    GLTFViewer.SetElementCheck(this.clipMenuBtns[btn], true);
                    break;
                case GLTFViewer.MENUUNCHECK:
                    GLTFViewer.SetElementCheck(this.clipMenuBtns[btn], false);
                    break;
                case GLTFViewer.MENUUNCHECKALL:
                    this.clipMenuBtns.forEach((function (elem, index) {
                        this.ClipMenuBtnState(index, null, GLTFViewer.MENUUNCHECK);
                    }).bind(this));
                    break;
            }
        }
    },
    ///////////////////////////////////////
    // Handles click on markupBtn which opens/closes markupMenu
    MarkupBtnState: {
        value: function (e, state) {
            if (!this.wantMarkup)
                return;

            switch (state) {
                case GLTFViewer.MENURESET:
                    this.MarkupMenuBtnState(null, e, GLTFViewer.MENURESET);
                    this.MarkupBtnState(e, GLTFViewer.MENUCLOSE);
                    break;
                case GLTFViewer.MENUCLICK:
                    if (GLTFViewer.GetElementVisible(this.markupMenu))
                        this.MarkupBtnState(e, GLTFViewer.MENUCLOSE);
                    else
                        this.MarkupBtnState(e, GLTFViewer.MENUOPEN);
                    break;
                case GLTFViewer.MENUOPEN:
                    if (!GLTFViewer.GetElementVisible(this.markupMenu)) {
                        if (this.popup1)
                            this.popup1.callback();
                        this.popup1 = { menu: this.markupMenu, callback: this.MarkupBtnState.bind(this, null, GLTFViewer.MENUCLOSE) };
                        GLTFViewer.SetElementVisible(this.markupMenu, true);
                        this.SelectionBtnState(null, GLTFViewer.MENURESET);
                        // action to perform
                        if (this.scene) {
                            // this will set up UI correctly
                            this.scene.MarkupLineType = this.scene.MarkupLineType;
                            this.scene.MarkupLineShape = this.scene.MarkupLineShape;
                            this.scene.MarkupLineColor = this.scene.MarkupLineColor;
                            this.scene.MarkupFontColor = this.scene.MarkupFontColor;
                            this.scene.MarkupBackColor = this.scene.MarkupBackColor;
                            this.scene.MarkupFontSize = this.scene.MarkupFontSize;
                            this.scene.MarkupState = GLTFViewer.Utils.Markup.STATE_ENABLED;
                        }
                    }
                    break;
                case GLTFViewer.MENUCLOSE:
                    if (GLTFViewer.GetElementVisible(this.markupMenu)) {
                        if (this.popup1 && this.popup1.menu === this.markupMenu) {
                            this.popup1 = null;
                            if (this.popup2)
                                this.popup2.callback();
                        }
                        GLTFViewer.SetElementVisible(this.markupMenu, false);
                        // action to perform
                        this.MarkupMenuBtnState(null, e, GLTFViewer.MENUCLOSEALL);
                        if (this.scene)
                            this.scene.MarkupState = GLTFViewer.Utils.Markup.STATE_DISABLED;
                    }
                    break;
                case GLTFViewer.MENUENABLE:
                    GLTFViewer.SetElementEnable(this.markupBtn, true);
                    break;
                case GLTFViewer.MENUDISABLE:
                    GLTFViewer.SetElementEnable(this.markupBtn, false);
                    break;
                case GLTFViewer.MENUSHOW:
                    this.MarkupBtnState(e, GLTFViewer.MENURESET);
                    GLTFViewer.SetElementVisible(this.markupBtn, true);
                    break;
                case GLTFViewer.MENUHIDE:
                    this.MarkupBtnState(e, GLTFViewer.MENURESET);
                    GLTFViewer.SetElementVisible(this.markupBtn, false);
                    break;
            }
        }
    },
    // markupMenu which handles click on markupMenuBtns which opens/closes some markupMenuMenus
    MarkupMenuBtnState: {
        value: function (btn, e, state, val) {
            if (!this.wantMarkup || !this.markupMenuMenus)
                return;

            function MarkupMenuBtnsColorCallback(btn, callback, color) {
                callback(color);
                this.MarkupMenuBtnState(btn, null, GLTFViewer.MENUCLOSE);
            }

            switch (state) {
                case GLTFViewer.MENURESET:
                    this.MarkupMenuBtnState(null, e, GLTFViewer.MENUCLOSEALL);
                    break;
                case GLTFViewer.MENUICON:
                    switch (btn) {
                        case GLTFViewer.markupMenuBtnsLineShape:
                            this.SetUpMenuBtn(this.markupMenuBtns[btn], val);
                            break;
                        case GLTFViewer.markupMenuBtnsLineColor:
                            this.SetUpMenuBtn(this.markupMenuBtns[btn], GLTFViewer.ICONLINECOLOR, null, val);
                            break;
                        case GLTFViewer.markupMenuBtnsFontColor:
                            this.SetUpMenuBtn(this.markupMenuBtns[btn], GLTFViewer.ICONFONTCOLOR, null, val);
                            break;
                        case GLTFViewer.markupMenuBtnsBackColor:
                            this.SetUpMenuBtn(this.markupMenuBtns[btn], GLTFViewer.ICONBACKCOLOR, null, val);
                            break;
                        case GLTFViewer.markupMenuBtnsFontSize:
                            this.markupFontSize[0].value = val;
                            break;
                    }
                    break;
                case GLTFViewer.MENUCLICK:
                    switch (btn) {
                        case GLTFViewer.markupMenuBtns2D:
                        case GLTFViewer.markupMenuBtns3D:
                            if (this.scene)
                                this.scene.MarkupLineType = GLTFViewer.Utils.Markup.LINE_TYPE_2D + btn;
                            break;
                        case GLTFViewer.markupMenuBtnsLineShape:
                        case GLTFViewer.markupMenuBtnsLineColor:
                        case GLTFViewer.markupMenuBtnsFontColor:
                        case GLTFViewer.markupMenuBtnsBackColor:
                            if (GLTFViewer.GetElementVisible(this.markupMenuMenus[btn]))
                                this.MarkupMenuBtnState(btn, e, GLTFViewer.MENUCLOSE);
                            else
                                this.MarkupMenuBtnState(btn, e, GLTFViewer.MENUOPEN);
                            break;
                        case GLTFViewer.markupMenuBtnsFontSize:
                            if (!GLTFViewer.Utils.IsNull(val))
                                this.scene.MarkupFontSize = val;
                            break;
                    }
                    break;
                case GLTFViewer.MENUOPEN:
                    switch (btn) {
                        case GLTFViewer.markupMenuBtnsLineShape:
                        case GLTFViewer.markupMenuBtnsLineColor:
                        case GLTFViewer.markupMenuBtnsFontColor:
                        case GLTFViewer.markupMenuBtnsBackColor:
                            if (!GLTFViewer.GetElementVisible(this.markupMenuMenus[btn])) {
                                if (this.popup2)
                                    this.popup2.callback();
                                this.popup2 = { menu: this.markupMenuMenus[btn], callback: this.MarkupMenuBtnState.bind(this, btn, null, GLTFViewer.MENUCLOSE) };
                                // action to perform
                                GLTFViewer.SetElementVisible(this.markupMenuMenus[btn], true);
                            }
                            if (this.scene) {
                                switch (btn) {
                                    case GLTFViewer.markupMenuBtnsLineColor:
                                        this.AttachColorPickerPanel(this.markupMenuMenus[btn], MarkupMenuBtnsColorCallback.bind(this, btn, (function (c) { this.scene.MarkupLineColor = c; }).bind(this)));
                                        break;
                                    case GLTFViewer.markupMenuBtnsFontColor:
                                        this.AttachColorPickerPanel(this.markupMenuMenus[btn], MarkupMenuBtnsColorCallback.bind(this, btn, (function (c) { this.scene.MarkupFontColor = c; }).bind(this)));
                                        break;
                                    case GLTFViewer.markupMenuBtnsBackColor:
                                        this.AttachColorPickerPanel(this.markupMenuMenus[btn], MarkupMenuBtnsColorCallback.bind(this, btn, (function (c) { var col = c.Clone(); col.a = col.a ? 127 : 0; this.scene.MarkupBackColor = col; }).bind(this)));
                                        break;
                                }
                            }
                            break;
                    }
                    break;
                case GLTFViewer.MENUCLOSE:
                    switch (btn) {
                        case GLTFViewer.markupMenuBtnsLineShape:
                        case GLTFViewer.markupMenuBtnsLineColor:
                        case GLTFViewer.markupMenuBtnsFontColor:
                        case GLTFViewer.markupMenuBtnsBackColor:
                            if (GLTFViewer.GetElementVisible(this.markupMenuMenus[btn])) {
                                if (this.popup2 && this.popup2.menu === this.markupMenuMenus[btn])
                                    this.popup2 = null;
                                // action to perform
                                GLTFViewer.SetElementVisible(this.markupMenuMenus[btn], false);
                            }
                            break;
                    }
                    break;
                case GLTFViewer.MENUCLOSEALL:
                    this.markupMenuMenus.forEach((function (elem, index) {
                        this.MarkupMenuBtnState(index, null, GLTFViewer.MENUCLOSE);
                    }).bind(this));
                    break;
                case GLTFViewer.MENUENABLE:
                    GLTFViewer.SetElementEnable(this.markupMenuBtns[btn], true);
                    break;
                case GLTFViewer.MENUDISABLE:
                    GLTFViewer.SetElementEnable(this.markupMenuBtns[btn], false);
                    break;
                case GLTFViewer.MENUCHECK:
                    GLTFViewer.SetElementCheck(this.markupMenuBtns[btn], true);
                    break;
                case GLTFViewer.MENUUNCHECK:
                    GLTFViewer.SetElementCheck(this.markupMenuBtns[btn], false);
                    break;
            }
        }
    },
    MarkupLineShapeBtnState: {
        value: function (btn, e, state) {
            if (!this.wantMarkup)
                return;
            switch (state) {
                case GLTFViewer.MENUCLICK:
                    if (this.scene)
                        this.scene.MarkupLineShape = GLTFViewer.Utils.Markup.LINE_SYMBOL_NONE + btn;
                    // close this menu which is menu GLTFViewer.markupMenuBtnsLineShape of markupMenuMenus
                    this.MarkupMenuBtnState(GLTFViewer.markupMenuBtnsLineShape, null, GLTFViewer.MENUCLOSE);
                    break;
            }
        }
    },
    ///////////////////////////////////////
    // Handles click on Explode button
    ExplodeBtnState: {
        value: function (e, state) {
            if (!this.wantExplode)
                return;

            switch (state) {
                case GLTFViewer.MENURESET:
                    this.SetExplodeSlider(0, true);
                    this.ExplodeBtnState(null, GLTFViewer.MENUUNCHECK);
                    this.ExplodeBtnState(e, GLTFViewer.MENUCLOSE);
                    this.ExplodeBtnState(e, GLTFViewer.MENUHIDE);
                    break;
                case GLTFViewer.MENUCLICK:
                    if (GLTFViewer.GetElementVisible(this.explodeMenu))
                        this.ExplodeBtnState(e, GLTFViewer.MENUCLOSE);
                    else
                        this.ExplodeBtnState(e, GLTFViewer.MENUOPEN);
                    break;
                case GLTFViewer.MENUOPEN:
                    if (!GLTFViewer.GetElementVisible(this.explodeMenu)) {
                        if (this.popup1)
                            this.popup1.callback();
                        this.popup1 = { menu: this.explodeMenu, callback: this.ExplodeBtnState.bind(this, null, GLTFViewer.MENUCLOSE) };
                        // action to perform
                        GLTFViewer.SetElementVisible(this.explodeMenu, true);
                    }
                    break;
                case GLTFViewer.MENUCLOSE:
                    if (GLTFViewer.GetElementVisible(this.explodeMenu)) {
                        if (this.popup1 && this.popup1.menu === this.explodeMenu)
                            this.popup1 = null;
                        // action to perform
                        GLTFViewer.SetElementVisible(this.explodeMenu, false);
                    }
                    break;
                case GLTFViewer.MENUENABLE:
                    GLTFViewer.SetElementEnable(this.explodeBtn, true);
                    break;
                case GLTFViewer.MENUDISABLE:
                    GLTFViewer.SetElementEnable(this.explodeBtn, false);
                    break;
                case GLTFViewer.MENUSHOW:
                    GLTFViewer.SetElementVisible(this.explodeBtn, true);
                    break;
                case GLTFViewer.MENUHIDE:
                    GLTFViewer.SetElementVisible(this.explodeBtn, false);
                    break;
                case GLTFViewer.MENUCHECK:
                    GLTFViewer.SetElementCheck(this.explodeBtn, true);
                    break;
                case GLTFViewer.MENUUNCHECK:
                    GLTFViewer.SetElementCheck(this.explodeBtn, false);
                    break;
            }
        }
    },
    ///////////////////////////////////////
    // Handles click on aboutBtn which opens aboutDialog
    _AboutBtnState: {
        value: function (aboutBtn, aboutMenuBtns, aboutMenu, AboutMenuBtnState, e, state) {
            if (!this.wantAbout)
                return;

            var me = arguments.callee.bind(this, aboutBtn, aboutMenuBtns, aboutMenu, AboutMenuBtnState);
            switch (state) {
                case GLTFViewer.MENURESET:
                    AboutMenuBtnState(aboutMenuBtns, aboutMenu, me, null, e, GLTFViewer.MENURESET);
                    me(e, GLTFViewer.MENUCLOSE);
                    break;
                case GLTFViewer.MENUCLICK:
                    if (GLTFViewer.GetElementVisible(aboutMenu))
                        me(e, GLTFViewer.MENUCLOSE);
                    else
                        me(e, GLTFViewer.MENUOPEN);
                    break;
                case GLTFViewer.MENUOPEN:
                    if (!GLTFViewer.GetElementVisible(aboutMenu)) {
                        if (this.popup1)
                            this.popup1.callback();
                        this.popup1 = { menu: aboutMenu, callback: me.bind(this, null, GLTFViewer.MENUCLOSE) };
                        GLTFViewer.SetElementVisible(aboutMenu, true);
                    }
                    break;
                case GLTFViewer.MENUCLOSE:
                    if (GLTFViewer.GetElementVisible(aboutMenu)) {
                        if (this.popup1 && this.popup1.menu === aboutMenu)
                            this.popup1 = null;
                        GLTFViewer.SetElementVisible(aboutMenu, false);
                    }
                    break;
                case GLTFViewer.MENUSHOW:
                    me(e, GLTFViewer.MENURESET);
                    GLTFViewer.SetElementVisible(aboutBtn, true);
                    break;
                case GLTFViewer.MENUHIDE:
                    me(e, GLTFViewer.MENURESET);
                    GLTFViewer.SetElementVisible(aboutBtn, false);
                    break;
            }
        }
    },
    // aboutMenu which handles click on aboutMenuBtns which opens/closes aboutMenuMenus
    _AboutMenuBtnState: {
        value: function (aboutMenuBtns, aboutMenu, AboutBtnState, btn, e, state) {
            if (!this.wantAbout)
                return;
            switch (state) {
                case GLTFViewer.MENUCLICK:
                    if (GLTFViewer.GetElementVisible(aboutMenu))
                        AboutBtnState(e, GLTFViewer.MENUCLOSE);
                    else
                        AboutBtnState(e, GLTFViewer.MENUOPEN);
                    switch (btn) {
                        case 0: // Doc
                            this.ShowHelp();
                            break;
                        case 1: // Info
                            this.ShowAboutDialog(true);
                            break;
                    }
                    break;
                case GLTFViewer.MENUCLOSE:
                    switch (btn) {
                        case 0: // Doc
                            break;
                        case 1: // Info
                            this.ShowAboutDialog(false);
                            break;
                    }
                    break;
                case GLTFViewer.MENUENABLE:
                    GLTFViewer.SetElementEnable(aboutMenuBtns[btn], true);
                    break;
                case GLTFViewer.MENUDISABLE:
                    GLTFViewer.SetElementEnable(aboutMenuBtns[btn], false);
                    break;
            }
        }
    },
    ///////////////////////////////////////
    ContainerKeyDown: {
        value: function (e) {
            if (GLTFViewer.Utils.IsNull(this.aboutDialog) || GLTFViewer.GetElementVisible(this.aboutDialog.box))
                e.stopPropagation();
            //            if (this.scene && e.keyCode === 27) { //esc
            //                if (this.scene.ClipState !== GLTFViewer.Utils.Clip.STATE_DISABLED)
            //                    this.scene.ClipState = GLTFViewer.Utils.Clip.STATE_DISABLED;
            //                else
            //                    this.scene.ResetSelection();
            //            }
        }
    },
    ContainerContextMenu: {
        value: function (e) {
            if (e && e.preventDefault)
                e.preventDefault();
            var numFiles = this.NumFiles();
            if (this.scene && (this.scene.handler || numFiles)) {
                if (this.scene.OkToShowContextMenu()) {
                    function contextContainerCallback(val, other) {
                        var item = val[0];
                        var idx = val[1];
                        var parentItem = val.length > 2 ? val[2] : "";
                        if (!this.scene)
                            return;

                        switch (item) {
                            case GLTFViewer.CM_FILE_CLOSE_FILE:
                                this.CloseFile();
                                break;
                            case GLTFViewer.CM_MAIN_HIDE_BODY:
                                this.scene.handler.HideBody(other);
                                break;
                            case GLTFViewer.CM_MAIN_EDIT_PROPERTIES:
                                this.scene.handler.EditProperties(other);
                                break;
                            case GLTFViewer.CM_MAIN_CREATE_PROBE:
                                this.scene.MarkupCreate3D();
                                break;
                            case GLTFViewer.CM_MAIN_RESET_VIEW:
                                this.scene.ResetScene();
                                break;
                            case GLTFViewer.CM_MAIN_SAVE_VIEW:
                                function ApplyCallback(ok, data) {
                                    if (ok && data[0] && data[0].length)
                                        this.scene.handler.CreateScene(data[0]);
                                }
                                var sceneItem = this.scene.handler.CurScene;
                                var name = sceneItem ? sceneItem.name + "_Copy" : "View";
                                var a = new GLTFViewer.Utils.Dialog("New View Name", [
                                ["View Name", GLTFViewer.Utils.Dialog.DATATEXT, name]
                            ], true, ApplyCallback.bind(this));
                                break;
                            case GLTFViewer.CM_MAIN_DELETE_VIEW:
                                var sceneItem = this.scene.handler.CurScene;
                                if (sceneItem.editable)
                                    this.scene.handler.DeleteScene(sceneItem);
                                break;
                            case GLTFViewer.CM_MAIN_SAVE_IMAGE:
                            case GLTFViewer.CM_MAIN_SAVE_IMAGE_PNG:
                                this.SaveImage();
                                break;
                            case GLTFViewer.CM_MAIN_SAVE_IMAGE_STL:
                                this.SaveSTL();
                                break;
                            default:
                                if (parentItem === GLTFViewer.CM_MAIN_SELECT_FILE)
                                    this.SelectFile(idx);
                                break;
                        }
                    }

                    var items = [];
                    var help = null;
                    var fileNames = null;
                    if (this.wantFile) {
                        help = [];
                        items.push(GLTFViewer.CM_FILE_CLOSE_FILE);
                        help.push(null);
                        if (numFiles) {
                            var files = [GLTFViewer.CM_MAIN_SELECT_FILE];
                            var paths = [null];
                            fileNames = this.FileNames();
                            files = files.concat(fileNames);
                            items.push(files);
                            var filePaths = this.FilePaths();
                            paths = paths.concat(filePaths);
                            help.push(paths);

                            items.push("-");
                        }
                    }
                    items.push(GLTFViewer.CM_MAIN_HIDE_BODY);
                    if (this.wantPropertyEdit)
                        items.push(GLTFViewer.CM_MAIN_EDIT_PROPERTIES);
                    items.push(GLTFViewer.CM_MAIN_CREATE_PROBE,
                      "-",
                      GLTFViewer.CM_MAIN_RESET_VIEW,
                      GLTFViewer.CM_MAIN_SAVE_VIEW,
                      GLTFViewer.CM_MAIN_DELETE_VIEW);
                    if (this.wantSTLExport)
                        items.push([GLTFViewer.CM_MAIN_SAVE_IMAGE,
                            GLTFViewer.CM_MAIN_SAVE_IMAGE_PNG,
                            GLTFViewer.CM_MAIN_SAVE_IMAGE_STL]);
                    else
                        items.push(GLTFViewer.CM_MAIN_SAVE_IMAGE);
                    this.contextMenuContainer = new GLTFViewer.Utils.SimpleContextMenu(this, this.controllingViewer.body, items, help, contextContainerCallback.bind(this));

                    if (this.scene.ClipViewState === GLTFViewer.Utils.Clip.VIEWSTATE_PREVIEW)
                        this.ClipMenuBtnState(null, e, GLTFViewer.MENURESET);
                    this.scene.MarkupDelete();
                    var enable = {};
                    if (this.wantFile) {
                        if (!GLTFViewer.Utils.IsNull(this.ActiveFileObj()))
                            enable[GLTFViewer.CM_FILE_CLOSE_FILE] = 1;
                        if (numFiles) {
                            enable[GLTFViewer.CM_MAIN_SELECT_FILE] = 1;
                            for (var i = 0; i < fileNames.length; ++i)
                                enable[fileNames[i]] = 1;
                        }
                    }
                    if (this.scene.handler) {
                        enable[GLTFViewer.CM_MAIN_SAVE_IMAGE] = 1;
                        enable[GLTFViewer.CM_MAIN_SAVE_IMAGE_PNG] = 1;
                        if (this.wantSTLExport)
                            enable[GLTFViewer.CM_MAIN_SAVE_IMAGE_STL] = 1;
                        var animationStopped = this.scene.AnimationStopped();
                        if (animationStopped)
                            enable[GLTFViewer.CM_MAIN_RESET_VIEW] = 1;
                        var indx = this.scene.HitIndx();
                        if (this.scene.handler.CurScene) {
                            if (this.canSave) {
                                enable[GLTFViewer.CM_MAIN_SAVE_VIEW] = 1;
                                if (this.scene.handler.CurScene.editable && animationStopped)
                                    enable[GLTFViewer.CM_MAIN_DELETE_VIEW] = 1;
                            }

                            if (!GLTFViewer.Utils.IsNull(indx) && indx >= 0 && animationStopped) {
                                enable[GLTFViewer.CM_MAIN_HIDE_BODY] = 1;
                                if (this.wantPropertyEdit)
                                    enable[GLTFViewer.CM_MAIN_EDIT_PROPERTIES] = 1;
                                if (this.scene.handler.CanMarkup && this.scene.MarkupState === GLTFViewer.Utils.Markup.STATE_DISABLED && GLTFViewer.GetElementEnable(this.markupBtn) && this.scene.AnyHit() && this.scene.HitIndx() >= 0)
                                    enable[GLTFViewer.CM_MAIN_CREATE_PROBE] = 1;
                            }
                        }
                    }
                    this.contextMenuContainer.Show(true, e, enable, indx);
                } else {
                    var hit = this.scene.MarkupHit;
                    if (hit && this.scene.MarkupEditable(hit)) {
                        var enable = {};
                        enable[GLTFViewer.CM_MARKUP_DELETE_MARKUP] = 1;
                        this.contextMenuMarkup.Show(true, e, enable, hit);
                    }
                }
            }
        }
    },
    ///////////////////////////////////////
    CurrentSceneState: {
        value: function () {
            if (!this.scene || !this.scene.handler)
                return null;
            return this.scene.handler.GetSceneState();
        }
    },
    SetTitle: {
        value: function (how, from, messageID, data) {
            if (this.isEKM || this.isReport || !this.messageHandler || this._option["p"])
                return;

            if (how === "READ") {
                if (this.viewportNumber === 0) {
                    // only viewport 1 keeps track and manages title
                    if (GLTFViewer.Utils.IsNull(this._titles))
                        this._titles = {};
                    if (!GLTFViewer.Utils.IsNull(data)) { // null means we are just refreshing
                        if (data.length)
                            this._titles[from] = data;
                        else
                            delete this._titles[from];
                    }

                    var title = "ANSYS Viewer";

                    if (this.viewportLayout === 1 ||
                            (this.viewportLayout === 2 && !this.viewer1.isFull) ||
                            (this.viewportLayout === 4 && !this.viewer1.isFull && !this.viewer2.isFull && !this.viewer3.isFull))
                        title = title + " - " + (this._titles[0] ? this._titles[0] : "");
                    if ((this.viewportLayout === 2 && !this.isFull) ||
                            (this.viewportLayout === 4 && !this.isFull && !this.viewer2.isFull && !this.viewer3.isFull))
                        title = title + " - " + (this._titles[1] ? this._titles[1] : "");
                    if (this.viewportLayout === 4 && !this.isFull && !this.viewer1.isFull && !this.viewer3.isFull)
                        title = title + " - " + (this._titles[2] ? this._titles[2] : "");
                    if (this.viewportLayout === 4 && !this.isFull && !this.viewer1.isFull && !this.viewer2.isFull)
                        title = title + " - " + (this._titles[3] ? this._titles[3] : "");
                    if (title === "ANSYS Viewer - ")
                        title = "ANSYS Viewer";

                    document.title = title;
                    window.resizeBy(0, -1);
                    window.resizeBy(0, 1);
                }
            } else if (how === "REFRESH")
                this.messageHandler.SendMessage(GLTFViewer.MSGTITLE, null);
            else // "WRITE"
                this.messageHandler.SendMessage(GLTFViewer.MSGTITLE, from);
        }
    },
    ///////////////////////////////////////////////////////////////////////////
    ReadFile: {
        // other is drag'n'drop resources, AVZ unzip entries, or tmp dir name
        value: function (mainFile, fileObj, data, other, callback, loadTypeOverride) {
            var file = fileObj._file;
            var fileType = fileObj._fileType;
            var loadType = GLTFViewer.Utils.IsNull(loadTypeOverride) ? fileObj._loadType : loadTypeOverride;
            var sceneState = loadType === GLTFViewer.LT_REPLACE ? null : this.CurrentSceneState();
            var filePath = GLTFViewer.Utils.GetFilePath(file);

            function cb(mainFile, filePath, fileType, handler, data, other, callback, state) {
                this.scene.EnableUpdate(true);

                if (fileType === GLTFViewer.FT_GLTF || fileType === GLTFViewer.FT_AVZ) {
                    this.SelectionMenuBtnState(0, null, GLTFViewer.MENUDISABLE);
                    this.SelectionMenuBtnState(1, null, GLTFViewer.MENUDISABLE);
                    if ((fileType === GLTFViewer.FT_AVZ || this.isServed) && this.canSave)
                        this.SaveBtnState(null, GLTFViewer.MENUSHOW);
                    else
                        this.SaveBtnState(null, GLTFViewer.MENUHIDE);
                } else { // SCDOC
                    this.ClipMenuBtnState(3, null, GLTFViewer.MENUSHOW);
                    this.SelectionMenuBtnState(0, null, GLTFViewer.MENUENABLE);
                    this.SelectionMenuBtnState(1, null, GLTFViewer.MENUENABLE);
                    this.SaveBtnState(null, GLTFViewer.MENUHIDE);
                }
                //this.controllingViewer.FileManagerBtnState(null, GLTFViewer.MENUSHOW);
                this.ZoomBtnState(null, GLTFViewer.MENUSHOW);
                //this.FullBtnState(null, GLTFViewer.MENUSHOW);
                //this.ViewportBtnState(null, GLTFViewer.MENUSHOW);
                if (handler.CanExplode)
                    this.ExplodeBtnState(null, GLTFViewer.MENUSHOW);
                this.ShowSceneAnimation(handler.HasAnimation());

                if (!state) {
                    if (callback)
                        callback(false);
                    return;
                }
                if (fileType === GLTFViewer.FT_AVZ) {
                    if (typeof other !== 'string') {
                        // other is unzip entries
                        // look for mup/view in other
                        var markupFileData;
                        var viewFileData;
                        var fileNames = Object.keys(other);
                        for (var i = 0; i < fileNames.length; ++i) {
                            var name = fileNames[i];
                            if (handler.CanMarkup && name.search(/\.mup$/) > 0)
                                markupFileData = other[name];
                            else if (handler.CanCreateViews && name.search(/\.view$/) > 0)
                                viewFileData = other[name];
                        }
                        // have to read view before markup
                        function readMarkupView1(fileData, type, callback) {
                            try {
                                var data = JSON.parse(fileData);
                                if (type == "markup")
                                    handler.ReadMarkups(data);
                                else
                                    handler.ReadViews(data, callback, sceneState);
                            } catch (err) {
                                GLTFViewer.Utils.WriteErr("ERROR(ReadFile:" + name + "): " + (err.message ? err.message : err) + " in " + type + " data");
                            }
                        }
                        function cb3(markupFileData) {
                            if (!GLTFViewer.Utils.IsNull(markupFileData))
                                readMarkupView1(markupFileData, "markup");
                        }
                        if (!GLTFViewer.Utils.IsNull(viewFileData))
                            readMarkupView1(viewFileData, "view", cb3.bind(this, markupFileData));
                        else if (!GLTFViewer.Utils.IsNull(markupFileData))
                            readMarkupView1(markupFileData, "markup");
                    } else {
                        function readMarkupView2(name, type, callback) {
                            var fs = require('fs');
                            fs.readFile(name, (function (type, callback, err, fileData) {
                                if (err) {
                                    GLTFViewer.Utils.WriteErr("ERROR(ReadFile): " + err + " in " + type + " data");
                                    return;
                                }
                                var data;
                                try {
                                    data = JSON.parse(fileData);
                                } catch (err) {
                                    GLTFViewer.Utils.WriteErr("ERROR(ReadFile): " + (err.message ? err.message : err) + " in " + type + " data");
                                    return;
                                }
                                if (type == "markup")
                                    handler.ReadMarkups(data);
                                else
                                    handler.ReadViews(data, callback, sceneState);
                            }).bind(this, type, callback));
                        }
                        // other is tmp dir name
                        if (handler.CanMarkup)
                            this.saveMUPName = this.tmpDir.FindFile(/\.mup$/);
                        else
                            this.saveMUPName = null;
                        if (handler.CanCreateViews)
                            this.saveViewName = this.tmpDir.FindFile(/\.view$/);
                        else
                            this.saveViewName = null;
                        function cb4(markupFileName) {
                            if (!GLTFViewer.Utils.IsNull(markupFileName))
                                readMarkupView2(markupFileName, "markup");
                        }
                        if (!GLTFViewer.Utils.IsNull(this.saveViewName))
                            readMarkupView2(this.saveViewName, "view", cb4.bind(this, this.saveMUPName));
                        else if (!GLTFViewer.Utils.IsNull(this.saveMUPName))
                            readMarkupView2(this.saveMUPName, "markup");
                    }
                } else if (fileType === GLTFViewer.FT_GLTF) {
                    if (other) {
                        // other is drag'n'drop resources
                        // look for mup/view in other
                        var markupFile;
                        var viewFile;
                        for (var key in other) {
                            var file = other[key];
                            var ft = GLTFViewer.GetFileType(GLTFViewer.Utils.GetFilePath(file));
                            if (handler.CanMarkup && ft === GLTFViewer.FT_MUP)
                                markupFile = file;
                            else if (handler.CanCreateViews && ft === GLTFViewer.FT_VIEW)
                                viewFile = file;
                        }
                        // have to read view before markup
                        function readMarkupView(file, type, callback) {
                            var fileReader = new FileReader();
                            fileReader.onloadend = (function (filePath, type, callback, e) {
                                if (GLTFViewer.Utils.IsNull(e.target.result) || !GLTFViewer.Utils.IsNull(e.target.error)) {
                                    GLTFViewer.Utils.WriteErr("ERROR(ReadFile:" + filePath + "): bad " + type + " data");
                                    return;
                                }
                                var data;
                                try {
                                    data = JSON.parse(e.target.result);
                                } catch (err) {
                                    GLTFViewer.Utils.WriteErr("ERROR(ReadFile:" + filePath + "): " + (err.message ? err.message : err) + " in " + type + " data");
                                    return;
                                }
                                if (type == "markup")
                                    handler.ReadMarkups(data);
                                else
                                    handler.ReadViews(data, callback, sceneState);
                            }).bind(this, GLTFViewer.Utils.GetFilePath(file), type, callback);

                            fileReader.readAsText(file);
                        }
                        function cb2(markupFile) {
                            if (!GLTFViewer.Utils.IsNull(markupFile))
                                readMarkupView(markupFile, "markup");
                        }
                        if (!GLTFViewer.Utils.IsNull(viewFile))
                            readMarkupView(viewFile, "view", cb2.bind(this, markupFile));
                        else if (!GLTFViewer.Utils.IsNull(markupFile))
                            readMarkupView(markupFile, "markup");
                    } else {
                        // reads from server
                        function readMarkupView3(file, type, callback) {
                            GLTFViewer.Utils.FileGLTF.LoadJSON(file, true, (function (type, callback, data) {
                                if (data) {
                                    if (type == "markup")
                                        handler.ReadMarkups(data);
                                    else
                                        handler.ReadViews(data, callback, sceneState);
                                } else if (!GLTFViewer.Utils.IsNull(callback))
                                    callback();
                            }).bind(this, type, callback));
                        }
                        function cb5(markupFile) {
                            if (!GLTFViewer.Utils.IsNull(markupFile))
                                readMarkupView3(markupFile, "markup");
                        }
                        var res = GLTFViewer.Utils.GetEKMBasePath(mainFile);
                        var ekmUrlParamNameContextIdValue = res.ekmUrlParamNameContextIdValue;
                        var pathBase = res.pathBase;
                        var mupName;
                        var viewName;
                        if (handler.CanMarkup)
                            mupName = GLTFViewer.Utils.ResolveEKMPath(ekmUrlParamNameContextIdValue, pathBase, "file.mup");
                        if (handler.CanCreateViews)
                            viewName = GLTFViewer.Utils.ResolveEKMPath(ekmUrlParamNameContextIdValue, pathBase, "file.view");
                        if (!GLTFViewer.Utils.IsNull(viewName))
                            readMarkupView3(viewName, "view", cb5.bind(this, mupName));
                        else if (!GLTFViewer.Utils.IsNull(mupName))
                            readMarkupView3(mupName, "markup");
                    }
                }
                if (this.scene.CanSelect())
                    this.SelectionBtnState(null, GLTFViewer.MENUSHOW);
                if (callback)
                    callback(true); // does not wait for MUP/VIEW to load
            }

            var handler;
            if (fileType === GLTFViewer.FT_MUP) {
                this.MarkupBtnState(null, GLTFViewer.MENURESET);
                handler = this.scene.handler;
                if (handler)
                    handler.ReadMarkups(data);
                if (callback)
                    callback(true);
                return;
            } else if (fileType === GLTFViewer.FT_VIEW) {
                handler = this.scene.handler;
                if (handler)
                    handler.ReadViews(data, null, sceneState);
                if (callback)
                    callback(true);
                return;
            }

            this.CloseFile(loadType !== GLTFViewer.LT_REPLACE); // reading in new file, close existing one, has to be done before new one created
            if (fileType === GLTFViewer.FT_GLTF || fileType === GLTFViewer.FT_AVZ) {
                try {
                    if (!(this.scene.handler instanceof GLTFViewer.Utils.FileGLTF))
                        handler = new GLTFViewer.Utils.FileGLTF(this.scene, fileType, data, other);
                    else {
                        handler = this.scene.handler;
                        handler._fileType = fileType;
                        handler._data = data;
                        handler._other = other;
                    }
                } catch (err) {
                    if (callback)
                        callback(false);
                    return;
                }
            } else { // SCDOC
                try {
                    handler = new GLTFViewer.Utils.FileSpaceClaim(this.scene, fileType, data, other);
                } catch (err) {
                    if (callback)
                        callback(false);
                    return;
                }
            }

            //if (this.scene.HasAnimation() && !this.scene.AnimationStopped())
            //    this.scene.AnimationStop();
            this.ShowSceneAnimation(false);

            this.scene.EnableUpdate(false);
            this.scene.ReadFile(handler, cb.bind(this, mainFile, filePath, fileType, handler, data, other, callback), loadType, sceneState);
        }
    },
    ParseArrayBuffer: {
        value: function (fileObj, callback, loadTypeOverride, data) {
            function CB1(unzip, fileObj, filePath, callback, loadTypeOverride) {
                var fileType = fileObj._fileType;
                // find .gltf file
                var fileData = null;
                var avzData = {};
                var fileNames = Object.keys(unzip.entries);
                var fn = null;
                for (var i = 0; i < fileNames.length; ++i) {
                    fn = fileNames[i];
                    if (GLTFViewer.Utils.IsNull(fileData) && GLTFViewer.GetFileType(fn) === GLTFViewer.FT_GLTF) {
                        fileData = unzip.entries[fn];
                        break;
                    } else if (fileType === GLTFViewer.FT_AVZM && GLTFViewer.GetFileType(fn) === GLTFViewer.FT_AVZ)
                        avzData[fn] = unzip.entries[fn];
                }
                if (fileData) {
                    // GLTF file
                    var jsonData;
                    try {
                        jsonData = JSON.parse(fileData);
                    } catch (err) {
                        GLTFViewer.Utils.WriteErr("ERROR(ParseArrayBuffer:" + filePath + "): " + (err.message ? err.message : err) + " in JSON data");
                        if (callback)
                            callback(false);
                        return;
                    }
                    // fileObj is containerFile for fn
                    this.ReadFile(fn, fileObj, jsonData, unzip.entries, callback, loadTypeOverride);
                } else {
                    // AVZM file
                    this.RemoveFile(fileObj);
                    var keys = Object.keys(avzData);
                    if (keys.length) {
                        var newIdx = -1;
                        var firstFileObj = null;
                        var multiFile = [];
                        for (var i = 0; i < keys.length; i++) {
                            var f = keys[i];
                            if (GLTFViewer.GetFileType(f) !== GLTFViewer.FT_AVZ)
                                continue;
                            var fileData = avzData[f];
                            var idx = this.FindFile(f, fileObj._file);
                            if (idx < 0) {
                                // not already added, so add it
                                // multifile will override LT_REPLACE with LT_UPDATE
                                idx = this.AddFile(f, GLTFViewer.FT_AVZ, GLTFViewer.LT_REPLACE, fileData, fileObj._file, multiFile);
                                if (idx >= 0)
                                    multiFile.push(this.Files()[idx]);
                            }
                            if (idx >= 0 && (newIdx < 0 || idx < newIdx)) {
                                newIdx = idx;
                                firstFileObj = this.Files()[newIdx];
                            }
                        }
                        if (multiFile.length > 1)
                            multiFile.sort(GLTFViewer.FileManager.FileNameCompare);
                        if (firstFileObj) {
                            this.SelectFile(firstFileObj, callback.bind(this, true)); // if firstFileObj fails to load, someone else will take care of it
                            return;
                        }
                    }

                    GLTFViewer.Utils.WriteErr("ERROR(ParseArrayBuffer:" + filePath + "): No '*.avz' found");
                    if (callback)
                        callback(false);
                }
            }
            var file = fileObj._file;
            var filePath = GLTFViewer.Utils.GetFilePath(file);
            if (data.target && (!GLTFViewer.Utils.IsNull(data.target.error) || GLTFViewer.Utils.IsNull(data.target.result))) {
                GLTFViewer.Utils.WriteErr("ERROR(ParseArrayBuffer:" + filePath + "): cannot be loaded");
                if (callback)
                    callback(false);
                return;
            }
            data = data.target ? data.target.result : data;
            var unzip = new JSUnzip(data, this.scene.progressBar);
            if (unzip.isZipFile()) {
                try {
                    unzip.readEntries(CB1.bind(this, unzip, fileObj, filePath, callback, loadTypeOverride));
                } catch (err) {
                    GLTFViewer.Utils.WriteErr(err);
                    if (callback)
                        callback(false);
                }
            } else {
                GLTFViewer.Utils.WriteErr("ERROR(ParseArrayBuffer:" + filePath + "): cannot be loaded");
                if (callback)
                    callback(false);
            }
        }
    },
    ReadFromArrayBuffer: {
        value: function (fileObj, callback, loadTypeOverride, data) {
            var file = fileObj._file;
            var fileType = fileObj._fileType;
            var filePath = GLTFViewer.Utils.GetFilePath(file);

            switch (fileType) {
                case GLTFViewer.FT_SCDOC:
                case GLTFViewer.FT_DSGZ:
                    this.ReadFile(filePath, fileObj, data, null, callback, false);
                    break;
                case GLTFViewer.FT_AVZ:
                case GLTFViewer.FT_AVZM:
                    this.ParseArrayBuffer(fileObj, callback, loadTypeOverride, data);
                    break;
                default:
                    // unsupported file type
                    if (callback)
                        callback(false);
                    break;
            }
        }
    },
    // drag&drop or fileload selection
    ReadFileObject: {
        value: function (fileObj, callback, loadTypeOverride) {
            var file = fileObj._file;
            var fileType = fileObj._fileType;
            var resources = fileObj._resources;
            var filePath = GLTFViewer.Utils.GetFilePath(file);

            switch (fileType) {
                case GLTFViewer.FT_GLTF:
                    {
                        var fileReader = new FileReader();
                        fileReader.onloadend = (function (fileObj, filePath, resources, callback, loadTypeOverride, e) {
                            if (!GLTFViewer.Utils.IsNull(e.target.error)) {
                                GLTFViewer.Utils.WriteErr("ERROR(ReadFileObject:" + filePath + "): cannot be loaded");
                                if (callback)
                                    callback(false);
                                return;
                            }
                            if (GLTFViewer.Utils.IsNull(e.target.result)) {
                                GLTFViewer.Utils.WriteErr("ERROR(ReadFileObject:" + filePath + "): bad JSON data");
                                if (callback)
                                    callback(false);
                                return;
                            }
                            var jsonData;
                            try {
                                jsonData = JSON.parse(e.target.result);
                            } catch (err) {
                                GLTFViewer.Utils.WriteErr("ERROR(ReadFileObject:" + filePath + "): " + (err.message ? err.message : err) + " in JSON data");
                                if (callback)
                                    callback(false);
                                return;
                            }
                            this.ReadFile(filePath, fileObj, jsonData, resources, callback, loadTypeOverride);
                        }).bind(this, fileObj, filePath, resources, callback, loadTypeOverride);
                        fileReader.readAsText(file);
                    }
                    break;
                case GLTFViewer.FT_AVZ:
                case GLTFViewer.FT_AVZM:
                    {
                        var fileReader = new FileReader();
                        fileReader.onloadend = this.ParseArrayBuffer.bind(this, fileObj, callback, loadTypeOverride);
                        fileReader.readAsArrayBuffer(fileObj._file);
                    }
                    break;
                case GLTFViewer.FT_SCDOC:
                case GLTFViewer.FT_DSGZ:
                    {
                        var fileReader = new FileReader();
                        fileReader.onloadend = (function (fileObj, filePath, callback, loadTypeOverride, e) {
                            if (!GLTFViewer.Utils.IsNull(e.target.error)) {
                                GLTFViewer.Utils.WriteErr("ERROR(ReadFileObject:" + filePath + "): cannot be loaded");
                                if (callback)
                                    callback(false);
                                return;
                            }
                            this.ReadFile(filePath, fileObj, e.target.result, null, callback, loadTypeOverride);
                        }).bind(this, fileObj, filePath, callback, loadTypeOverride);
                        fileReader.readAsArrayBuffer(file);
                    }
                    break;
                default:
                    // unsupported file type
                    if (callback)
                        callback(false);
                    break;
            }
        }
    },
    // url
    ReadFilePath: {
        value: function (fileObj, callback, loadTypeOverride) {
            var file = fileObj._file;
            var fileType = fileObj._fileType;
            var filePath = GLTFViewer.Utils.GetFilePath(file);

            switch (fileType) {
                case GLTFViewer.FT_GLTF:
                    {
                        GLTFViewer.Utils.FileGLTF.LoadJSON(filePath, false, (function (fileObj, filePath, callback, loadTypeOverride, jsonData) {
                            if (jsonData)
                                this.ReadFile(filePath, fileObj, jsonData, null, callback, loadTypeOverride);
                            else if (callback)
                                callback(false);
                        }).bind(this, fileObj, filePath, callback, loadTypeOverride));
                    }
                    break;
                case GLTFViewer.FT_AVZ:
                case GLTFViewer.FT_AVZM:
                case GLTFViewer.FT_SCDOC:
                case GLTFViewer.FT_DSGZ:
                    {
                        var BYTES = 10000;
                        var delegate = {};
                        delegate.HandleError = (function (callback, path, err) {
                            GLTFViewer.Utils.WriteErr("ERROR(ReadFilePath:" + path + "): " + err);
                            if (callback)
                                callback(false);
                        }).bind(this, callback);
                        delegate.HandleProgress = (function (BYTES, path, totalBytes, loadedBytes) {
                            var loaded = loadedBytes / totalBytes * BYTES;
                            this.scene.progressBar.Update(loaded);
                        }).bind(this, BYTES);
                        delegate.HandleData = (function (fileObj, callback, loadTypeOverride, path, data) {
                            this.ReadFromArrayBuffer(fileObj, callback, loadTypeOverride, data);
                        }).bind(this, fileObj, callback, loadTypeOverride);
                        this.scene.progressBar.Start(BYTES);
                        // RJF the 'data:' domain URL is a served URL, not a file...
                        if (filePath.startsWith("data:")) { 
                            this.isServed = true;
                        }
                        if (!this.isServed)
                            GLTFViewer.Utils.FileGLTF.LoadStream(filePath, "FILE", delegate); // load using ActiveXObject
                        else
                            GLTFViewer.Utils.FileGLTF.LoadStream(filePath, "arraybuffer", delegate); // load using XMLHttpRequest
                    }
                    break;
                default:
                    // unsupported file type
                    if (callback)
                        callback(false);
                    break;
            }
        }
    },
    // url
    ReadUsingNodeJS: {
        value: function (fileObj, callback, loadTypeOverride) {
            var file = fileObj._file;
            var fileType = fileObj._fileType;
            var filePath = GLTFViewer.Utils.GetFilePath(file);

            switch (fileType) {
                case GLTFViewer.FT_GLTF:
                    {
                        var fs = require('fs');
                        fs.readFile(filePath, "utf8", (function (mainGLTF, callback, loadTypeOverride, err, fileData) {
                            if (err) {
                                GLTFViewer.Utils.WriteErr("ERROR(ReadUsingNodeJS:" + mainGLTF + "): " + err);
                                if (callback)
                                    callback(false);
                                return;
                            }

                            var jsonData;
                            try {
                                if (fileData.charCodeAt(0) === 65279)
                                    jsonData = JSON.parse(fileData.substring(1));
                                else
                                    jsonData = JSON.parse(fileData);
                            } catch (err) {
                                GLTFViewer.Utils.WriteErr("ERROR(ReadUsingNodeJS): " + (err.message ? err.message : err) + " in JSON data");
                                if (callback)
                                    callback(false);
                                return;
                            }
                            this.ReadFile(mainGLTF, fileObj, jsonData, fileObj._resources, callback, loadTypeOverride);
                        }).bind(this, filePath, callback, loadTypeOverride));
                    }
                    break;
                case GLTFViewer.FT_ARZ:
                    //this.controllingViewer.CloseFile(); // reading in new file, close existing one
                    this.controllingViewer.ReadARZ(filePath, callback);
                    break;
                case GLTFViewer.FT_AVZ:
                case GLTFViewer.FT_AVZM:
                    {
                        function CB(fileObj, callback, loadTypeOverride, tmpDir) {
                            this.tmpDir = tmpDir;
                            if (GLTFViewer.Utils.IsNull(this.tmpDir)) {
                                GLTFViewer.Utils.WriteErr("ERROR(ReadUsingNodeJS): Can't decompress '" + filePath + "'");
                                if (callback)
                                    callback(false);
                                return;
                            }
                            if (fileType === GLTFViewer.FT_AVZ) {
                                var mainGLTF = this.tmpDir.FindFile(/\.json$|\.gltf$/);
                                if (!GLTFViewer.Utils.IsNull(mainGLTF)) {
                                    var fs = require('fs');
                                    fs.readFile(mainGLTF, "utf8", (function (mainGLTF, callback, loadTypeOverride, err, fileData) {
                                        if (err) {
                                            GLTFViewer.Utils.WriteErr("ERROR(ReadUsingNodeJS:" + mainGLTF + "): " + err);
                                            if (callback)
                                                callback(false);
                                            return;
                                        }

                                        var jsonData;
                                        try {
                                            if (fileData.charCodeAt(0) === 65279)
                                                jsonData = JSON.parse(fileData.substring(1));
                                            else
                                                jsonData = JSON.parse(fileData);
                                        } catch (err) {
                                            GLTFViewer.Utils.WriteErr("ERROR(ReadUsingNodeJS): " + (err.message ? err.message : err) + " in JSON data");
                                            if (callback)
                                                callback(false);
                                            return;
                                        }
                                        this.ReadFile(mainGLTF, fileObj, jsonData, this.tmpDir.name, callback, loadTypeOverride);
                                    }).bind(this, mainGLTF, callback, loadTypeOverride));
                                } else {
                                    GLTFViewer.Utils.WriteErr("ERROR(ReadUsingNodeJS:" + filePath + "): No '*.gltf' found");
                                    if (callback)
                                        callback(false);
                                }
                            } else {
                                // AVZM
                                this.RemoveFile(fileObj);
                                var avzData = {};
                                var fileNames = this.tmpDir.FindAllFiles(/\.avz$/);
                                if (fileNames.length) {
                                    var newIdx = -1;
                                    var firstFileObj = null;
                                    var multiFile = [];
                                    for (var i = 0; i < fileNames.length; i++) {
                                        var f = fileNames[i];
                                        if (GLTFViewer.GetFileType(f) !== GLTFViewer.FT_AVZ)
                                            continue;
                                        var idx = this.FindFile(f, fileObj._file);
                                        if (idx < 0) {
                                            // not already added, so add it
                                            idx = this.AddFile(f, GLTFViewer.FT_AVZ, GLTFViewer.LT_REPLACE, null, fileObj._file, multiFile);
                                            if (idx >= 0)
                                                multiFile.push(this.Files()[idx]);
                                        }
                                        if (idx >= 0 && (newIdx < 0 || idx < newIdx)) {
                                            newIdx = idx;
                                            firstFileObj = this.Files()[newIdx];
                                        }
                                    }
                                    if (multiFile.length > 1)
                                        multiFile.sort(GLTFViewer.FileManager.FileNameCompare);
                                    if (firstFileObj) {
                                        this.SelectFile(firstFileObj, callback.bind(this, true)); // if firstFileObj fails to load, someone else will take care of it
                                        return;
                                    }
                                }

                                GLTFViewer.Utils.WriteErr("ERROR(ReadUsingNodeJS:" + filePath + "): No '*.avz' found");
                                if (callback)
                                    callback(false);
                            }
                        }

                        GLTFViewer.FileManager.UnZipFile(fileObj, CB.bind(this, fileObj, callback, loadTypeOverride));
                    }
                    break;
                case GLTFViewer.FT_SCDOC:
                case GLTFViewer.FT_DSGZ:
                    {
                        var fs = require('fs');
                        fs.readFile(filePath, (function (fileObj, filePath, callback, err, data) {
                            if (err) {
                                GLTFViewer.Utils.WriteErr("ERROR(ReadUsingNodeJS:" + filePath + "): " + err);
                                if (callback)
                                    callback(false);
                                return;
                            }
                            this.ReadFromArrayBuffer(fileObj, callback, loadTypeOverride, data);
                        }).bind(this, fileObj, filePath, callback));
                        return;
                    }
                    break;
                default:
                    // unsupported file type
                    if (callback)
                        callback(false);
                    break;
            }
        }
    },
    ShowARZ: {
        value: function (html) {
            if (!GLTFViewer.Utils.IsNull(this.iFrame) && !GLTFViewer.GetElementVisible(this.iFrame)) {
                document.title = "ANSYS Report Viewer";
                window.resizeBy(0, -1);
                window.resizeBy(0, 1);
                GLTFViewer.SetElementVisible(this.rootContainer, false);
                GLTFViewer.SetElementVisible(this.iFrame, true);
                if (!GLTFViewer.Utils.IsNull(this.iFrameMenu)) {
                    GLTFViewer.SetElementVisible(this.iFrameMenu, true);
                    this.MenuFade(true);
                }
            }
            this.iFrame.prop("src", html);
        }
    },
    HideARZ: {
        value: function () {
            if (!GLTFViewer.Utils.IsNull(this.iFrame) && GLTFViewer.GetElementVisible(this.iFrame)) {
                this.rootContainer.css("display", "flex");
                this.rootContainer.css("display", "-webkit-flex");
                GLTFViewer.SetElementVisible(this.iFrame, false);
                if (!GLTFViewer.Utils.IsNull(this.iFrameMenu))
                    GLTFViewer.SetElementVisible(this.iFrameMenu, false);
                this.iFrame.prop("src", "");
                //this.CloseFile(); // close ARZ file
                setTimeout((function () {
                    this.UpdateLayout();
                    this.controllingViewer.SetTitle("REFRESH");
                }).bind(this), 1);
            }
        }
    },
    ReadARZ: {
        value: function (url, callback) {
            try {
                var tmpDir = new GLTFViewer.Utils.TempDir(".");
                var AdmZip = require('adm-zip');
                var zip = new AdmZip(url);
                zip.extractAllTo(tmpDir.name, true);
                var mainHTML = tmpDir.FindFile(/\.html$|\.htm$/);
                if (callback)
                    callback(true);
                //this.Reset();
                this.ShowARZ(mainHTML);
            } catch (err) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadARZ): Can't decompress '" + url + "'");
                if (callback)
                    callback(false);
                return;
            }
        }
    },
    // this is how file manager loads a file
    LoadFile: {
        value: function (fileObj, callback, loadTypeOverride) {
            function CB(fileObj, callback, status) {
                this.Enable(true);
                this.scene.progressBar.Stop();
                if (callback)
                    callback(status);
            }

            try {
                this.Enable(false);
                setTimeout(this._LoadFile.bind(this, fileObj, CB.bind(this, fileObj, callback), loadTypeOverride), 0);
            } catch (err) {
                // this should not ever happen
                this.Enable(true);
                this.scene.progressBar.Stop();
                if (callback)
                    callback(false);
            }
        }
    },
    _LoadFile: {
        value: function (fileObj, callback, loadTypeOverride) {
            var file = fileObj._file;
            var fileType = fileObj._fileType;
            var resources = fileObj._resources;
            if (!this.scene) {
                if (callback)
                    callback(false);
                return;
            }
            var filePath = GLTFViewer.Utils.GetFilePath(file);

            if (fileType === GLTFViewer.FT_UNKNOWN) {
                if (callback)
                    callback(false);
                return;
            }

            var CB = (function (file, callback, status) {
                if (status) {
                    this.SetAnimationSlider(this.scene ? this.scene.AnimationMinTime() : 0, true);
                    this.SetAnimationMinMaxSpeed(this.scene.AnimationMinTime(), this.scene.AnimationMaxTime());
                } else
                    GLTFViewer.Utils.WriteErr("ERROR(LoadFile): Failed to load '" + GLTFViewer.Utils.GetFilePath(file) + "'");

                if (callback)
                    callback(status);
            }).bind(this, file, callback);

            var isObject = file instanceof Object;
            var isArrayBuffer = resources instanceof ArrayBuffer;

            if (isArrayBuffer) {
                this.ReadFromArrayBuffer(fileObj, CB, loadTypeOverride, resources);
                return;
            }

            if (this.hasNodeJS) {
                this.ReadUsingNodeJS(fileObj, CB, loadTypeOverride);
                return;
            }

            // file is file object
            if (isObject) {
                this.ReadFileObject(fileObj, CB, loadTypeOverride);
                return;
            }

            // file is a url
            this.ReadFilePath(fileObj, CB, loadTypeOverride);
        }
    },
    // main entry point for adding files/files
    AddFiles: {
        // files can be an array of url/path's or File objects, fileType is required for array of url/path's
        value: function (windowNum, _files, _fileType, _loadType, dontmultifile, callback) {
            _fileType = GLTFViewer.GetFileType(null, _fileType); // in case _fileType is a string, turn it into GLTFViewer.FT_*
            if (!this.scene || GLTFViewer.Utils.IsNull(_files)) {
                if (callback)
                    callback(false);
                return;
            }

            if (typeof _files === "string" || GLTFViewer.Utils.IsNull(_files.length))
                _files = [_files];

            var resources = {};

            if (_files.length > 1 || !(_files[0] instanceof ArrayBuffer)) {
                // if any of the files are AVZM or ARZ, load the first one we find
                for (var i = 0; i < _files.length; i++) {
                    var file = _files[i];
                    var ft = GLTFViewer.GetFileType(GLTFViewer.Utils.GetFilePath(file), _fileType);
                    if (ft === GLTFViewer.FT_AVZM || ft === GLTFViewer.FT_ARZ) {
                        _files = [file];
                        _fileType = ft;
                        break;
                    }
                }

                // get a known _fileType
                if (_fileType === GLTFViewer.FT_UNKNOWN) {
                    for (var i = 0; i < _files.length; i++) {
                        var file = _files[i];
                        var ft = GLTFViewer.GetFileType(GLTFViewer.Utils.GetFilePath(file), _fileType);
                        if (ft !== GLTFViewer.FT_UNKNOWN && ft !== GLTFViewer.FT_MUP && ft !== GLTFViewer.FT_VIEW) {
                            _fileType = ft;
                            break;
                        }
                    }
                    if (_fileType === GLTFViewer.FT_UNKNOWN) {
                        if (callback)
                            callback(false);
                        return;
                    }
                }

                // now get all files that are of _fileType
                // and repack files into resources, this will be needed for GLTF a file
                var newFiles = [];
                for (var i = 0; i < _files.length; ++i) {
                    var file = _files[i];
                    var fileName = GLTFViewer.Utils.GetFileName(GLTFViewer.Utils.GetFilePath(file));
                    var ft = GLTFViewer.GetFileType(fileName);
                    if ((typeof file === "string") && ft === GLTFViewer.FT_UNKNOWN)
                        ft = _fileType;
                    resources[fileName] = file;
                    if (ft === _fileType)
                        newFiles.push(file);
                }
                _files = newFiles;
            } else
                resources = _files[0];

            if (_files.length > 1)
                _loadType = GLTFViewer.LT_REPLACE;

            var newIdx = -1;
            var firstFileObj = null;
            var multiFile = [];
            for (var i = 0; i < _files.length; i++) {
                var file = _files[i];
                var fileType = GLTFViewer.GetFileType(GLTFViewer.Utils.GetFilePath(file), _fileType);
                if (fileType === GLTFViewer.FT_AVZ || fileType === GLTFViewer.FT_SCDOC || fileType === GLTFViewer.FT_DSGZ ||
                    fileType === GLTFViewer.FT_GLTF || fileType === GLTFViewer.FT_AVZM || fileType === GLTFViewer.FT_ARZ) {
                    var idx = this.FindFile(file, null);
                    if (idx < 0) {
                        // not already added, so add it
                        idx = this.AddFile(file, fileType, _loadType, resources, null, fileType !== GLTFViewer.FT_AVZM ? multiFile : []);
                        if (idx >= 0 && fileType !== GLTFViewer.FT_AVZM && !dontmultifile)
                            multiFile.push(this.Files()[idx]);
                    }
                    if (idx >= 0 && (newIdx < 0 || idx <= newIdx)) {
                        newIdx = idx;
                        firstFileObj = this.Files()[newIdx];
                    }
                }
            }
            if (multiFile.length > 1)
                multiFile.sort(GLTFViewer.FileManager.FileNameCompare);
            if (firstFileObj) {
                var viewer = this.GetViewer(windowNum);
                viewer.SelectFile(firstFileObj, callback);
            }
            else if (callback) // no files got added
                callback(false);
        }
    },
    ///////////////////////////////////////////////////////////////////////////
    //
    // External methods
    //
    CanSelect: {
        value: function () {
            if (!this.scene)
                return null;
            return this.scene.CanSelect();
        }
    },
    SetSelectionMode: {
        value: function (mode) {
            if (!this.scene)
                return null;
            return this.scene.SetSelectionMode(mode);
        }
    },
    GetTopParts: {
        value: function () {
            if (!this.scene)
                return null;
            return this.scene.GetTopParts();
        }
    },
    GetBodies: {
        value: function () {
            if (!this.scene)
                return null;
            return this.scene.GetBodies();
        }
    },
    SetHighlightBodyState: {
        value: function (name, on) {
            if (this.scene)
                this.scene.SetHighlightBodyState(name, on);
        }
    },
    GetPartName: {
        value: function (part) {
            if (!this.scene)
                return null;
            return this.scene.GetPartName(part);
        }
    },
    GetPartParent: {
        value: function (part) {
            if (!this.scene)
                return null;
            return this.scene.GetPartParent(part);
        }
    },
    GetPartParts: {
        value: function (part) {
            if (!this.scene)
                return null;
            return this.scene.GetPartParts(part);
        }
    },
    GetPartBodys: {
        value: function (part) {
            if (!this.scene)
                return null;
            return this.scene.GetPartBodys(part);
        }
    },
    GetBodyName: {
        value: function (body) {
            if (!this.scene)
                return null;
            return this.scene.GetBodyName(body);
        }
    },
    GetRegions: {
        value: function () {
            if (!this.scene)
                return null;
            return this.scene.GetRegions();
        }
    },
    GetRegionName: {
        value: function (region) {
            if (!this.scene)
                return null;
            return this.scene.GetRegionName(region);
        }
    },
    GetSelections: {
        value: function () {
            if (!this.scene)
                return null;
            return this.scene.GetSelections();
        }
    },
    GetParts: {
        value: function () {
            if (!this.scene)
                return null;
            return this.scene.GetParts();
        }
    },
    FileOpen: {
        value: function () {
            this.inputFile._ctrlKey = false;
            this._inputFile._shiftKey = false;
            this._inputFile._altKey = false;
            this.inputFile.click();
        }
    },
    FileLoad: {
        value: function (windowNum, url, urlType, loadType, callback) {
            this.AddFiles(windowNum, url, urlType, GLTFViewer.Utils.IsNull(loadType) ? GLTFViewer.LT_REPLACE : loadType, false, callback);
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer, {
    CM_MAIN_SELECT_FILE: { value: "Select File" },
    CM_MAIN_HIDE_BODY: { value: "Hide Body" },
    CM_MAIN_EDIT_PROPERTIES: { value: "Edit Properties" },
    CM_MAIN_CREATE_PROBE: { value: "Create Probe" },
    CM_MAIN_RESET_VIEW: { value: "Restore Defaults" },
    CM_MAIN_SAVE_VIEW: { value: "Save View" },
    CM_MAIN_DELETE_VIEW: { value: "Delete View" },
    CM_MAIN_SAVE_IMAGE: { value: "Save Image" },
    CM_MAIN_SAVE_IMAGE_PNG: { value: "PNG" },
    CM_MAIN_SAVE_IMAGE_STL: { value: "STL" },

    CM_MARKUP_DELETE_MARKUP: { value: "Delete Markup" },

    CM_FILE_CLOSE_FILE: { value: "Close File" },

    CM_SCENE_RESET_VIEW: { value: "Restore Defaults" },
    CM_SCENE_COPY_VIEW: { value: "Copy View" },
    CM_SCENE_DELETE_VIEW: { value: "Delete View" },

    CM_ENTRY_EDIT_PROPERTIES: { value: "Edit Properties" },

    FileManagerBtnHelp: { value: "View Manager" },
    fullHelp: { value: "Expand or restore viewer window" },

    viewportHelp: { value: "Split Viewer window" },
    viewportMenuBtnsHelp: { value: ["1 Viewport",
                                    "2 Viewports",
                                    "4 Viewports",
                                    "Synchronize viewports"]
    },
    fileHelp: { value: "Open local file" },
    printHelp: { value: "Print file" },
    closeHelp: { value: "Close file" },
    optionsHelp: { value: "Options" },
    saveHelpLocal: { value: "Save local AVZ file" },
    saveHelpServed: { value: "Save changes to server" },
    zoomHelp: { value: "Zoom to fit" },
    selectionHelp: { value: "Highlight mode" },
    clipHelp: { value: "Cut plane" },
    markupHelp: { value: "Markup" },
    explodeBtnHelp: { value: "Explode Model" },
    aboutHelp: { value: "Help" },
    selectionMenuBtnsHelp: { value: ["Highlight edge",
                                     "Highlight face",
                                     "Highlight body"]
    },
    aboutMenuBtnsHelp: { value: ["Viewer Help",
                                 "About"]
    },
    clipMenuBtnsHelp: { value: ["Cut plane Z",
                                "Cut plane X",
                                "Cut plane Y",
                                "Cut plane by point",
                                "Cut plane by three points",
                                "Move cut plane"]
    },
    markupMenuBtnsHelp: { value: ["2D",
                                  "3D",
                                  "Line shape",
                                  "Line color",
                                  "Font color",
                                  "Background color",
                                  "Font size"]
    },
    markupMenuBtns2D: { value: 0 },
    markupMenuBtns3D: { value: 1 },
    markupMenuBtnsLineShape: { value: 2 },
    markupMenuBtnsLineColor: { value: 3 },
    markupMenuBtnsFontColor: { value: 4 },
    markupMenuBtnsBackColor: { value: 5 },
    markupMenuBtnsFontSize: { value: 6 },

    markupLineShapeMenuBtnsHelp: { value: ["Line",
                                           "Arrow",
                                           "Ball"]
    },

    BORDERCOLOR: { value: "rgb(152, 168, 169)" },
    HOVERCOLOR: { value: "rgb(51, 152, 218)" },
    SELECTCOLOR: { value: "rgb(51, 152, 218)" },
    BUTTONCOLOR: { value: "rgb(189, 195, 199)" },
    MOUSEBUTTONS: { value: ["WHEEL",
                            "LEFT",
                            "MIDDLE",
                            "RIGHT",
                            "SHIFT+LEFT",
                            "SHIFT+MIDDLE",
                            "SHIFT+RIGHT",
                            "CTRL+LEFT",
                            "CTRL+MIDDLE",
                            "CTRL+RIGHT",
                            "CTRL+SHIFT+LEFT",
                            "CTRL+SHIFT+MIDDLE",
                            "CTRL+SHIFT+RIGHT"]
    },

    MSGLOCK: { value: "_LOCK_" },
    MSGIMAGE: { value: "_IMAGE_" },
    MSGTITLE: { value: "_TITLE_" },

    TITLEHEIGHT: { value: 30 },
    CONTAINER_INNER_MARGIN: { value: 5 },
    ICONSEPARATION: { value: 8 },

    LOGOWIDTH: { value: 129 },
    LOGOHEIGHT: { value: 96 },
    LOGOTOPMARGIN: { value: -20 },
    LOGORIGHTMARGIN: { value: -8 },

    ICONSIZE: { value: 32 },

    ICONNONE: { value: 0 },
    ICONFONTSIZE: { value: 0 },
    ICONZOOM: { value: 1 },
    ICONFILE: { value: 2 },
    ICONVIS: { value: 3 },
    ICONABOUT: { value: 4 },
    ICONABOUTHELP: { value: 4 },
    ICONABOUTABOUT: { value: 5 },
    ICONPLAY: { value: 6 },
    ICONPAUSE: { value: 7 },
    ICONSTOP: { value: 8 },
    ICONCLIP: { value: 9 },
    ICONCLIP0: { value: 10 },
    ICONCLIP1: { value: 11 },
    ICONCLIP2: { value: 12 },
    ICONCLIP3: { value: 13 },
    ICONCLIP4: { value: 14 },
    ICONCLIP5: { value: 15 },
    ICONFULL: { value: 16 },
    ICONMARKUPLINE: { value: 17 },
    ICONMARKUPARROW: { value: 18 },
    ICONMARKUPBALL: { value: 19 },
    ICONMARKUP2D: { value: 20 },
    ICONMARKUP3D: { value: 21 },
    ICONSAVE: { value: 22 },
    ICONFONTCOLOR: { value: 23 },
    ICONLINECOLOR: { value: 24 },
    ICONBACKCOLOR: { value: 25 },
    ICONMARKUP: { value: 26 },
    ICONFF: { value: 27 },
    ICONREW: { value: 28 },
    ICONLOOP: { value: 29 },
    ICONSELECTION: { value: 32 },
    ICONSELECTIONEDGE: { value: 30 },
    ICONSELECTIONFACE: { value: 31 },
    ICONSELECTIONBODY: { value: 32 },
    ICONEXPLODE: { value: 33 },
    ICONVP1: { value: 34 },
    ICONVP2: { value: 35 },
    ICONVP4: { value: 36 },
    ICONVPLOCK: { value: 37 },
    ICONOPTIONS: { value: 38 },
    ICONPRINT: { value: 39 },
    ICONCLOSE: { value: 40 },


    MODENORMAL: { value: 0 },     // normal icon
    MODEHOVER: { value: 1 },      // bold highlighted icon, displayed in layer on top of other icons
    MODESELECTED: { value: 2 },    // normal icon with orange background

    MENURESET: { value: 0 },
    MENUICON: { value: 1 },
    MENUCLICK: { value: 2 }, // toggles open/close
    MENUOPEN: { value: 3 },
    MENUCLOSE: { value: 4 },
    MENUCLOSEALL: { value: 5 },
    MENUSHOW: { value: 6 },
    MENUHIDE: { value: 7 },
    MENUHIDEALL: { value: 8 },
    MENUENABLE: { value: 9 },
    MENUDISABLE: { value: 10 },
    MENUDISABLEALL: { value: 11 },
    MENUCHECK: { value: 12 },
    MENUUNCHECK: { value: 13 },
    MENUUNCHECKALL: { value: 14 },

    FT_UNKNOWN: { value: 0 },
    FT_GLTF: { value: 1 },
    FT_SCDOC: { value: 2 },
    FT_AVZ: { value: 3 },
    FT_ARZ: { value: 4 },
    FT_MUP: { value: 5 },
    FT_VIEW: { value: 6 },
    FT_AVZM: { value: 7 },  // MULTI-AVZ
    FT_DSGZ: { value: 8 },

    SELECTION_NONE: { value: -1 },
    SELECTION_EDGE: { value: 0 },
    SELECTION_FACE: { value: 1 },
    SELECTION_BODY: { value: 2 },

    LT_REPLACE: { value: 0 }, // replace loaded file with new file
    LT_APPEND: { value: 1 }, // update same nodes, add new nodes, do not remove other nodes
    LT_UPDATE: { value: 2 }, // update same nodes, add new nodes, remove other nodes

    DEFAULT_MARKUP_FONT_SIZE: { value: 16 },

    // methods
    GetFileType: {
        value: function (fileName, fileType) {
            if (!GLTFViewer.Utils.IsNull(fileType)) {
                if (fileType === "GLTF" || fileType === GLTFViewer.FT_GLTF)
                    return GLTFViewer.FT_GLTF;
                if (fileType === "SCDOC" || fileType === GLTFViewer.FT_SCDOC)
                    return GLTFViewer.FT_SCDOC;
                if (fileType === "AVZ" || fileType === GLTFViewer.FT_AVZ)
                    return GLTFViewer.FT_AVZ;
                if (fileType === "ARZ" || fileType === GLTFViewer.FT_ARZ)
                    return GLTFViewer.FT_ARZ;
                if (fileType === "MUP" || fileType === GLTFViewer.FT_MUP)
                    return GLTFViewer.FT_MUP;
                if (fileType === "VIEW" || fileType === GLTFViewer.FT_VIEW)
                    return GLTFViewer.FT_VIEW;
                if (fileType === "AVZM" || fileType === GLTFViewer.FT_AVZM)
                    return GLTFViewer.FT_AVZM;
            }

            if (fileName instanceof Array)
                fileName = fileName[0];
            if (GLTFViewer.Utils.IsNull(fileName) || (typeof fileName !== 'string') || fileName.length === 0)
                return GLTFViewer.FT_UNKNOWN;

            var fileExt = GLTFViewer.Utils.GetExtension(fileName);
            if (fileExt === "json" || fileExt === "gltf")
                return GLTFViewer.FT_GLTF;
            if (fileExt === "scdoc")
                return GLTFViewer.FT_SCDOC;
            if (fileExt === "dsgz")
                return GLTFViewer.FT_DSGZ;
            if (fileExt === "avz")
                return GLTFViewer.FT_AVZ;
            if (fileExt === "arz")
                return GLTFViewer.FT_ARZ;
            if (fileExt === "mup")
                return GLTFViewer.FT_MUP;
            if (fileExt === "view")
                return GLTFViewer.FT_VIEW;
            if (fileExt === "avzm")
                return GLTFViewer.FT_AVZM;

            return GLTFViewer.FT_UNKNOWN;
        }
    },
    GetFileTypeExt: {
        value: function (fileType) {
            if (fileType === "GLTF" || fileType === GLTFViewer.FT_GLTF)
                return "gltf";
            if (fileType === "SCDOC" || fileType === GLTFViewer.FT_SCDOC)
                return "scdoc";
            if (fileType === "DSGZ" || fileType === GLTFViewer.FT_DSGZ)
                return "dsgz";
            if (fileType === "AVZ" || fileType === GLTFViewer.FT_AVZ)
                return "avz";
            if (fileType === "ARZ" || fileType === GLTFViewer.FT_ARZ)
                return "arz";
            if (fileType === "MUP" || fileType === GLTFViewer.FT_MUP)
                return "mup";
            if (fileType === "VIEW" || fileType === GLTFViewer.FT_VIEW)
                return "view";
            if (fileType === "AVZM" || fileType === GLTFViewer.FT_AVZM)
                return "avzm";

            return "unknown";
        }
    },
    SetElementCheck: {
        value: function (element, check) {
            if (GLTFViewer.Utils.IsNull(element))
                return;
            GLTFViewer.SetElemColor(element, (GLTFViewer.Utils.IsNull(check) || check) ? GLTFViewer.MODESELECTED : GLTFViewer.MODENORMAL);
        }
    },
    GetElementCheck: {
        value: function (element) {
            if (GLTFViewer.Utils.IsNull(element))
                return false;
            var c = element.css("background-color");
            return c === GLTFViewer.SELECTCOLOR;
        }
    },
    SetElementEnable: {
        value: function (element, enable) {
            if (GLTFViewer.Utils.IsNull(element))
                return;
            if (GLTFViewer.Utils.IsNull(enable) || enable) {
                element.css("opacity", 1);
                element.prop("disabled", false);
            } else {
                element.css("opacity", 0.3);
                element.prop("disabled", true);
            }
        }
    },
    GetElementEnable: {
        value: function (element) {
            return !GLTFViewer.Utils.IsNull(element) && GLTFViewer.GetElementVisible(element) && !element.prop("disabled");
        }
    },
    SetElementVisible: {
        value: function (element, visible) {
            if (GLTFViewer.Utils.IsNull(element))
                return;
            if (visible) {
                element.css("display", "block");
            } else {
                element.css("display", "none");
            }
        }
    },
    GetElementVisible: {
        value: function (element) {
            return !GLTFViewer.Utils.IsNull(element) && element.css("display") !== "none";
        }
    },
    SetElemColor: {
        value: function (element, mode) {
            if (mode === GLTFViewer.MODESELECTED)
                element.css("background-color", GLTFViewer.SELECTCOLOR);
            else
                element.css("background-color", GLTFViewer.BUTTONCOLOR);
        }
    },
    MakeUnselectable: {
        value: function (element) {
            if (element.nodeType == 1)
                element.setAttribute("unselectable", "on");
            var child = element.firstChild;
            while (child) {
                GLTFViewer.MakeUnselectable(child);
                child = child.nextSibling;
            }
        }
    },
    IsURL: {
        value: function (path) {
            var isAbsolutePathRegExp = new RegExp("^\\\\", "i");
            if (path.match(isAbsolutePathRegExp))
                return false;

            try {
                var url = require('url');
                var urlObj = url.parse(path, true, true); // this treats \\hostname\Share\... as a URL,  DE164100
                if (urlObj && urlObj.host)
                    return true;
            } catch (err) {
            }

            // this is not the best way to do this
            isAbsolutePathRegExp = new RegExp("^[a-z]:", "i");
            if (path.match(isAbsolutePathRegExp))
                return false; // drive letter
            isAbsolutePathRegExp = new RegExp("^.*://", "i");
            if (path.match(isAbsolutePathRegExp))
                return true;

            return false;
        }
    }
});
///////////////////////////////////////////////////////////////////////////////
GLTFViewer.FileManager = function (controllingViewer, numWindows, sideContainer) {
    this._controllingViewer = controllingViewer;
    this._numWindows = numWindows;
    this._files = [];
    this._activeFileObj = [];
    this._panel = new GLTFViewer.FileManager.Panel(this._controllingViewer, this, numWindows, sideContainer);
};
GLTFViewer.FileManager.prototype = Object.create(null, {
    // private members
    _controllingViewer: { writable: true, value: null },
    _numWindows: { writable: true, value: null },
    _panel: { writable: true, value: null },
    _files: { writable: true, value: null }, // array of file names/handles
    _activeFileObj: { writable: true, value: null }, // current active file
    // public members
    numFiles: {
        get: function () {
            return this._files.length;
        }
    },
    files: {
        get: function () {
            return this._files;
        }
    },
    fileNames: {
        get: function () {
            var names = [];
            for (var i = 0; i < this.numFiles; ++i) {
                var name = this._files[i]._name;
                if (this._files[i]._mTime) {
                    var d = new Date(this._files[i]._mTime);
                    name = name + " " + d.toLocaleString();
                }
                names.push(name);
            }

            return names;
        }
    },
    filePaths: {
        get: function () {
            var paths = [];
            for (var i = 0; i < this.numFiles; ++i)
                paths.push(this._files[i]._path);
            return paths;
        }
    },
    // private methods
    // public methods
    ActiveFileObj: {
        value: function (viewer) {
            var windowNum = !GLTFViewer.Utils.IsNull(viewer.viewportNumber) ? viewer.viewportNumber : viewer;
            return this._activeFileObj[windowNum];
        }
    },
    ActiveFileIndex: {
        value: function (viewer) {
            return this.FindFile(this.ActiveFileObj(viewer));
        }
    },
    ///////////////////////////////////
    AddFile: {
        // add another file to list, does not load the file
        // file could be a filepath name
        //  or it could be a browser file object returned from a selection dialog or drag and drop
        value: function (viewer, file, fileType, loadType, resources, containerFile, multiFile) {
            var idx = this.FindFile(file, containerFile);
            if (idx >= 0)
                return idx; // already added

            // add to _files
            var fileObj = new GLTFViewer.FileManager.FileObject(file, fileType, loadType, resources, containerFile, multiFile);
            this._files.push(fileObj);

            // sort it to correct location
            this._files.sort(GLTFViewer.FileManager.FileNameCompare);

            // refind its location
            return this.FindFile(fileObj); // this better not fail
        }
    },
    RemoveFile: {
        // remove fileObj and return what should become active, probably only works for AVZM files
        value: function (viewer, fileObj) {
            if (GLTFViewer.Utils.IsNull(fileObj))
                return; // no fileObj

            var idx = this.FindFile(fileObj);
            if (idx < 0)
                return; // file not found;

            var activeFileObj = this.ActiveFileObj(viewer);
            var deleteActive = fileObj == activeFileObj;
            if (deleteActive)
                this.CloseFile(viewer);

            // remove from multiFile
            for (var i = 0; i < fileObj.NumMultiFiles(); ++i) {
                if (fileObj === fileObj._multiFile[i]) {
                    fileObj._multiFile.splice(i, 1);
                    break;
                }
            }
            // remove from _files
            this._files.splice(idx, 1);
            //viewer.SetMultiFileSlider();

            if (this.numFiles === 0) {
                this._controllingViewer.Reset(); // this should call our Reset
                return;
            }
        }
    },
    SelectFile: {
        value: function (viewer, fileObj, callback, loadTypeOverride) {
            function Callback(viewer, activeFileObj, fileObj, callback, status) {
                if (fileObj._fileType !== GLTFViewer.FT_AVZM && fileObj._fileType !== GLTFViewer.FT_ARZ) {
                    if (status) {
                        this._activeFileObj[viewer.viewportNumber] = fileObj;
                        var file = fileObj._file;
                        var filePath = GLTFViewer.Utils.GetFilePath(file);
                        viewer.SetTitle("WRITE", fileObj._name);
                        var idx = this.ActiveFileIndex(viewer);
                        if (this._panel)
                            this._panel.SelectFile(viewer.viewportNumber, fileObj);
                    } else {
                        this.CloseFile(viewer); // close previous file so can reload it, may not have to do this, depends when fileObj failure occurred
                        this.RemoveFile(viewer, fileObj); // failed to load, remove it
                        if (callback)
                            callback(false);
                        return;
                    }

                    // cleanup should have been handled in this._viewer.LoadFile
                    viewer.SetMultiFileSlider();
                }
                if (callback)
                    callback(status);
            }
            if (GLTFViewer.Utils.IsNull(fileObj)) {
                if (callback)
                    callback(true);
                return;
            }

            if (!(fileObj instanceof GLTFViewer.FileManager.FileObject) && !isNaN(fileObj)) {
                fileObj = parseInt(fileObj);
                if (fileObj > this.numFiles - 1)
                    fileObj = this.numFiles - 1;
                else if (fileObj < 0)
                    fileObj = 0;
                fileObj = this._files[fileObj];
            }
            if (!fileObj) {
                if (callback)
                    callback(true);
                return;
            }

            var activeFileObj = this.ActiveFileObj(viewer);
            if (GLTFViewer.FileManager.AlmostSameFiles(fileObj._file, fileObj._containerFile, activeFileObj) &&
                !GLTFViewer.FileManager.SameFiles(fileObj._file, fileObj._containerFile, fileObj._mTime, activeFileObj)) {
                // remove activeFileObj
                this.RemoveFile(viewer, activeFileObj);
                // remove all files from fileObj._containerFile
                if (!GLTFViewer.Utils.IsNull(fileObj._containerFile)) {
                    for (var i = 0; i < this._files.length; ++i) {
                        var file = this._files[i];
                        if (fileObj._containerFile === file._containerFile)
                            this.RemoveFile(viewer, file);
                    }
                }
            }

            if (!GLTFViewer.FileManager.SameFiles(fileObj._file, fileObj._containerFile, fileObj._mTime, activeFileObj)) {
                viewer.SaveBtnState(null, fileObj._containerFile ? GLTFViewer.MENUDISABLE : GLTFViewer.MENUENABLE);
                viewer.LoadFile(fileObj, Callback.bind(this, viewer, activeFileObj, fileObj, callback), loadTypeOverride);
            } else {
                if (callback)
                    callback(true);
            }
        }
    },
    CloseFile: {
        value: function (viewer, dontResetScene) {
            var windowNum = viewer.viewportNumber;
            if (this._panel)
                this._panel.CloseFile(windowNum);
            this._activeFileObj[windowNum] = null;
            viewer.Reset(dontResetScene);
        }
    },
    IsMultiFile: {
        value: function (fileObj) {
            var idx = this.FindFile(fileObj);
            if (idx < 0)
                return false; // file not found;
            return this._files[idx].NumMultiFiles() > 1;
        }
    },
    ///////////////////////////////////
    AddScene: {
        value: function (viewer, sceneItem, callback) {
            if (!this._panel)
                return null;
            return this._panel.AddScene(viewer.viewportNumber, sceneItem, callback);
        }
    },
    RemoveScene: {
        value: function (viewer, li) {
            if (this._panel)
                this._panel.RemoveScene(viewer.viewportNumber, li);
        }
    },
    SelectScene: {
        value: function (viewer, li) {
            if (this._panel)
                this._panel.SelectScene(viewer.viewportNumber, li);
        }
    },
    ///////////////////////////////////
    AddEntry: {
        value: function (viewer, name, visible, visCallback, editCallback, parentVisList, onlyGroups) {
            if (!this._panel)
                return null;
            return this._panel.AddEntry(viewer.viewportNumber, name, visible, visCallback, editCallback, parentVisList, onlyGroups);
        }
    },
    RemoveEntry: {
        value: function (viewer, entry) {
            if (this._panel)
                this._panel.RemoveEntry(viewer.viewportNumber, entry);
        }
    },
    RemoveAllEntries: {
        value: function (viewer) {
            if (this._panel)
                this._panel.RemoveAllEntries(viewer.viewportNumber);
        }
    },
    ///////////////////////////////////
    CloseContextMenus: {
        value: function () {
            if (this._panel)
                this._panel.CloseContextMenus();
        }
    },
    IsPanelVisible: {
        value: function () {
            if (!this._panel)
                return false;
            return this._panel.IsVisible();
        }
    },
    ShowPanel: {
        value: function (show) {
            if (this._panel)
                this._panel.Show(show);
        }
    },
    FindFile: {
        value: function (file, containerFile) {
            if (GLTFViewer.Utils.IsNull(file))
                return -1;
            if (GLTFViewer.Utils.IsNull(containerFile) && !GLTFViewer.Utils.IsNull(file._containerFile))
                containerFile = file._containerFile;
            if (!GLTFViewer.Utils.IsNull(file._fileType))
                file = file._file;
            var mTime = GLTFViewer.FileManager.GetMTime(file, containerFile);
            for (var i = 0; i < this.numFiles; ++i) {
                if (GLTFViewer.FileManager.SameFiles(file, containerFile, mTime, this._files[i]))
                    return i;
            }
            return -1;
        }
    },
    Reset: {
        // reset to initially created state
        value: function () {
            if (this._panel)
                this._panel.Reset();
        }
    },
    Clear: {
        // clear to ready for deletion state
        value: function () {
            GLTFViewer.FileManager.prototype.Reset.call(this);
            if (this._panel)
                this._panel.Clear();
            this._controllingViewer = null;
            this._files = null;
            this._activeFileObj = null;
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.FileManager, {
    AlmostSameFiles: {
        value: function (file1, containerFile, file2) {
            if (GLTFViewer.Utils.IsNull(file1) || GLTFViewer.Utils.IsNull(file2))
                return false;
            var fileSame = GLTFViewer.Utils.GetFilePath(file1) === GLTFViewer.Utils.GetFilePath(file2._file);
            var containerSame = GLTFViewer.Utils.GetFilePath(containerFile) === GLTFViewer.Utils.GetFilePath(file2._containerFile);
            return fileSame && containerSame;
        }
    },
    SameFiles: {
        value: function (file1, containerFile, mTime, file2) {
            if (GLTFViewer.Utils.IsNull(file1) || GLTFViewer.Utils.IsNull(file2))
                return false;
            if (!GLTFViewer.FileManager.AlmostSameFiles(file1, containerFile, file2))
                return false;
            var mTimeSame = mTime === file2._mTime;
            return mTimeSame;
        }
    },
    FileNameCompare: {
        value: function (a, b) {
            function NameMatch(aN, aT, bN, bT) {
                var aL = aN.length;
                var bL = bN.length;
                if (aL === 0 && bL === 0)
                    return 0;
                if (aL === 0 || bL === 0) {
                    if (aL === 0)
                        return -1;
                    return 1;
                }
                var ae = GLTFViewer.Utils.GetExtension(aN);
                var be = GLTFViewer.Utils.GetExtension(bN);
                aN = GLTFViewer.Utils.RemoveExt(aN);
                bN = GLTFViewer.Utils.RemoveExt(bN);
                var re = /(\D)+|(\d)+/g;
                var aParts = aN.match(re);
                var bParts = bN.match(re);
                var l = Math.min(aParts.length, bParts.length);
                for (var i = 0; i < l; ++i) {
                    var ap = aParts[i];
                    var bp = bParts[i];
                    if (ap === bp)
                        continue;
                    if (!isNaN(ap) && !isNaN(bp))
                        return ap - bp;
                    else
                        return ap.localeCompare(bp);
                }
                if (ae === be) {
                    if (aParts.length === bParts.length) {
                        return aT - bT;
                    }
                    return aParts.length - bParts.length;
                }
                return ae < be;
            }
            var aName = a._name.toUpperCase().trim();
            var aMTime = a._mTime;
            var bName = b._name.toUpperCase().trim();
            var bMTime = b._mTime;
            var nameCompare = NameMatch(aName, aMTime, bName, bMTime);

            if (nameCompare === 0) {
                var aContainerName = a._containerFile ? GLTFViewer.Utils.RemoveExt(GLTFViewer.Utils.GetFileName(GLTFViewer.Utils.GetFilePath(a._containerFile))).toUpperCase().trim() : "";
                var aContainerMTime = a._containerFile ? a._containerFile._mTime : 0;
                var bContainerName = b._containerFile ? GLTFViewer.Utils.RemoveExt(GLTFViewer.Utils.GetFileName(GLTFViewer.Utils.GetFilePath(b._containerFile))).toUpperCase().trim() : "";
                var bContainerMTime = b._containerFile ? b._containerFile._mTime : 0;
                nameCompare = NameMatch(aContainerName, aContainerMTime, bContainerName, bContainerName);
            }

            return nameCompare;
        }
    },
    GetMTime: {
        value: function (file, containerFile) {
            function GetTime(f) {
                if (f.lastModified)
                    return f.lastModified;
                if (f.lastModifiedDate) {
                    var d = new Date(f.lastModifiedDate);
                    return d.getTime();
                }

                var fs;
                try {
                    fs = require('fs');
                    var fp = GLTFViewer.Utils.GetFilePath(f);
                    var stat = fs.statSync(fp);
                    if (stat)
                        return stat.mtime.getTime();
                } catch (err) {
                }

                return 0;
            }

            if (GLTFViewer.Utils.IsNull(file))
                return 0;

            if (GLTFViewer.Utils.IsNull(containerFile) && !GLTFViewer.Utils.IsNull(file._containerFile))
                containerFile = file._containerFile;
            if (!GLTFViewer.Utils.IsNull(file._fileType))
                file = file._file;


            // if containerFile, return its time
            if (!GLTFViewer.Utils.IsNull(containerFile)) {
                var t = GetTime(containerFile);
                if (t)
                    return t;
            }

            // else return file time
            return GetTime(file);
        }
    },
    UnZipFile: {
        value: function (fileObj, callback) {
            if (GLTFViewer.Utils.IsNull(fileObj)) {
                callback(null);
                return;
            }
            var dir = fileObj._dir;
            if (!GLTFViewer.Utils.IsNull(dir)) {
                callback(dir); // already unzipped
                return;
            }

            var filePath = GLTFViewer.Utils.GetFilePath(fileObj._file);
            if (!GLTFViewer.IsURL(filePath)) {
                try {
                    var tmpDir = new GLTFViewer.Utils.TempDir(".");
                    var AdmZip = require('adm-zip');
                    var zip = new AdmZip(filePath);
                    zip.extractAllTo(tmpDir.name, true);
                    fileObj._dir = tmpDir;
                    callback(tmpDir);
                    return;
                } catch (err) {
                }

                callback(null);
            }

            // maybe it is a URL
            var fileName = GLTFViewer.Utils.GetFileName(filePath);
            try {
                var fileType = fileObj._fileType;
                var tmpDir = new GLTFViewer.Utils.TempDir(".");
                var path = require('path');
                fileName = path.join(tmpDir.name, fileName);

                function DownLoad(url, dest, cb) {
                    var http = require('http');
                    var request = http.get(url, (function (dest, cb, response) {
                        if (response.statusCode !== 200)
                            cb(false);
                        else {
                            var fs = require('fs');
                            var file = fs.createWriteStream(dest);
                            response.pipe(file);
                            file.on('finish', function () {
                                file.close(cb.bind(this, true));  // close() is async, call cb after close completes.
                            });
                        }
                    }).bind(this, dest, cb)).on('error', (function (cb) { // Handle errors
                        cb(false);
                    }).bind(this, cb));
                };

                function CB(tmpDir, fileObj, callback, dest, status) {
                    if (!status) {
                        callback(null);
                        return;
                    }

                    var AdmZip = require('adm-zip');
                    var zip = new AdmZip(dest);
                    zip.extractAllTo(tmpDir.name, true);
                    fileObj._dir = tmpDir;
                    callback(tmpDir);
                }
                DownLoad(filePath, fileName, CB.bind(this, tmpDir, fileObj, callback, fileName));
                return;
            } catch (err) {
            }

            callback(null);
        }
    }
});
///////////////////////////////////////////////////////////////////////////////
GLTFViewer.FileManager.FileObject = function (file, fileType, loadType, resources, containerFile, multiFile) {
    var filePath = GLTFViewer.Utils.GetFilePath(file);

    this._file = file;
    this._name = GLTFViewer.Utils.GetFileName(filePath);
    if (GLTFViewer.GetFileType(this._name) !== fileType)
        this._name = "ANSYSViewer." + GLTFViewer.GetFileTypeExt(fileType);
    this._fileType = fileType;
    this._loadType = loadType;
    this._mTime = GLTFViewer.FileManager.GetMTime(file, containerFile);
    this._resources = resources;
    this._containerFile = containerFile;
    this._multiFile = multiFile;
    this._path = containerFile ? GLTFViewer.Utils.GetFilePath(containerFile) : filePath;
    this._isURL = GLTFViewer.IsURL(this._path); // only used by nodeJS
};
GLTFViewer.FileManager.FileObject.prototype = Object.create(null, {
    // private members
    _file: { writable: true, value: null },
    _name: { writable: true, value: null },
    _fileType: { writable: true, value: null },
    _loadType: { writable: true, value: null },
    _mTime: { writable: true, value: null },
    _resources: { writable: true, value: null },
    _containerFile: { writable: true, value: null },
    _multiFile: { writable: true, value: null },
    _dir: { writable: true, value: null },
    _path: { writable: true, value: null },
    _isURL: { writable: true, value: false },
    // public methods
    GetMultiFiles: {
        value: function () {
            if (!this._multiFile)
                return [];
            return this._multiFile.filter(function (x) { return x !== undefined && x != null; });
        }
    },
    NumMultiFiles: {
        value: function () {
            return this.GetMultiFiles().length;
        }
    }
});
///////////////////////////////////////////////////////////////////////////////
GLTFViewer.FileManager.Panel = function (controllingViewer, fileManager, numWindows, container) {
    this._controllingViewer = controllingViewer;
    this._fileManager = fileManager;
    this._numWindows = numWindows;

    var PanelWidth = 230;

    container.append("<div style='display:none;padding:0;margin:0;border:0;min-width:" + PanelWidth + "px;height:100%;overflow:hidden;background:white;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:-moz-none;-ms-user-select:none;-o-user-select:none;user-select:none;'></div>");
    this._panel2 = $("div", container).last();
    if (!controllingViewer.mobile) {
        this._resizeBarSize = 3;
        this._panel2.append("<div style='float:right;padding:0;margin:0;width:0;height:100%;border-right:" + this._resizeBarSize + "px ridge " + GLTFViewer.BORDERCOLOR + ";'></div>");
        var resizeReticle = $("div", this._panel2).last();
        resizeReticle.hover(function () {
            $(this).css('cursor', 'ew-resize');
        }, function () {
            $(this).css('cursor', '');
        });
        this._resizeTouchHandler = new GLTFViewer.Utils.TouchHandler(controllingViewer, resizeReticle, null, this._Resize.bind(this));
    } else {
        this._resizeBarSize = 1;
        this._panel2.append("<div style='float:right;padding:0;margin:0;width:0;height:100%;border-right:" + this._resizeBarSize + "px ridge " + GLTFViewer.BORDERCOLOR + ";'></div>");
        var url = GLTFViewer.Utils.Dialog.GeneratePanelResizeURL(16, 32, GLTFViewer.BORDERCOLOR);
        container.append("<img src='" + url + "' style='display:none;z-index:99991;position:absolute;bottom:25%;left:100px;background:transparent;'></img>");
        this._resizeTouchImage = $("img", container).last();

        this._resizeTouchImage.hover(function () {
            $(this).css('cursor', 'ew-resize');
        }, function () {
            $(this).css('cursor', '');
        });
        this._resizeTouchHandler = new GLTFViewer.Utils.TouchHandler(controllingViewer, this._resizeTouchImage, null, this._Resize.bind(this));
    }

    this._panel2.append("<div class='view-man-panel' style='padding:0;margin:0;width:" + (PanelWidth - this._resizeBarSize) + "px;height:100%;overflow:auto;background:white;'></div>");
    this._panel = $("div", this._panel2).last();

    // since we have a border, space with padding
    this._minWidth = 120; // needs to encompass "View Manager" x
    this._panel.append("<div style='padding:" + GLTFViewer.CONTAINER_INNER_MARGIN + "px;border-bottom:1px solid " + GLTFViewer.BORDERCOLOR + ";'></div>");
    var header = $("div", this._panel).last();
    header.append("<label style='display:inline;padding:0;margin:0;border:0;font-size:14px;font-family:Segoe UI,Arial,Helvetica,sans-serif;'>View Manager</label>");
    header.append("<a style='float:right;font-size:13px;'>&#10005;</a>");
    var cancel = $("a", header).last();
    cancel.hover(function () {
        $(this).css('color', GLTFViewer.HOVERCOLOR);
        $(this).css('cursor', 'pointer');
    }, function () {
        $(this).css('color', 'black');
        $(this).css('cursor', '');
    });
    cancel.click((function (e) {
        // close the panel
        e.stopPropagation();
        this._controllingViewer.CloseContextMenus();
        this._controllingViewer.GetMainUIViewer().FileManagerBtnState(e, GLTFViewer.MENUCLOSE);
    }).bind(this));
    this._panel.click((function (e) {
        this._controllingViewer.CloseContextMenus();
    }).bind(this));

    this._fileContainer = [];
    this._sceneContainer = [];
    this._visibilityList = [];
    for (var i = 0; i < numWindows; ++i) {
        // ul for file
        this._panel.append("<ul style='list-style-type:none;padding:0;margin:" + GLTFViewer.CONTAINER_INNER_MARGIN + "px;'></ul>");
        var ul = $("ul", this._panel).last();
        ul.append("<label style='padding:0;margin:0;border:0;font-size:14px;font-family:Segoe UI,Arial,Helvetica,sans-serif;white-space:nowrap'></label>");
        var lab = $("label", ul).last();
        if (this._controllingViewer.wantViewport)
            lab.text("Window " + (i + 1));

        lab.__th__ = this._BuildFileContextMenu(i, lab);

        // ul for scenes
        ul.append("<ul style='list-style-type:none;padding:0;margin-left:15px;'></ul>");
        this._sceneContainer[i] = $("ul", ul).last();

        this._fileContainer[i] = ul;
    }

    GLTFViewer.MakeUnselectable(this._panel[0]);

    GLTFViewer.Utils.NoContext(this._controllingViewer, this._panel);

    if (this._controllingViewer.wantPropertyEdit) {
        function contextEntryCallback(val, other) {
            var item = val[0];
            switch (item) {
                case GLTFViewer.CM_ENTRY_EDIT_PROPERTIES:
                    if (other)
                        other();
                    break;
            }
        }
        this._contextMenuEntry = new GLTFViewer.Utils.SimpleContextMenu(this._controllingViewer, this._controllingViewer.body, [GLTFViewer.CM_ENTRY_EDIT_PROPERTIES], null, contextEntryCallback.bind(this));
    }
};
GLTFViewer.FileManager.Panel.prototype = Object.create(null, {
    // private members
    _controllingViewer: { writable: true, value: null },
    _numWindows: { writable: true, value: 0 },
    _fileManager: { writable: true, value: null },
    _panel: { writable: true, value: null },
    _panel2: { writable: true, value: null },
    _resizeBarSize: { writable: true, value: 0 },
    _fileContainer: { writable: true, value: null }, // where we put file radio-like buttons
    _sceneContainer: { writable: true, value: null }, // where we put scene radio-like buttons
    _visibilityList: { writable: true, value: null }, // where we put visList objects
    _lastClickedVisList: { writable: true, value: null },
    _contextMenuFile: { writable: true, value: null },
    _contextMenuScene: { writable: true, value: null },
    _contextMenuEntry: { writable: true, value: null },
    _resizeTouchHandler: { writable: true, value: null },
    _resizeTouchImage: { writable: true, value: null },
    // private methods
    _SetSize: {
        value: function (w) {
            if (w < this._minWidth)
                w = this._minWidth;
            var maxWidth = this._controllingViewer._nonFullContainer.width();
            //var height = this._controllingViewer._nonFullContainer.height();
            if (maxWidth > 20)
                maxWidth -= 20;
            if (w > maxWidth)
                w = maxWidth;
            this._panel2.css("min-width", w + "px");
            this._panel2.css("width", w + "px");
            this._panel2.css("height", "100%");
            this._panel.css("width", (w - this._resizeBarSize) + "px");
            this._panel.css("height", "100%");
            this._panel.toggle().toggle();
            if (this._resizeTouchImage)
                this._resizeTouchImage.css("left", w + "px");
            this._controllingViewer.UpdateLayout();
        }
    },
    _Resize: {
        value: function (e) {
            var cnt = this._resizeTouchHandler.Touches.Count();
            // no touches or mouse presses
            if (cnt === 0)
                return;
            // 1 touch or 1 mouse button pressed
            if (cnt === 1) {
                var touch = this._resizeTouchHandler.Touches.GetTouchByIndex(0);
                var touchID = touch.GetID();
                if (touchID === 0 || touchID === 1) {
                    // resize dialog
                    var t = this._resizeTouchHandler.Touches.GetStartDelta(1);
                    var dialogWidth = this._panel2.width() + t.x;
                    this._SetSize(dialogWidth);
                }
            }
        }
    },
    _BuildFileContextMenu: {
        value: function (wihdowNum, lab) {
            if (!this._controllingViewer.wantFile)
                return;

            function contextCallback(windowNum, e) {
                function contextFileCallback(val, windowNum) {
                    var item = val[0];
                    var idx = val[1];
                    var parentItem = val.length > 2 ? val[2] : "";
                    var viewer = this._controllingViewer.GetViewerByNumber(windowNum);
                    switch (item) {
                        case GLTFViewer.CM_FILE_CLOSE_FILE:
                            if (viewer)
                                this._fileManager.CloseFile(viewer);
                            break;
                        default:
                            if (parentItem === GLTFViewer.CM_MAIN_SELECT_FILE) {
                                if (viewer)
                                    viewer.SelectFile(idx);
                            }
                            break;
                    }
                }

                var items = [];
                var help = [];
                items.push(GLTFViewer.CM_FILE_CLOSE_FILE);
                help.push(null);
                var fileNames = null;
                var numFiles = this._fileManager.numFiles;
                if (numFiles) {
                    var files = [GLTFViewer.CM_MAIN_SELECT_FILE];
                    var paths = [null];
                    fileNames = this._fileManager.fileNames;
                    files = files.concat(fileNames);
                    items.push(files);
                    var filePaths = this._fileManager.filePaths;
                    paths = paths.concat(filePaths);
                    help.push(paths);
                }
                this._contextMenuFile = new GLTFViewer.Utils.SimpleContextMenu(this._controllingViewer, this._controllingViewer.body, items, help, contextFileCallback.bind(this));

                e.preventDefault();
                e.stopPropagation();
                var enable = {};
                enable[GLTFViewer.CM_FILE_CLOSE_FILE] = !GLTFViewer.Utils.IsNull(this._fileManager.ActiveFileObj(windowNum));
                if (numFiles) {
                    enable[GLTFViewer.CM_MAIN_SELECT_FILE] = 1;
                    for (var i = 0; i < fileNames.length; ++i)
                        enable[fileNames[i]] = 1;
                }
                this._contextMenuFile.Show(true, e, enable, windowNum);
            }
            return new GLTFViewer.Utils.TouchHandler(this._controllingViewer, lab, null, null, null, null, null, null, null, contextCallback.bind(this, wihdowNum));
        }
    },
    _FindVisibilityElemIndex: {
        value: function (windowNum, vl) {
            function Find(vislist, vl, val) {
                var c = vislist.childrenVisList;
                for (var i = 0; i < c.length; ++i) {
                    if (vl.li === c[i].li)
                        return true;
                    ++val.indx;
                    if (c[i].childrenVisList.length) {
                        if (Find(c[i], vl, val))
                            return true;
                    }
                }
                return false;
            }

            if (!this._visibilityList[windowNum])
                return -1;

            var val = { indx: 0 };
            if (Find(this._visibilityList[windowNum], vl, val))
                return val.indx;
            return -1;
        }
    },
    // Change the value of a checkbox, optionally propagating down or up, and optionally trigger callback function
    _SetInpValue: {
        value: function (visList, value, propagateDown, propagateUp, trigger, childrenValue) {
            var inp = visList.inp;

            function GetChildrenValue(_visList) {
                var childrenVisList = _visList.childrenVisList;
                var _childrenValue = 2;
                for (var i = 0; i < childrenVisList.length; ++i) {
                    var childValue = childrenVisList[i].displayedValue;
                    if (i === 0)
                        _childrenValue = childValue;
                    else if (_childrenValue !== childValue)
                        return 2;
                }
                return _childrenValue;
            }

            // propagate down
            if (propagateDown) {
                var childrenVisList = visList.childrenVisList;
                for (var i = 0; i < childrenVisList.length; ++i)
                    this._SetInpValue(childrenVisList[i], value, true, false, trigger, value);
                childrenValue = value;
            } else if (GLTFViewer.Utils.IsNull(childrenValue)) // propagating up
                childrenValue = visList.childrenVisList.length ? GetChildrenValue(visList) : value;

            // set value of inp
            if (visList.onlyGroups)
                value = childrenValue;
            if (inp) {
                var displayedValue = (value === childrenValue) ? value : 2;
                visList.displayedValue = displayedValue;
                if (displayedValue === 0) { // off
                    inp.prop("checked", false);
                    inp.prop("indeterminate", false);
                } else if (displayedValue === 1) { // on
                    inp.prop("checked", true);
                    inp.prop("indeterminate", false);
                } else // indeterminate
                    inp.prop("indeterminate", true);
            }
            if (value !== 2) {
                visList.value = value;
                if (trigger && visList.visCallback)
                    visList.visCallback(value);
            }

            // propagate up
            var parentVisList = visList.parentVisList;
            if (propagateUp && parentVisList.inp) {
                var childrenVal = GetChildrenValue(parentVisList);
                if (parentVisList.onlyGroups) // parentVisList set by children
                    this._SetInpValue(parentVisList, childrenVal, false, true, false, childrenVal);
                else
                    this._SetInpValue(parentVisList, parentVisList.value, false, true, false, childrenVal);
            }
        }
    },
    //   *   [_]   Title
    //   ^ ^  ^  ^
    //   | |  |  +- 5px 
    //   | |  +---- 13px
    //   | +------- 5px
    //   +--------- 11px
    _AddExpandableLabelWithCheckBox: {
        value: function (windowNum, name, visible, visCallback, editCallback, parentVisList, onlyGroups) {
            var hasName = !GLTFViewer.Utils.IsNull(name) && name.length;
            if (GLTFViewer.Utils.IsNull(parentVisList))
                parentVisList = this._visibilityList[windowNum].childrenVisList[0];
            var ListImgWidth = 9;
            var SpaceWidth = 5;
            var ToggleWidth = 13; // probably varies

            var visList = {
                li: null, // li entry that goes into parents ul
                ul: null, // ul of li for children li's
                inp: null, // this visibility checkbox
                imgC: null,
                imgE: null,
                ToggleFunc: null,

                parentVisList: parentVisList, // parents visList
                childrenVisList: [], // checkboxes of children visibility items
                visCallback: visCallback,
                value: visible ? 1 : 0, // must be 0 or 1, realValue
                displayedValue: visible ? 1 : 0, // apparentValue
                onlyGroups: onlyGroups
            };
            parentVisList.childrenVisList.push(visList);

            if (hasName) {
                function ToggleFunc(visList, e) {
                    var propagateDown = !GLTFViewer.Utils.IsNull(e); // we clicked on a checkbox, else we are hiding just this node
                    //if (propagateDown)
                    //    e.stopPropagation();
                    this._controllingViewer.CloseContextMenus();
                    var value = visList.value ? 0 : 1;
                    if (propagateDown && e.shiftKey && !GLTFViewer.Utils.IsNull(this._lastClickedVisList) && this._lastClickedVisList != visList) {
                        // multi select
                        var idx2 = this._FindVisibilityElemIndex(windowNum, this._lastClickedVisList);
                        if (idx2 >= 0) {
                            var idx1 = this._FindVisibilityElemIndex(windowNum, visList);
                            var start = idx1 < idx2 ? idx1 : idx2;
                            var end = idx1 < idx2 ? idx2 : idx1;

                            function SetElementValue(start, end, value) {
                                function SetIt(vislist, start, end, value, val) {
                                    var c = vislist.childrenVisList;
                                    for (var i = 0; i < c.length; ++i) {
                                        if (val.indx > end)
                                            return;
                                        if (val.indx >= start)
                                            this._SetInpValue(c[i], value, false, true, true);
                                        ++val.indx;
                                        if (c[i].childrenVisList.length)
                                            SetIt.call(this, c[i], start, end, value, val);
                                    }
                                }

                                var val = { indx: 0 };
                                return SetIt.call(this, this._visibilityList[windowNum], start, end, value, val);
                            }
                            SetElementValue.call(this, start, end, value);
                        } else
                            this._SetInpValue(visList, value, propagateDown, true, true);
                    } else
                        this._SetInpValue(visList, value, propagateDown, true, true);
                    this._lastClickedVisList = visList;
                }
                visList.ToggleFunc = ToggleFunc.bind(this, visList);

                // li entry for name
                parentVisList.ul.append("<li style='list-style-type:none;margin:0;white-space:nowrap;'></li>");
                var li = $("li", parentVisList.ul).last();
                visList.li = li;
                li.append("<img src='" + this._controllingViewer.imageDir + "closed.png' style='display:none;margin-right:" + (SpaceWidth) + "px'></img>");
                var imgE = $('img', li).last();
                visList.imgE = imgE;
                li.append("<img src='" + this._controllingViewer.imageDir + "open.png' style='display:none;margin-right:" + (SpaceWidth) + "px'></img>");
                var imgC = $('img', li).last();
                visList.imgC = imgC;
                // label for name with optional checkbox
                li.append("<label style='padding:0;margin:0;border:0;margin-left:" + (ListImgWidth + SpaceWidth + ToggleWidth + SpaceWidth) + "px;margin-right:" + SpaceWidth + "px;font-size:14px;font-family:Segoe UI,Arial,Helvetica,sans-serif;'></label>");
                var lab = $('label', li).last();
                lab.append("<input type='checkbox' style='padding:0;margin:0;border:1px solid black;margin-left:0;margin-right:" + SpaceWidth + "px;'></input>");
                var inp = $('input', lab).last();
                visList.inp = inp;
                inp.on("click", visList.ToggleFunc);

                lab.append(name);

                imgE.hover((function (_imgE) {
                    _imgE.css('cursor', 'pointer');
                }).bind(this, imgE), (function (_imgE) {
                    _imgE.css('cursor', '');
                }).bind(this, imgE));
                imgC.hover((function (_imgC) {
                    _imgC.css('cursor', 'pointer');
                }).bind(this, imgC), (function (_imgC) {
                    imgC.css('cursor', '');
                }).bind(this, imgC));
                lab.hover((function (_lab) {
                    _lab.css('color', GLTFViewer.HOVERCOLOR);
                    _lab.css('cursor', 'pointer');
                }).bind(this, lab), (function (_lab) {
                    lab.css('color', 'black');
                    lab.css('cursor', '');
                }).bind(this, lab));

                var ml = lab.css("margin-left").replace("px", "");
                ml -= ToggleWidth + SpaceWidth;
                lab.css("margin-left", ml + "px");

                // ul for children
                li.append("<ul style='display:none;list-style-type:none;padding:0;margin-left:" + (ListImgWidth + SpaceWidth) + "px;'></ul>");
                var ul = $("ul", li).last();
                visList.ul = ul;

                function onClick(how, _ul, _imgE, _imgC, e) {
                    e.stopPropagation();
                    this._controllingViewer.CloseContextMenus();
                    if (how === "Expand") {
                        _imgE.css("display", "none");
                        _imgC.css("display", "inline");
                        _ul.css("display", "block");
                    } else {
                        _imgE.css("display", "inline");
                        _imgC.css("display", "none");
                        _ul.css("display", "none");
                    }
                }
                imgE.click(onClick.bind(this, "Expand", ul, imgE, imgC));
                imgC.click(onClick.bind(this, "Collapse", ul, imgE, imgC));

                GLTFViewer.MakeUnselectable(li[0]);

                if (parentVisList.li) {
                    // there are now some children, so enable expansion
                    if (!GLTFViewer.GetElementVisible(parentVisList.imgC) && !GLTFViewer.GetElementVisible(parentVisList.imgE)) {
                        parentVisList.imgE.css("display", "inline");
                        var parentlab = $('label', parentVisList.li).first();
                        parentlab.css("margin-left", 0);
                    }
                }

                this._SetInpValue(visList, visList.value, false, true, false);

                if (editCallback && this._contextMenuEntry) {
                    function contextCallback(editCallback, e) {
                        e.preventDefault();
                        e.stopPropagation();
                        var enable = {};
                        enable[GLTFViewer.CM_ENTRY_EDIT_PROPERTIES] = this._controllingViewer.scene.AnimationStopped();
                        this._contextMenuEntry.Show(true, e, enable, editCallback);
                    }
                    visList.__th__ = new GLTFViewer.Utils.TouchHandler(this._controllingViewer, lab, null, null, null, null, null, null, null, contextCallback.bind(this, editCallback));
                }
            }

            return visList;
        }
    },
    // public methods
    ///////////////////////////////////
    SelectFile: {
        value: function (windowNum, fileObj) {
            var filePath = GLTFViewer.Utils.GetFilePath(fileObj._file);
            var fileName = fileObj._name;
            if (fileObj._mTime) {
                var d = new Date(fileObj._mTime);
                fileName = fileName + " " + d.toLocaleString();
            }

            // set label:
            if (this._controllingViewer.wantFile) {
                var lab = $("label", this._fileContainer[windowNum]).first();
                if (this._controllingViewer.wantViewport)
                    lab.text("Window " + (windowNum + 1) + ": " + fileName);
                else
                    lab.text(fileName);

                var containerFile = fileObj._containerFile;
                if (!GLTFViewer.Utils.IsNull(containerFile)) {
                    var containerFilePath = GLTFViewer.Utils.GetFilePath(containerFile);
                    lab.prop("title", containerFilePath); // make the tool tip the containerFile
                } else
                    lab.prop("title", filePath);
            }
        }
    },
    CloseFile: {
        value: function (windowNum) {
            var lab = $("label", this._fileContainer[windowNum]).first();
            if (this._controllingViewer.wantViewport)
                lab.text("Window " + (windowNum + 1));
            else
                lab.text("");
            this.RemoveAllScenes(windowNum);
        }
    },
    ///////////////////////////////////
    AddScene: {
        value: function (windowNum, sceneItem, callback) {
            var SpaceWidth = 5;

            // li entry for name
            this._sceneContainer[windowNum].append("<li style='list-style-type:none;margin:0;white-space:nowrap;'></li>");
            var li = $("li", this._sceneContainer[windowNum]).last();

            // label for name
            li.append("<label style='padding:0;margin:0;border:0;font-size:14px;font-family:Segoe UI,Arial,Helvetica,sans-serif;'></label>");
            var lab = $('label', li).last();
            lab.append(sceneItem.name);
            // if there is no callback, the sceneItem is non-selectable
            if (!GLTFViewer.Utils.IsNull(callback)) {
                lab.hover((function (_lab) {
                    if (_lab.css("background-color") === GLTFViewer.HOVERCOLOR)
                        _lab.css('color', "white");
                    else
                        _lab.css('color', GLTFViewer.HOVERCOLOR);
                    _lab.css('cursor', 'pointer');
                }).bind(this, lab), (function (_lab) {
                    _lab.css('color', 'black');
                    _lab.css('cursor', '');
                }).bind(this, lab));
                lab.click((function (callback, e) {
                    e.preventDefault();
                    e.stopPropagation();
                    this._controllingViewer.CloseContextMenus();
                    callback();
                }).bind(this, callback));

                function contextCallback(windowNum, sceneItem, e) {
                    function contextSceneCallback(viewer, val, other) {
                        var item = val[0];
                        if (!viewer.scene || !viewer.scene.handler)
                            return;

                        switch (item) {
                            case GLTFViewer.CM_SCENE_RESET_VIEW:
                                viewer.scene.ResetScene(other);
                                break;
                            case GLTFViewer.CM_SCENE_COPY_VIEW:
                                function ApplyCallback(sceneItem, ok, data) {
                                    if (ok && data[0] && data[0].length)
                                        viewer.scene.handler.CreateScene(data[0], sceneItem);
                                }
                                var sceneItem = (other instanceof GLTFViewer.Utils.FileGLTF.SceneItem) ? other : null;
                                var name = sceneItem ? sceneItem.name + "_Copy" : "View";
                                var a = new GLTFViewer.Utils.Dialog("New View Name",
                                                                    [["View Name", GLTFViewer.Utils.Dialog.DATATEXT, name]],
                                                                    true, ApplyCallback.bind(this, sceneItem));
                                break;
                            case GLTFViewer.CM_SCENE_DELETE_VIEW:
                                viewer.scene.handler.DeleteScene(other);
                                break;
                        }
                    }
                    var viewer = this._controllingViewer.GetViewerByNumber(windowNum);
                    this._contextMenuScene = new GLTFViewer.Utils.SimpleContextMenu(this._controllingViewer, this._controllingViewer.body,
                                                                                    [GLTFViewer.CM_SCENE_RESET_VIEW,
                                                                                     GLTFViewer.CM_SCENE_COPY_VIEW,
                                                                                     GLTFViewer.CM_SCENE_DELETE_VIEW], null, contextSceneCallback.bind(this, viewer));

                    e.preventDefault();
                    e.stopPropagation();
                    var enable = {};
                    enable[GLTFViewer.CM_SCENE_RESET_VIEW] = 1;
                    enable[GLTFViewer.CM_SCENE_COPY_VIEW] = this._controllingViewer.canSave;
                    enable[GLTFViewer.CM_SCENE_DELETE_VIEW] = this._controllingViewer.canSave && sceneItem.editable;
                    this._contextMenuScene.Show(true, e, enable, sceneItem);
                }
                li.__th__ = new GLTFViewer.Utils.TouchHandler(this._controllingViewer, lab, null, null, null, null, null, null, null, contextCallback.bind(this, windowNum, sceneItem));
            }

            GLTFViewer.MakeUnselectable(li[0]);

            return li;
        }
    },
    RemoveScene: {
        value: function (windowNum, li) {
            li.remove();
        }
    },
    RemoveAllScenes: {
        value: function (windowNum) {
            this.RemoveAllEntries(windowNum);
            if (this._sceneContainer && this._sceneContainer[windowNum])
                this._sceneContainer[windowNum].children().remove();
        }
    },
    SelectScene: {
        value: function (windowNum, li) {
            $("> label", this._sceneContainer[windowNum].children()).css('background-color', 'white');
            $("> label", li).css('background-color', GLTFViewer.HOVERCOLOR);

            this._lastClickedVisList = null;

            if (this._visibilityList[windowNum]) {
                // detach visibility from current scene
                this._visibilityList[windowNum].ul.detach();
                // attach to this scene
                li.append(this._visibilityList[windowNum].ul);
            }
        }
    },
    ///////////////////////////////////
    AddEntry: {
        value: function (windowNum, name, visible, visCallback, editCallback, parentVisList, onlyGroups) {
            // ul for visibility checkboxes gets appended to sceneItem.visList
            if (GLTFViewer.Utils.IsNull(this._visibilityList[windowNum])) {
                // create a visList structure for top element "All"
                this._visibilityList[windowNum] = {
                    li: null,
                    ul: $("<ul style='list-style-type:none;padding:0;margin-left:5px;'></ul>"),
                    inp: null,
                    imgC: null,
                    imgE: null,
                    ToggleFunc: null,

                    parentVisList: null,
                    childrenVisList: [],
                    visCallback: null,
                    onlyGroups: true
                };
                // _visibilityContainer = _visibilityList[windowNum].ul

                var visList = this._AddExpandableLabelWithCheckBox(windowNum, "All", true, null, null, this._visibilityList[windowNum], true);
            }

            return this._AddExpandableLabelWithCheckBox(windowNum, name, visible, visCallback, editCallback, parentVisList, onlyGroups);
        }
    },
    RemoveEntry: {
        value: function (windowNum, entry) {
            function Delete(vislist, entry) {
                var c = vislist.childrenVisList;
                for (var i = 0; i < c.length; ++i) {
                    if (entry === c[i]) {
                        if (c[i].li) {
                            // remove all children
                            while (entry.childrenVisList.length)
                                Delete(entry, entry.childrenVisList[0]);
                            $(c[i].li).remove();
                        }
                        vislist.childrenVisList.splice(i, 1);
                        return;
                    }
                    // check children
                    if (c[i].childrenVisList.length)
                        Delete(c[i], entry);
                }
            }

            if (GLTFViewer.Utils.IsNull(this._visibilityList[windowNum]) || GLTFViewer.Utils.IsNull(entry))
                return;

            Delete(this._visibilityList[windowNum], entry);
            if (this._visibilityList[windowNum].childrenVisList.length && this._visibilityList[windowNum].childrenVisList[0].childrenVisList.length === 0) {
                // top entry "All" has no children
                Delete(this._visibilityList[windowNum], this._visibilityList[windowNum].childrenVisList[0]);
            }
            if (this._visibilityList[windowNum].childrenVisList.length === 0) {
                this._visibilityList[windowNum].ul.remove();
                this._visibilityList[windowNum] = null;
            }
        }
    },
    RemoveAllEntries: {
        value: function (windowNum) {
            if (!this._visibilityList[windowNum])
                return;

            while (this._visibilityList[windowNum] && this._visibilityList[windowNum].childrenVisList.length)
                this.RemoveEntry(windowNum, this._visibilityList[windowNum].childrenVisList[0]);
        }
    },
    ///////////////////////////////////
    CloseContextMenus: {
        value: function () {
            if (this._contextMenuFile)
                this._contextMenuFile.Show(false);
            if (this._contextMenuScene)
                this._contextMenuScene.Show(false);
            if (this._contextMenuEntry)
                this._contextMenuEntry.Show(false);
        }
    },
    IsVisible: {
        value: function () {
            if (!this._panel2)
                return false;
            return GLTFViewer.GetElementVisible(this._panel2);
        }
    },
    Show: {
        value: function (show) {
            if (!this._panel2)
                return;
            if (!show && this.IsVisible()) {
                if (this._resizeTouchImage)
                    GLTFViewer.SetElementVisible(this._resizeTouchImage, false);
                this._panel2.hide(0, this._controllingViewer.UpdateLayout.bind(this._controllingViewer));
            } else if (show && !this.IsVisible()) {
                // ensure that it is a good size before showing
                var dialogWidth = this._panel2.width();
                this._SetSize(dialogWidth);
                if (this._resizeTouchImage)
                    GLTFViewer.SetElementVisible(this._resizeTouchImage, true);
                this._panel2.show(0, this._controllingViewer.UpdateLayout.bind(this._controllingViewer));
            }
        }
    },
    Reset: {
        // reset to initially created state
        value: function () {
        }
    },
    Clear: {
        // clear to ready for deletion state
        value: function () {
            GLTFViewer.FileManager.Panel.prototype.Reset.call(this);
            this._controllingViewer = null;
            this._fileManager = null;
            this._sceneContainer = null;
            this._panel = null;
            this._panel2 = null;
            this._contextMenuFile = null;
            this._contextMenuScene = null;
            this._contextMenuEntry = null;
            this._fileContainer = null;
            this._visibilityList = null;
        }
    }
});
///////////////////////////////////////
// This is for backward compatibility for:
// var v = require("gltfviewer");
// var viewer = new v.GLTFViewer(id, ...);
//
// the new way is:
// var v = require("gltfviewer");
// var viewer = new v(id, ...);
//
GLTFViewer.GLTFViewer = function () {
    GLTFViewer.apply(this, arguments);
};
GLTFViewer.GLTFViewer.prototype = Object.create(GLTFViewer.prototype, {
    constructor: { value: GLTFViewer.GLTFViewer }
});
// This is for backward compatibility for:
///////////////////////////////////////

window.requestAnimationFrame = window.requestAnimationFrame || (function () {
    return window.mozRequestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.msRequestAnimationFrame;
})();
///////////////////////////////////////////////////////////////////////////////
//
// utitilies
//
GLTFViewer.Utils = function ( ) {
};
// Static data
Object.defineProperties(GLTFViewer.Utils, {
    ShowAlert: { writable: true, value: true }, // this will apply to all viewers
    maxValue: { value: 1.79769E+308 },
    maxDouble: { value: 10000000000000 },
    root2: { value: 1.4142135623730950488016887242097 },
    root3: { value: 1.7320508075688772935274463415059 },
    root6: { value: 2.4494897427831780981972840747059 },
    epsilon: { value: 1E-13 },
    lengthAccuracy: { value: 1E-08 },
    lengthAccuracySquared: { value: 1E-08 * 1E-08 },
    angleAccuracy: { value: 1E-06 },
    fitAccuracy: { value: 1E-05 },
    GetXY: {
        value: function (e) {
            var touches = [];
            if (e.touches)
                touches = e.touches;
            else if (e.pointerId)
                touches = [e];
            else {
                // probably mouse
                touches.push({ timeStamp: e.timeStamp, clientX: e.clientX, clientY: e.clientY });
            }

            return touches.length ? touches[0] : { timestammp: e.timeStamp, clientX: -1, clientY: -1 };
        }
    },
    GetClientXY: {
        value: function (container, e) {
            var cr = container.getBoundingClientRect();
            e = GLTFViewer.Utils.GetXY(e);
            return { t: e.timeStamp, x: e.clientX - cr.left, y: e.clientY - cr.top };
        }
    },
    tEmptyArray: {
        get: function () {
            return new Int8Array(0);
        }
    },
    glMtxIdentity: {
        get: function () {
            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        }
    },
    IslengthZero: {
        value: function (length) {
            return length <= GLTFViewer.Utils.lengthAccuracy && length >= -GLTFViewer.Utils.lengthAccuracy;
        }
    },
    EqualDoubles: {
        value: function (a, b) {
            return GLTFViewer.Utils.WithinTolerance(a, b, GLTFViewer.Utils.epsilon, GLTFViewer.Utils.epsilon);
        }
    },
    EqualLengths: {
        value: function (a, b) {
            return GLTFViewer.Utils.WithinTolerance(a, b, GLTFViewer.Utils.epsilon, GLTFViewer.Utils.lengthAccuracy);
        }
    },
    WithinTolerance: {
        value: function (a, b, relativeTolerance, absoluteTolerance) {
            var d0 = a - b;
            if (d0 < 0) d0 = -d0;
            var d1 = a + b;
            if (d1 < 0) d1 = -d1;
            return d0 < absoluteTolerance || d0 <= relativeTolerance * 0.5 * d1;
        }
    },
    CRLFtoCR: {
        value: function (text) {
            if (typeof text !== 'string')
                return "";

            var t = text.replace(/\n\r/g, '\n');
            t = t.replace(/\r/g, '\n');

            return t;
        }
    },
    acos: {
        value: function (a) {
            if (a >= -1 && a <= 1) return Math.acos(a);
            var threshold = 1 + GLTFViewer.Utils.angleAccuracy;
            if (a < -1 && a > -threshold) return Math.PI;
            if (a > 1 && a < threshold) return 0;
            return 0;
        }
    },
    IsFullScreenAvailable: {
        value: function () {
            return document.fullscreenEnabled || // W3C standard
                   document.msFullscreenEnabled || // IE 11+
                   document.mozFullScreenEnabled || // Firefox 10+, Firefox for Android
                   document.webkitFullscreenEnabled || // Safari 5.1+, Chrome 15+, Opera 15+, Chrome for Android, Opera Mobile 16+
                   false;
        }
    },
    IsFullScreen: {
        value: function () {
            if (!GLTFViewer.Utils.IsFullScreenAvailable())
                return false;
            if (document.fullscreenElement)
                return document.fullscreenElement !== null; // W3C standard
            else if (document.msFullscreenElement)
                return document.msFullscreenElement !== null; // IE 11+
            else if (document.mozFullScreenElement)
                return document.mozFullScreenElement !== null; // Firefox 10+, Firefox for Android
            else if (document.webkitFullscreenElement)
                return document.webkitFullscreenElement !== null; // Safari 5.1+, Chrome 15+, Opera 15+, Chrome for Android, Opera Mobile 16+
            return false;
        }
    },
    ToFullScreen: {
        value: function (elem) {
            elem = elem || document.documentElement;
            if (!GLTFViewer.Utils.IsFullScreenAvailable() || GLTFViewer.Utils.IsFullScreen())
                return;
            if (elem.requestFullscreen)
                elem.requestFullscreen(); // W3C standard
            else if (elem.msRequestFullscreen)
                elem.msRequestFullscreen(); // IE 11+
            else if (elem.mozRequestFullScreen)
                elem.mozRequestFullScreen(); // Firefox 10+, Firefox for Android
            else if (elem.webkitRequestFullScreen) {
                if (navigator.userAgent.indexOf('Safari') !== -1 && navigator.userAgent.indexOf('Chrome') === -1)
                    elem.webkitRequestFullScreen(); // Safari 5.1+
                else
                    elem.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT); // Chrome 15+
            } else if (elem.webkitRequestFullscreen) {
                if (navigator.userAgent.indexOf('Safari') !== -1 && navigator.userAgent.indexOf('Chrome') === -1)
                    elem.webkitRequestFullscreen(); // Safari 6+
                else
                    elem.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT); // Chrome 20+, Opera 15+, Chrome for Android, Opera Mobile 16+
            }
        }
    },
    FromFullScreen: {
        value: function () {
            if (!GLTFViewer.Utils.IsFullScreen())
                return;
            if (document.exitFullscreen)
                document.exitFullscreen(); // W3C standard
            else if (document.msExitFullscreen)
                document.msExitFullscreen(); // IE 11+
            else if (document.mozCancelFullScreen)
                document.mozCancelFullScreen(); // Firefox 10+, Firefox for Android
            else if (document.webkitCancelFullScreen)
                document.webkitCancelFullScreen(); // Chrome 15+, Safari 5.1+
            else if (document.webkitExitFullscreen)
                document.webkitExitFullscreen(); // Chrome 20+, Safari 6+, Opera 15+, Chrome for Android, Opera Mobile 16+
        }
    },
    IsApple: {
        value: function () {
            var agent = navigator.userAgent.toLowerCase();
            return agent.indexOf('ipod') !== -1 || // ipod
                   agent.indexOf('iphone') !== -1 || // iphone
                   agent.indexOf('ipad') !== -1; // ipad
        }
    },
    IsMobile: {
        value: function () {
            var agent = navigator.userAgent.toLowerCase();
            return agent.indexOf('ipod') !== -1 || // ipod
                   agent.indexOf('iphone') !== -1 || // iphone
                   agent.indexOf('ipad') !== -1 || // ipad
                   agent.indexOf('android') !== -1 || // android
                   agent.indexOf('googletv') !== -1 || // googleTV
                   agent.indexOf('playbook') !== -1 || // blackberry
                   (agent.indexOf('bb10') !== -1 && agent.indexOf('mobi') !== -1) || // blackberry
                   (agent.indexOf('blackberry') !== -1 && agent.indexOf('webkit') !== -1) || // blackberry
                   agent.indexOf('windows phone') !== -1 || // windows
                   (agent.indexOf('hpwos') !== -1 && agent.indexOf('tablet') !== -1) || // hp
                   agent.indexOf('htc_flyer') !== -1 || // htc
                   agent.indexOf('webos') !== -1 || // palm
                   agent.indexOf('bada') !== -1 || // samsung
                   agent.indexOf('tizen') !== -1; // samsung
        }
    },
    Base64EncArr: {
        value: function (aBytes) {
            var uint6ToB64 = function (nUint6) {
                return nUint6 < 26 ?
                        nUint6 + 65
                        : nUint6 < 52 ?
                        nUint6 + 71
                        : nUint6 < 62 ?
                        nUint6 - 4
                        : nUint6 === 62 ?
                        43
                        : nUint6 === 63 ?
                        47
                        :
                        65;
            };
            var nMod3, sB64Enc = "";
            for (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {
                nMod3 = nIdx % 3;
        //        if (nIdx > 0 && (nIdx * 4 / 3) % 76 === 0)
        //            sB64Enc += "\r\n";
                nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);
                if (nMod3 === 2 || aBytes.length - nIdx === 1) {
                    sB64Enc += String.fromCharCode(uint6ToB64(nUint24 >>> 18 & 63), uint6ToB64(nUint24 >>> 12 & 63), uint6ToB64(nUint24 >>> 6 & 63), uint6ToB64(nUint24 & 63));
                    nUint24 = 0;
                }
            }
            return sB64Enc.replace(/A(?=A$|$)/g, "=");
        }
    },
    StrokeEllipse: {
        value: function (gx, x, y, w, h) {
            var ox = (w / 2) * .5522848;
            var oy = (h / 2) * .5522848;
            var xe = x + w, ye = y + h;
            var xm = x + w / 2, ym = y + h / 2;
            gx.beginPath();
            gx.moveTo(x, ym);
            gx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            gx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            gx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            gx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
            gx.closePath();
            gx.stroke();
        }
    },
    FillEllipse: {
        value: function (gx, x, y, w, h) {
            var ox = (w / 2) * .5522848;
            var oy = (h / 2) * .5522848;
            var xe = x + w, ye = y + h;
            var xm = x + w / 2, ym = y + h / 2;
            gx.beginPath();
            gx.moveTo(x, ym);
            gx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            gx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            gx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            gx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
            gx.closePath();
            gx.fill();
        }
    },
    TextWidth: {
        value: function(gx, texts) {
            if (!(texts instanceof Array))
                texts = [texts];
            else if (!texts.length)
                return 0;
            var width = 0;
            for (var i = 0; i < texts.length; ++i) {
                var w = gx.measureText(texts[i]);
                width = Math.max(width, w.width);
            }
            return width;
        }
    },
    FlatRgba: {
        value: function (r, g, b, a, flat) {
            flat[0] = r / 255.0;
            flat[1] = g / 255.0;
            flat[2] = b / 255.0;
            flat[3] = a / 255.0;
        }
    },
    FlatColor: {
        value: function (colr, flat) {
            flat[0] = ((colr >> 16) & 0xff) / 255.0;
            flat[1] = ((colr >> 8) & 0xff) / 255.0;
            flat[2] = (colr & 0xff) / 255.0;
            flat[3] = ((colr >> 24) & 0xff) / 255.0;
        }
    },
    RemoveDuplicates: {
        value: function (list) {
            if (!list)
                return list;
            return list.filter(function(elem, pos) {
                return list.indexOf(elem) == pos;
            });
        }
    },
    IsNull: {
        value: function (v) {
            return (typeof v === 'undefined') || v === null;
        }
    },
    InsertReplace: {
        value: function(str, re, replace) {
            var nStart = str.match(re);
            if (!nStart || nStart.length !== 1)
                return null;
            nStart = str.search(re);
            var m = str.match(re);
            var nEnd = nStart + m[0].length;
            var p0 = str.substr(0, nStart);
            var p1 = str.substr(nEnd);
            return p0 + replace + p1;
        }
    },
    InsertAfter: {
        value: function(str, re, after) {
            var n = str.match(re);
            if (!n || n.length !== 1)
                return null;
            n = str.search(re);
            var m = str.match(re);
            n += m[0].length;
            var p0 = str.substr(0, n);
            var p1 = str.substr(n);
            return p0 + after + p1;
        }
    },
    InsertBefore: {
        value: function(str, re, before) {
            var n = str.match(re);
            if (!n || n.length !== 1)
                return null;
            n = str.search(re);
            var p0 = str.substr(0, n);
            var p1 = str.substr(n);
            return p0 + before + p1;
        }
    },
    SplitLine: {
        value: function (gx, maxLength, tip) {
            var retVal = [];
            if (GLTFViewer.Utils.IsNull(tip) || tip == "")
                return retVal;
            var colon = tip.split("~");
            for (var i = 0; i < colon.length; ++i)
                colon[i] = colon[i].split(" ");
            var str = "";
            var maxWidth = 0;
            for (var c = 0; c < colon.length; ++c) {
                if (c)
                    str += ":";
                for (var s = 0; s < colon[c].length; ++s) {
                    var _str = str;
                    if (_str.length && s > 0)
                        _str += " ";
                    _str += colon[c][s];
                    var mt = gx.measureText(_str);
                    if (maxLength && mt.width > maxLength) {                        
                        retVal.push(str);
                        str = colon[c][s];
                        mt = gx.measureText(str);
                        maxWidth = Math.max(maxWidth, mt.width);
                        if (mt.width > maxLength) {
                            retVal.push(str);
                            str = "";
                        }
                    } else {
                        str = _str;
                        maxWidth = Math.max(maxWidth, mt.width);
                    }
                }
            }
            if (str.length) {
                var mt = gx.measureText(str);
                retVal.push(str);
                maxWidth = Math.max(maxWidth, mt.width);
            }

//            while (str != "") {
//                var s = gx.measureText(str);
//                if (s.width <= maxlength) {
//                    reVal.push(str);
//                    break;
//                }
//            }
            return {width: maxWidth + 2, data: retVal};
        }
    },

    NoContext: {
        value: function(viewer, element) {
            element.on("contextmenu", (function (_viewer, e) {
                if (_viewer)
                    _viewer.CloseContextMenus();
                e.preventDefault();
                e.stopPropagation();
            }).bind(this, viewer));
        }
    },
    GetMemoryUsage: {
        value: function () {
            try {
                return process.memoryUsage();
            } catch (err) {
                return null;
            }
        }
    },
    Interpolate: {
        value: function (value0, value1, f) {
            if (f <= 0)
                return value0;
            else if (f >= 1)
                return value1;

            if (typeof value0 === "number")
                return value0 + (value1 - value0) * f;

            if (value0 instanceof Array && value0.length === 16) {
                // 4x4 array
                var translate0 = [value0[12], value0[13], value0[14]];
                var translate1 = [value1[12], value1[13], value1[14]];
                var scale0 = [Math.sqrt(value0[0] * value0[0] + value0[1] * value0[1] + value0[2] * value0[2]),
                              Math.sqrt(value0[4] * value0[4] + value0[5] * value0[5] + value0[6] * value0[6]),
                              Math.sqrt(value0[8] * value0[8] + value0[9] * value0[9] + value0[10] * value0[10])];
                var scale1 = [Math.sqrt(value1[0] * value1[0] + value1[1] * value1[1] + value1[2] * value1[2]),
                              Math.sqrt(value1[4] * value1[4] + value1[5] * value1[5] + value1[6] * value1[6]),
                              Math.sqrt(value1[8] * value1[8] + value1[9] * value1[9] + value1[10] * value1[10])];
                var val0 = [value0[0] / scale0[0], value0[1] / scale0[0], value0[2] / scale0[0], 0,
                            value0[4] / scale0[1], value0[5] / scale0[1], value0[6] / scale0[1], 0,
                            value0[8] / scale0[2], value0[9] / scale0[2], value0[10] / scale0[2], 0,
                            0, 0, 0, 1];
                var val1 = [value1[0] / scale1[0], value1[1] / scale1[0], value1[2] / scale1[0], 0,
                            value1[4] / scale1[1], value1[5] / scale1[1], value1[6] / scale1[1], 0,
                            value1[8] / scale1[2], value1[9] / scale1[2], value1[10] / scale1[2], 0,
                            0, 0, 0, 1];

                var quat0 = [];
                var quat1 = [];

                var t01 = (val0[0] + val0[5] + val0[10]) > 0;
                var t02 = val0[0] > val0[5] && val0[0] > val0[10];
                var t03 = val0[5] > val0[10];
                var t04 = 2 * (t01 ?               (Math.sqrt(1 + val0[0] + val0[5] + val0[10]))
                                   : (t02 ?        (Math.sqrt(1 + val0[0] - val0[5] - val0[10])) 
                                          : (t03 ? (Math.sqrt(1 - val0[0] + val0[5] - val0[10]))
                                                 : (Math.sqrt(1 - val0[0] - val0[5] + val0[10])))));
                quat0[0] = t01 ?               (( val0[6] - val0[9]) / t04) 
                               : (t02 ?        (0.25 * t04) 
                                      : (t03 ? (( val0[1] + val0[4]) / t04) 
                                             : (( val0[2] + val0[8]) / t04)));
                quat0[1] = t01 ?               ((-val0[2] + val0[8]) / t04) 
                               : (t02 ?        (( val0[1] + val0[4]) / t04) 
                                      : (t03 ? (0.25 * t04) 
                                             : (( val0[6] + val0[9]) / t04)));
                quat0[2] = t01 ?               (( val0[1] - val0[4]) / t04) 
                               : (t02 ?        (( val0[2] + val0[8]) / t04) 
                                      : (t03 ? (( val0[6] + val0[9]) / t04)
                                             : (0.25 * t04)));
                quat0[3] = t01 ?               (0.25 * t04) 
                               : (t02 ?        (( val0[6] - val0[9]) / t04) 
                                      : (t03 ? ((-val0[2] + val0[8]) / t04)
                                             : (( val0[1] - val0[4]) / t04)));

                var t11 = (val1[0] + val1[5] + val1[10]) > 0;
                var t12 = val1[0] > val1[5] && val1[0] > val1[10];
                var t13 = val1[5] > val1[10];
                var t14 = 2 * (t11 ?               (Math.sqrt(1 + val1[0] + val1[5] + val1[10]))
                                   : (t12 ?        (Math.sqrt(1 + val1[0] - val1[5] - val1[10])) 
                                          : (t13 ? (Math.sqrt(1 - val1[0] + val1[5] - val1[10]))
                                                 : (Math.sqrt(1 - val1[0] - val1[5] + val1[10])))));
                quat1[0] = t11 ?               (( val1[6] - val1[9]) / t14) 
                               : (t12 ?        (0.25 * t14) 
                                      : (t13 ? (( val1[1] + val1[4]) / t14) 
                                             : (( val1[2] + val1[8]) / t14)));
                quat1[1] = t11 ?               ((-val1[2] + val1[8]) / t14) 
                               : (t12 ?        (( val1[1] + val1[4]) / t14) 
                                      : (t13 ? (0.25 * t14) 
                                             : (( val1[6] + val1[9]) / t14)));
                quat1[2] = t11 ?               (( val1[1] - val1[4]) / t14) 
                               : (t12 ?        (( val1[2] + val1[8]) / t14) 
                                      : (t13 ? (( val1[6] + val1[9]) / t14)
                                             : (0.25 * t14)));
                quat1[3] = t11 ?               (0.25 * t14) 
                               : (t12 ?        (( val1[6] - val1[9]) / t14) 
                                      : (t13 ? ((-val1[2] + val1[8]) / t14)
                                             : (( val1[1] - val1[4]) / t14)));

                var translate = [];
                var scale = [];
                var quat = [];
                for (var i = 0; i < 3; ++i) {
                    translate[i] = translate0[i] + (translate1[i] - translate0[i]) * f;
                    scale[i] = scale0[i] + (scale1[i] - scale0[i]) * f;
                }

                var q = GLTFViewer.Utils.Quat.Slerp(new GLTFViewer.Utils.Quat(quat0[0], quat0[1], quat0[2], quat0[3]),
                                             new GLTFViewer.Utils.Quat(quat1[0], quat1[1], quat1[2], quat1[3]),
                                             f);
                quat[0] = q.x;
                quat[1] = q.y;
                quat[2] = q.z;
                quat[3] = q.w;
                    
                var value = [];

                value[0] =  (1 - 2 * quat[1] * quat[1] - 2 * quat[2] * quat[2]) * scale[0];
                value[1] =  (    2 * quat[0] * quat[1] + 2 * quat[2] * quat[3]) * scale[0];
                value[2] =  (    2 * quat[0] * quat[2] - 2 * quat[1] * quat[3]) * scale[0];
                value[3] =  0;
                value[4] =  (    2 * quat[0] * quat[1] - 2 * quat[2] * quat[3]) * scale[1];
                value[5] =  (1 - 2 * quat[0] * quat[0] - 2 * quat[2] * quat[2]) * scale[1];
                value[6] =  (    2 * quat[1] * quat[2] + 2 * quat[0] * quat[3]) * scale[1];
                value[7] =  0;
                value[8] =  (    2 * quat[0] * quat[2] + 2 * quat[1] * quat[3]) * scale[2];
                value[9] =  (    2 * quat[1] * quat[2] - 2 * quat[0] * quat[3]) * scale[2];
                value[10] = (1 - 2 * quat[0] * quat[0] - 2 * quat[1] * quat[1]) * scale[2];
                value[11] = 0;
                value[12] = translate[0];
                value[13] = translate[1];
                value[14] = translate[2];
                value[15] = 1;

                return value;
            }

            // regular array
            var value = [];
            for (var i = 0; i < value0.length; ++i)
                value[i] = value0[i] + (value1[i] - value0[i]) * f;

            return value;
        }
    },
    // makes a white ball with black border, using only luminance and alpha channel
    MakeBallImage: {
        value: function(radius, border) {
            // make power of 2
            var rad = Math.pow(2, Math.ceil(Math.log(radius) / Math.log(2)));
            radius = rad * 0.625;
            var ball = new Uint8Array(8 * rad * rad);
            border /= 2;
            for (var y = 0; y < rad; ++y) {
                for (var x = 0; x < rad; ++x) {
                    var d = Math.sqrt(x * x + y * y);
                    var cr, cg, cb, ca;
                    if (d < radius + 1) {
                        cl = 255;
                        ca = d <= radius ? 255 : 255 * (d - radius);
                    } else {
                        cl = 0;
                        ca = 0;
                    }
                    if (border && d < radius + border && d >= radius - border) {
                        var a = 1 - Math.abs(d - radius) / border;
                        cl = d > radius ? 0 : cl * (1 - a);
                        ca = ca * (1 - a) + 255 * a; 
                    }

                    var _x = (rad - 1) - x; // rad - 1 to 0
                    var _y = (rad - 1) - y; // rad - 1 to 0
                    var o1 = (rad + y) * 4 * rad + 2 * (rad + x); // +x,-y
                    var o2 = (rad + y) * 4 * rad + 2 * _x; // -x,-y
                    var o3 = _y * 4 * rad + 2 * (rad + x); // +x,+y
                    var o4 = _y * 4 * rad + 2 * _x; // -x,+y

                    ball[o1 + 0] = ball[o2 + 0] = ball[o3 + 0] = ball[o4 + 0] = cl;
                    ball[o1 + 1] = ball[o2 + 1] = ball[o3 + 1] = ball[o4 + 1] = ca;
                }
            }
            return ball;
        }
    },
    MakeFacedCylinder3D: {
         value: function (r1, r2, len, slices, stacks) {
            var vCnt = slices * (stacks + 3) + 2;
            var fCnt = (slices + stacks * slices) * 2;
            var iCnt = fCnt * 3;
            var vDat = new Float32Array(6 * vCnt);
            var iDat = new Uint16Array(iCnt);
            var fAngle = new Float32Array(2 * slices);
            var a = Math.PI / 2.0;
            var as = 2.0 * Math.PI / slices;
            for (slice = 0; slice < slices; a -= as, slice++) {
                fAngle[slice * 2] = Math.cos(a);
                fAngle[slice * 2 + 1] = Math.sin(a);
            }
            var rd = r1 - r2;
            var rs = rd / stacks;
            var z = -len / 2;
            var zs = len / stacks;
            var nz = 0, k = 1;
            if (r2 === 0) k = Math.cos(Math.PI);
            var v = 0;
            var f = 0;
            vDat[v++] = 0;
            vDat[v++] = 0;
            vDat[v++] = z;
            vDat[v++] = 0;
            vDat[v++] = 0;
            vDat[v++] = -1;
            var r = r1;
            for (var slice = 0; slice < slices; slice++) {
                vDat[v++] = r * fAngle[slice * 2];
                vDat[v++] = r * fAngle[slice * 2 + 1];
                vDat[v++] = z;
                vDat[v++] = 0;
                vDat[v++] = 0;
                vDat[v++] = -1;
                if (slice > 0) {
                    iDat[f++] = 0;
                    iDat[f++] = slice;
                    iDat[f++] = slice + 1;
                }
            }
            iDat[f++] = 0;
            iDat[f++] = slices;
            iDat[f++] = 1;
            stacks++;
            for (var stack = 1; stack <= stacks; stack++) {
                for (var slice = 0; slice < slices; slice++) {
                    var nx = k * fAngle[slice * 2];
                    var ny = k * fAngle[slice * 2 + 1];
                    var d = Math.sqrt(nx * nx + ny * ny + nz * nz);
                    vDat[v++] = r * fAngle[slice * 2];
                    vDat[v++] = r * fAngle[slice * 2 + 1];
                    vDat[v++] = z;
                    vDat[v++] = nx / d;
                    vDat[v++] = ny / d;
                    vDat[v++] = nz / d;
                    if (stack > 1 && slice > 0) {
                        var ss = slices * stack;
                        iDat[f++] = ss + slice - slices;
                        iDat[f++] = ss + slice;
                        iDat[f++] = ss + slice - slices + 1;
                        iDat[f++] = ss + slice - slices + 1;
                        iDat[f++] = ss + slice;
                        iDat[f++] = ss + slice + 1;
                    }
                }
                if (stack > 1) {
                    var ss = slices * stack;
                    iDat[f++] = ss + slice - slices;
                    iDat[f++] = ss + slice;
                    iDat[f++] = ss - slices + 1;
                    iDat[f++] = ss - slices + 1;
                    iDat[f++] = ss + slice;
                    iDat[f++] = ss + 1;
                }
                if (stack < stacks) {
                    z += zs;
                    r -= rs;
                }
            }
            for (var slice = 0; slice < slices; slice++) {
                vDat[v++] = r * fAngle[slice * 2];
                vDat[v++] = r * fAngle[slice * 2 + 1];
                vDat[v++] = z;
                vDat[v++] = 0;
                vDat[v++] = 0;
                vDat[v++] = 1;
                if (slice > 0) {
                    var ss = slices * stack;
                    iDat[f++] = ss + slice;
                    iDat[f++] = vCnt - 1;
                    iDat[f++] = ss + slice + 1;
                }
            }
            vDat[v++] = 0;
            vDat[v++] = 0;
            vDat[v++] = z;
            vDat[v++] = 0;
            vDat[v++] = 0;
            vDat[v++] = 1;
            var ss = slices * stack;
            iDat[f++] = ss + slice;
            iDat[f++] = vCnt - 1;
            iDat[f++] = ss + 1;
            return { vertices: vDat, indices: iDat, size: iCnt };
        }
    },
    WriteLn: {
        value: function (str1, str2) {
            if (GLTFViewer.Utils.IsNull(str1))
                return;
            var line = str1;
            if (!GLTFViewer.Utils.IsNull(str2))
                line = line + " " + str2;

            ///////////////////
            // write to floating console
            if (false) {
                if (GLTFViewer.Utils.IsNull(GLTFViewer.Utils._console)) {
                    function ApplyCallback() {
                        GLTFViewer.Utils._console = null;
                    }
                    GLTFViewer.Utils._console = new GLTFViewer.Utils.Dialog("Console", null, false, ApplyCallback.bind(this), null, false, 0, 100, 200, 500);
                    GLTFViewer.Utils._consoleLine = 0;
                }
                if (GLTFViewer.Utils._console)
                    GLTFViewer.Utils._console.AppendData(++GLTFViewer.Utils._consoleLine + ": " + line);
            }
            // write to floating console
            ///////////////////

            console.log(line);
        }
    },
    WriteErr: {
        value: function (str1, str2) {
            if (GLTFViewer.Utils.IsNull(str1))
                return;
            if (str1.message)
                str1 = str1.message;

            // attempt to get callers frame
            var f = null;
            var l = null;
            if (false) // this code does not seem to work with standalone viewer
            {
                var e = new Error();
                if (!e.stack) {
                    try {
                        // IE requires the Error to actually be throw or else the Error's 'stack' property is undefined.
                        throw e;
                    } catch (e) {
                    }
                }
                if (e.stack) {
                    var stack = e.stack.toString().split(/\r\n|\n/);
                    // We want our caller's frame. It's index into |stack| depends on the
                    // browser and browser version, so we need to search for the second frame:
                    var frameRE = /(\/.*):(\d+):(?:\d+)[^\d]*$/;
                    do {
                        var frame = stack.shift();
                    } while (!frameRE.exec(frame) && stack.length);
                    e = frameRE.exec(stack.shift());
                    f = GLTFViewer.Utils.GetFileName(e[1]);
                    l = e[2];
                }
            }

            var line = str1;
            if (!GLTFViewer.Utils.IsNull(str2))
                line = line + " " + str2;
            if (!GLTFViewer.Utils.IsNull(f)) {
                if (!GLTFViewer.Utils.IsNull(l))
                    line = f + ":" + l + ":" + line;
                else
                    line = f + ":" + line;
            }
            console.log(line);
            //alert(line);
            
            if ((typeof __DONTSHOWALERT__ === 'undefined') && GLTFViewer.Utils.ShowAlert) {
                var parts = line.match(/.{1,55}/g);
                line = parts.join("\n");
                line = line + "\nIgnore further messages?";
                GLTFViewer.Utils.ShowAlert = !confirm(line);
            }
        }
    },
    IsAbsolutePath: {
        value: function (path) {
            var isAbsolutePathRegExp = new RegExp("^" + window.location.protocol, "i");
            if (path.match(isAbsolutePathRegExp))
                return true;
            isAbsolutePathRegExp = new RegExp("^[a-z]+:", "i");
            if (path.match(isAbsolutePathRegExp))
                return true;
            isAbsolutePathRegExp = new RegExp("^[/\\\\]")
            if (path.match(isAbsolutePathRegExp))
                return true;
            return false;
        }
    },
    ResolveEKMPath: {
        value: function (ekmUrlParamNameContextIdValue, pathBase, path) {
            //detect absolute path following the same protocol as window.location
            function UrlParamAppend(url, urlParamName, urlParamValue) {
                if (urlParamValue !== null && urlParamValue !== undefined) {
                    if (urlParamValue.length > 0) {
                        // Assuming url does not have any params initially
                        url = url + "?" + urlParamName + "=" + urlParamValue;
                    }
                }
                return url;
            }

            if (!this.IsAbsolutePath(path))
                path = pathBase + path;
            return UrlParamAppend(path, "tab", ekmUrlParamNameContextIdValue);
        }
    },
    GetEKMBasePath: {
        value: function (path) {
            function GetUrlParams(urlLocation) {
                var match;
                var pl = /\+/g;  // Regex for replacing addition symbol with a space
                var search = /([^&=]+)=?([^&]*)/g;
                var decode = function (s) { return decodeURIComponent(s.replace(pl, " ")); };
                var query = urlLocation.search.substring(1);
                var urlParams = {};
                while ((match = search.exec(query)) != null)
                    urlParams[decode(match[1])] = decode(match[2]);
                return urlParams;
            }
            function GetUrlParamByName(name, urlLocation) {
                var urlParams = GetUrlParams(urlLocation);
                if (name in urlParams) {
                    return urlParams[name];
                }
                return "";
            }

            // EKM Specific url param value
            var locationObj = document.createElement('a');
            locationObj.href = path;
            var ekmUrlParamNameContextIdValue = GetUrlParamByName("tab", locationObj);
            var p = locationObj.href.replace(/\\/g, '/');
            var i = p.lastIndexOf("/");
            var pathBase = (i !== 0) ? p.substring(0, i + 1) : '';
            return { ekmUrlParamNameContextIdValue: ekmUrlParamNameContextIdValue, pathBase: pathBase };
        }
    },
    GetFilePath: { 
        value: function (file) {
            if (GLTFViewer.Utils.IsNull(file))
                return "<unknown>";
            // nwjs sets .path to full path of drop/load event
            // normally browsers just set .name
            return file.path ? file.path : (file.name ? file.name : (typeof file === "string" ? file : "<unknown>"));
        }
    },
    GetFileName: { 
        value: function (fileName) {
            var s = fileName.split(/:|\/|\\/);
            if (s.length)
                return s[s.length - 1];
            return "";
        }
    },
    RemoveExt: {
        value: function (fileName) {
            if (typeof fileName !== 'string')
                return "";
            var i = fileName.lastIndexOf(".");
            if (i > 0)
                return fileName.substr(0, i);
            return fileName;
        }
    },
    GetExtension: { 
        value: function (fileName) {
            if (typeof fileName !== 'string')
                return "";
            var i = fileName.lastIndexOf(".");
            if (i > 0) // could be >= 0 ?
                return fileName.substr(i + 1).toLowerCase();
            return "";
        }
    },
    ReplaceExtension: { 
        value: function (fileName, ext) {
            var i = fileName.lastIndexOf(".");
            if (i > 0) // could be >= 0 ?
                return fileName.substr(0, i + 1) + ext;
            return "";
        }
    },
    ReplaceFileName: { 
        value: function (path, name) {
            var s = path.split(/:/);
            if (s.length) {
                s2 = s[s.length - 1].split(/\/|\\/);
                if (s2.length)
                    s2[s2.length - 1] = name;
                s[s.length - 1] = s2.join('/');
            }
            return s.join(':');
        }
    },
    ResolvePath: {
        value: function (path) {
            var s = path.split(/:/);
            if (s.length) {
                var joiner = '\\';
                if (s[s.length - 1].charAt(0) == '/')
                    joiner = '/';
                s2 = s[s.length - 1].split(/\/|\\/);
                for (var i = 1; i < s2.length; ) {
                    if (s2[i] === "..") {
                        s2.splice(i - 1, 2);
                        --i;
                    } else if (s2[i] === ".")
                        s2.splice(i, 1);
                    else
                        ++i;
                }
                s[s.length - 1] = s2.join(joiner);
            }
            return s.join(':');
        }
    },
    // creates a pre multiply matrix
    ExplosionMatrix: {
        value: function (sceneCenter, itemCenter, explosion) {
            var diff = GLTFViewer.Utils.Vec3.Create(sceneCenter, itemCenter).Scale(explosion);
            return GLTFViewer.Utils.Transformation.Identity.Translate(diff);
        }
    },
    GetBrowserHeight: {
        value: function () {
            return Math.max(
                $(document).height(),
                $(window).height(),
                /* For opera: */
                document.documentElement.clientHeight
            );
        }
    },
    GetBrowserWidth: {
        value: function () {
            return Math.max(
                $(document).width(),
                $(window).width(),
                /* For opera: */
                document.documentElement.clientWidth
            );
        }
    },
    BuildSlider: {
        value: function (viewer, container, id, width, height, margin, ballSize, trackSize, mn, mx, step) {
            var trackSizeBy2 = trackSize / 2;
            var isFlex = GLTFViewer.Utils.IsNull(width);

            container.append("<input id='" + id + "' type='range' min='" + mn + "' max='" + mx + "' step='" + step + "' value='0' style='display:inline;border:0;margin:" + margin + "px;padding:0;" + (isFlex ? "flex:1;-webkit-flex:1;" : "") + "'></input>");
            var slider = $("input", container).last();
            if (!isFlex)
                slider.css("width", width + "px");
            slider.css("height", height + "px");

            $("<style>input[id='" + id + "'] {-webkit-appearance:none;border:0;background:transparent;}</style>").appendTo($("head", viewer.document));
            // for chrome
            $("<style>input[id='" + id + "']:focus {outline:none;}</style>").appendTo($("head", viewer.document));

            //chrome
            $("<style>input[id='" + id + "']::-webkit-slider-runnable-track {height:" + trackSize + "px;background:white;border:none;border-radius:" + trackSizeBy2 + "px;}</style>").appendTo($("head", viewer.document));
            $("<style>input[id='" + id + "']:focus::-webkit-slider-runnable-track {background:white;}</style>").appendTo($("head", viewer.document));
            $("<style>input[id='" + id + "']::-webkit-slider-thumb {-webkit-appearance:none;border:none;height:" + ballSize + "px;width:" + ballSize + "px;border-radius:50%;background:" + GLTFViewer.BUTTONCOLOR + ";margin-top:" + ((trackSize - ballSize) / 2) + "px;}</style>").appendTo($("head", viewer.document));

            // firefox
            $("<style>input[id='" + id + "']::-moz-range-track     {height:" + trackSize + "px;background:white;border:none;border-radius:" + trackSizeBy2 + "px;}</style>").appendTo($("head", viewer.document));
            $("<style>input[id='" + id + "']::-moz-range-thumb     {border:none;height:" + ballSize + "px;width:" + ballSize + "px;border-radius:50%;background:" + GLTFViewer.BUTTONCOLOR + ";}</style>").appendTo($("head", viewer.document));
            //    $("<style>input[id='" + id + "']:-moz-focusring {outline:1px solid white;outline-offset:-1px;}</style>").appendTo($("head", viewer.document));

            // IE
            $("<style>input[id='" + id + "']::-ms-track            {height:" + trackSize + "px;background:transparent;border-color:transparent;border:none;color:transparent;}</style>").appendTo($("head", viewer.document));
            $("<style>input[id='" + id + "']:focus::-ms-fill-lower {background:white;border-radius:" + trackSizeBy2 + "px;}</style>").appendTo($("head", viewer.document));
            $("<style>input[id='" + id + "']:focus::-ms-fill-upper {background:white;border-radius:" + trackSizeBy2 + "px;}</style>").appendTo($("head", viewer.document));
            $("<style>input[id='" + id + "']::-ms-fill-lower       {background:white;border-radius:" + trackSizeBy2 + "px;}</style>").appendTo($("head", viewer.document));
            $("<style>input[id='" + id + "']::-ms-fill-upper       {background:white;border-radius:" + trackSizeBy2 + "px;}</style>").appendTo($("head", viewer.document));
            $("<style>input[id='" + id + "']::-ms-thumb            {border:none;height:" + ballSize + "px;width:" + ballSize + "px;border-radius:50%;background:" + GLTFViewer.BUTTONCOLOR + ";}</style>").appendTo($("head", viewer.document));
            // IE displays tooltip, so do not show it
            $("<style>input[id='" + id + "']::-ms-tooltip {display:none;}</style>").appendTo($("head", viewer.document));

            return slider;
        }
    },
    CreateModalShield: {
        value: function () {
            // create a shield over body
            var body = $("body");
            body.append("<div style='display:none;z-index:99998;position:absolute;top:0;left:0;width:" + GLTFViewer.Utils.GetBrowserWidth() + "px;height:" + GLTFViewer.Utils.GetBrowserHeight() + "px;background:transparent;'></div>");
            var container = $("div", body).last();
            GLTFViewer.Utils.NoContext(null, container);
            container.on("keydown", function (e) {
                e.stopPropagation();
            });

            $(window).resize((function (elem) {
                if (GLTFViewer.GetElementVisible(elem)) {
                    elem.css("width", GLTFViewer.Utils.GetBrowserWidth() + "px");
                    elem.css("height", GLTFViewer.Utils.GetBrowserHeight() + "px");
                }
            }).bind(this, container));

            return container;
        }
    }
});
////////////////////////////////////////
//
// Shader
//
/** @constructor */
GLTFViewer.Utils.ShaderProgram = function (gl, precision, vertexShader, fragmentShader) {
    this._gl = gl;
    this._shaders = [];
    this._attribLocation = {};
    this._uniformLocation = {};
    this._program = gl.createProgram();
    var err = gl.getError();
    if (err !== 0)
        throw new Error("ERROR(ShaderProgram): Can't create shader program: " + err);
    this._AttachShader(gl.VERTEX_SHADER, vertexShader);
    var fs = fragmentShader;
    if (precision)
        fs = "precision " + precision + " float;\n" + fs;
    this._AttachShader(gl.FRAGMENT_SHADER, fs);
    this._Link();
};
GLTFViewer.Utils.ShaderProgram.prototype = Object.create(null, {
    // properties
    constructor: { value: GLTFViewer.Utils.ShaderProgram },
    _gl: { writable: true, value: null },
    _inUse: { writable: true, value: false },
    _program: { writable: true, value: null },
    _shaders: { writable: true, value: null },
    _attribLocation: { writable: true, value: null },
    _uniformLocation: { writable: true, value: null },
    attribLocation: { get: function () { return this._attribLocation; } },
    uniformLocation: { get: function () { return this._uniformLocation; } },
    // methods
    _AttachShader: {
        value: function (typ, src) {
            var shader = this._gl.createShader(typ);
            this._gl.shaderSource(shader, src);
            this._gl.compileShader(shader);
            if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS))
                throw new Error("ERROR(ShaderProgram.AttachShader): ", this._gl.getShaderInfoLog(shader));
            this._gl.attachShader(this._program, shader);
            this._shaders.push(shader);
        }
    },
    _Link: {
        value: function () {
            if (this._shaders.length === 0)
                throw new Error("ERROR(ShaderProgram.Link): No shaders attached");
            this._gl.linkProgram(this._program);
            if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS))
                throw new Error("ERROR(ShaderProgram.Link): Unable to initialize the shader program");
            for (var i in this._shaders)
                this._gl.deleteShader(this._shaders[i]);
            this._shaders = [];
            // get attributes
            this._attribLocation = {};
            var na = this._gl.getProgramParameter(this._program, this._gl.ACTIVE_ATTRIBUTES);
            for (var i = 0; i < na; ++i) {
                var a = this._gl.getActiveAttrib(this._program, i);
                var n = a.name.replace(/\[[0-9]*\]/, "");
                this._attribLocation[n] = this._gl.getAttribLocation(this._program, a.name);
                this[n] = this._attribLocation[n];
            }
            // get uniforms
            this._uniformLocation = {};
            var nu = this._gl.getProgramParameter(this._program, this._gl.ACTIVE_UNIFORMS);
            for (var i = 0; i < nu; ++i) {
                var u = this._gl.getActiveUniform(this._program, i);
                var n = u.name.replace(/\[[0-9]*\]/, "");
                this._uniformLocation[n] = this._gl.getUniformLocation(this._program, u.name);
                this[n] = this._uniformLocation[n];
            }
        }
    },
    StartProgram: {
        value: function () {
            if (!this._program)
                return false;
            if (this._gl.__EKM_SHADER__ && this._gl.__EKM_SHADER__ === this)
                return true; // already started
            if (this._gl.__EKM_SHADER__)
                this._gl.__EKM_SHADER__.StopProgram();
            this._gl.useProgram(this._program);
            this._gl.__EKM_SHADER__ = this;
            // enable attributes
            for (var i in this._attribLocation)
                this._gl.enableVertexAttribArray(this._attribLocation[i]);
            return true;
        }
    },
    StopProgram: {
        value: function () {
            // disable attributes
            for (var i in this._attribLocation)
                this._gl.disableVertexAttribArray(this._attribLocation[i]);
            this._gl.useProgram(null);
            this._gl.__EKM_SHADER__ = null;
        }
    },
    DeleteProgram: {
        value: function () {
            if (this._gl.__EKM_SHADER__ === this)
                this._gl.__EKM_SHADER__.StopProgram();
            if (this._program) {
                this._gl.deleteProgram(this._program);
                this._program = null;
            }
        }
    }
});
// statics
Object.defineProperties(GLTFViewer.Utils.ShaderProgram, {
    precision: { value: "highp" },
    CreateClipableProgram: {
        value: function (gl, precision, vertexShader, fragmentShader, objectMatrix, position, clipPlaneName) {
            var varyingName = "_v_objPosition_";
            
            // fix vertex shader
            var re = /\s*void\s*main\s*\([^)]*\)\s*\{/;
            var str = "\nvarying vec4 " + varyingName + ";\nuniform mat4 " + objectMatrix + ";\n";
            var vs = GLTFViewer.Utils.InsertBefore(vertexShader, re, str);
            if (vs) {
                str = "\n" + varyingName + " = " + objectMatrix + " * vec4(" + position + ", 1.0);\n";
                vs = GLTFViewer.Utils.InsertAfter(vs, re, str);
            }
            if (!vs) {
                GLTFViewer.Utils.WriteLn("ERROR(ShaderProgram.CreateClipableProgram): Can't add clip code to vertex shader");
                 return null;
            }

            // fix fragment shader
            str = "\nvarying vec4 " + varyingName + ";\nuniform vec4 " + clipPlaneName + ";\n";
            var fs = GLTFViewer.Utils.InsertBefore(fragmentShader, re, str);
            if (fs) {
                str = "\nif (dot(" + varyingName + ", " + clipPlaneName + ") < 0.0) discard;\n";
                fs = GLTFViewer.Utils.InsertAfter(fs, re, str);
            }
            if (!fs) {
                GLTFViewer.Utils.WriteLn("ERROR(ShaderProgram.CreateClipableProgram): Can't add clip code to fragment shader");
                 return null;
            }

            var program = null;
            try {
                program = new GLTFViewer.Utils.ShaderProgram(gl, precision, vs, fs);
            } catch (err) {
                GLTFViewer.Utils.WriteErr(err);
            }
            return program;
        }
    },
    CreateClipableCapProgram: {
        value: function (gl, precision, vertexShader, fragmentShader, objectMatrix, position, clipPlaneName, colorName) {
            var varyingName = "_v_objPosition_";
            
            // fix vertex shader
            var re = /\s*void\s*main\s*\([^)]*\)\s*\{/;
            var str = "\nvarying vec4 " + varyingName + ";\nuniform mat4 " + objectMatrix + ";\n";
            var vs = GLTFViewer.Utils.InsertBefore(vertexShader, re, str);
            if (vs) {
                str = "\n" + varyingName + " = " + objectMatrix + " * vec4(" + position + ", 1.0);\n";
                vs = GLTFViewer.Utils.InsertAfter(vs, re, str);
            }
            if (!vs) {
                GLTFViewer.Utils.WriteLn("ERROR(ShaderProgram.CreateClipableCapProgram): Can't add clip code to vertex shader");
                 return null;
            }

            // fix fragment shader
            str = "\nvarying vec4 " + varyingName + ";\nuniform vec4 " + clipPlaneName + ";\nuniform vec4 " + colorName + ";\n";
            var fs = GLTFViewer.Utils.InsertBefore(fragmentShader, re, str);
            if (fs) {
                str = "\nif (dot(" + varyingName + ", " + clipPlaneName + ") < 0.0) discard;\n";
                fs = GLTFViewer.Utils.InsertAfter(fs, re, str);
            }
            if (fs) {
                re = /gl_FragColor\s*=\s*[^;]*\s*;/;
                str = "\ngl_FragColor = " + colorName + ";\n";
                fs = GLTFViewer.Utils.InsertReplace(fs, re, str);
            }
            if (!fs) {
                GLTFViewer.Utils.WriteLn("ERROR(ShaderProgram.CreateClipableCapProgram): Can't add clip code to fragment shader");
                 return null;
            }

            var program = null;
            try {
                program = new GLTFViewer.Utils.ShaderProgram(gl, precision, vs, fs);
            } catch (err) {
                GLTFViewer.Utils.WriteErr(err);
            }
            return program;
        }
    },
    CreatePeelProgram: {
        value: function (gl, precision, vertexShader, fragmentShader) {
            // fix fragment shader
            var re = /\s*void\s*main\s*\(\s*\)\s*\{/;
            var str = "\nuniform vec2 uSze;\n" +
                      "uniform int uPass;\n" +
                      "const float fAcc = 0.00001;\n" +
                      "uniform sampler2D DepthTex;\n";
            var fs = GLTFViewer.Utils.InsertBefore(fragmentShader, re, str);
            if (!fs)
                return null;

            re = /gl_FragColor.*;/;
            str = "\nif (uPass == 1) {\n" +
                  "  gl_FragColor.r = gl_FragCoord.z;\n" +
                  "} else if (uPass == 2) {\n" +
                  "  float d = texture2D(DepthTex, gl_FragCoord.xy / uSze).r;\n" + 
                  "  if (d == 0.0 || abs(d - gl_FragCoord.z) > fAcc) discard;\n" +
                  "} else if (uPass == 3) {\n" +
                  "  float d = texture2D(DepthTex, gl_FragCoord.xy / uSze).r;\n" + 
                  "  if (d == 0.0 || d - gl_FragCoord.z >= -fAcc) discard;\n" +
                  "  gl_FragColor.r = gl_FragCoord.z;\n" +
                  "}\n";
            fs = GLTFViewer.Utils.InsertAfter(fs, re, str);
            if (!fs)
                return null;

            var program = null;
            try {
                program = new GLTFViewer.Utils.ShaderProgram(gl, precision, vertexShader, fs);
            } catch (err) {
                // This can error on half_float configurations
                // We will allow the error in such cases and disable the clip tool
                // If we should have float support, then report an error
                var OES_texture_float = gl.getExtension('OES_texture_float');
                if (OES_texture_float) {
                    GLTFViewer.Utils.WriteErr(err);
                }
            }
            return program;
        }
    },
    RemoveComments: {
        value: function (shader) {
            var res = shader.replace(/\/\*[^]*?\*\//gm, "");
            return res.replace(/\/\/.*/g, "");
        }
    }
});
///////////////////////////////////////
//
//  Background
//
// will either be textured from image, or it will be a colored quad
/** @constructor */
GLTFViewer.Utils.Background = function (gl) {
    this._gl = gl;
    this._colorShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.Background._vsColor, GLTFViewer.Utils.Background._fsColor);
    var data = new ArrayBuffer(12 * 4); // single interleaved buffer
    this._solidPos = new Float32Array(data, 0, 12); // view into buffer
    this._solidClr = new Uint32Array(data, 0, 12); // view into buffer
    this._solidBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this._solidBuf);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
};
GLTFViewer.Utils.Background.prototype = Object.create(null, {
    // private members
    _gl: { writable: true, value: null },
    _colorSet: { writable: true, value: false },
    _bkColor0: { writable: true, value: -1 },    // LT
    _bkColor1: { writable: true, value: -1 },    // RT
    _bkColor2: { writable: true, value: -1 },    // LB
    _bkColor3: { writable: true, value: -1 },    // RB
    _colorShader: { writable: true, value: null },
    _solidBuf: { writable: true, value: null },
    _solidPos: { writable: true, value: null },
    _solidClr: { writable: true, value: null },
    // public members
    IsDark: {
        value: function (where) {
            if (!this._colorSet)
                return false;
            var c = new GLTFViewer.Utils.RGBA();
            var c2 = new GLTFViewer.Utils.RGBA();
            switch (where) {
                case GLTFViewer.Utils.Background.LEFTTOP:
                    c.SetRawABGR(this._bkColor0);
                    break;
                case GLTFViewer.Utils.Background.TOP:
                    c.SetRawABGR(this._bkColor0);
                    c2.SetRawABGR(this._bkColor0);
                    c.r = (c.r + c2.r) / 2;
                    c.g = (c.g + c2.g) / 2;
                    c.b = (c.b + c2.b) / 2;
                    c.a = (c.a + c2.a) / 2;
                    break;
                case GLTFViewer.Utils.Background.RIGHTTOP:
                    c.SetRawABGR(this._bkColor1);
                    break;
                case GLTFViewer.Utils.Background.RIGHT:
                    c.SetRawABGR(this._bkColor1);
                    c2.SetRawABGR(this._bkColor3);
                    c.r = (c.r + c2.r) / 2;
                    c.g = (c.g + c2.g) / 2;
                    c.b = (c.b + c2.b) / 2;
                    c.a = (c.a + c2.a) / 2;
                    break;
                case GLTFViewer.Utils.Background.RIGHTBOTTOM:
                    c.SetRawABGR(this._bkColor3);
                    break;
                case GLTFViewer.Utils.Background.BOTTOM:
                    c.SetRawABGR(this._bkColor3);
                    c2.SetRawABGR(this._bkColor2);
                    c.r = (c.r + c2.r) / 2;
                    c.g = (c.g + c2.g) / 2;
                    c.b = (c.b + c2.b) / 2;
                    c.a = (c.a + c2.a) / 2;
                    break;
                case GLTFViewer.Utils.Background.LEFTBOTTOM:
                    c.SetRawABGR(this._bkColor2);
                    break;
                case GLTFViewer.Utils.Background.LEFT:
                    c.SetRawABGR(this._bkColor2);
                    c2.SetRawABGR(this._bkColor0);
                    c.r = (c.r + c2.r) / 2;
                    c.g = (c.g + c2.g) / 2;
                    c.b = (c.b + c2.b) / 2;
                    c.a = (c.a + c2.a) / 2;
                    break;
                default: // GLTFViewer.Utils.Background.CENTER
                    c.SetRawABGR(this._bkColor1);
                    c2.SetRawABGR(this._bkColor2);
                    c.r = (c.r + c2.r) / 2;
                    c.g = (c.g + c2.g) / 2;
                    c.b = (c.b + c2.b) / 2;
                    c.a = (c.a + c2.a) / 2;
                    break;
            }
            return c.GetGray() < 0.5;
        }
    },
    // private methods
    // public methods
    Reset: {
        value: function () {
            this._colorSet = false;
            this._bkColor0 = -1;
            this._bkColor1 = -1;
            this._bkColor2 = -1;
            this._bkColor3 = -1;
        }
    },
    Clear: {
        value: function () {
            GLTFViewer.Utils.Background.prototype.Reset.call(this);
            if (this._colorShader !== null) {
                this._colorShader.DeleteProgram();
                this._colorShader = null;
            }
            this._solidPos = null;
            this._solidClr = null;
            if (this._solidBuf) {
                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, null);
                this._gl.deleteBuffer(this._solidBuf);
                this._solidBuf = null;
            }
            this._gl = null;
        }
    },
    SetSolidColors: {
        value: function (LT, RT, LB, RB) {
            this._colorSet = true;
            this._bkColor0 = LT;
            this._bkColor1 = RT;
            this._bkColor2 = LB;
            this._bkColor3 = RB;
        }
    },
    Render: {
        value: function () {
            var gl = this._gl;
            if (!this._colorSet)
                return;
            var pos = this._solidPos;
            var clr = this._solidClr;
            var shader = this._colorShader;
            if (!shader.StartProgram())
                return;
            gl.disable(gl.DEPTH_TEST);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._solidBuf);
            var vc = 0;
            pos[vc++] = 0;
            pos[vc++] = 0;
            clr[vc++] = this._bkColor0;
            pos[vc++] = 1;
            pos[vc++] = 0;
            clr[vc++] = this._bkColor1;
            pos[vc++] = 0;
            pos[vc++] = 1;
            clr[vc++] = this._bkColor2;
            pos[vc++] = 1;
            pos[vc++] = 1;
            clr[vc++] = this._bkColor3;
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._solidPos);
            gl.vertexAttribPointer(shader.aPos, 2, gl.FLOAT, false, 12, 0);
            gl.vertexAttribPointer(shader.aTex, 4, gl.UNSIGNED_BYTE, true, 12, 8);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.enable(gl.DEPTH_TEST);
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.Background, {
    // private members
    _vsColor: {
        value: "attribute vec2 aPos;\n" +
               "attribute vec4 aTex;\n" +
               "varying vec4 vTex;\n" +
               "void main() {\n" +
                   "vec2 tmp = (aPos * 2.0 - 1.0) * vec2(1, -1);\n" +
                   "vTex = aTex;\n" +
                   "gl_Position = vec4(tmp, 0, 1);\n" +
               "}"
    },
    _fsColor: {
        value: "varying vec4 vTex;\n" +
               "void main() {\n" +
                   "gl_FragColor = vTex;\n" +
               "}"
    },
    // public members
    LEFTTOP: { value: 0 },
    TOP: { value: 1 },
    RIGHTTOP: { value: 2 },
    RIGHT: { value: 3 },
    RIGHTBOTTOM: { value: 4 },
    BOTTOM: { value: 5 },
    LEFTBOTTOM: { value: 6 },
    LEFT: { value: 7 },
    CENTER: { VALUE: 8 }
    // public methods
});
///////////////////////////////////////
//
// Ruler
//
/** @constructor */
GLTFViewer.Utils.Ruler = function (gx, navigator) {
    this._gx = gx;
    this._navigator = navigator;
};
GLTFViewer.Utils.Ruler.prototype = Object.create(null, {
    // private members
    _navigator: { writable: true, value: null },
    _gx: { writable: true, value: null },
    // public members
    // private methods
    // public methods
    Reset: {
        value: function () {
        }
    },
    Clear: {
        value: function () {
            this._navigator = null;
            this._gx = null;
        }
    },
    Render: {
        value: function () {
            var textHeight = 12;
            var navigator = this._navigator;
            if (navigator.persp || navigator._scene.viewer._option["tn"])
                return;
            var scene = navigator._scene;
            var handler = scene ? scene.handler : null;
            if (!handler)
                return;
            var foreground = (scene.background && scene.background.IsDark(GLTFViewer.Utils.Background.BOTTOM)) ? "rgba(255, 255, 255, 1)" : "rgba(0, 0, 0, 1)";
            var background = (scene.background && scene.background.IsDark(GLTFViewer.Utils.Background.BOTTOM)) ? "rgba(0, 0, 0, 0.5)" : "rgba(255, 255, 255, 0.5)";
            var gx = this._gx;
            var width = navigator.canvasWidth;
            var height = navigator.canvasHeight;
            var objScale = navigator.projectionTM.a33;
            if (width > height)
                objScale *= width / height;
            var rulerWidthFraction = 1 / 3;
            var rulerLength = rulerWidthFraction * objScale;
            var tmp = Math.log(rulerLength) / Math.LN10;
            tmp = Math.pow(10, Math.floor(tmp));
            rulerLength = Math.floor(rulerLength / tmp) * tmp;
            // make width of ruler a nice round number
            rulerWidth = rulerLength / objScale;

            // get ruler info
            var units = null;
            var ruler = handler.Ruler;
            if (!ruler)
                return;
            var scale = ruler.scale;
            if (scale > 0) {
                units = ruler.units;
                if (!units || units === "")
                    return;
                rulerLength *= scale;
            }
            var text;
            if (rulerLength >= 100000) 
                text = rulerLength.toExponential(3);
            else if (rulerLength >= 1000)
                text = rulerLength.toFixed(0);
            else if (rulerLength >= 100)
                text = rulerLength.toFixed(1);
            else if (rulerLength >= 10)
                text = rulerLength.toFixed(2);
            else if (rulerLength >= 1)
                text = rulerLength.toFixed(3);
            else if (rulerLength >= 0.01)
                text = rulerLength.toFixed(4);
            else 
                text = rulerLength.toExponential(3);
            if (units) {
                text += "  (" + units + ")";
            }
            var rulerX = width * (1 - rulerWidth) / 2;
            var rulerY = height - 50;

            gx.lineCap = 'round';
            gx.textBaseline = "middle";
            gx.textAlign = "start";
            gx.font = textHeight + "px Sans-Serif";

            // background
            var border = 2;
            var x = rulerX;
            var y = rulerY;
            var tlx = x - border;
            var tly = y - border;
            var brx = x + width * rulerWidth + 10 + gx.measureText(text).width + border;
            var bry = y + textHeight + border;
            gx.fillStyle = background;
            gx.lineWidth = 0;
            gx.beginPath();
            gx.moveTo(tlx, tly);
            gx.lineTo(tlx, bry);
            gx.lineTo(brx, bry);
            gx.lineTo(brx, tly);
            gx.fill();

            // foreground
            // ruler
            gx.strokeStyle = foreground;
            gx.lineWidth = 1;
            x = rulerX;
            y = rulerY;
            gx.beginPath();
            gx.moveTo(x, y);
            y += textHeight;
            gx.lineTo(x, y);
            x += width * rulerWidth;
            gx.lineTo(x, y);
            y -= textHeight;
            gx.lineTo(x, y);
            gx.stroke();
            // text
            x += 10;
            y += textHeight / 2;
            gx.fillStyle = foreground;
            gx.fillText(text, x, y);
        }
    }
});
//
// Ruler
//
///////////////////////////////////////
///////////////////////////////////////
//
// Legend
//
/** @constructor */
GLTFViewer.Utils.Legend = function(scene, vertical, x, y, size, attachment, border, foregroundColorRGBA, backgroundColorRGBA, title, valueMin, valueMax, numTicks, valueLocation, logIt, img, units, other) {
    this._scene = scene;
    this._vertical = vertical;
    if ((typeof x === 'number') && x >= 0 && x < 1)
        this._x = x;
    if ((typeof y === 'number') && y >= 0 && y < 1)
        this._y = y;
    if ((typeof size === 'number') && size > 0 && size <= 1)
        this._size = size;
    if ((typeof attachment === 'number') && attachment >= 0 && attachment <= 15)
        this._attachment = attachment;
    if (border)
        this._border = true;
    if (foregroundColorRGBA instanceof GLTFViewer.Utils.RGBA)
        this._foregroundColor = "rgba(" + Math.round(foregroundColorRGBA.r) + "," + Math.round(foregroundColorRGBA.g) + "," + Math.round(foregroundColorRGBA.b) + "," + foregroundColorRGBA.a / 255 + ")";
    else
        this._foregroundColor = "rgba(0, 0, 0, 1)";
    if ((backgroundColorRGBA instanceof GLTFViewer.Utils.RGBA) && backgroundColorRGBA.a)
        this._backgroundColor = "rgba(" + Math.round(backgroundColorRGBA.r) + "," + Math.round(backgroundColorRGBA.g) + "," + Math.round(backgroundColorRGBA.b) + "," + backgroundColorRGBA.a / 255 + ")";
    if (title instanceof Array) {
        this._title = title;
        if (this._title.length > 2)
            this._title.length = 2;
    } else
        this._title = [];
    if (typeof valueMin === 'number')
        this._valueMin = valueMin;
    if (typeof valueMin === 'number')
        this._valueMax = valueMax;
    if (this._valueMin > this._valueMax) {
        var t = this._valueMax;
        this._valueMax = this._valueMin;
        this._valueMin = t;
    }
    if (!GLTFViewer.Utils.IsNull(valueLocation)) {
        this._valueLocation = valueLocation;
        this._numTicks = valueLocation.length / 2;
        if (this._numTicks < 2) {
            GLTFViewer.Utils.WriteErr("ERROR(Legend): Too few valueLocations");
            this._numTicks = 0;
            this._valueLocation = null;
        }
    }  else if (typeof numTicks === 'number' && numTicks > 1)
        this._numTicks = numTicks;
    if (GLTFViewer.Utils.IsNull(valueLocation) && logIt)
        this._logIt = true;
    // needs to be a png image
    this._img = img;

    this._units = [];
    if (typeof units === 'string' && units.length) {
        this._units = [];
        this._units.push("[" + units + "]");
    }
    if (other instanceof Array)
        this._other = other;
    else
        this._other = [];
};
GLTFViewer.Utils.Legend.prototype = Object.create(null, {
    // private members
    _scene: { writable: true, value: null },
    _vertical: { writable: true, value: true },
    _x: { writable: true, value: 0 },
    _y: { writable: true, value: 0 },
    _size: { writable: true, value: 0.5 },
    _attachment: { writable: true, value: 7 }, // RLTB bits, defaults to left/center
    _border: { writable: true, value: false },
    _foregroundColor: { writable: true, value: null }, // black
    _backgroundColor: { writable: true, value: null }, // transparent
    _title: { writable: true, value: null },
    _valueMin: { writable: true, value: 0 },
    _valueMax: { writable: true, value: 1 },
    _numTicks: { writable: true, value: 0 }, // auto
    _valueLocatino: { writable: true, value: null },
    _logIt: { writable: true, value: false }, // linear
    _img: { writable: true, value: null },
    _units: { writable: true, value: null },
    _other: { writable: true, value: null },
    _canvasWidth: { writable: true, value: 0 },
    _canvasHeight: { writable: true, value: 0 },
    _legendImage: { writable: true, value: null },
    _legendX: { writable: true, value: 0 },
    _legendY: { writable: true, value: 0 },
    _legendWidth: { writable: true, value: 0 },
    _legendHeight: { writable: true, value: 0 },

    // private members
    _GenerateTickValues: {
        value: function (numTicks) {
            // generate tick values
            var values = [];
            var vMax = this._valueMax;
            var vMin = this._valueMin;
            var vRange = vMax - vMin;
            values.push([0, vMin.toExponential(4)]);
            if (numTicks > 2) {
                if (!GLTFViewer.Utils.IsNull(this._valueLocation)) {
                    for (var i = 1; i < numTicks - 1; ++i) {
                        var v = this._valueLocation[2 * i + 0] * vRange + vMin;
                        values.push([this._valueLocation[2 * i + 1], v.toExponential(4)]);
                    }
                } else if (this._logIt && this._valueMin > 0 && this._valueMax > 0) {
                    var logMax = Math.log(vMax) / Math.LN10;
                    var logMin = Math.log(vMin) / Math.LN10;
                    var logInc = (logMax - logMin) / (numTicks > 3 ? (numTicks - 1) : 1);
                    for (var i = 1; i < numTicks - 1; ++i) {
                        logMin += logInc;
                        var v = Math.pow(10, logMin);
                        values.push([i / (numTicks - 1), v.toExponential(4)]);
                    }
                } else {
                    for (var i = 1; i < numTicks - 1; ++i) {
                        var f = i / (numTicks - 1);
                        var v = vMin + f * vRange;
                        values.push([f, v.toExponential(4)]);
                    }
                }
            }
            values.push([1, vMax.toExponential(4)]);

            return values;
        }
    },
    //  +------------------+
    //  | Title\n          |   <- gets allocated 0 - 2 lines
    //  | Title            |
    //  | +---+- Value n   |   <- get allocated N lines
    //  | |   |            |
    //  | |   +- Value ... |
    //  | |   |            |
    //  | |   +- Value 2   |
    //  | |   |            |
    //  | |   +- Value 1   |
    //  | |   |            |
    //  | +---+- Value 0   |
    //  | [Units]          |    <- gets allocated 0 - 1 lines
    //  | Other\n          |    <- gets allocated 0 - N lines
    //  | string           |
    //  +------------------+
    _BuildVerticalImage: {
        value: function () {
            var canvasWidth = this._canvasWidth;
            var canvasHeight = this._canvasHeight;

            // legend height =
            //    margin
            //  + title.length * fontSize
            //  + title.length ? margin : 0
            //  + numTicks * fontSize
            //  + units.length * fontSize
            //  + other.length  ? margin : 0
            //  + other.length * _OTHERFONTSCALE * fontSize
            //  + margin

            var maxSceneSize = canvasWidth > canvasHeight ? canvasHeight : canvasWidth;
            this._legendHeight =  Math.ceil(maxSceneSize * this._size);
            var numTicks = 3;
            if (this._numTicks) {
                numTicks = this._numTicks;
                if (GLTFViewer.Utils.IsNull(this._valueLocation) && this._logIt && numTicks < 4) {
                    numTicks = 4;
                }
            }
            var fontSize = Math.floor((this._legendHeight - 2 * GLTFViewer.Utils.Legend._MARGIN - (this._title.length ? GLTFViewer.Utils.Legend._MARGIN : 0) - (this._other.length ? GLTFViewer.Utils.Legend._MARGIN : 0)) / (this._title.length + numTicks + this._units.length + GLTFViewer.Utils.Legend._OTHERFONTSCALE * this._other.length));
            if (fontSize < 1)
                fontSize = 1;
            else if (fontSize > GLTFViewer.Utils.Legend._MAXFONTSIZE)
                fontSize = GLTFViewer.Utils.Legend._MAXFONTSIZE;
            var otherFontSize = Math.floor(fontSize * GLTFViewer.Utils.Legend._OTHERFONTSCALE);
            if (otherFontSize < 1)
                otherFontSize = 1;
            
            if (!this._numTicks) {
                numTicks = Math.floor((this._legendHeight - 2 * GLTFViewer.Utils.Legend._MARGIN - (this._title.length ? GLTFViewer.Utils.Legend._MARGIN : 0) - (this._other.length ? GLTFViewer.Utils.Legend._MARGIN : 0) - this._other.length * otherFontSize) / fontSize) - this._title.length - this._units.length;
                if (numTicks > GLTFViewer.Utils.Legend._MAXTICKS)
                    numTicks = GLTFViewer.Utils.Legend._MAXTICKS;
            }

            // generate tick values
            var values = this._GenerateTickValues(numTicks);

            var gx = this._scene.gx;
            gx.textBaseline = "top"; // measure from top of text
            gx.textAlign = "left"; // measure from left of text
            gx.font = "bold " + fontSize + "px sans-serif";
            gx.fillStyle = "black"; //this._foregroundColor;
            //gx.strokeStyle = this._foregroundColor;
            gx.lineWidth = 0;

            // calculate width
            this._legendWidth = 0;
            {
                // Measure width of title
                var titleWidth = GLTFViewer.Utils.TextWidth(gx, this._title);

                // measure width of values
                var valueWidth = 0;
                for (var i = 0; i < values.length; ++i) {
                    var w = GLTFViewer.Utils.TextWidth(gx, values[i][1]);
                    values[i].push(w);
                    valueWidth = Math.max(valueWidth, w);
                }
                valueWidth += GLTFViewer.Utils.Legend._BARSIZE + GLTFViewer.Utils.Legend._MARGIN + GLTFViewer.Utils.Legend._TICKSIZE;

                // Measure width of units
                var unitWidth = GLTFViewer.Utils.TextWidth(gx, this._units);

                // Measure width of other
                gx.font = otherFontSize + "px sans-serif";
                var otherWidth = GLTFViewer.Utils.TextWidth(gx, this._other);

                this._legendWidth = Math.ceil(Math.max(titleWidth, valueWidth, unitWidth, otherWidth) + 2 * GLTFViewer.Utils.Legend._MARGIN);
            }
            // recalculate this._legendHeight
            // space the ticks evenly
            var barHeight = this._legendHeight - 2 * GLTFViewer.Utils.Legend._MARGIN - (this._title.length ? GLTFViewer.Utils.Legend._MARGIN : 0) - (this._other.length ? GLTFViewer.Utils.Legend._MARGIN : 0) - (this._title.length + this._units.length + 1) * fontSize - this._other.length * otherFontSize;
            this._legendHeight = barHeight + 2 * GLTFViewer.Utils.Legend._MARGIN + (this._title.length ? GLTFViewer.Utils.Legend._MARGIN : 0) + (this._other.length ? GLTFViewer.Utils.Legend._MARGIN : 0) + (this._title.length + this._units.length + 1) * fontSize + this._other.length * otherFontSize;

            // create a canvas to render the legend
            var canvas = document.createElement("canvas");
            document.body.appendChild(canvas);
            canvas.width = this._legendWidth;
            canvas.height = this._legendHeight;
            var cgx = canvas.getContext('2d');
            // prevent the color map image from being smoothed
            cgx.mozImageSmoothingEnabled = false;
            cgx.msImageSmoothingEnabled = false;
            cgx.imageSmoothingEnabled = false;

            // Draw Background
            if (!GLTFViewer.Utils.IsNull(this._backgroundColor)) {            
                cgx.fillStyle = this._backgroundColor;
                cgx.fillRect(0, 0, this._legendWidth, this._legendHeight);            
            }
             
            cgx.font = "bold " + fontSize + "px sans-serif";
            cgx.fillStyle = this._foregroundColor;
            cgx.strokeStyle = this._foregroundColor;
            cgx.lineWidth = 2;

            // Draw Border
            if (this._border)
                cgx.strokeRect(0, 0, this._legendWidth, this._legendHeight);

            var RL = Math.floor(this._attachment / 4);
            var onLeft = ((RL == 0 && this._x > 0.5) || RL == 2);
            if (onLeft)
                cgx.textAlign = "right";
            else
                cgx.textAlign = "left";

            // Draw Title
            var y = GLTFViewer.Utils.Legend._MARGIN;
            if (this._title.length) {
                cgx.textBaseline = "top";
                var x = onLeft ? (this._legendWidth - GLTFViewer.Utils.Legend._MARGIN) : GLTFViewer.Utils.Legend._MARGIN;
                for (var i = 0; i < this._title.length; ++i) {
                    cgx.fillText(this._title[i], x, y);
                    y += fontSize;
                }
                y += GLTFViewer.Utils.Legend._MARGIN;
            }

            // Draw Image
            {
                cgx.textBaseline = "middle";
                y += Math.ceil(0.5 * fontSize);
                var width = GLTFViewer.Utils.Legend._BARSIZE;
                var height = barHeight;
                var x = onLeft ? (this._legendWidth - GLTFViewer.Utils.Legend._MARGIN - width) : GLTFViewer.Utils.Legend._MARGIN;

                if (this._img) {
                    // Image
                    cgx.translate(x, y + height);
                    cgx.rotate(-Math.PI / 2);

                    if (GLTFViewer.Utils.IsNull(this._valueLocation))
                        cgx.drawImage(this._img, 0, 0, height, width);
                    else {
                        var _x1 = 0;
                        var _x2 = 0;
                        for (var i = 1; i < numTicks; ++i) {
                            var _w1 = this._valueLocation[2 * i + 0] - this._valueLocation[2 * i - 2];
                            var _w2 = this._valueLocation[2 * i + 1] - this._valueLocation[2 * i - 1];
                            cgx.drawImage(this._img,
                                          _x1 * this._img.width, 0, _w1 * this._img.width, this._img.height,
                                          _x2 * height, 0, _w2 * height, width);
                            _x1 += _w1;
                            _x2 += _w2;
                        }
                    }
                    cgx.rotate(Math.PI / 2);
                    cgx.translate(-x, -y - height);
                }

                // Box
                cgx.strokeRect(x, y, width, height);

                // Ticks
                x += onLeft ? -GLTFViewer.Utils.Legend._TICKSIZE : width;
                y += height;
                width = GLTFViewer.Utils.Legend._TICKSIZE;
                for (var i = 0; i < values.length; ++i) {
                    var _x = x;
                    var _y = y - values[i][0] * height;
                    cgx.beginPath();
                    cgx.moveTo(_x, _y);
                    _x += width;
                    cgx.lineTo(_x, _y);
                    cgx.stroke();

                    _x +=  onLeft ? -(width + GLTFViewer.Utils.Legend._MARGIN) : GLTFViewer.Utils.Legend._MARGIN;
                    cgx.fillText(values[i][1], _x, _y);
                }
                y += Math.floor(0.5 * fontSize);
            }

            // Draw Units
            if (this._units.length) {
                cgx.textBaseline = "top"; // measure from top of text
                var x = onLeft ? (this._legendWidth - GLTFViewer.Utils.Legend._MARGIN) : GLTFViewer.Utils.Legend._MARGIN;
                cgx.fillText(this._units[0], x, y);
                y += fontSize;
            }

            // Draw Other
            if (this._other.length) {
                cgx.textBaseline = "top"; // measure from top of text
                cgx.font = otherFontSize + "px sans-serif";
                var x = onLeft ? (this._legendWidth - GLTFViewer.Utils.Legend._MARGIN) : GLTFViewer.Utils.Legend._MARGIN;
                y += GLTFViewer.Utils.Legend._MARGIN;
                for (var i = 0; i < this._other.length; ++i) {
                    cgx.fillText(this._other[i], x, y);
                    y += otherFontSize;
                }
            }

            // get canvas into img
            this._legendImage = canvas.toDataURL();
            document.body.removeChild(canvas);
        }
    },
    //  +---------------------------------+
    //  |         0   1   2      .      n |
    //  |                                 |
    //  |       e   e   e      e      e   |
    //  |      u   u   u      u      u    |
    //  |     l   l   l      l      l     |
    //  |    a   a   a      a      a      |
    //  |   V   V   V      V      V       |
    //  |  /   /   /      /      /        |
    //  | +---+---+------+------+         |
    //  | |                     | Other\n |
    //  | +---------------------+ string  |
    //  | Title\n         [Units]         |
    //  | Title                           |
    //  +---------------------------------+
    _BuildHorizontalImage: {
        value: function () {
            var canvasWidth = this._canvasWidth;
            var canvasHeight = this._canvasHeight;

            var tw, th; // title
            var uw, uh; // units
            var ow, oh; // other
            var bw, bh; // bar
            var vow, vh; // values

            var maxSceneSize = canvasWidth > canvasHeight ? canvasHeight : canvasWidth;
            this._legendWidth = Math.ceil(maxSceneSize * this._size);
            var numTicks = 3;
            if (this._numTicks) {
                numTicks = this._numTicks;
                if (GLTFViewer.Utils.IsNull(this._valueLocation) && this._logIt && numTicks < 4) {
                    numTicks = 4;
                }
            }

            // assume a fontsize of 10 for ticks
            var gx = this._scene.gx;
            gx.textBaseline = "top"; // measure from top of text
            gx.textAlign = "left"; // measure from left of text
            gx.font = "bold 10px sans-serif";
            gx.fillStyle = "black"; //this._foregroundColor;
            //gx.strokeStyle = this._foregroundColor;
            gx.lineWidth = 0;
            // guess at sizes
            // title width
            tw = GLTFViewer.Utils.TextWidth(gx, this._title);
            th = this._title.length * 10;
            // units width
            uw = GLTFViewer.Utils.TextWidth(gx, this._units);
            uh = this._units.length * 10;

            var values = this._GenerateTickValues(2);
            var valueWidth0 = GLTFViewer.Utils.TextWidth(gx, values[0][1]);
            var valueWidth1 = GLTFViewer.Utils.TextWidth(gx, values[1][1]);
            valueWidth = Math.max(valueWidth0, valueWidth1);
            // vertical distance of tick text if on 45 angle and left/center aligned
            var vdh = Math.sqrt(25 + valueWidth * valueWidth);
            vh = Math.ceil(vdh * Math.sin(Math.PI / 4 + Math.acos(valueWidth / vdh)));
            // horizontal distance of last tick entry
            vdh = Math.sqrt(25 + valueWidth1 * valueWidth1);
            vow = Math.ceil(vdh * Math.cos(Math.PI / 4 - Math.acos(valueWidth1 / vdh)));

            // assume a fontsize of 8 for ticks
            gx.font = "8px sans-serif";
            ow = GLTFViewer.Utils.TextWidth(gx, this._other);
            oh = this._other.length * 8;

            bw = Math.ceil(numTicks * 10 * GLTFViewer.Utils.root2);
            bh = GLTFViewer.Utils.Legend._BARSIZE;

            // legend width =
            //    2 * margin
            //  + Max(tw + uw, bw) * fontScale
            //  + Max(vow, ow + margin)
            //  + margin
            
            var fontScale = (this._legendWidth - 3 * GLTFViewer.Utils.Legend._MARGIN - Math.max(vow, ow + (ow ? GLTFViewer.Utils.Legend._MARGIN : 0))) / Math.max(tw + uw, bw);
            fontSize = Math.floor(fontScale * 10);
            if (fontSize < 1)
                fontSize = 1;
            else if (fontSize > GLTFViewer.Utils.Legend._MAXFONTSIZE)
                fontSize = GLTFViewer.Utils.Legend._MAXFONTSIZE;
            var otherFontSize = Math.floor(fontSize * GLTFViewer.Utils.Legend._OTHERFONTSCALE);
            if (otherFontSize < 1)
                otherFontSize = 1;
            if (!this._numTicks) {
                tw = Math.ceil(tw * fontSize / 10);
                uw = Math.ceil(uw * fontSize / 10);
                vow = Math.ceil(vow * fontSize / 10);
                ow = Math.ceil(ow * otherFontSize / 10);
                numTicks = Math.floor((this._legendWidth - 3 * GLTFViewer.Utils.Legend._MARGIN - Math.max(vow, ow + (ow ? GLTFViewer.Utils.Legend._MARGIN : 0))) / fontSize / GLTFViewer.Utils.root2);
                if (numTicks > GLTFViewer.Utils.Legend._MAXTICKS)
                    numTicks = GLTFViewer.Utils.Legend._MAXTICKS;
            }

            // generate tick values
            var values = this._GenerateTickValues(numTicks);

            // calculate real sizes
            // width
            {
                gx.font = "bold " + fontSize + "px sans-serif";

                // title
                tw = GLTFViewer.Utils.TextWidth(gx, this._title);
                th = this._title.length * fontSize;
                // units
                uw = GLTFViewer.Utils.TextWidth(gx, this._units);
                uh = this._units.length * fontSize;

                // values
                var valueWidth0 = GLTFViewer.Utils.TextWidth(gx, values[0][1]);
                var valueWidth1 = GLTFViewer.Utils.TextWidth(gx, values[1][1]);
                valueWidth = Math.max(valueWidth0, valueWidth1);
                // vertical distance of tick text if on 45 angle and left/center aligned
                var vdh = Math.sqrt(25 + valueWidth * valueWidth);
                vh = Math.ceil(vdh * Math.sin(Math.PI / 4 + Math.acos(valueWidth / vdh)));
                // horizontal distance of last tick entry
                vdh = Math.sqrt(25 + valueWidth1 * valueWidth1);
                vow = Math.ceil(vdh * Math.cos(Math.PI / 4 - Math.acos(valueWidth1 / vdh)));

                var vw = Math.ceil(numTicks * fontSize * GLTFViewer.Utils.root2);
                bw = Math.max(Math.max(uw + tw, vw), this._legendWidth - 3 * GLTFViewer.Utils.Legend._MARGIN - Math.max(vow, ow + (ow ? GLTFViewer.Utils.Legend._MARGIN : 0)));

                // measure width of other
                gx.font = otherFontSize + "px sans-serif";
                ow = GLTFViewer.Utils.TextWidth(gx, this._other);
                oh = this._other.length * otherFontSize;

                this._legendWidth = bw + Math.max(vow, ow + (ow ? GLTFViewer.Utils.Legend._MARGIN : 0)) + 3 * GLTFViewer.Utils.Legend._MARGIN;
            }
            // height
            var thuh = Math.max(th, uh);
            thuh += (thuh ? GLTFViewer.Utils.Legend._MARGIN : 0);
            this._legendHeight = 3 * GLTFViewer.Utils.Legend._MARGIN + Math.max(thuh + GLTFViewer.Utils.Legend._BARSIZE, oh) + GLTFViewer.Utils.Legend._TICKSIZE + vh;

            // create a canvas to render the legend
            var canvas = document.createElement("canvas");
            document.body.appendChild(canvas);
            canvas.width = this._legendWidth;
            canvas.height = this._legendHeight;
            var cgx = canvas.getContext('2d');
            // prevent the color map image from being smoothed
            cgx.mozImageSmoothingEnabled = false;
            cgx.msImageSmoothingEnabled = false;
            cgx.imageSmoothingEnabled = false;

            // Draw Background
            if (!GLTFViewer.Utils.IsNull(this._backgroundColor)) {            
                cgx.fillStyle = this._backgroundColor;
                cgx.fillRect(0, 0, this._legendWidth, this._legendHeight);            
            }
             
            cgx.font = "bold " + fontSize + "px sans-serif";
            cgx.fillStyle = this._foregroundColor;
            cgx.strokeStyle = this._foregroundColor;
            cgx.lineWidth = 2;

            // Draw Border
            if (this._border)
                cgx.strokeRect(0, 0, this._legendWidth, this._legendHeight);

            var RL = Math.floor(this._attachment / 4);
            var TB = this._attachment - RL * 4;
            var onBottom = ((TB == 0 && this._y < 0.5) || TB == 2);

            // location of bar
            var x = 2 * GLTFViewer.Utils.Legend._MARGIN;
            var y = onBottom ? GLTFViewer.Utils.Legend._MARGIN + Math.max(thuh + GLTFViewer.Utils.Legend._BARSIZE, oh) - GLTFViewer.Utils.Legend._BARSIZE : this._legendHeight - Math.max(thuh + GLTFViewer.Utils.Legend._BARSIZE, oh) - GLTFViewer.Utils.Legend._MARGIN;

            // Draw Title
            if (this._title.length) {
                cgx.textAlign = "left";
                cgx.textBaseline = "top";
                var _y = onBottom ? (y - GLTFViewer.Utils.Legend._MARGIN - th) : y + GLTFViewer.Utils.Legend._BARSIZE + GLTFViewer.Utils.Legend._MARGIN;
                for (var i = 0; i < this._title.length; ++i) {
                    cgx.fillText(this._title[i], x, _y);
                    _y += fontSize;
                }
            }

            // Draw Units
            if (this._title.length) {
                cgx.textAlign = "right";
                cgx.textBaseline = "top";
                var _y = onBottom ? (y - GLTFViewer.Utils.Legend._MARGIN - uh) : y + GLTFViewer.Utils.Legend._BARSIZE + GLTFViewer.Utils.Legend._MARGIN;
                var _x = x + bw;
                cgx.fillText(this._units[0], _x, _y);
            }

            // Draw Other
            if (this._other.length) {
                cgx.font = otherFontSize + "px sans-serif";
                cgx.textAlign = "left";
                cgx.textBaseline = "top";
                var _y = onBottom ? GLTFViewer.Utils.Legend._MARGIN : y;
                var _x = x + GLTFViewer.Utils.Legend._MARGIN + bw;
                for (var i = 0; i < this._other.length; ++i) {
                    cgx.fillText(this._other[i], _x, _y);
                    _y += otherFontSize;
                }
                cgx.font = "bold " + fontSize + "px sans-serif";
            }

            // Draw Image
            {
                cgx.textAlign = "left";
                cgx.textBaseline = "middle";
                var width = bw;
                var height = GLTFViewer.Utils.Legend._BARSIZE;

                // Image
                if (this._img) {
                    if (GLTFViewer.Utils.IsNull(this._valueLocation))
                        cgx.drawImage(this._img, x, y, width, height);
                    else {
                        var _x1 = 0;
                        var _x2 = 0;
                        for (var i = 1; i < numTicks; ++i) {
                            var _w1 = this._valueLocation[2 * i + 0] - this._valueLocation[2 * i - 2];
                            var _w2 = this._valueLocation[2 * i + 1] - this._valueLocation[2 * i - 1];
                            cgx.drawImage(this._img,
                                          _x1 * this._img.width, 0, _w1 * this._img.width, this._img.height,
                                          x + _x2 * width, y, _w2 * width, height);
                            _x1 += _w1;
                            _x2 += _w2;
                        }
                    }
                }

                // Box
                cgx.strokeRect(x, y, width, height);

                // Ticks
                y += onBottom ? GLTFViewer.Utils.Legend._BARSIZE : -GLTFViewer.Utils.Legend._TICKSIZE;
                for (var i = 0; i < values.length; ++i) {
                    var _x = x + values[i][0] * width;
                    var _y = y;
                    cgx.beginPath();
                    cgx.moveTo(_x, _y);
                    _y += GLTFViewer.Utils.Legend._TICKSIZE;
                    cgx.lineTo(_x, _y);
                    cgx.stroke();

                    _y += onBottom ? GLTFViewer.Utils.Legend._MARGIN : -(GLTFViewer.Utils.Legend._MARGIN + GLTFViewer.Utils.Legend._TICKSIZE);

                    cgx.translate(_x, _y);
                    cgx.rotate((onBottom ? Math.PI : -Math.PI) / 4);
                    cgx.fillText(values[i][1], 0, 0);
                    cgx.rotate((onBottom ? -Math.PI : Math.PI) / 4);
                    cgx.translate(-_x, -_y);
                }
            }

            // get canvas into img
            this._legendImage = canvas.toDataURL();
            document.body.removeChild(canvas);
        }
    },
    _BuildImage: {
        value: function () {
            var navigator = this._scene.navigator;
            var canvasWidth = navigator.canvasWidth;
            var canvasHeight = navigator.canvasHeight;
            if (this._canvasWidth == canvasWidth && this._canvasHeight == canvasHeight)
                return;
            this._legendImage = null;
            this._canvasWidth = canvasWidth;
            this._canvasHeight = canvasHeight;

            if (!this._vertical)
                this._BuildHorizontalImage();
            else
                this._BuildVerticalImage();

            // dump out legend to png file
            if (false) {
                function dataURItoBlob(dataURI) {
                    var byteString;
                    if (dataURI.split(',')[0].indexOf('base64') >= 0)
                        byteString = atob(dataURI.split(',')[1]);
                    else
                        byteString = unescape(dataURI.split(',')[1]);
                    var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
                    var ia = new Uint8Array(byteString.length);
                    for (var i = 0; i < byteString.length; i++) {
                        ia[i] = byteString.charCodeAt(i);
                    }
                    return new Blob([ia], { type: mimeString });
                }
                var blob = dataURItoBlob(this._legendImage);
                if (!this._scene.aaaa)
                    this._scene.aaaa = 1;
                else 
                    ++this._scene.aaaa;
                window.navigator.msSaveBlob(blob, "gaw" + this._scene.aaaa + ".png");
            }

        }
    },
    // public members
    Reset: {
        value: function () {
            this._canvasWidth = 0;
            this._canvasHeight = 0;
        }
    },
    Clear: {
        value: function () {
            this._scene = null;
            this._foregroundColor = null;
            this._backgroundColor = null;
            this._title = null;
            this.img = null;
            this._units = null;
            this._other = null;
            this._legendImage = null;
            this._valueLocation = null;
        }
    },
    Render: {
        value: function () {
            this._BuildImage();
            if (GLTFViewer.Utils.IsNull(this._legendImage))
                return;

            // determine where it is going to go
            // where we really want to put the legend unless it is attached to something

            var x = this._x ? this._x * this._canvasWidth : 0;
            var y = this._y ? this._y * this._canvasHeight : 0;

            var RL = Math.floor(this._attachment / 4);
            var TB = this._attachment - RL * 4;
            switch (RL) {
                case 1: // Left
                    x = 0;
                    break;
                case 2: // Right
                    x = this._canvasWidth - this._legendWidth;
                    break;
                case 3: // Center
                    x = (this._canvasWidth - this._legendWidth) / 2;
                    break;
            }
            switch (TB) {
                case 1: // Bottom
                    y = this._canvasHeight - this._legendHeight;
                    break;
                case 2: // Top
                    y = 0;
                    break;
                case 3: // Center
                    y = (this._canvasHeight - this._legendHeight) / 2;
                    break;
            }

            // draw legendImage unto scene gx
            var img2D = document.createElement("img");
            img2D.src = this._legendImage;
            document.body.appendChild(img2D);

            var gx = this._scene.gx;
            gx.mozImageSmoothingEnabled = false;
            gx.msImageSmoothingEnabled = false;
            gx.imageSmoothingEnabled = false;
            x -= x % 2;
            y -= y % 2;
            gx.drawImage(img2D, x, y, this._legendWidth, this._legendHeight);

            document.body.removeChild(img2D);
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.Legend, {
    // private members
    _MAXTICKS: { value: 11 },
    _MAXFONTSIZE: { value: 15 },
    _BARSIZE: { value: 20 }, // width or height
    _TICKSIZE: { value: 5 },
    _MARGIN: { value: 5 },
    _OTHERFONTSCALE: { value: 0.8 }, // fraction of fontSize
    // public members
//    DIRTY_NO: { value: 0 },
    // methods
    RenderHighlight: {
        value: function (gx) {

        }
    }
});
//
// Legend
//
///////////////////////////////////////
///////////////////////////////////////
//
// Markup
//
/** @constructor */
GLTFViewer.Utils.Markup = function(scene) {
    this._scene = scene;
    this._dirty = GLTFViewer.Utils.Markup.DIRTY_NO;
    this._lines = {};
    this._state = GLTFViewer.Utils.Markup.STATE_DISABLED;

    this._cursorRay = new GLTFViewer.Utils.CursorRay(scene.navigator);
    this._lineID = 1;
    this._hit = 0;
    this._hitPnt = new GLTFViewer.Utils.Vec3();
    this._hitWhat = GLTFViewer.Utils.Markup.Line.HIT_NONE;
    this._select = 0;
    this._selectWhat = GLTFViewer.Utils.Markup.Line.HIT_NONE;
    this._wantTextEdit = false;
    this._textSize = GLTFViewer.DEFAULT_MARKUP_FONT_SIZE;

    this.LineType = GLTFViewer.Utils.Markup.LINE_TYPE_2D;
    this._position = new GLTFViewer.Utils.Vec3();
    this._position2D = new GLTFViewer.Utils.Vec3();
    this._textOffset = new GLTFViewer.Utils.Vec3();
    this._textAttach = GLTFViewer.Utils.Markup.TEXT_ATTACH_AUTO;
    this.LineShape = GLTFViewer.Utils.Markup.LINE_SYMBOL_NONE;
    this.LineColor = new GLTFViewer.Utils.RGBA(0, 0, 0, 255);
    this._textFont = "sans-serif";
    this.FontColor = new GLTFViewer.Utils.RGBA(0, 0, 0, 255);
    this.BackColor = new GLTFViewer.Utils.RGBA(255, 255, 255, 127);
    this.FontSize = GLTFViewer.DEFAULT_MARKUP_FONT_SIZE;

    this._startEdit = new GLTFViewer.Utils.Vec3();
    this._offsetEdit = new GLTFViewer.Utils.Vec3();

    var gl = this._scene.gl;
    this._lineShader = new GLTFViewer.Utils.ShaderProgram(scene.gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.Markup._vsSolid, GLTFViewer.Utils.Markup._fsSolid);
    this._dashShader = new GLTFViewer.Utils.ShaderProgram(scene.gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.Markup._vsDash, GLTFViewer.Utils.Markup._fsDash);
    this._solidPos = new Float32Array(9);
    this._solidBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this._solidBuf);
    gl.bufferData(gl.ARRAY_BUFFER, this._solidPos, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
};
GLTFViewer.Utils.Markup.prototype = Object.create(null, {
    // private members
    _blurTimer: { writable: true, value: null },
    _scene: { writable: true, value: null },
    _dirty: { writable: true, value: 0 },
    _lines: { writable: true, value: null },
    _lineID: { writable: true, value: 1 },
    _lineShader: { writable: true, value: null },
    _dashShader: { writable: true, value: null },
    _solidBuf: { writable: true, value: null },
    _solidPos: { writable: true, value: null },
    _state: { writable: true, value: 0 },
    _cursorRay: { writable: true, value: null },
    _hit: { writable: true, value: 0 },
    _hitPnt: { writable: true, value: null },
    _hitWhat: { writable: true, value: 0 },
    _select: { writable: true, value: 0 },
    _selectWhat: { writable: true, value: 0 },
    _textLine: { writable: true, value: null },
    _wantTextEdit: { writable: true, value: false },
    _tip: { writable: true, value: null },
    // get fed to CreateMarkupLine when dynamically creating lines
    // type, lineColor, position, textOffset, textAttach, lineShape, text, textSize, textFont, textColor, backColor) {
    _type: { writable: true, value: 0 },
    _position: { writable: true, value: null },
    _index: { writable: true, value: null },
    _position2D: { writable: true, value: null },
    _lineShape: { writable: true, value: 0 },
    _lineColor: { writable: true, value: null },
    _textOffset: { writable: true, value: null },
    _textAttach: { writable: true, value: 0 },
    _textSize: { writable: true, value: 16 },
    _textFont: { writable: true, value: null },
    _textColor: { writable: true, value: null },
    _backColor: { writable: true, value: null },
    // edit
    _startEdit: { writable: true, value: null },
    _offsetEdit: { writable: true, value: null },
    // public members
    IsDirty: {
        value: function () {
            return this.Dirty === GLTFViewer.Utils.Markup.DIRTY_YES;
        }
    },
    ResetDirty: {
        value: function () {
            this.Dirty = GLTFViewer.Utils.Markup.DIRTY_NO;
        }
    },
    Dirty: {
        get: function () {
            return this._dirty;
        },
        set: function (val) {          
            this._dirty = val;
        }
    },
    LineType: {
        get: function () {
            return this._type;
        },
        set: function (val) {          
            if (val < GLTFViewer.Utils.Markup.LINE_TYPE_2D || val > GLTFViewer.Utils.Markup.LINE_TYPE_3D)
                return;
            this._scene.viewer.MarkupMenuBtnState(GLTFViewer.markupMenuBtns2D, null, GLTFViewer.MENUUNCHECK);
            this._scene.viewer.MarkupMenuBtnState(GLTFViewer.markupMenuBtns3D, null, GLTFViewer.MENUUNCHECK);
            this._scene.viewer.MarkupMenuBtnState(val - GLTFViewer.Utils.Markup.LINE_TYPE_2D, null, GLTFViewer.MENUCHECK);
            if (val === GLTFViewer.Utils.Markup.LINE_TYPE_2D) {
                this._scene.viewer.MarkupMenuBtnState(GLTFViewer.markupMenuBtnsLineShape, null, GLTFViewer.MENUDISABLE);
                this._scene.viewer.MarkupMenuBtnState(GLTFViewer.markupMenuBtnsLineColor, null, GLTFViewer.MENUDISABLE);
            } else {
                this._scene.viewer.MarkupMenuBtnState(GLTFViewer.markupMenuBtnsLineShape, null, GLTFViewer.MENUENABLE);
                this._scene.viewer.MarkupMenuBtnState(GLTFViewer.markupMenuBtnsLineColor, null, GLTFViewer.MENUENABLE);
            }
            this._type = val;
        }
    },
    LineShape: {
        get: function () {
            return this._lineShape;
        },
        set: function (val) {
            if (val < GLTFViewer.Utils.Markup.LINE_SYMBOL_NONE || val > GLTFViewer.Utils.Markup.LINE_SYMBOL_BALL)
                return;
            this._lineShape = val;
            this._scene.viewer.MarkupMenuBtnState(GLTFViewer.markupMenuBtnsLineShape, null, GLTFViewer.MENUICON, GLTFViewer.ICONMARKUPLINE + (val - GLTFViewer.Utils.Markup.LINE_SYMBOL_NONE));
            if (this._select) {
                if (this.Dirty === GLTFViewer.Utils.Markup.DIRTY_NO)
                    this.Dirty = GLTFViewer.Utils.Markup.DIRTY_YES;
                var line = this._lines[this._select];
                line._lineShape = val;
                this._scene.Invalidate(true);
            }
        }
    },
    LineColor: {
        get: function () {
            return this._lineColor;
        },
        set: function (val) {          
            this._lineColor = val.Clone();
            this._scene.viewer.MarkupMenuBtnState(GLTFViewer.markupMenuBtnsLineColor, null, GLTFViewer.MENUICON, val);
            if (this._select) {
                if (this.Dirty === GLTFViewer.Utils.Markup.DIRTY_NO)
                    this.Dirty = GLTFViewer.Utils.Markup.DIRTY_YES;
                var line = this._lines[this._select];
                line._lineColor = val.Clone();
                this._scene.Invalidate(true);
            }
        }
    },
    FontColor: {
        get: function () {
            return this._textColor;
        },
        set: function (val) {          
            this._textColor = val.Clone();
            this._scene.viewer.MarkupMenuBtnState(GLTFViewer.markupMenuBtnsFontColor, null, GLTFViewer.MENUICON, val);
            if (this._select) {
                if (this.Dirty === GLTFViewer.Utils.Markup.DIRTY_NO)
                    this.Dirty = GLTFViewer.Utils.Markup.DIRTY_YES;
                var line = this._lines[this._select];
                line._textColor = val.Clone();
                this._scene.Invalidate(true);
            }
        }
    },
    FontSize: {
        get: function () {
            // look in gui
//            var val = this._scene.viewer.markupFontSize[0].value;
//            if (val && val.length) {
//                val = val * 1;
//                this._textSize = val;
//            }
            return this._textSize;
        },
        set: function (val) {               
            if (GLTFViewer.Utils.IsNull(val))
                return;
            val = val * 1;
            if (val < 1 || val > 99)
                return;       
            this._textSize = val;
            this._scene.viewer.MarkupMenuBtnState(GLTFViewer.markupMenuBtnsFontSize, null, GLTFViewer.MENUICON, val);
            if (this._select) {
                if (this.Dirty === GLTFViewer.Utils.Markup.DIRTY_NO)
                    this.Dirty = GLTFViewer.Utils.Markup.DIRTY_YES;
                var line = this._lines[this._select];
                line._textSize = val;
                this._scene.Invalidate(true);
            }
        }
    },
    BackColor: {
        get: function () {
            return this._backColor;
        },
        set: function (val) {          
            this._backColor = val.Clone();
            this._scene.viewer.MarkupMenuBtnState(GLTFViewer.markupMenuBtnsBackColor, null, GLTFViewer.MENUICON, this._backColor);
            if (this._select) {
                if (this.Dirty === GLTFViewer.Utils.Markup.DIRTY_NO)
                    this.Dirty = GLTFViewer.Utils.Markup.DIRTY_YES;
                var line = this._lines[this._select];
                line._backColor = this._backColor.Clone();
                this._scene.Invalidate(true);
            }
        }
    },
    // private methods
    OnTextInputBlur: {
        value: function (e) {
            this.EndTexting();
            if (!GLTFViewer.Utils.IsNull(this._blurTimer))
                clearTimeout(this._blurTimer);
            this._blurTimer = setTimeout((function () {
                this._blurTimer = null;
            }).bind(this), 500);
        }
    },
    OnTextInputKeyDown: {
        value: function (e) {
            e.stopPropagation();
            if (e.keyCode === 27) {
                var wantTextEdit = this._wantTextEdit;
                e.preventDefault();
                this.EndTexting();
                if (wantTextEdit)
                    this._scene.MarkupDelete();
                else
                    this._scene.MarkupEsc();
            }
        }
    },
    OnTextInputKeyUp: {
        value: function (e) {
            e.stopPropagation();
            this.TextInputChanged();
        }
    },
    OnTextInputMouseDown: {
        value: function (e) {
            e.stopPropagation();
        }
    },
    OnTextInputMouseUp: {
        value: function (e) {
            e.stopPropagation();
        }
    },
    OnTextInputMouseMove: {
        value: function (e) {
            e.stopPropagation();
        }
    },
    OnTextInputOnPaste: {
        value: function (e) {
            setTimeout(this.TextInputChanged.bind(this), 10);
        }
    },
    _ToClosestHit3D: {
        value: function (x, y) {
            var scene = this._scene;
            var navigator = scene.navigator;
            this._cursorRay.Update(x, y);
            return scene.handler ? scene.handler.HitTestPos(navigator.uTVP, navigator.canvasWidth, navigator.canvasHeight, this._cursorRay) : null;
        }
    },
    _ToClosestHit2D: {
        value: function (x, y) {
            var scene = this._scene;
            var navigator = scene.navigator;
            var b = this._ToClosestHit3D(x, y);
            if (b) {
                navigator.Project(b);

                this._cursorRay.Update(b.x, b.y);
                scene.handler.HitTest(navigator.uTVP, navigator.canvasWidth, navigator.canvasHeight, this._cursorRay, true);

                return scene.handler.hit;
            }

            return new GLTFViewer.Utils.Vec3(x, y, 0);
        }
    },
    TextInputChanged: {
        value: function () {
            this.UpdateTexting();
        }
    },
    _RenderTmpLine: {
        value: function () {
            var navigator = this._scene.navigator;
            var canvasWidth = navigator.canvasWidth;
            var canvasHeight = navigator.canvasHeight;
            var gx = this._scene.gx;

            if (this.LineType !== GLTFViewer.Utils.Markup.LINE_TYPE_2D) {
                var x1 = this._position.x;
                var y1 = this._position.y;
                var x2 = x1 + this._textOffset.x;
                var y2 = y1 + this._textOffset.y;

                var hasBall = this.LineShape === GLTFViewer.Utils.Markup.LINE_SYMBOL_BALL;
                var hasArrow = this.LineShape === GLTFViewer.Utils.Markup.LINE_SYMBOL_ARROW;
                var len2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
                var ball2 = (GLTFViewer.Utils.Markup._ballSize + 1) / 2;
                ball2 *= ball2;
                var drawLine = (!hasBall && len2 > 1) || (hasBall && len2 > ball2);

                var color = "rgba(" + Math.round(this.LineColor.r) + "," + Math.round(this.LineColor.g) + "," + Math.round(this.LineColor.b) + "," + this.LineColor.a / 255 + ")";

                // POINTS
                if (hasBall) {
                    gx.lineWidth = 0;
                    gx.fillStyle = color;

                    gx.beginPath();
                    gx.arc(x1, y1, 3.5, 0, 2 * Math.PI, false);
                    gx.fill();
                }

                if (drawLine) {
                    gx.lineCap = 'round';
                    gx.strokeStyle = color;

                    gx.lineWidth = 1.5;
                    gx.beginPath();
                    gx.moveTo(x1, y1);
                    gx.lineTo(x2, y2);
                    gx.stroke();

                    if (hasArrow) {
                        var slope2D = new GLTFViewer.Utils.Vec3(x1 - x2, y1 - y2, 0);
                        slope2D.Normalize();

                        var slope1 = new GLTFViewer.Utils.Vec3(slope2D.x - slope2D.y, slope2D.y + slope2D.x, 0);
                        slope1.Normalize();
                        var slope2 = new GLTFViewer.Utils.Vec3(slope2D.x + slope2D.y, slope2D.y - slope2D.x, 0);
                        slope2.Normalize();

                        gx.beginPath();
                        gx.moveTo(x1 - GLTFViewer.Utils.Markup._ballSize * slope1.x, y1 - GLTFViewer.Utils.Markup._ballSize * slope1.y);
                        gx.lineTo(x1, y1);
                        gx.lineTo(x1 - GLTFViewer.Utils.Markup._ballSize * slope2.x, y1 - GLTFViewer.Utils.Markup._ballSize * slope2.y);
                        gx.stroke();
                    }
                }
            }

            GLTFViewer.Utils.Markup.RenderHighlight(gx,
                                             this.LineType,
                                             this._position,
                                             this._textOffset,
                                             null,
                                             true,
                                             GLTFViewer.Utils.Markup.Line.HIT_NONE,
                                             true);
        }
    },
    // public methods
    Reset: { // clear to just created state
        value: function () {
            for (var i = 0; i < this._lines.length; ++i)
                this._lines[i] = null;
            this.Dirty = GLTFViewer.Utils.Markup.DIRTY_NO;
            this._lines = [];
            this._lineID = 1;
            this._hit = 0;
            this._tip = null;
            this._hitWhat = this._selectWhat = GLTFViewer.Utils.Markup.Line.HIT_NONE;
            this.ResetSelection();
            this._textLine = null;
            this._wantTextEdit = false;
            if (!GLTFViewer.Utils.IsNull(this._blurTimer)) {
                clearTimeout(this._blurTimer);
                this._blurTimer = null;
            }
        }
    },
    Clear: { // clear for deletion
        value: function () {
            GLTFViewer.Utils.Markup.prototype.Reset.call(this);
            var keys = Object.keys(this._lines);
            for (var i = 0; i < keys.length; ++i) {
                this._lines[keys[i]].Clear();
                delete this._lines[keys[i]];
            }
            this._lines = null;

            if (this._lineShader !== null) {
                this._lineShader.DeleteProgram();
                this._lineShader = null;
            }
            if (this._dashShader !== null) {
                this._dashShader.DeleteProgram();
                this._dashShader = null;
            }
            this._solidPos = null;
            if (this._solidBuf) {
                var gl = this._scene.gl;
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.deleteBuffer(this._solidBuf);
                this._solidBuf = null;
            }
            this._hitPnt = null;
            this._position = null;
            this._position2D = null;
            this._textOffset = null;
            this._lineColor = null;
            this._textColor = null;
            this._backColor = null;
            this._cursorRay = null;
            this._textLine = null;
            this._tip = null;
            this._scene = null;
        }
    },
    AnySelection: {
        value: function () {
            return this._select !== 0;
        }
    },
    ResetSelection: {
        value: function () {
            this._select = 0;
            this._scene.viewer.MarkupMenuBtnState(GLTFViewer.markupMenuBtns2D, null, GLTFViewer.MENUENABLE);
            if (!GLTFViewer.Utils.IsApple())
                this._scene.viewer.MarkupMenuBtnState(GLTFViewer.markupMenuBtns3D, null, GLTFViewer.MENUENABLE);
        }
    },
    SetSelection: {
        value: function (val, what) {
            this._select = val;
            this._selectWhat = what;
            this.UpdateState(val);
            this._scene.viewer.MarkupMenuBtnState(GLTFViewer.markupMenuBtns2D, null, this._select ? GLTFViewer.MENUDISABLE : GLTFViewer.MENUENABLE);
            if (!GLTFViewer.Utils.IsApple())
                this._scene.viewer.MarkupMenuBtnState(GLTFViewer.markupMenuBtns3D, null, this._select ? GLTFViewer.MENUDISABLE : GLTFViewer.MENUENABLE);
        }
    },
    UpdateSelection: {
        value: function (ctrlKey, altKey) {
            var curSelection = this._select;
//            if (this._select === this._hit && this._hitWhat === GLTFViewer.Utils.Markup.Line.HIT_TEXT)
            if (this._hit && this._hitWhat === GLTFViewer.Utils.Markup.Line.HIT_TEXT && this._state !== GLTFViewer.Utils.Markup.STATE_EDIT_TEXT)
                this.StartTexting(this._hitPnt);
            else
                this.EndTexting();
            if (this._hit)
                this.SetSelection(this._hit, this._hitWhat);
            else 
                this.ResetSelection();
            return (curSelection !== this._select && this._select);
        }
    },
    UpdateState: {
        value: function (hit) {
            if (hit) {
                var line = this._lines[hit];

                this.LineType = line._type;
                this._position = line._position.Clone();
                this._index = line._index;
                this._position2D = line._position2D.Clone();
                this.LineColor = line._lineColor.Clone();
                this.LineShape = line._lineShape;
                this._textOffset = line._textOffset.Clone();
//                this._textAttach = line._textAttach;
                this.FontSize = line._textSize;
//                this._textFont = line._textFont;
                this.FontColor = line._textColor.Clone();
                this.BackColor = line._backColor.Clone();
            }
        }
    },
    GetLineKeys: {
        value: function () {
            return Object.keys(this._lines);
        }
    },
    GetLine: {
        value: function (key) {
            return this._lines[key];
        }
    },
    Render3D: {
        // drawn in 3d canvas
        value: function (TVP) {
            var keys = Object.keys(this._lines);
            if (!this._scene.AnimationStopped() || keys.length === 0)
                return;
            var gl = this._scene.gl;
            var shader = this._lineShader;
            if (shader.StartProgram()) {
                gl.enable(gl.DEPTH_TEST);
                gl.uniformMatrix4fv(shader.uTVP, false, TVP);
                gl.bindBuffer(gl.ARRAY_BUFFER, this._solidBuf);

                for (var i = 0; i < keys.length; ++i)
                    this._lines[keys[i]].RenderLine(GLTFViewer.Utils.Markup.LINE_SOLID, shader, this._solidPos);

                gl.bindBuffer(gl.ARRAY_BUFFER, null);
            }

            shader = this._dashShader;
            if (shader.StartProgram()) {
                gl.disable(gl.DEPTH_TEST);
                gl.uniformMatrix4fv(shader.uTVP, false, TVP);
                gl.bindBuffer(gl.ARRAY_BUFFER, this._solidBuf);

                for (var i = 0; i < keys.length; ++i)
                    this._lines[keys[i]].RenderLine(GLTFViewer.Utils.Markup.LINE_DASHED, shader, this._solidPos);

                gl.bindBuffer(gl.ARRAY_BUFFER, null);
            }
        }
    },
    Render2D: {
        // drawn in 2d canvas
        value: function (TVP) {
            var keys = Object.keys(this._lines);
            for (var i = 0; i < keys.length; ++i) {
                var line = this._lines[keys[i]];
                if (this._scene.AnimationStopped() || line._type === GLTFViewer.Utils.Markup.LINE_TYPE_2D)
                    line.RenderText(this._select == keys[i], this._state === GLTFViewer.Utils.Markup.STATE_EDIT_TEXT && line === this._textLine);
            }

            if (!this._scene.AnimationStopped())
                return;

            if (this._state === GLTFViewer.Utils.Markup.STATE_CREATE_LINE)
                this._RenderTmpLine();

            if (this._state !== GLTFViewer.Utils.Markup.STATE_EDIT_TEXT && this._wantTextEdit)
                this.StartTexting();

            // highlight
            if (this._state !== GLTFViewer.Utils.Markup.STATE_DISABLED && (this._hit !== 0 || this._select !== 0)) {
                for (var i = 0; i < keys.length; ++i) {
                    if (this._hit == keys[i] || this._select == keys[i]) {
                        var line = this._lines[keys[i]];
                        if (line._isDrawn)
                            GLTFViewer.Utils.Markup.RenderHighlight(this._scene.gx,
                                                             line._type,
                                                             line._position2D,
                                                             line._textOffset,
                                                             line._textBox,
                                                             this._select == keys[i],
                                                             this._hit == keys[i] ? this._hitWhat : GLTFViewer.Utils.Markup.Line.HIT_NONE,
                                                             line === this._textLine);
                    }
                }
            }
        }
    },
    CreateMarkupLine: {
        value: function (editable, type, position, index, lineColor, lineShape, text, textOffset, textAttach, textSize, textFont, textColor, backColor) {
            if (editable instanceof GLTFViewer.Utils.Markup.Line) {
                backColor = editable._backColor;
                textColor = editable._textColor;
                textFont = editable._textFont;
                textSize = editable._textSize;
                textAttach = editable._textAttach;
                textOffset = editable._textOffset;
                text = editable._text;
                lineShape = editable._lineShape;
                lineColor = editable._lineColor;
                position = editable._position;
                index = editable._index;
                type = editable._type;
                editable = editable._editable;
            }

            var key = this._lineID;
            ++this._lineID;
            this._lines[key] = new GLTFViewer.Utils.Markup.Line(this._scene,
                                                         !GLTFViewer.Utils.IsNull(editable) ? editable : false,
                                                         !GLTFViewer.Utils.IsNull(type) ? type : this.LineType,
                                                         position ? position : this._position,
                                                         !GLTFViewer.Utils.IsNull(index) ? index : this._index,
                                                         lineColor ? lineColor : this.LineColor,
                                                         !GLTFViewer.Utils.IsNull(lineShape) ? lineShape : this.LineShape,
                                                         !GLTFViewer.Utils.IsNull(text) ? text : "",
                                                         textOffset ? textOffset : this._textOffset,
                                                         !GLTFViewer.Utils.IsNull(textAttach) ? textAttach : this._textAttach,
                                                         !GLTFViewer.Utils.IsNull(textSize) ? textSize : this.FontSize,
                                                         !GLTFViewer.Utils.IsNull(textFont) ? textFont : this._textFont,
                                                         textColor ? textColor : this.FontColor,
                                                         backColor ? backColor : this.BackColor);
            if (this._lines[key].Editable && this._state === GLTFViewer.Utils.Markup.STATE_ENABLED) {
                if (this.Dirty === GLTFViewer.Utils.Markup.DIRTY_NO)
                    this.Dirty = GLTFViewer.Utils.Markup.DIRTY_MAYBE;
                this._hitWhat = GLTFViewer.Utils.Markup.Line.HIT_TEXT;
                this._hit = key;
                this.SetSelection(this._hit, this._hitWhat);
                this._tip = null;
                this._wantTextEdit = true;
                this._hitPnt.Set();
            } else // probably a copy of a markup
                this.Dirty = GLTFViewer.Utils.Markup.DIRTY_YES;

            return key;
        }
    },
    DeleteMarkupLine: {
        value: function (key) {
            var line = this._lines[key];
            if (!GLTFViewer.Utils.IsNull(line)) {
                if (this.Dirty === GLTFViewer.Utils.Markup.DIRTY_MAYBE)
                    this.Dirty = GLTFViewer.Utils.Markup.DIRTY_NO;
                line.Clear();
                delete this._lines[key];
            }
            this.EscMarkupLine();
        }
    },
    EscMarkupLine: {
        value: function () {
            this._hit = 0;
            this.ResetSelection();
            this._tip = null;
            this._textLine = null;
            this._wantTextEdit = false;
        }
    },
    HitTip: {
        value: function (x, y, z) {
            function ToString(n) {
                //if (Math.abs(n) > 1)
                    return n.toPrecision(4);
                //return n.toFixed(4);
            }
            return "(" + ToString(x) + ", " + ToString(y) + (GLTFViewer.Utils.IsNull(z) ? "" : ", " + ToString(z)) +")";
        }
    },
    HitMarkup: {
        value: function (pnt) {
            if (this._wantTextEdit && this._state === GLTFViewer.Utils.Markup.STATE_ENABLED)
                return this._hit;

            this._hitWhat = GLTFViewer.Utils.Markup.Line.HIT_NONE;
            this._hit = 0;
            this._tip = null;
            var keys = Object.keys(this._lines);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                var line = this._lines[key];
                this._hitWhat = line.HitMarkup(pnt, key == this._select);
                if (this._hitWhat !== GLTFViewer.Utils.Markup.Line.HIT_NONE) {   
                    this._hit = parseInt(key);
                    this._hitPnt.Set(pnt);
                    if (this._hitWhat === GLTFViewer.Utils.Markup.Line.HIT_START) {
                        if (line._type === GLTFViewer.Utils.Markup.LINE_TYPE_2D)
                            this._tip = this.HitTip(line._position.x, line._position.y);
                        else
                            this._tip = this.HitTip(line._position.x, line._position.y, line._position.z);
                    } else if (this._hitWhat === GLTFViewer.Utils.Markup.Line.HIT_START_OFFSET)
                        this._tip = this.HitTip(line._textOffset.x, line._textOffset.y);
                    break;
                }
            }

            return this._hit;
        }
    },
    Start: {
        value: function (x, y) {
            if (!GLTFViewer.Utils.IsNull(this._blurTimer)) {
                clearTimeout(this._blurTimer);
                this._blurTimer = null;
                return;
            }
            var hit = this._hit;
            var hitWhat = this._hitWhat;
            switch (this._state) {
                case GLTFViewer.Utils.Markup.STATE_ENABLED:
                    if (hit !== 0 && hitWhat !== GLTFViewer.Utils.Markup.Line.HIT_NONE) {
                        this.UpdateState(hit);

                        this._startEdit.Set(x, y, 0);
                        this._offsetEdit.Set(0, 0, 0);
                        if (this.LineType === GLTFViewer.Utils.Markup.LINE_TYPE_3D && hitWhat === GLTFViewer.Utils.Markup.Line.HIT_LINE) {
                            var line =  this._lines[hit];
                            this._offsetEdit.Set(x - line._position2D.x, y - line._position2D.y, 0);
                        }

                        if (this.LineType === GLTFViewer.Utils.Markup.LINE_TYPE_2D && hitWhat === GLTFViewer.Utils.Markup.Line.HIT_TEXT) {
                            var line =  this._lines[hit];
                            if (line._textBox) {
                                if (line._textAttach !== GLTFViewer.Utils.Markup.TEXT_ATTACH_CENTER) {
                                    var navigator = this._scene.navigator;
                                    var canvasWidth = navigator.canvasWidth;
                                    var canvasHeight = navigator.canvasHeight;
                                    line._textAttach = GLTFViewer.Utils.Markup.TEXT_ATTACH_CENTER;
                                    var c = line._textBox.GetCenter();
                                    line._position2D.Set(c.x, c.y, 0);
                                    line._position.Set(c.x / canvasWidth, c.y / canvasHeight, 0);
                                    this._position2D.Set(line._position2D);
                                    this._position.Set(line._position);
                                }
                            }
                        }

                        this._state = GLTFViewer.Utils.Markup.STATE_EDIT_MOVE;
                        return;
                    }

                    if (this._select !== 0)
                        return;

                    if (this.LineType === GLTFViewer.Utils.Markup.LINE_TYPE_2D) {
                        // really ends up creating empty text box
                        this._position.Set(x, y, 0);
                        this._position2D.Set(x, y, 0);
                        this._textAttach = GLTFViewer.Utils.Markup.TEXT_ATTACH_CENTER;
                    } else {
                        var hit2D = this._ToClosestHit2D(x, y);
                        this._position.Set(hit2D.pnt);
                        this._index = hit2D.indx;
                        this._position2D.Set(hit2D.pnt);
                        this._textAttach = GLTFViewer.Utils.Markup.TEXT_ATTACH_AUTO;
                    }
                    this._textOffset.Set();
                    this._state = GLTFViewer.Utils.Markup.STATE_CREATE_LINE;
                    break;
            }
        }
    },
    Update: {
        value: function (x, y) {
            var navigator = this._scene.navigator;
            var canvasWidth = navigator.canvasWidth;
            var canvasHeight = navigator.canvasHeight;
            // this is not quite right
            if (x < 0)
                x = 0;
            else if (x > canvasWidth)
                x = canvasWidth;
            if (y < 0)
                y = 0;
            else if (y > canvasHeight)
                y = canvasHeight;

            this._tip = null;
            var hit = this._hit;
            var hitWhat = this._hitWhat;

            function MoveStart() {
                var line =  this._lines[hit];
                if (this.LineType === GLTFViewer.Utils.Markup.LINE_TYPE_2D) {
                    var widthBy2 = (line._textBox.max - line._textBox.mix) / 2;
                    var heightBy2 = (line._textBox.may - line._textBox.miy) / 2;
                    var lr = 1;
                    var tb = 1;
                    x = this._position.x + (x - this._startEdit.x) / canvasWidth;
                    y = this._position.y + (y - this._startEdit.y) / canvasHeight;
                    x *= canvasWidth; // convert to pixels
                    y *= canvasHeight;
                    if (x < widthBy2) {
                        x = 0;
                        lr = 0;
                    } else if (x > canvasWidth - widthBy2) {
                        x = canvasWidth;
                        lr = 2;
                    }
                    if (y < heightBy2) {
                        y = 0;
                        tb = 0;
                    } else if (y > canvasHeight - heightBy2) {
                        y = canvasHeight;
                        tb = 2;
                    }
                    x /= canvasWidth; // convert back to fraction
                    y /= canvasHeight;
                    line._position.Set(x, y, 0);
                    line._textAttach = GLTFViewer.Utils.Markup.Line.LRTBToAttach(lr, tb);
                    this._tip = this.HitTip(line._position.x, line._position.y);
                } else {
                    var p = this._ToClosestHit3D(x, y);
                    if (p) {
                        line._position.Set(p);
                        this._tip = this.HitTip(p.x, p.y, p.z);
                    }
                }
                this._scene.Invalidate(true);
            }

            switch (this._state) {
                case GLTFViewer.Utils.Markup.STATE_CREATE_LINE:
                    if (this.LineType !== GLTFViewer.Utils.Markup.LINE_TYPE_2D) {
                        if (x < 5)
                            x = 5;
                        else if (x > canvasWidth - 5)
                            x = canvasWidth - 5;
                        if (y < 5)
                            y = 5;
                        else if (y > canvasHeight - 5)
                            y = canvasHeight - 5;
                        x = Math.round(x - this._position.x);
                        y = Math.round(y - this._position.y);
                        this._textOffset.Set(x, y, 0);
                        this._tip = this.HitTip(x, y);
                    }
                    break;
                case GLTFViewer.Utils.Markup.STATE_EDIT_MOVE:
                    var line =  this._lines[hit];
                    if (this.Dirty === GLTFViewer.Utils.Markup.DIRTY_NO)
                        this.Dirty = GLTFViewer.Utils.Markup.DIRTY_YES;
                    switch (hitWhat) {
                        case GLTFViewer.Utils.Markup.Line.HIT_TEXT:
                        case GLTFViewer.Utils.Markup.Line.HIT_START_OFFSET:
                            if (this.LineType === GLTFViewer.Utils.Markup.LINE_TYPE_2D)
                                MoveStart.call(this); // 2D moves start around not offset
                            else {
                                x = this._textOffset.x + (x - this._startEdit.x);
                                y = this._textOffset.y + (y - this._startEdit.y);
                                var px = this._position2D.x + x;
                                var py = this._position2D.y + y;
                                if (px < 5)
                                    x -= px - 5;
                                else if (px > canvasWidth - 5)
                                    x -= px - (canvasWidth - 5);
                                if (py < 5)
                                    y -= py - 5;
                                else if (py > canvasHeight - 5)
                                    y -= py - (canvasHeight - 5);
                                line._textOffset.Set(x, y, 0);
                                this._tip = this.HitTip(x, y);
                                this._scene.Invalidate(true);
                            }
                            break;
                        case GLTFViewer.Utils.Markup.Line.HIT_LINE:
                            var line =  this._lines[hit];
                            x -= this._offsetEdit.x;
                            y -= this._offsetEdit.y;
                            var p = this._ToClosestHit3D(x, y);
                            if (p) {
                                line._position.Set(p);
                                this._tip = this.HitTip(p.x, p.y, p.z);
                            }
                            this._scene.Invalidate(true);
                            break;
                        case GLTFViewer.Utils.Markup.Line.HIT_START:
                            MoveStart.call(this);
                            break;
                    }
                    break;
            }
            this._scene.Invalidate();
        }
    },
    End: {
        value: function (x, y) {
            this.Update(x, y);
            switch (this._state) {
                case GLTFViewer.Utils.Markup.STATE_CREATE_LINE:
                    // need to convert position to correct locations for real line, someone else will create line
                    var navigator = this._scene.navigator;
                    var canvasWidth = navigator.canvasWidth;
                    var canvasHeight = navigator.canvasHeight;
                    if (this.LineType === GLTFViewer.Utils.Markup.LINE_TYPE_2D) {
                        this._position.x /= canvasWidth;
                        this._position.y /= canvasHeight;
                    } else
                        this._scene.navigator.UnProject(this._position);
                    this._scene.Invalidate();
                case GLTFViewer.Utils.Markup.STATE_EDIT_MOVE:
                    this._state = GLTFViewer.Utils.Markup.STATE_ENABLED;
                    break;
            }
        }
    },
    StartTexting: {
        value: function (pnt) {
            if (this._state === GLTFViewer.Utils.Markup.STATE_ENABLED) {
                var line = this._lines[this._hit];
                if (line.StartTexting(pnt)) {
                    this._state = GLTFViewer.Utils.Markup.STATE_EDIT_TEXT; 
                    this._textLine = line;
                    this._scene.Invalidate();
                }
            }
        }
    },
    UpdateTexting: {
        value: function () {
            if (this._state === GLTFViewer.Utils.Markup.STATE_EDIT_TEXT) {
                if (this._textLine)
                    this._textLine.UpdateTexting();
                this._scene.Invalidate();
            }
        }
    },
    EndTexting: {
        value: function () {
            if (this._state === GLTFViewer.Utils.Markup.STATE_EDIT_TEXT) {
                this._state = GLTFViewer.Utils.Markup.STATE_ENABLED; 
                this._wantTextEdit = false;
                if (this._textLine) {
                    this._textLine.EndTexting();
                    if (!this._textLine._text.length)
                        this._scene.MarkupDelete(); // empty so delete it
                    else 
                        this.Dirty = GLTFViewer.Utils.Markup.DIRTY_YES;
                    this._textLine = null;
                }
                this._scene.Invalidate();
            }
        }
    },
    GetTip: {
        value: function () {
            return this._tip;
        }
    },
    Editable: {
        value: function (key) {
            var line = this._lines[key];
            if (GLTFViewer.Utils.IsNull(line))
                return false;
            return line.Editable;
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.Markup, {
    // private members
    _ballSize: { value: 7 },
    _vsSolid: {
        value: "uniform mat4 uTVP;\n" +
               "attribute vec3 aPos;\n" +
               "void main(void) {\n" +
                   "gl_PointSize = 7.0;\n" + // must match _ballSize
                   "gl_Position = uTVP * vec4(aPos, 1.0);\n" +
               "}"
    },
    _fsSolid: {
        value: "uniform vec4 uClr;\n" +
               "uniform bool uPnt;\n" + 
               "void main() {\n" +
                   "if (uPnt) {\n" +
                       "vec2 xy = gl_PointCoord - vec2(0.5);\n" +
                       "float dist = length(xy);\n" +
                       "if (dist > 0.5) discard;\n" +
                   "}\n" +
                   "gl_FragColor = uClr;\n" +
               "}"
    },
    _vsDash: {
        value: "uniform mat4 uTVP;\n" +
               "attribute vec3 aPos;\n" +
               "varying vec2 vPos;\n" +
               "void main(void) {\n" +
                   "gl_Position = uTVP * vec4(aPos, 1.0);\n" +
                   "vPos = gl_Position.xy;\n" +
               "}"
    },
    _fsDash: {
        value: "uniform vec4 uClr;\n" +
               "uniform vec2 uStart;\n" +
               "uniform vec2 uSze;\n" +
               "varying vec2 vPos;\n" + 
               "void main() {\n" +
                   "vec2 v = vec2((1.0 + vPos.x) * uSze.x / 2.0, (1.0 - vPos.y) * uSze.y / 2.0);\n" +
                   "float f = length(v - uStart);\n" +
                   "if (mod(floor(f / 7.0), 2.0) == 1.0) discard;\n" +                    
                   "gl_FragColor = uClr;\n" +
               "}"
    },
    _vsPoint: {
        value: "uniform mat4 uTVP;\n" +
               "attribute vec3 aPos;\n" +
               "void main(void) {\n" +
                   "gl_PointSize = 10.0;\n" +
                   "gl_Position = uTVP * vec4(aPos, 1.0);\n" +
               "}"
    },
    _fsPoint: {
        value: "uniform vec4 uClr;\n" +
               "void main() {\n" +
                   "vec2 xy = gl_PointCoord - vec2(0.5);\n" +
                   "float dist = length(xy);\n" +
                   "if (dist > 0.5) discard;\n" +
                   "gl_FragColor = uClr;\n" +
               "}"
    },
    // public members
    DIRTY_NO: { value: 0 },
    DIRTY_MAYBE: { value: 1 },
    DIRTY_YES: { value: 2 },

    LINE_TYPE_2D: { value: 0 }, // position is in fractions of screen size, top left is (0,0), bottom right is (1,1)
    LINE_TYPE_3D: { value: 1 },

    LINE_SYMBOL_NONE: { value: 0 },
    LINE_SYMBOL_ARROW: { value: 1 },
    LINE_SYMBOL_BALL: { value: 2 },

    LINE_SOLID: { value: 0 },
    LINE_DASHED: { value: 1 },

    TEXT_ATTACH_AUTO: { value: 0 },
    TEXT_ATTACH_NW: { value: 1 },
    TEXT_ATTACH_N: { value: 2 },
    TEXT_ATTACH_NE: { value: 3 },
    TEXT_ATTACH_W: { value: 4 },
    TEXT_ATTACH_CENTER: { value: 5 },
    TEXT_ATTACH_E: { value: 6 },
    TEXT_ATTACH_SW: { value: 7 },
    TEXT_ATTACH_S: { value: 8 },
    TEXT_ATTACH_SE: { value: 9 },

    // Markup Set State
    STATE_DISABLED: { value: 0 },
    STATE_ENABLED: { value: 1 },    
    // from STATE_ENABLED can go to one of the following states
    STATE_CREATE_LINE: { value: 2 },
    STATE_EDIT_MOVE: { value: 3 },
    STATE_EDIT_TEXT: { value: 4 },

    // methods
    RenderHighlight: {
        value: function (gx, type, position2D, textOffset, textBox, isSelected, hitWhat, editText) {
            var selectColor = "rgba(" + 51 + "," + 152 + "," + 218 + "," + 128 / 255 + ")";
            var highlightColor = "rgba(" + 51 + "," + 152 + "," + 218 + "," + 192 / 255 + ")";
            gx.fillStyle = isSelected ? selectColor : highlightColor;
            gx.strokeStyle = isSelected ? selectColor : highlightColor;

            var lineWidth = GLTFViewer.Utils.Markup.Line.HIGHLIGHT_LINE_WIDTH;
            var lineWidthBy2 = lineWidth / 2;

            if (textBox) {
                gx.fillStyle = (isSelected && hitWhat !== GLTFViewer.Utils.Markup.Line.HIT_TEXT) ? selectColor : highlightColor;
                if (editText) {
                    gx.lineWidth = 2;
                    gx.strokeRect(textBox.mix - lineWidthBy2, textBox.miy - lineWidthBy2, (textBox.max - textBox.mix) + lineWidth, (textBox.may - textBox.miy) + lineWidth);
                } else {
                    gx.lineWidth = 0;
                    gx.fillRect(textBox.mix - lineWidthBy2, textBox.miy - lineWidthBy2, (textBox.max - textBox.mix) + lineWidth, (textBox.may - textBox.miy) + lineWidth);
                }
            }

            var x1 = position2D.x;
            var y1 = position2D.y;
            var x2 = x1 + textOffset.x;
            var y2 = y1 + textOffset.y;

            gx.lineWidth = lineWidth;
            gx.lineCap = 'butt';

            if (type === GLTFViewer.Utils.Markup.LINE_TYPE_2D) {
                if (isSelected) {
                    // Draw box at start
                    gx.lineWidth = 0;
                    gx.fillStyle = hitWhat !== GLTFViewer.Utils.Markup.Line.HIT_TEXT ? selectColor : highlightColor;
                    gx.fillRect(x1 - lineWidth, y1 - lineWidth, 2 * lineWidth, 2 * lineWidth);
                }
            } else {
                // draw solid line from start to start offset
                gx.strokeStyle = isSelected ? selectColor : highlightColor;
                gx.beginPath();
                gx.moveTo(x1, y1);
                gx.lineTo(x2, y2);
                gx.stroke();

                gx.lineWidth = 0;

                // Draw ball at start
                gx.fillStyle = (isSelected && hitWhat !== GLTFViewer.Utils.Markup.Line.HIT_START) ? selectColor : highlightColor;
                gx.beginPath();
                gx.arc(x1, y1, lineWidth, 0, 2 * Math.PI, false);
                gx.fill();

                // Draw box at start offset
                gx.fillStyle = (isSelected && hitWhat !== GLTFViewer.Utils.Markup.Line.HIT_START_OFFSET) ? selectColor : highlightColor;
                gx.fillRect(x2 - lineWidth, y2 - lineWidth, 2 * lineWidth, 2 * lineWidth);
            }
        }
    }
});
///////////////////////////////////////
GLTFViewer.Utils.Markup.Line = function (scene, editable, type, position, index, lineColor, lineShape, text, textOffset, textAttach, textSize, textFont, textColor, backColor) {
    this._scene = scene;
    this._input = scene.viewer.markupTextArea;
    this._editable = !GLTFViewer.Utils.IsNull(editable) ? editable : false;
    this._type = !GLTFViewer.Utils.IsNull(type) ? type : GLTFViewer.Utils.Markup.LINE_TYPE_2D;
    this._position = position ? position.Clone() : new GLTFViewer.Utils.Vec3();
    this._index = index;
    this._lineColor = lineColor ? lineColor.Clone() : new GLTFViewer.Utils.RGBA(0, 0, 0, 255);
    this._lineShape = lineShape ? lineShape : GLTFViewer.Utils.Markup.LINE_SYMBOL_NONE;
    this._text = text ? GLTFViewer.Utils.CRLFtoCR(text) : "";
    this._textOffset = (textOffset && this._type !== GLTFViewer.Utils.Markup.LINE_TYPE_2D) ? textOffset.Clone() : new GLTFViewer.Utils.Vec3();
    this._textAttach = textAttach ? textAttach : GLTFViewer.Utils.Markup.TEXT_ATTACH_AUTO;
    this._textSize = (textSize && textSize > 0 && textSize < 100) ? textSize : GLTFViewer.DEFAULT_MARKUP_FONT_SIZE;
    this._textFont = textFont ? textFont : "san-serif";
    this._textColor = textColor ? textColor.Clone() : new GLTFViewer.Utils.RGBA(0, 0, 0, 255);
    this._backColor = backColor ? backColor.Clone() : new GLTFViewer.Utils.RGBA(255, 255, 255, 127);
    this._visible = true;

    this._position2D = new GLTFViewer.Utils.Vec3();
    this._end2D = new GLTFViewer.Utils.Vec3();
};
GLTFViewer.Utils.Markup.Line.prototype = Object.create(null, {
    // private members
    _type: { writable: true, value: 0 },
    _editable: { writable: true, value: false },
    _position: { writable: true, value: null },
    _index: { writable: true, value: null },
    _lineColor: { writable: true, value: null },
    _lineShape: { writable: true, value: 0 },
    _text: { writable: true, value: null },
    _textOffset: { writable: true, value: null }, // in pixels
    _textAttach: { writable: true, value: 0 },
    _textSize: { writable: true, value: 0 },
    _textFont: { writable: true, value: null },
    _textColor: { writable: true, value: null },
    _backColor: { writable: true, value: null },
    _visible: { writable: true, value: true },
    //
    _scene: { writable: true, value: null },
    _input: { writable: true, value: null },
    _isDrawn: { writable: true, value: false },
    _position2D: { writable: true, value: null },
    _textBox: { writable: true, value: null },
    _attachText: { writable: true, value: 0 },
    _isTexting: { writable: true, value: false },
    // public members
    Editable: {
        get: function () {
            return this._editable;
        }
    },
    // private methods
    _UpdatePosition: {
        value: function (val) {
            if (this._type === GLTFViewer.Utils.Markup.LINE_TYPE_3D && !GLTFViewer.Utils.IsNull(this._index)) {
                // might have to modify position based on explosion
                var explosion = this._scene.GetExplosion();
                if (explosion) {
                    var sceneCenter = this._scene.GetSceneBox(true).GetCenter();
                    var sceneNodeItem = this._scene.handler._sceneNodeIndexToSceneNode[this._index];
                    if (sceneNodeItem) {
                        var matrix = sceneNodeItem.AccumulatedMatrix();
                        var sceneNodeItemCenter = sceneNodeItem.BoundingBox(null, 0, true, matrix).GetCenter();
                        matrix = GLTFViewer.Utils.ExplosionMatrix(sceneCenter, sceneNodeItemCenter, this._scene.GetExplosion());
                        val = val.Transform(matrix);
                    }
                }
            }
        }
    },
    _RenderBox: {
        value: function (size, color, bordercolor, sizeOnly) {
            var navigator = this._scene.navigator;
            var canvasWidth = navigator.canvasWidth;
            var canvasHeight = navigator.canvasHeight;

            var lrtb = GLTFViewer.Utils.Markup.Line.GetLRTBAttach(this._textAttach, this._textOffset, size);
            var lr = lrtb.lr;
            var tb = lrtb.tb;

            var tickSize = [[], [], []];
            if (this._type === GLTFViewer.Utils.Markup.LINE_TYPE_2D) {
                tickSize[0][0] = [0, 0];
                tickSize[0][1] = [0, 0];
                tickSize[0][2] = [0, 0];
                tickSize[1][0] = [0, 0];
                tickSize[1][1] = [0, 0];
                tickSize[1][2] = [0, 0];
                tickSize[2][0] = [0, 0];
                tickSize[2][1] = [0, 0];
                tickSize[2][2] = [0, 0];
            } else {
                tickSize[0][0] = [2, 5];
                tickSize[0][1] = [5, 3.5];
                tickSize[0][2] = [2, 5];
                tickSize[1][0] = [5, 3.5];
                tickSize[1][1] = [0, 0];
                tickSize[1][2] = [5, 3.5];
                tickSize[2][0] = [2, 5];
                tickSize[2][1] = [5, 3.5];
                tickSize[2][2] = [2, 5];
            }

            var loc = this._position2D.Clone().Add(this._textOffset);
            var fit = [[], [], []];
            var xMin = [[], [], []];
            var xMax = [[], [], []];
            var yMin = [[], [], []];
            var yMax = [[], [], []];
            for (var x = 0; x <= 2; ++x) {
                for (var y = 0; y <= 2; ++y) {
                    if (x === 0) {
                        xMin[x][y] = loc.x + tickSize[x][y][0];
                        xMax[x][y] = loc.x + size.x + tickSize[x][y][0];
                    } else if (x === 1) {
                        xMin[x][y] = loc.x - size.x / 2;
                        xMax[x][y] = loc.x + size.x / 2;
                    } else {
                        xMin[x][y] = loc.x - size.x - tickSize[x][y][0];
                        xMax[x][y] = loc.x - tickSize[x][y][0];
                    }

                    if (y === 0) {
                        yMin[x][y] = loc.y + tickSize[x][y][0];
                        yMax[x][y] = loc.y + size.y + tickSize[x][y][0];
                    } else if (y === 1) {
                        yMin[x][y] = loc.y - size.y / 2;
                        yMax[x][y] = loc.y + size.y / 2;
                    } else {
                        yMin[x][y] = loc.y - size.y - tickSize[x][y][0];
                        yMax[x][y] = loc.y - tickSize[x][y][0];
                    }

                    fit[x][y] = (xMin[x][y] >= 0 && xMax[x][y] <= canvasWidth && yMin[x][y] >= 0 && yMax[x][y] <= canvasHeight);
                }
            }

            var x = lr;
            var y = tb;

            if (this._textAttach === GLTFViewer.Utils.Markup.TEXT_ATTACH_AUTO) {
                var slope = this._textOffset.NegateCreate();
                slope.Normalize();
                if (this._type !== GLTFViewer.Utils.Markup.LINE_TYPE_2D)
                    fit[1][1] = false; // only 2D can go to center

                var xInc = (lr === 2) ? -1 : ((lr === 0) ? 1 : (slope.x >= 0 ? 1 : -1));
                var yInc = (tb === 2) ? -1 : ((tb === 0) ? 1 : (slope.y >= 0 ? 1 : -1));

                var i = 0;
                while (i < 3 && !fit[x][0] && !fit[x][1] && !fit[x][2]) {
                    x = (x + xInc + 3) % 3;
                    ++i;
                }
                i = 0;
                while (i < 3 && !fit[x][y]) {
                    y = (y + yInc + 3) % 3;
                    ++i;
                }

                if (x === 1 && y === 1) {
                    var x2 = (x + xInc + 3) % 3;
                    if (fit[x2][y])
                        x = x2;
                    else {
                        var y2 = (y + yInc + 3) % 3;
                        if (fit[x][y2])
                            y = y2;
                    }
                }                

                if (!fit[x][y])
                    x = lr; // just let it flow offscreen
            }

            if (sizeOnly) {
                var retVal = new GLTFViewer.Utils.Box(xMin[x][y], yMin[x][y], 0, xMax[x][y], yMax[x][y], 0);
                retVal.lrtb = { lr: x, tb: y };
                return retVal;
            }

            var gx = this._scene.gx;
            if (!GLTFViewer.Utils.IsNull(bordercolor)) {
                gx.strokeStyle = "rgba(" + Math.round(bordercolor.r) + "," + Math.round(bordercolor.g) + "," + Math.round(bordercolor.b) + "," + bordercolor.a / 255 + ")";
                gx.lineWidth = 1;
            } else 
                gx.lineWidth = 0;
            gx.fillStyle = "rgba(" + Math.round(color.r) + "," + Math.round(color.g) + "," + Math.round(color.b) + "," + color.a / 255 + ")";

            var xLoc, yLoc;
            gx.beginPath();
            if ((x === 1 && y == 1) || this._type === GLTFViewer.Utils.Markup.LINE_TYPE_2D) {
                xLoc = xMin[x][y];
                yLoc = yMin[x][y];
                gx.moveTo(xLoc, yLoc);
                yLoc = yMax[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMax[x][y];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMin[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMin[x][y];
                gx.lineTo(xLoc, yLoc);
            } else if (x === 0 && y == 0) {
                xLoc = loc.x;
                yLoc = loc.y;
                gx.moveTo(xLoc, yLoc);
                xLoc = xMin[x][y];
                yLoc = yMin[x][y] + tickSize[x][y][1];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMax[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMax[x][y];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMin[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMin[x][y] + tickSize[x][y][1];
                gx.lineTo(xLoc, yLoc);
                xLoc = loc.x;
                yLoc = loc.y;
                gx.lineTo(xLoc, yLoc);
            } else if (x === 0 && y == 1) {
                xLoc = loc.x;
                yLoc = loc.y;
                gx.moveTo(xLoc, yLoc);
                xLoc = xMin[x][y];
                yLoc = loc.y + tickSize[x][y][1];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMax[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMax[x][y];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMin[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMin[x][y];
                gx.lineTo(xLoc, yLoc);
                yLoc = loc.y - tickSize[x][y][1];
                gx.lineTo(xLoc, yLoc);
                xLoc = loc.x;
                yLoc = loc.y;
                gx.lineTo(xLoc, yLoc);
            } else if (x === 0 && y == 2) {
                xLoc = loc.x;
                yLoc = loc.y;
                gx.moveTo(xLoc, yLoc);
                xLoc = xMin[x][y] + tickSize[x][y][1];
                yLoc = yMax[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMax[x][y];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMin[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMin[x][y];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMax[x][y] - tickSize[x][y][1];
                gx.lineTo(xLoc, yLoc);
                xLoc = loc.x;
                yLoc = loc.y;
                gx.lineTo(xLoc, yLoc);
            } else if (x === 1 && y == 0) {
                xLoc = loc.x;
                yLoc = loc.y;
                gx.moveTo(xLoc, yLoc);
                xLoc = loc.x - tickSize[x][y][1];
                yLoc = yMin[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMin[x][y];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMax[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMax[x][y];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMin[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = loc.x + tickSize[x][y][1];
                gx.lineTo(xLoc, yLoc);
                xLoc = loc.x;
                yLoc = loc.y;
                gx.lineTo(xLoc, yLoc);
            } else if (x === 1 && y == 2) {
                xLoc = loc.x;
                yLoc = loc.y;
                gx.moveTo(xLoc, yLoc);
                xLoc = loc.x + tickSize[x][y][1];
                yLoc = yMax[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMax[x][y];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMin[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMin[x][y];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMax[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = loc.x - tickSize[x][y][1];
                gx.lineTo(xLoc, yLoc);
                xLoc = loc.x;
                yLoc = loc.y;
                gx.lineTo(xLoc, yLoc);
            } else if (x === 2 && y == 0) {
                xLoc = loc.x;
                yLoc = loc.y;
                gx.moveTo(xLoc, yLoc);
                xLoc = xMax[x][y] - tickSize[x][y][1];
                yLoc = yMin[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMin[x][y];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMax[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMax[x][y];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMin[x][y] + tickSize[x][y][1];
                gx.lineTo(xLoc, yLoc);
                xLoc = loc.x;
                yLoc = loc.y;
                gx.lineTo(xLoc, yLoc);
            } else if (x === 2 && y == 1) {
                xLoc = loc.x;
                yLoc = loc.y;
                gx.moveTo(xLoc, yLoc);
                xLoc = xMax[x][y];
                yLoc = loc.y - tickSize[x][y][1];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMin[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMin[x][y];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMax[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMax[x][y];
                gx.lineTo(xLoc, yLoc);
                yLoc = loc.y + tickSize[x][y][1];
                gx.lineTo(xLoc, yLoc);
                xLoc = loc.x;
                yLoc = loc.y;
                gx.lineTo(xLoc, yLoc);
            } else if (x === 2 && y == 2) {
                xLoc = loc.x;
                yLoc = loc.y;
                gx.moveTo(xLoc, yLoc);
                xLoc = xMax[x][y];
                yLoc = yMax[x][y] - tickSize[x][y][1];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMin[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMin[x][y];
                gx.lineTo(xLoc, yLoc);
                yLoc = yMax[x][y];
                gx.lineTo(xLoc, yLoc);
                xLoc = xMax[x][y] - tickSize[x][y][1];
                gx.lineTo(xLoc, yLoc);
                xLoc = loc.x;
                yLoc = loc.y;
                gx.lineTo(xLoc, yLoc);
            }
            if (!GLTFViewer.Utils.IsNull(bordercolor)) {
                gx.closePath();
                gx.stroke();
            }
            gx.fill();

            var retVal = new GLTFViewer.Utils.Box(xMin[x][y], yMin[x][y], 0, xMax[x][y], yMax[x][y], 0);
            retVal.lrtb = { lr: x, tb: y };
            return retVal;
        }
    },
    _PointClipped: {
        value: function (pnt) {
            if (this._scene.ClipViewState !== GLTFViewer.Utils.Clip.VIEWSTATE_PLANE)
                return false;
            var clip = this._scene.handler._clip;

            // comparison should be to 0, but there are accuracy problems
            if (clip.flipped)
                return clip.glClip0[0] * pnt.x + clip.glClip0[1] * pnt.y + clip.glClip0[2] * pnt.z + clip.glClip0[3] < -0.001;

            return clip.glClip1[0] * pnt.x + clip.glClip1[1] * pnt.y + clip.glClip1[2] * pnt.z + clip.glClip1[3] < -0.001;
        }
    },
    _PointVisible: {
        value: function (pnt, canvasWidth, canvasHeight) {
            if (pnt.x < 0 || pnt.x > canvasWidth || pnt.y < 0 || pnt.y > canvasHeight)
                return false;

            return true;
        }
    },
    // public methods
    Reset: {
        value: function () {
            this._isTexting = false;
        }
    },
    Clear: {
        value: function () {
            GLTFViewer.Utils.Markup.Line.prototype.Reset.call(this);
            this._position = null;
            this._lineColor = null;
            this._text = null;
            this._textOffset = null;
            this._textColor = null;
            this._backColor = null;

            this._scene = null;
            this._input = null;
            this._position2D = null;
            this._textBox = null;
        }
    },
    StartTexting: {
        value: function (pnt) {
            var index = 0;
            if (pnt) {
                index = this.GetTextIndex(pnt);
                if (index < 0)
                    return false;
            }
            this._input[0].value = this._text;
            this._input.css("font-family", this._textFont);
            this._input.css("font-size", this._textSize + "px");
            this._input.css("visibility", "visible");
            this._input.focus();

            this._isTexting = true;
            this._attachText = this._textAttach;
            if (this._textBox)
                this._textAttach = GLTFViewer.Utils.Markup.Line.LRTBToAttach(this._textBox.lrtb.lr,this._textBox.lrtb.tb);
            this.UpdateTexting();

            this._input[0].setSelectionRange(index, index);

            return true;
        }
    },
    UpdateTexting: {
        value: function () {
            var navigator = this._scene.navigator;
            var canvasWidth = navigator.canvasWidth;
            var canvasHeight = navigator.canvasHeight;

            this._text = this._input[0].value;

            var margin = Math.ceil(this._textSize / 5);
            // initialize font
            var gx = this._scene.gx;
            gx.textBaseline = "hanging";
            gx.textAlign = "left";
            gx.font = this._textSize + 'px ' + this._textFont;
            var textArr = this._text.split('\n');
            // Measure size of text
            var newWidth = Math.ceil(Math.max(GLTFViewer.Utils.TextWidth(gx, textArr), GLTFViewer.Utils.Markup.Line.DEFAULT_TEXT_WIDTH * this._textSize / 2) + 2 * margin + this._textSize);
            if (newWidth > canvasWidth)
                newWidth = canvasWidth;
            var newHeight = Math.ceil(textArr.length * this._textSize + 2 * margin + this._textSize);
            if (newHeight > canvasHeight)
                newHeight = canvasHeight;
            var lrtb = GLTFViewer.Utils.Markup.Line.AttachToLRTB(this._textAttach);
            var lr = lrtb.lr;
            var tb = lrtb.tb;
            this._textBox = this._RenderBox(new GLTFViewer.Utils.Vec3(newWidth, newHeight, 0), null, null, true);
            var x = this._textBox.mix;
            var y = this._textBox.miy;
            if (x < 0) {
                var amt = Math.ceil(-x);
                newWidth -= amt;
                x = 0;
            }
            if (x + newWidth > canvasWidth) {
                var amt = Math.ceil((lr === 1 ? 2 : 1) * (x + newWidth - canvasWidth));
                newWidth -= amt;
            }
            if (y < 0) {
                var amt = Math.ceil(-y);
                newHeight -= amt;
                y = 0;
            }
            if (y + newHeight > canvasHeight) {
                var amt = Math.ceil((tb === 1 ? 2 : 1) * (y + newHeight - canvasHeight));
                newHeight -= amt;
            }

            // size textBox to fit newWidth and newHeight
            this._textBox = this._RenderBox(new GLTFViewer.Utils.Vec3(newWidth, newHeight, 0), null, null, true);

            this._input.css("line-height", this._textSize + "px");
            this._input.css("width" , (newWidth - margin - 1) + "px");
            this._input.css("height" , (newHeight - 2) + "px");
            this._input.css("left", (this._textBox.mix - 1) + "px");
            this._input.css("top", (this._textBox.miy) + "px");
            this._input.css("border", 0);
            this._input.css("padding-left", margin + "px");
        }
    },
    EndTexting: {
        value: function () {
            this._input.css("visibility", "hidden");

            if (!this._isTexting)
                return;            
            this._isTexting = false;

            this._text = this._input[0].value;

            var navigator = this._scene.navigator;
            var canvasWidth = navigator.canvasWidth;
            var canvasHeight = navigator.canvasHeight;

            this._textAttach = this._attachText;
        }
    },
    RenderLine: {
        value: function (how, shader, pos) {
            var navigator = this._scene.navigator;
            var canvasWidth = navigator.canvasWidth;
            var canvasHeight = navigator.canvasHeight;
            var gl = this._scene.gl;
            if (how !== GLTFViewer.Utils.Markup.LINE_DASHED)
                this._isDrawn = false;

            var isVisible = GLTFViewer.Utils.IsNull(this._index) || this._scene.handler.IsVisible(this._index);
            if (!this._visible || !isVisible)
                return;

            var end = this._position.Clone();
            if (this._type === GLTFViewer.Utils.Markup.LINE_TYPE_2D) {
                end.x *= canvasWidth;
                end.y *= canvasHeight;
                end.z = 0;
            } else {
                this._UpdatePosition(end);
                if (this._PointClipped(end))
                    return;
                this._scene.navigator.Project(end);
            }
            if (!this._PointVisible(end, canvasWidth, canvasHeight))
                return;
            this._position2D.Set(end);
            var start = new GLTFViewer.Utils.Vec3(end.x + this._textOffset.x, end.y + this._textOffset.y, end.z);
            if (!this._PointVisible(start, canvasWidth, canvasHeight))
                return;
            this._scene.navigator.UnProject(end);
            this._scene.navigator.UnProject(start);
            // end = end of line in 3D
            // this._position2D = end of line in 2D
            // start = start of line in 3D

            var slope2D = this._textOffset.NegateCreate();
            slope2D.Normalize();
            this._isDrawn = true;

            if (this._type === GLTFViewer.Utils.Markup.LINE_TYPE_2D)
                return;

            var hasBall = this._lineShape === GLTFViewer.Utils.Markup.LINE_SYMBOL_BALL;
            var hasArrow = this._lineShape === GLTFViewer.Utils.Markup.LINE_SYMBOL_ARROW;
            var len2 = this._textOffset.GetMagnitudeSquared();
            var ball2 = (GLTFViewer.Utils.Markup._ballSize + 1) / 2;
            ball2 *= ball2;
            var drawLine = (!hasBall && len2 > 1) || (hasBall && len2 > ball2);
            var drawArrow = hasArrow && drawLine;
            gl.uniform4f(shader.uClr, this._lineColor.r / 255, this._lineColor.g / 255, this._lineColor.b / 255, this._lineColor.a / 255);
            gl.uniform1i(shader.uPnt, 0);
            if (drawLine && how === GLTFViewer.Utils.Markup.LINE_DASHED) {
                gl.uniform2f(shader.uSze, canvasWidth, canvasHeight);
                gl.uniform2f(shader.uStart, this._position2D.x, this._position2D.y);
            }

            pos[0] = start.x; pos[1] = start.y; pos[2] = start.z;
            pos[3] = end.x; pos[4] = end.y; pos[5] = end.z;
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, pos);
            gl.vertexAttribPointer(shader.aPos, 3, gl.FLOAT, false, 0, 0);
            if (drawLine)
                gl.drawArrays(gl.LINES, 0, 2);

            if (how !== GLTFViewer.Utils.Markup.LINE_DASHED) {
                gl.disable(gl.DEPTH_TEST);
                // POINTS
                if (hasBall) {
                    gl.uniform1i(shader.uPnt, 1);
                    gl.drawArrays(gl.POINTS, 1, 1);
                    gl.uniform1i(shader.uPnt, 0);
                }

                // ARROWS
                if (drawArrow) {
                    var slope1 = new GLTFViewer.Utils.Vec3(slope2D.x - slope2D.y, slope2D.y + slope2D.x, 0);
                    slope1.Normalize();
                    var slope2 = new GLTFViewer.Utils.Vec3(slope2D.x + slope2D.y, slope2D.y - slope2D.x, 0);
                    slope2.Normalize();
                    
                    if (hasArrow) {
                        var p = this._position2D.Clone();
                        p.x -= GLTFViewer.Utils.Markup._ballSize * slope1.x;
                        p.y -= GLTFViewer.Utils.Markup._ballSize * slope1.y;
                        this._scene.navigator.UnProject(p);
                        pos[0] = p.x; pos[1] = p.y; pos[2] = p.z;

                        p.x = this._position2D.x - GLTFViewer.Utils.Markup._ballSize * slope2.x;
                        p.y = this._position2D.y - GLTFViewer.Utils.Markup._ballSize * slope2.y;
                        p.z = this._position2D.z;
                        this._scene.navigator.UnProject(p);
                        pos[6] = p.x; pos[7] = p.y; pos[8] = p.z;
                        gl.bufferSubData(gl.ARRAY_BUFFER, 0, pos);
                        gl.drawArrays(gl.LINE_STRIP, 0, 3);
                    }
                }

                gl.enable(gl.DEPTH_TEST);
            }
        }
    },
    GetTextIndex: {
        value: function(pnt) {
            if (GLTFViewer.Utils.IsNull(pnt) || (pnt.x === 0 && pnt.y === 0) || this._text.length === 0)
                return -1;

            var margin = Math.ceil(this._textSize / 5);

            // initialize font
            var gx = this._scene.gx;
            gx.textBaseline = "hanging";
            gx.textAlign = "left";
            gx.font = this._textSize + 'px ' + this._textFont;

            var textArr = this._text.split('\n');

            var x = pnt.x - this._textBox.mix - margin;
            var y = pnt.y - this._textBox.miy - margin;
            var line = Math.max(Math.floor(y / this._textSize), 0);
            if (line >= textArr.length)
                return -1;

            var col;
            var lastw = 0;
            for (col = 0; col < textArr[line].length; ++col) {
                var w = gx.measureText(textArr[line].substr(0, col + 1)).width;
                var cw = w - lastw;
                if (x <= lastw + cw / 2)
                    break;
                lastw = w;
            }
            var index = col;
            for (var i = 0; i < line; ++i)
                index += textArr[i].length + 1;

            return index;
        }
    },
    RenderText: {
        value: function (select, editing) {
            if (!editing)
                this._textBox = null;
            if (!this._isDrawn || (this._text.length === 0 && !editing && !select))
                return;

            var margin = Math.ceil(this._textSize / 5);

            // initialize font
            var gx = this._scene.gx;
            gx.textBaseline = "hanging";
            gx.textAlign = "left";
            gx.font = this._textSize + 'px ' + this._textFont;

            var textArr = this._text.split('\n');

            // Measure size of text
            //var width = Math.max(GLTFViewer.Utils.TextWidth(gx, textArr), GLTFViewer.Utils.Markup.Line.DEFAULT_TEXT_WIDTH * this._textSize / 2) + 2 * margin;
            var width = GLTFViewer.Utils.TextWidth(gx, textArr);
            if (width === 0)
                width = GLTFViewer.Utils.Markup.Line.DEFAULT_TEXT_WIDTH * this._textSize / 2;
            width += 2 * margin;
            var height = textArr.length * this._textSize + 2 * margin;
            if (editing) {
                if (this._textBox) {
                    width = this._textBox.max - this._textBox.mix + 1;
                    height = this._textBox.may - this._textBox.miy + 1;
                } else {
                    width += this._textSize;
                    height += this._textSize;
                }
            }

            // Draw Box
            var borderColor = null;
            if (this._type === GLTFViewer.Utils.Markup.LINE_TYPE_2D) {
                if (this._backColor.a) {
                    var hsv = GLTFViewer.Utils.HSV.CreateFromColor(this._backColor);
                    hsv.v = (hsv.v > 0.5) ? hsv.v / 2 : (hsv.v + 1.0) / 2;
                    hsv.a = (hsv.a + 1) / 2;
                    borderColor = new GLTFViewer.Utils.RGBA();
                    borderColor.SetHsv(hsv.h, hsv.s, hsv.v, hsv.a);
                }
            } else
                borderColor = this._lineColor;

            if (!editing || !this._textBox)
                this._textBox = this._RenderBox(new GLTFViewer.Utils.Vec3(width, height, 0), this._backColor, borderColor);

            if (!editing && this._text.length) {
                var x = this._textBox.mix + margin;

                // Draw Text
                gx.fillStyle = "rgba(" + Math.round(this._textColor.r) + "," + Math.round(this._textColor.g) + "," + Math.round(this._textColor.b) + "," + this._textColor.a / 255 + ")";
                gx.lineWidth = 0;
                var y = this._textBox.miy + margin + 1;           
                var agent = window.navigator.userAgent.toLowerCase();
                if (agent.match(/trident.*rv\:11\./) || agent.indexOf('ipod') !== -1 || agent.indexOf('iphone') !== -1 || agent.indexOf('ipad') !== -1)
                    y -= margin; // is this a bug in IE 11
                for (var i = 0; i < textArr.length; ++i) {
                    gx.fillText(textArr[i], x, y);
                    y += this._textSize;
                }
            }
        }
    },
    HitMarkup: {
        value: function (pnt, isSelected) {
            if (!this._isDrawn || !this._editable)
                return GLTFViewer.Utils.Markup.Line.HIT_NONE;

            // HIT_TEXT
            if (this._textBox && this._textBox.IsWithin(pnt))
                return GLTFViewer.Utils.Markup.Line.HIT_TEXT;

            // 2D has nothing but text
            if (this._type === GLTFViewer.Utils.Markup.LINE_TYPE_2D)
                return GLTFViewer.Utils.Markup.Line.HIT_NONE;

            var lineWidth = GLTFViewer.Utils.Markup.Line.HIGHLIGHT_LINE_WIDTH;
            var lineWidthBy2 = lineWidth / 2;

            var x1 = this._position2D.x;
            var y1 = this._position2D.y;
            var x2 = x1 + this._textOffset.x;
            var y2 = y1 + this._textOffset.y;

            // check start offset box
            if (Math.abs(pnt.x - x2) < lineWidth && Math.abs(pnt.y - y2) < lineWidth)
                return GLTFViewer.Utils.Markup.Line.HIT_START_OFFSET;

            // check start ball
            if (Math.abs(pnt.x - x1) < lineWidth && Math.abs(pnt.y - y1) < lineWidth)
                return GLTFViewer.Utils.Markup.Line.HIT_START;

            // HIT_LINE
            if (((x2 <= x1 && pnt.x >= x2 - lineWidthBy2 && pnt.x <= x1 + lineWidthBy2) || (x2 > x1 && pnt.x >= x1 - lineWidthBy2 && pnt.x <= x2 + lineWidthBy2)) &&
                ((y2 <= y1 && pnt.y >= y2 - lineWidthBy2 && pnt.y <= y1 + lineWidthBy2) || (y2 > y1 && pnt.y >= y1 - lineWidthBy2 && pnt.y <= y2 + lineWidthBy2))) {
                var a = y2 - y1;
                var b = x1 - x2;
                var c = x2 * y1 - x1 * y2;
                var d = Math.sqrt(a * a + b * b);
                if (d) {
                    a /= d;
                    b /= d;
                    c /= d;
                }
                d = pnt.x * a + pnt.y * b + c;
                if (Math.abs(d) < lineWidth)
                    return GLTFViewer.Utils.Markup.Line.HIT_LINE;
            }

            return GLTFViewer.Utils.Markup.Line.HIT_NONE;
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.Markup.Line, {
    // private members
    HIGHLIGHT_LINE_WIDTH: { value: 5 },
    DEFAULT_TEXT_WIDTH: { value: 10 },
    // public members
    HIT_NONE: { value: 0 },
    HIT_TEXT: { value: 1 },
    HIT_LINE: { value: 2 },
    HIT_START: { value: 3 },
    HIT_START_OFFSET: { value: 4 },
    // methods
    LRTBToAttach: {
        value: function (lr, tb) {
            var attach = [[GLTFViewer.Utils.Markup.TEXT_ATTACH_NW, GLTFViewer.Utils.Markup.TEXT_ATTACH_N, GLTFViewer.Utils.Markup.TEXT_ATTACH_NE],
                          [GLTFViewer.Utils.Markup.TEXT_ATTACH_W, GLTFViewer.Utils.Markup.TEXT_ATTACH_CENTER, GLTFViewer.Utils.Markup.TEXT_ATTACH_E],
                          [GLTFViewer.Utils.Markup.TEXT_ATTACH_SW, GLTFViewer.Utils.Markup.TEXT_ATTACH_S, GLTFViewer.Utils.Markup.TEXT_ATTACH_SE]];

            return attach[tb][lr];
        }
    },
    AttachToLRTB: {
        value: function (attach) {
            if (attach === 0)
                return {lr:0, tb:0};
            var lrtb = [{lr:0, tb:0}, {lr:1, tb:0}, {lr:2, tb:0},
                        {lr:0, tb:1}, {lr:1, tb:1}, {lr:2, tb:1},
                        {lr:0, tb:2}, {lr:1, tb:2}, {lr:2, tb:2}];

            return lrtb[attach - GLTFViewer.Utils.Markup.TEXT_ATTACH_NW];
        }
    },
    GetLRTBAttach: {
        value: function (attach, offset, size, updateOffset) {
            var lr;
            var tb;
            switch (attach) {
                case GLTFViewer.Utils.Markup.TEXT_ATTACH_N:
                    lr = 1;
                    tb = 0;
                    break;
                case GLTFViewer.Utils.Markup.TEXT_ATTACH_NE:
                    lr = 2;
                    tb = 0;
                    break;
                case GLTFViewer.Utils.Markup.TEXT_ATTACH_E:
                    lr = 2;
                    tb = 1;
                    break;
                case GLTFViewer.Utils.Markup.TEXT_ATTACH_SE:
                    lr = 2;
                    tb = 2;
                    break;
                case GLTFViewer.Utils.Markup.TEXT_ATTACH_S:
                    lr = 1;
                    tb = 2;
                    break;
                case GLTFViewer.Utils.Markup.TEXT_ATTACH_SW:
                    lr = 0;
                    tb = 2;
                    break;
                case GLTFViewer.Utils.Markup.TEXT_ATTACH_W:
                    lr = 0;
                    tb = 1;
                    break;
                case GLTFViewer.Utils.Markup.TEXT_ATTACH_NW:
                    lr = 0;
                    tb = 0;
                    break;
                case GLTFViewer.Utils.Markup.TEXT_ATTACH_CENTER:
                    lr = 1;
                    tb = 1;
                    break;
                case GLTFViewer.Utils.Markup.TEXT_ATTACH_AUTO:
                default:
                    lr = 1;
                    tb = 1;
                    var offsetSlope = offset.x ? (offset.y / offset.x) : (offset.y  * GLTFViewer.Utils.maxDouble);
                    var sizeRatio = size.y / size.x;
                    if (offset.y >= 0) {
                        if (offset.x >= 0) {
                            if (offsetSlope < sizeRatio / 2) {
                                lr = 0;
                                tb = 1;
                            } else if (offsetSlope < 2 * sizeRatio) {
                                lr = 0;
                                tb = 0;
                            } else {
                                lr = 1;
                                tb = 0;
                            }
                        } else {
                            if (offsetSlope < -2 * sizeRatio) {
                                lr = 1;
                                tb = 0;
                            } else if (offsetSlope < -sizeRatio / 2) {
                                lr = 2;
                                tb = 0;
                            } else {
                                lr = 2;
                                tb = 1;
                            }
                        }
                    } else {
                        if (offset.x >= 0) {
                            if (offsetSlope > -sizeRatio / 2) {
                                lr = 0;
                                tb = 1;
                            } else if (offsetSlope > -2 * sizeRatio) {
                                lr = 0;
                                tb = 2;
                            } else {
                                lr = 1;
                                tb = 2;
                            }
                        } else {
                            if (offsetSlope > 2 * sizeRatio) {
                                lr = 1;
                                tb = 2;
                            } else if (offsetSlope > sizeRatio / 2) {
                                lr = 2;
                                tb = 2;
                            } else {
                                lr = 2;
                                tb = 1;
                            }
                        }
                    }
                    if (updateOffset) {
                        if (lr === 0)
                            offset.x -= size.x / 2;
                        else if (lr === 2)
                            offset.x += size.x / 2;
                        if (tb === 0)
                            offset.y -= size.y / 2;
                        else if (tb === 2)
                            offset.y += size.y / 2;
                    }
                    break;
            }

            return { lr: lr, tb: tb };
        }
    }
});
//
// Markup
//
///////////////////////////////////////
///////////////////////////////////////
//
// Clip
//
/** @constructor */
GLTFViewer.Utils.Clip = function (scene) {
    var gl = this._gl = scene.gl;
    this._scene = scene;
    this._clipViewState = GLTFViewer.Utils.Clip.VIEWSTATE_NONE;
    this.clipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_DONE;
    this.clipState = GLTFViewer.Utils.Clip.STATE_DISABLED;
    this.clipP0 = new GLTFViewer.Utils.Vec3();
    this.clipP1 = new GLTFViewer.Utils.Vec3();
    this.clipP2 = new GLTFViewer.Utils.Vec3();
    this.clipP3 = new GLTFViewer.Utils.Vec3();
    this.glClip0 = new Float32Array(4);
    this.glClip1 = new Float32Array(4);
    this._mtxArray = new Float32Array(16);
    this._uTex = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
    this._uClr = new Float32Array(4 * 2);
    this._uPos = new Float32Array([-1, 1, 1, 1, 1, -1, -1, -1]);
    this._uMtl = new Float32Array(16);
    var data = new Float32Array(48);
    this._hintBuf = data.subarray(0, 45);
    this._cutFaceBuf = data.subarray(0, 24);
    this._clipPointBuf = data.subarray(0, 48);
    this._clipPlaneBuf = data.subarray(0, 15);
    this._glBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this._glBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    try {
        this._pointShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.Clip._vsPoint, GLTFViewer.Utils.Clip._fsPoint);
        this._capShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.Clip._vsCap, GLTFViewer.Utils.Clip._fsCap);
        this._planeShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.Clip._vsPlane, GLTFViewer.Utils.Clip._fsPlane);
    } catch (err) {
        // This can error on half_float configurations
        // We will allow the error in such cases and disable the clip tool
        // If we should have float support, then report an error
        var OES_texture_float = gl.getExtension('OES_texture_float');
        if (OES_texture_float) {
            GLTFViewer.Utils.WriteErr(err);
        }
        if (this._pointShader) {
            this._pointShader.DeleteProgram();
            this._pointShader = null;
        }
        if (this._capShader) {
            this._capShader.DeleteProgram();
            this._capShader = null;
        }
        if (this._planeShader) {
            this._planeShader.DeleteProgram();
            this._planeShader = null;
        }
        if (OES_texture_float) {
            gl.deleteBuffer(this._glBuffer);
            this._glBuffer = null;
            throw err;
        }
    }
    var ballSize = 8;
    var image = GLTFViewer.Utils.MakeBallImage(ballSize / 2, 2);

    this._circleTexture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this._circleTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE_ALPHA, ballSize, ballSize, 0, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE, image);
    gl.bindTexture(gl.TEXTURE_2D, null);

    this._capTexture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this._capTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.bindTexture(gl.TEXTURE_2D, null);
};
GLTFViewer.Utils.Clip.prototype = Object.create(null, {
    // private properties
    _scene: { writable: true, value: null },
    _gl: { writable: true, value: null },
    _mtxArray: { writable: true, value: null },
    _circleTexture: { writable: true, value: null },
    _clipState: { writable: true, value: null },
    _clipViewState: { writable: true, value: null },
    _clipDrawMode: { writable: true, value: null },
    _pointShader: { writable: true, value: null },
    _capShader: { writable: true, value: null },
    _planeShader: { writable: true, value: null },
    _hintBuf: { writable: true, value: null },
    _cutFaceBuf: { writable: true, value: null },
    _clipPointBuf: { writable: true, value: null },
    _clipPlaneBuf: { writable: true, value: null },
    _glBuffer: { writable: true, value: null },
    _uTex: { writable: true, value: null },
    _uClr: { writable: true, value: null },
    _uPos: { writable: true, value: null },
    _uMtl: { writable: true, value: null },
    _capTexture: { writable: true, value: null },
    _capTextureValid: { writable: true, value: false },
    _clipValid: { writable: true, value: false },
    _lastSelectionMode: { writable: true, value: -1 },
    // public properties
    clipO: { writable: true, value: null },
    clipD: { writable: true, value: null },
    glClip0: { writable: true, value: null },
    glClip1: { writable: true, value: null },
    clipPlane: { writable: true, value: null },
    clipP0: { writable: true, value: null },
    clipP1: { writable: true, value: null },
    clipP2: { writable: true, value: null },
    clipP3: { writable: true, value: null },
    flipped: { writable: true, value: false },
    // private methods
    _SetClipPointsFromPlane: {
        value: function (plane) {            
            this.clipP0.x = plane.orgn.x;
            this.clipP0.y = plane.orgn.y;
            this.clipP0.z = plane.orgn.z;

            this.clipP1.x = plane.orgn.x + plane.dix.x;
            this.clipP1.y = plane.orgn.y + plane.dix.y;
            this.clipP1.z = plane.orgn.z + plane.dix.z;

            this.clipP2.x = plane.orgn.x + plane.diy.x;
            this.clipP2.y = plane.orgn.y + plane.diy.y;
            this.clipP2.z = plane.orgn.z + plane.diy.z;
        }
    },
    // public methods
    state: {
        get: function () {
            var val = {};
            val.clipState = this.clipState;
            val.clipPlane = this.clipPlane ? this.clipPlane.Clone() : null;
            return val;
        },
        set: function (val) {
            this.clipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_DONE;
            this._clipState = val.clipState;
            this._clipViewState = this._clipState !== GLTFViewer.Utils.Clip.STATE_DISABLED ? GLTFViewer.Utils.Clip.VIEWSTATE_PLANE : GLTFViewer.Utils.Clip.VIEWSTATE_NONE;
            this.clipPlane = val.clipPlane ? val.clipPlane.Clone() : null;
            if (this.clipPlane) {
                this._SetClipPointsFromPlane(this.clipPlane);
                this.UpdateClip();
            }

            if (this._clipState === GLTFViewer.Utils.Clip.STATE_DISABLED) {
                this._scene.viewer.ClipMenuBtnState(null, null, GLTFViewer.MENUUNCHECKALL);
                this._scene.viewer.ClipMenuBtnState(5, null, GLTFViewer.MENUDISABLE);
                this._scene.viewer.ClipBtnState(null, GLTFViewer.MENUUNCHECK);
            } else {
                this._scene.viewer.ClipBtnState(null, GLTFViewer.MENUCHECK);
                this._scene.viewer.ClipMenuBtnState(5, null, GLTFViewer.MENUENABLE);
                this._scene.viewer.ClipMenuBtnState(null, null, GLTFViewer.MENUUNCHECKALL);
                switch (this._clipState) {
                    case GLTFViewer.Utils.Clip.STATE_Z:
                    case GLTFViewer.Utils.Clip.STATE_X:
                    case GLTFViewer.Utils.Clip.STATE_Y:
                        this._scene.viewer.ClipMenuBtnState(this._clipState - GLTFViewer.Utils.Clip.STATE_Z, null, GLTFViewer.MENUCHECK);
                        break;
                    case GLTFViewer.Utils.Clip.STATE_1PT:
                        this._scene.viewer.ClipMenuBtnState(3, null, GLTFViewer.MENUCHECK);
                        break;
                    case GLTFViewer.Utils.Clip.STATE_3PTS:
                        this._scene.viewer.ClipMenuBtnState(4, null, GLTFViewer.MENUCHECK);
                        break;
                }
            }

            this._scene.Invalidate(true);
        }
    },
    capTexture: {
        get: function() {
            this._capTextureValid = true; // assume it is going to be valid
            return this._capTexture;
        }
    },
    clipDrawMode: {
        get: function () {
            return this._clipDrawMode;
        },
        set: function (mode) {
            if (mode < GLTFViewer.Utils.Clip.DRAWMODE_DONE || mode > GLTFViewer.Utils.Clip.DRAWMODE_MOVING)
                return;

            switch (mode) {
                case GLTFViewer.Utils.Clip.DRAWMODE_DONE:
                case GLTFViewer.Utils.Clip.DRAWMODE_1_PT:
                case GLTFViewer.Utils.Clip.DRAWMODE_3RD_OF_3_PTS:
                case GLTFViewer.Utils.Clip.DRAWMODE_2ND_OF_3_PTS:
                case GLTFViewer.Utils.Clip.DRAWMODE_1ST_OF_3_PTS:
                    if (mode === GLTFViewer.Utils.Clip.DRAWMODE_1_PT) {
                        if (this._clipDrawMode !== mode) {
                            this._lastSelectionMode = this._scene.GetSelectionMode();
                            this._scene.SetSelectionMode(GLTFViewer.SELECTION_FACE);
                        }
                    } else if (this._lastSelectionMode !== -1) {
                        this._scene.SetSelectionMode(this._lastSelectionMode);
                        this._lastSelectionMode = -1;
                    }
                    this._scene.viewer.ClipMenuBtnState(5, null, GLTFViewer.MENUUNCHECK);
                    this._scene.container.style.cursor = "default";
                    break;
                case GLTFViewer.Utils.Clip.DRAWMODE_MOVE:
                case GLTFViewer.Utils.Clip.DRAWMODE_MOVING:
                    this._scene.viewer.ClipMenuBtnState(5, null, GLTFViewer.MENUENABLE);
                    this._scene.viewer.ClipMenuBtnState(5, null, GLTFViewer.MENUCHECK);
                    this._scene.container.style.cursor = "url('" + this._scene.imageDir + "Point.cur'), default";
                    break;
            }
            this._clipDrawMode = mode;
        }
    },
    clipState: {
        get: function () {
            return this._clipState;
        },
        set: function (state) {
            if (state < GLTFViewer.Utils.Clip.STATE_DISABLED || state > GLTFViewer.Utils.Clip.STATE_3PTS)
                return;

            switch (state) {
                case GLTFViewer.Utils.Clip.STATE_DISABLED:
                    this._scene.viewer.ClipMenuBtnState(null, null, GLTFViewer.MENUUNCHECKALL);
                    this._scene.viewer.ClipMenuBtnState(5, null, GLTFViewer.MENUDISABLE);
                    this._scene.viewer.ClipBtnState(null, GLTFViewer.MENUUNCHECK);

                    if (this._clipState !== state) {
                        this.clipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_DONE;
                        this._clipViewState = GLTFViewer.Utils.Clip.VIEWSTATE_NONE;
                    }
                    this._lastSelectionState = -1;
                    break;
                case GLTFViewer.Utils.Clip.STATE_Z:
                case GLTFViewer.Utils.Clip.STATE_X:
                case GLTFViewer.Utils.Clip.STATE_Y:
                    this._scene.viewer.ClipBtnState(null, GLTFViewer.MENUCHECK);
                    this._scene.viewer.ClipMenuBtnState(null, null, GLTFViewer.MENUUNCHECKALL);
                    this._scene.viewer.ClipMenuBtnState(state - GLTFViewer.Utils.Clip.STATE_Z, null, GLTFViewer.MENUCHECK);

                    if (this._clipState !== state) {
                        var dir;
                        if (state === GLTFViewer.Utils.Clip.STATE_X)
                            dir = GLTFViewer.Utils.Direction.dix;
                        else if (state === GLTFViewer.Utils.Clip.STATE_Y)
                            dir = GLTFViewer.Utils.Direction.diy;
                        else
                            dir = GLTFViewer.Utils.Direction.diz;
                        var o = this._scene.GetSceneBox().GetCenter();

                        var v = dir.TransformCreate(this._scene.navigator.modelViewInvTrp);
                        if (v.z > 0)
                            dir.Negate();

                        this.clipPlane = new GLTFViewer.Utils.Plane(o, dir);
                        this.UpdateClip();

                        this.clipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_MOVE;
                        this._clipViewState = GLTFViewer.Utils.Clip.VIEWSTATE_PLANE;
                    }
                    break;
                case GLTFViewer.Utils.Clip.STATE_1PT:
                    this._scene.viewer.ClipBtnState(null, GLTFViewer.MENUCHECK);
                    this._scene.viewer.ClipMenuBtnState(null, null, GLTFViewer.MENUUNCHECKALL);
                    this._scene.viewer.ClipMenuBtnState(3, null, GLTFViewer.MENUCHECK);

                    if (this._clipState !== state) {
                        this.clipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_1_PT;
                        this._clipViewState = GLTFViewer.Utils.Clip.VIEWSTATE_PREVIEW;
                    }
                    break;
                case GLTFViewer.Utils.Clip.STATE_3PTS:
                    this._scene.viewer.ClipBtnState(null, GLTFViewer.MENUCHECK);
                    this._scene.viewer.ClipMenuBtnState(null, null, GLTFViewer.MENUUNCHECKALL);
                    this._scene.viewer.ClipMenuBtnState(4, null, GLTFViewer.MENUCHECK);

                    if (this._clipState !== state) {
                        this.clipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_1ST_OF_3_PTS;
                        this._clipViewState = GLTFViewer.Utils.Clip.VIEWSTATE_PREVIEW;
                    }
                    break;
            }
            this._clipState = state;

            this._scene.Invalidate(true);
        }
    },
    UpdateClip: {
        value: function () {
            var sb = this._scene.GetSceneBox();
            if (sb.IsEmpty()) {
                this._clipValid = false;
                return;
            }
            this._clipValid = true;
            var navigator = this._scene.navigator;
            var o = this.clipPlane.orgn;
            var dix = this.clipPlane.dix;
            var diy = this.clipPlane.diy;
            var nor = this.clipPlane.diz;
            var u, v;
            var miu = +GLTFViewer.Utils.maxDouble;
            var miv = +GLTFViewer.Utils.maxDouble;
            var mau = -GLTFViewer.Utils.maxDouble;
            var mav = -GLTFViewer.Utils.maxDouble;
            var corners = sb.GetCorners();
            for (var i = corners.length - 1; i >= 0; i--) {
                var p = corners[i];
                var tVec = new GLTFViewer.Utils.Vec3(p.x - o.x, p.y - o.y, p.z - o.z);
                u = tVec.Dot(dix);
                v = tVec.Dot(diy);
                if (miu > u) miu = u;
                if (miv > v) miv = v;
                if (mau < u) mau = u;
                if (mav < v) mav = v;
            }
            var ps = navigator.ps ? navigator.ps : navigator._GetPixelSize();
            var d = ps * 20;
            miu -= d;
            miv -= d;
            mau += d;
            mav += d;
            this.clipPlane.Evaluate(this.clipP0, miu, miv);
            this.clipPlane.Evaluate(this.clipP1, miu, mav);
            this.clipPlane.Evaluate(this.clipP2, mau, mav);
            this.clipPlane.Evaluate(this.clipP3, mau, miv);

            var v = nor.TransformCreate(navigator.modelViewInvTrp);
            var s = (v.z > 0) ? -1 : 1;

            var d = ps / 16 * s;
            o = new GLTFViewer.Utils.Vec3(o.x - nor.x * d, o.y - nor.y * d, o.z - nor.z * d);
            this.clipO = o;
            d = -nor.Dot(o);
            this.glClip1[0] = nor.x * s;
            this.glClip1[1] = nor.y * s;
            this.glClip1[2] = nor.z * s;
            this.glClip1[3] = d * s;
            this.clipD = new GLTFViewer.Utils.Direction(nor.x, nor.y, nor.z);
            this.glClip0[0] = nor.x;
            this.glClip0[1] = nor.y;
            this.glClip0[2] = nor.z;
            this.glClip0[3] = d;
            this.flipped = (s !== 1);
        }
    },
    RenderPlane: {
        value: function (TVP) {
            if (!this._clipValid)
                return;
            if (this._clipViewState !== GLTFViewer.Utils.Clip.VIEWSTATE_PLANE)
                return;
            var gl = this._gl;
            var shader = this._planeShader;
            if (!shader.StartProgram())
                return;
            gl.uniformMatrix4fv(shader.uTWd, false, GLTFViewer.Utils.glMtxIdentity);
            gl.uniformMatrix4fv(shader.uTVP, false, TVP);
            gl.depthMask(false);
            gl.enable(gl.DEPTH_TEST); 
            gl.enable(gl.BLEND);
            gl.enable(gl.POLYGON_OFFSET_FILL);
            gl.polygonOffset(-1, 0);
            var vc = 0;
            var t = this._clipPlaneBuf;
            t[vc++] = this.clipP0.x; t[vc++] = this.clipP0.y; t[vc++] = this.clipP0.z;
            t[vc++] = this.clipP1.x; t[vc++] = this.clipP1.y; t[vc++] = this.clipP1.z;
            t[vc++] = this.clipP3.x; t[vc++] = this.clipP3.y; t[vc++] = this.clipP3.z;
            t[vc++] = this.clipP2.x; t[vc++] = this.clipP2.y; t[vc++] = this.clipP2.z;
            gl.bindBuffer(gl.ARRAY_BUFFER, this._glBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._clipPlaneBuf);
            gl.vertexAttribPointer(shader.aPos, 3, gl.FLOAT, false, 12, 0);
            var tmpColor = new Float32Array(4);
            GLTFViewer.Utils.FlatRgba(250, 250, 250, 50, tmpColor);
            gl.uniform4fv(shader.uClr, tmpColor);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            vc = 6;
            t[vc++] = this.clipP2.x; t[vc++] = this.clipP2.y; t[vc++] = this.clipP2.z;
            t[vc++] = this.clipP3.x; t[vc++] = this.clipP3.y; t[vc++] = this.clipP3.z;
            t[vc++] = this.clipP0.x; t[vc++] = this.clipP0.y; t[vc++] = this.clipP0.z;
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._clipPlaneBuf);
            GLTFViewer.Utils.FlatRgba(250, 0, 0, 100, tmpColor);
            gl.uniform4fv(shader.uClr, tmpColor);
            gl.drawArrays(gl.LINE_STRIP, 0, 5);
            gl.depthMask(true);
            gl.disable(gl.BLEND);
            gl.polygonOffset(0, 0);
            gl.disable(gl.POLYGON_OFFSET_FILL);
        }
    },
    RenderCap: {
        value: function (TVP, eye, lighting) {
            if (!this._capTextureValid || !this._clipValid)
                return;
            this._capTextureValid = false;
            if (this._clipViewState !== GLTFViewer.Utils.Clip.VIEWSTATE_PLANE)
                return;
            var gl = this._gl;
            var shader = this._capShader;
            if (!shader.StartProgram())
                return;
            gl.bindBuffer(gl.ARRAY_BUFFER, this._glBuffer);
            gl.vertexAttribPointer(shader.aPos, 3, gl.FLOAT, false, 24, 0);
            gl.vertexAttribPointer(shader.aNor, 3, gl.FLOAT, false, 24, 12);
            gl.uniformMatrix4fv(shader.uTVP, false, TVP);
            gl.uniformMatrix4fv(shader.uLit, false, lighting);
            // we only care about specular power fro this
            var tMat = new GLTFViewer.Utils.Material(new GLTFViewer.Utils.RGBA());
            tMat.ToArray(this._uMtl, 0);
            gl.uniformMatrix4fv(shader.uMtl, false, this._uMtl);
            gl.uniform3fv(shader.uEye, eye);
            gl.enable(gl.POLYGON_OFFSET_FILL);
            gl.polygonOffset(.1, 0);
            gl.enable(gl.BLEND);
            var vc = 0;
            var t = this._cutFaceBuf;
            t[vc++] = this.clipP0.x; t[vc++] = this.clipP0.y; t[vc++] = this.clipP0.z;
            t[vc++] = this.clipD.x; t[vc++] = this.clipD.y; t[vc++] = this.clipD.z;
            t[vc++] = this.clipP1.x; t[vc++] = this.clipP1.y; t[vc++] = this.clipP1.z;
            t[vc++] = this.clipD.x; t[vc++] = this.clipD.y; t[vc++] = this.clipD.z;
            t[vc++] = this.clipP3.x; t[vc++] = this.clipP3.y; t[vc++] = this.clipP3.z;
            t[vc++] = this.clipD.x; t[vc++] = this.clipD.y; t[vc++] = this.clipD.z;
            t[vc++] = this.clipP2.x; t[vc++] = this.clipP2.y; t[vc++] = this.clipP2.z;
            t[vc++] = this.clipD.x; t[vc++] = this.clipD.y; t[vc++] = this.clipD.z;
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._cutFaceBuf);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this._capTexture);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.disable(gl.BLEND);
            gl.polygonOffset(0, 0);
            gl.disable(gl.POLYGON_OFFSET_FILL);
        }
    },
    RenderMoveHint: {
        value: function (w, h, cursorRay) {
            var navigator = this._scene.navigator;
            var gl = this._gl;
            var p0 = cursorRay.ray.orgn.Clone();
            var p1 = new GLTFViewer.Utils.Vec3(p0.x + this.clipPlane.diz.x * navigator.ps, p0.y + this.clipPlane.diz.y * navigator.ps, p0.z + this.clipPlane.diz.z * navigator.ps);
            navigator.Project(p0);
            navigator.Project(p1);
            p0.z = 0;
            p1.z = 0;
            var diX = GLTFViewer.Utils.Direction.Create(p0, p1);
            if (!diX.IsZero()) {
                var diY = new GLTFViewer.Utils.Direction(-diX.y, diX.x, 0);
                var vp = GLTFViewer.Utils.Transformation.orthoRH(w, -h, -10, 100);
                vp.Multiply(navigator.cameraTM);
                var scale = .7;
                var oft = 10;
                var x = (w / 2 - (cursorRay.x)) / scale;
                var y = (h / 2 - (cursorRay.y)) / scale;
                var z = 50;
                var wd = GLTFViewer.Utils.Transformation.TranslationCreate(-x + diX.x * oft, -y + diX.y * oft, -z + diX.z * oft);
                wd.Multiply(GLTFViewer.Utils.Transformation.ScaleAboutPointCreate(scale, x, y, 0));
                wd.Multiply(GLTFViewer.Utils.Transformation.RotationCreate(diX.x, diX.y, diX.z, diY.x, diY.y, diY.z));        
                var shader = this._planeShader;
                if (!shader.StartProgram())
                    return;
                gl.disable(gl.DEPTH_TEST);
                gl.depthMask(false);
                gl.enable(gl.BLEND);
                wd.ToArray(this._mtxArray);
                gl.uniformMatrix4fv(shader.uTWd, false, this._mtxArray);
                vp.ToArray(this._mtxArray);
                gl.uniformMatrix4fv(shader.uTVP, false, this._mtxArray);
                var tClr = new GLTFViewer.Utils.RGBA(50, 50, 255, 100);
                var tmpColor = new Float32Array(4);
                tClr.ToArray(tmpColor, 0);
                gl.uniform4fv(shader.uClr, tmpColor);
                var vc = 0;
                var t = this._hintBuf;
                t[vc++] = 40 - 5; t[vc++] = -30; t[vc++] = 0;
                t[vc++] = 60 - 5; t[vc++] = 0; t[vc++] = 0;
                t[vc++] = 40 - 5; t[vc++] = -15; t[vc++] = 0;
                t[vc++] = 40 - 5; t[vc++] = -15; t[vc++] = 0;
                t[vc++] = 60 - 5; t[vc++] = 0; t[vc++] = 0;
                t[vc++] = 40 - 5; t[vc++] = 15; t[vc++] = 0;
                t[vc++] = 40 - 5; t[vc++] = -15; t[vc++] = 0;
                t[vc++] = 40 - 5; t[vc++] = 15; t[vc++] = 0;
                t[vc++] = 18 + 3; t[vc++] = -15; t[vc++] = 0;
                t[vc++] = 18 + 3; t[vc++] = -15; t[vc++] = 0;
                t[vc++] = 40 - 5; t[vc++] = 15; t[vc++] = 0;
                t[vc++] = 18 + 3; t[vc++] = 15; t[vc++] = 0;
                t[vc++] = 60 - 5; t[vc++] = 0; t[vc++] = 0;
                t[vc++] = 40 - 5; t[vc++] = 30; t[vc++] = 0;
                t[vc++] = 40 - 5; t[vc++] = 15; t[vc++] = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, this._glBuffer);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._hintBuf);
                gl.vertexAttribPointer(shader.aPos, 3, gl.FLOAT, false, 12, 0);
                gl.drawArrays(gl.TRIANGLES, 0, 15);
                wd = GLTFViewer.Utils.Transformation.TranslationCreate(-x - diX.x * oft, -y - diX.y * oft, -z - diX.z * oft);
                wd.Multiply(GLTFViewer.Utils.Transformation.ScaleAboutPointCreate(scale, x, y, 0));
                wd.Multiply(GLTFViewer.Utils.Transformation.RotationCreate(-diX.x, -diX.y, -diX.z, diY.x, diY.y, diY.z));
                wd.ToArray(this._mtxArray);
                gl.uniformMatrix4fv(shader.uTWd, false, this._mtxArray);
                gl.drawArrays(gl.TRIANGLES, 0, 15);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.disable(gl.BLEND);
                gl.depthMask(true);
                gl.enable(gl.DEPTH_TEST);
            }
        }
    },
    RenderPreview: {
        value: function (TVP, w, h, hit, plane) {
            var navigator = this._scene.navigator;
            var gl = this._gl;
            if (this.clipDrawMode === GLTFViewer.Utils.Clip.DRAWMODE_1_PT) {
                this.clipPlane = plane;
                this._SetClipPointsFromPlane(plane);
                var p0 = this.clipP0;
                var p1 = this.clipP1;
                var p2 = this.clipP2;
                var p3 = this.clipP3;
                var d = navigator.ps * 100 / Math.sqrt(navigator.zoom);
                this.clipPlane.Evaluate(p0, -d, -d);
                this.clipPlane.Evaluate(p1, +d, -d);
                this.clipPlane.Evaluate(p2, +d, +d);
                this.clipPlane.Evaluate(p3, -d, +d);
                var shader = this._planeShader;
                if (!shader.StartProgram())
                    return;
                gl.uniformMatrix4fv(shader.uTWd, false, GLTFViewer.Utils.glMtxIdentity);
                gl.uniformMatrix4fv(shader.uTVP, false, TVP);
                gl.disable(gl.DEPTH_TEST);
                gl.depthMask(false);
                gl.enable(gl.BLEND);
                gl.enable(gl.POLYGON_OFFSET_FILL);
                gl.polygonOffset(-.5, 0);
                var vc = 0;
                var t = this._clipPlaneBuf;
                t[vc++] = p0.x; t[vc++] = p0.y; t[vc++] = p0.z;
                t[vc++] = p1.x; t[vc++] = p1.y; t[vc++] = p1.z;
                t[vc++] = p3.x; t[vc++] = p3.y; t[vc++] = p3.z;
                t[vc++] = p2.x; t[vc++] = p2.y; t[vc++] = p2.z;
                gl.bindBuffer(gl.ARRAY_BUFFER, this._glBuffer);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._clipPlaneBuf);
                gl.vertexAttribPointer(shader.aPos, 3, gl.FLOAT, false, 12, 0);
                var tmpColor = new Float32Array(4);
                GLTFViewer.Utils.FlatRgba(250, 250, 250, 80, tmpColor);
                gl.uniform4fv(shader.uClr, tmpColor);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                gl.enable(gl.DEPTH_TEST);
                GLTFViewer.Utils.FlatRgba(250, 250, 250, 100, tmpColor);
                gl.uniform4fv(shader.uClr, tmpColor);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                gl.disable(gl.DEPTH_TEST);
                vc = 6;
                t[vc++] = p2.x; t[vc++] = p2.y; t[vc++] = p2.z;
                t[vc++] = p3.x; t[vc++] = p3.y; t[vc++] = p3.z;
                t[vc++] = p0.x; t[vc++] = p0.y; t[vc++] = p0.z;
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._clipPlaneBuf);
                GLTFViewer.Utils.FlatRgba(250, 150, 150, 80, tmpColor);
                gl.uniform4fv(shader.uClr, tmpColor);
                gl.drawArrays(gl.LINE_STRIP, 0, 5);
                gl.enable(gl.DEPTH_TEST);
                GLTFViewer.Utils.FlatRgba(250, 0, 0, 180, tmpColor);
                gl.uniform4fv(shader.uClr, tmpColor);
                gl.drawArrays(gl.LINE_STRIP, 0, 5);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.depthMask(true);
                gl.disable(gl.BLEND);
                gl.polygonOffset(0, 0);
                gl.disable(gl.POLYGON_OFFSET_FILL);
            } else if (this.clipDrawMode < GLTFViewer.Utils.Clip.DRAWMODE_1ST_OF_3_PTS) {
                var shader = this._pointShader;
                if (!shader.StartProgram())
                    return;
                gl.bindBuffer(gl.ARRAY_BUFFER, this._glBuffer);
                gl.vertexAttribPointer(shader.aPos, 3, gl.FLOAT, false, 16, 0);
                gl.vertexAttribPointer(shader.aTex, 1, gl.FLOAT, false, 16, 12);
                gl.uniformMatrix4fv(shader.uTVP, false, TVP);
                gl.uniform2fv(shader.uPos, this._uPos);
                gl.uniform2fv(shader.uTex, this._uTex);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this._circleTexture);
                gl.disable(gl.DEPTH_TEST);
                gl.depthMask(false);
                gl.enable(gl.BLEND);
                var tClr = new GLTFViewer.Utils.RGBA(255, 0, 0, 255);
                tClr.ToArray(this._uClr, 0);
                tClr.SetRgba(255, 230, 230, 255);
                tClr.ToArray(this._uClr, 4);
                gl.uniform2f(shader.uSze, 2 * 4.5 / w, 2 * 4.5 / h);
                gl.uniform4fv(shader.uClr, this._uClr);
                var c;
                var vc = 0;
                var p0 = this.clipP0;
                var t = this._clipPointBuf;
                t[vc++] = p0.x; t[vc++] = p0.y; t[vc++] = p0.z; t[vc++] = 0;
                t[vc++] = p0.x; t[vc++] = p0.y; t[vc++] = p0.z; t[vc++] = 1;
                t[vc++] = p0.x; t[vc++] = p0.y; t[vc++] = p0.z; t[vc++] = 2;
                t[vc++] = p0.x; t[vc++] = p0.y; t[vc++] = p0.z; t[vc++] = 2;
                t[vc++] = p0.x; t[vc++] = p0.y; t[vc++] = p0.z; t[vc++] = 3;
                t[vc++] = p0.x; t[vc++] = p0.y; t[vc++] = p0.z; t[vc++] = 0;
                c = 6;
                if (this.clipDrawMode < GLTFViewer.Utils.Clip.DRAWMODE_2ND_OF_3_PTS) {
                    p0 = this.clipP1;
                    t[vc++] = p0.x; t[vc++] = p0.y; t[vc++] = p0.z; t[vc++] = 0;
                    t[vc++] = p0.x; t[vc++] = p0.y; t[vc++] = p0.z; t[vc++] = 1;
                    t[vc++] = p0.x; t[vc++] = p0.y; t[vc++] = p0.z; t[vc++] = 2;
                    t[vc++] = p0.x; t[vc++] = p0.y; t[vc++] = p0.z; t[vc++] = 2;
                    t[vc++] = p0.x; t[vc++] = p0.y; t[vc++] = p0.z; t[vc++] = 3;
                    t[vc++] = p0.x; t[vc++] = p0.y; t[vc++] = p0.z; t[vc++] = 0;
                    c += 6;
                }
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._clipPointBuf);
                gl.drawArrays(gl.TRIANGLES, 0, c);
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.disable(gl.BLEND);
                gl.depthMask(true);
                gl.enable(gl.DEPTH_TEST);
            }
        }
    },
    SetClipPoint: {
        value: function (p) {
            if (!p)
                return;
            if (this.clipDrawMode === GLTFViewer.Utils.Clip.DRAWMODE_1_PT) {
                var v = p.diz.TransformCreate(this._scene.navigator.modelViewInvTrp);
                if (v.z > 0)
                    p.diz.Negate();
                this.clipPlane = new GLTFViewer.Utils.Plane(p.orgn, p.diz);
                this._SetClipPointsFromPlane(p);
                this.clipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_MOVE;
                this._clipViewState = GLTFViewer.Utils.Clip.VIEWSTATE_PLANE;
                this.UpdateClip();
                this._scene.viewer.ClipMenuBtnState(5, null, GLTFViewer.MENUCHECK);
            } else if (this.clipDrawMode === GLTFViewer.Utils.Clip.DRAWMODE_1ST_OF_3_PTS) {
                this.clipP0.Set(p.x, p.y, p.z);
                this.clipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_2ND_OF_3_PTS;
            } else if (this.clipDrawMode === GLTFViewer.Utils.Clip.DRAWMODE_2ND_OF_3_PTS) {
                var p0 = this.clipP0;
                var tVec = new GLTFViewer.Utils.Vec3(p0.x - p.x, p0.y - p.y, p0.z - p.z);
                if (!tVec.IsLength(0)) {
                    this.clipP1.Set(p.x, p.y, p.z);
                    this.clipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_3RD_OF_3_PTS;
                }
            } else if (this.clipDrawMode === GLTFViewer.Utils.Clip.DRAWMODE_3RD_OF_3_PTS) {
                var p0 = this.clipP0;
                var p1 = this.clipP1;
                var p2 = p;
                var o = new GLTFViewer.Utils.Vec3((p0.x + p1.x + p2.x) / 3.0, (p0.y + p1.y + p2.y) / 3.0, (p0.z + p1.z + p2.z) / 3.0);
                var v0 = new GLTFViewer.Utils.Vec3();
                var v1 = new GLTFViewer.Utils.Vec3();
                v1.Set(p2.x - p0.x, p2.y - p0.y, p2.z - p0.z);
                v0.Set(p1.x - p0.x, p1.y - p0.y, p1.z - p0.z);
                v0.Cross(v1);
                var dir = v0.GetDirection();
                var v = dir.TransformCreate(this._scene.navigator.modelViewInvTrp);
                if (v.z > 0)
                    dir.Negate();
                if (!dir.IsZero()) {
                    this.clipPlane = new GLTFViewer.Utils.Plane(o, dir);
                    this.clipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_MOVE;
                    this._clipViewState = GLTFViewer.Utils.Clip.VIEWSTATE_PLANE;
                    this.UpdateClip();
                    this._scene.viewer.ClipMenuBtnState(5, null, GLTFViewer.MENUCHECK);
                }
            }
            this._scene.Invalidate(true);
        }
    },
    Reset: { // clear to just created state
        value: function() {
            this.clipState = GLTFViewer.Utils.Clip.STATE_DISABLED;
            this._capTextureValid = false;
            this._clipValid = false;
        }
    },
    Clear: { // clear for deletion
        value: function() {
            var gl = this._gl;
            if (this._pointShader !== null) {
                this._pointShader.DeleteProgram();
                this._pointShader = null;
            }
            if (this._capShader !== null) {                
                this._capShader.DeleteProgram();
                this._capShader = null;
            }
            if (this._planeShader !== null) {                
                this._planeShader.DeleteProgram();
                this._planeShader = null;
            }
            if (this._capTexture !== null) {
                gl.deleteTexture(this._capTexture);
                this._capTexture = null;
            }
            if (this._circleTexture) {
                gl.deleteTexture(this._circleTexture);
                this._circleTexture = null;
            }
            if (this._glBuffer !== null) {
                gl.deleteBuffer(this._glBuffer);
                this._glBuffer = null;
            }
            this._mtxArray = null;
            this._hintBuf = null;
            this._cutFaceBuf = null;
            this._clipPointBuf = null;
            this._clipPlaneBuf = null;
            this._uTex = null;
            this._uClr = null;
            this._uPos = null;
            this._uMtl = null;
            this.glClip0 = null;
            this.glClip1 = null;
            this.clipP0 = null;
            this.clipP1 = null;
            this.clipP2 = null;
            this.clipP3 = null;
            this._scene = null;
            this._gl = null;
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.Clip, {
    // private members
    _vsPoint: {
        value: "uniform mat4 uTVP;\n" +
               "uniform vec2 uPos[4];\n" +
               "uniform vec2 uTex[4];\n" +
               "uniform vec2 uSze;\n" +
               "attribute vec3 aPos;\n" +
               "attribute float aTex;\n" +
               "varying vec2 vTex;\n" +
               "void main() {\n" +
                   "int i = int(aTex);\n" +
                   "vTex = uTex[i];\n" +
                   "vec2 o = uPos[i] * uSze * uTVP[3][3];\n" +
                   "gl_Position = uTVP * vec4(aPos, 1) + vec4(o, 0, 0);\n" +
               "}"
    },
    _fsPoint: {
        value: "uniform vec4 uClr[2];\n" +
               "uniform sampler2D uSmp;\n" +
               "varying vec2 vTex;\n" +
               "void main() {\n" +
                   "vec4 t = texture2D(uSmp, vTex);\n" +
                   "vec4 c = uClr[0] + uClr[1] * t.r;\n" +
                   "c.a *= t.a;\n" +
                   "gl_FragColor = c;\n" +
               "}"
    },
    _vsCap: {
        value: "uniform mat4 uTVP;\n" +
               "uniform vec3 uEye;\n" +
               "attribute vec3 aPos;\n" +
               "attribute vec3 aNor;\n" +
               "varying vec3 vNor;\n" +
               "varying vec3 vDir;\n" +
               "varying vec3 vTex;\n" +
               "void main() {\n" +
                   "vDir = normalize(aPos - uEye);\n" +
                   "vec4 pos = uTVP * vec4(aPos, 1.0);\n" +
                   "vTex = vec3(pos.xy, pos.w);\n" +
                   "vNor = aNor;\n" +
                   "gl_Position = pos;\n" +
               "}"
    },
    _fsCap: {
        value: "uniform mat4 uLit[2];\n" +
               "uniform mat4 uMtl;\n" +
               "uniform sampler2D uSmp;\n" +
               "varying vec3 vNor;\n" +
               "varying vec3 vDir;\n" +
               "varying vec3 vTex;\n" +
               "void main() {\n" +
                   "vec2 xy = .5 + vTex.xy / vTex.z / 2.0;\n" +
                   "vec4 c = texture2D(uSmp, xy);\n" +
                   "if(c.a == 0.0) discard;\n" +
                   "vec3 rgb = vec3(0);\n" +
                   "vec3 nor = normalize(vNor);\n" +
                   "nor *= -sign(dot(vDir, nor));\n" +
                   "vec3 r = reflect(uLit[0][3].xyz, nor);\n" +
                   "float s = pow(max(dot(r, vDir), 0.0), uMtl[3].x);\n" +
                   "float d = max(dot(uLit[0][3].xyz, nor), 0.0);\n" +
                   "vec3 sp = s * uLit[0][2].rgb / 7.0;\n" +
                   "vec3 di = d * c.rgb * uLit[0][1].rgb;\n" +
                   "vec3 am = c.rgb * uLit[0][0].rgb;\n" +
                   "rgb = am + di + sp;\n" +
                   "r = reflect(uLit[1][3].xyz, nor);\n" +
                   "s = pow(max(dot(r, vDir), 0.0), uMtl[3].x);\n" +
                   "d = max(dot(uLit[1][3].xyz, nor), 0.0);\n" +
                   "sp = s * uLit[1][2].rgb / 7.0;\n" +
                   "di = d * c.rgb * uLit[1][1].rgb;\n" +
                   "am = c.rgb * uLit[1][0].rgb;\n" +
                   "rgb = rgb + am + di + sp;\n" +
                   "gl_FragColor = vec4(rgb, c.a);\n" +
               "}"
    },
    _vsPlane: {
        value: "uniform mat4 uTWd;\n" +
               "uniform mat4 uTVP;\n" +
               "attribute vec3 aPos;\n" +
               "void main() {\n" +
                   "vec4 pos = uTWd * vec4(aPos, 1.0);\n" +
                   "gl_Position = uTVP * pos;\n" +
               "}"
    },
    _fsPlane: {
        value: "uniform vec4 uClr;\n" +
               "void main() {\n" +
                   "gl_FragColor = uClr;\n" +
               "}"
    },
    // public members
    GetClipPointsFromPlane: {
        value: function (plane) {
            var clipP0 = new GLTFViewer.Utils.Vec3(plane.orgn.x, plane.orgn.y, plane.orgn.z);
            var clipP1 = new GLTFViewer.Utils.Vec3(plane.orgn.x + plane.diy.x, plane.orgn.y + plane.diy.y, plane.orgn.z + plane.diy.z);
            var clipP2 = new GLTFViewer.Utils.Vec3(plane.orgn.x + plane.dix.x, plane.orgn.y + plane.dix.y, plane.orgn.z + plane.dix.z);
            return { p0: clipP0, p1: clipP1, p2: clipP2 };
        }
    },
    // Clip Set State
    STATE_DISABLED: { value: 0 },
    STATE_Z: { value: 1 },
    STATE_X: { value: 2 },
    STATE_Y: { value: 3 },
    STATE_1PT: { value: 4 },
    STATE_3PTS: { value: 5 },
    // Clip Drawing Mode
    DRAWMODE_DONE: { value: 0 },
    DRAWMODE_1_PT: { value: 1 }, // plane from point on surface
    DRAWMODE_3RD_OF_3_PTS: { value: 2 }, // 3rd of 3 points
    DRAWMODE_2ND_OF_3_PTS: { value: 3 }, // 2nd of 3 points
    DRAWMODE_1ST_OF_3_PTS: { value: 4 }, // plane from 3 points
    DRAWMODE_MOVE: { value: 5 }, // about to move plane
    DRAWMODE_MOVING: { value: 6 }, // moving plane
    // Clip Viewing State
    VIEWSTATE_NONE: { value: 0 },
    VIEWSTATE_PREVIEW: { value: 1 },
    VIEWSTATE_PLANE: { value: 2 }
});
//
// Clip
//
///////////////////////////////////////
///////////////////////////////////////
//
// Cursor Ray
//
/** @constructor */
GLTFViewer.Utils.CursorRay = function(navigator, x, y) {
    this._navigator = navigator;
    this.Update(x, y);
};
GLTFViewer.Utils.CursorRay.prototype = Object.create(null, {
    // private members
    _navigator: { writable: true, value: null },
    // public members
    x: { writable: true, value: 0 },
    y: { writable: true, value: 0 },
    ray: { writable: true, value: null },
    rx: { writable: true, value: 0 },
    ry: { writable: true, value: 0 },
    dix: { writable: true, value: null },
    diy: { writable: true, value: null },
    // private methods
    // public methods
    Clone: {
        value: function () {
            var copy = new GLTFViewer.Utils.CursorRay();
            copy._navigator = this._navigator;
            copy.x = this.x;
            copy.y = this.y;
            copy.ray = this.ray.Clone();
            copy.dix = this.dix.Clone();
            copy.diy = this.diy.Clone();
            copy.rx = this.rx;
            copy.ry = this.ry;
            return copy;
        }
    },
    Update: {
        value: function (x, y) {
            var navigator = this._navigator;
            if (!navigator || (typeof x === 'undefined') || (typeof y === 'undefined'))
                return;
            this.x = x;
            this.y = y;
            var rayPos = new GLTFViewer.Utils.Vec3(x, y, 0);
            var tmp = new GLTFViewer.Utils.Vec3(x, y, 1);
            navigator.UnProject(rayPos);
            navigator.UnProject(tmp);
            var v = GLTFViewer.Utils.Vec3.Create(rayPos, tmp);
            var rayDir = v.GetDirection();
            if (rayDir.IsZero())
                rayDir = navigator.projectionInvTM.GetZDirection().NegateCreate();
            this.ray = new GLTFViewer.Utils.Line(rayPos, rayDir);
            this.dix = this.ray.dir.CreateArbitraryPerpendicular();
            this.diy = this.ray.dir.CrossCreate(this.dix).GetDirection();
            this.rx = this.ray.orgn.Dot(this.dix);
            this.ry = this.ray.orgn.Dot(this.diy);
        }
    },
    TransformCreate: {
        value: function (trans) {
            var copy = this.Clone();
            if (trans.IsIdentity())
                return copy;
            copy._navigator = this._navigator;
            copy.x = this.x;
            copy.y = this.y;
            copy.ray.Transform(trans);
            copy.dix.Set(copy.ray.dir);
            copy.dix.SetArbitraryPerpendicular();
            copy.diy.Set(copy.ray.dir);
            copy.diy.Cross(copy.dix).Normalize();
            copy.rx = copy.ray.orgn.Dot(copy.dix);
            copy.ry = copy.ray.orgn.Dot(copy.diy);
            return copy;
        }
    },
    ToArray: {
        value: function (array) {
            var o = this.ray.orgn;
            var d = this.ray.dir;
            array[0] = o.x;
            array[1] = o.y;
            array[2] = o.z;
            array[3] = this.x;
            array[4] = d.x;
            array[5] = d.y;
            array[6] = d.z;
            array[7] = this.y;
        }
    }
});
///////////////////////////////////////
//
// Light
//
/** @constructor */
GLTFViewer.Utils.Light = function() {
    this.ambient = new GLTFViewer.Utils.RGBA(0, 0, 0, 255);
    this.diffuse = new GLTFViewer.Utils.RGBA(0, 0, 0, 255);
    this.specular = new GLTFViewer.Utils.RGBA(0, 0, 0, 255);
    this.dir = new GLTFViewer.Utils.Vec3();
};
GLTFViewer.Utils.Light.prototype = Object.create(null, {
    ambient: { writable: true, value: null },
    diffuse: { writable: true, value: null },
    specular: { writable: true, value: null },
    dir: { writable: true, value: null }
});
///////////////////////////////////////
//
// Material
//
/** @constructor */
GLTFViewer.Utils.Material = function(a, d, s, p) {
    if (typeof a === "undefined") {
        this.ambient = new GLTFViewer.Utils.RGBA();
        this.diffuse = new GLTFViewer.Utils.RGBA();
        this.specular = new GLTFViewer.Utils.RGBA();
        this.power = 0;
    } else if (a instanceof GLTFViewer.Utils.RGBA) {
        this.ambient = new GLTFViewer.Utils.RGBA();
        this.diffuse = new GLTFViewer.Utils.RGBA();
        this.specular = new GLTFViewer.Utils.RGBA();
        this.Set(a);
    } else {
        this.ambient = a.Clone();
        this.diffuse = d.Clone();
        this.specular = s.Clone();
        this.power = p;
    }
};
GLTFViewer.Utils.Material.prototype = Object.create(null, {
    ambient: { writable: true, value: null },
    diffuse: { writable: true, value: null },
    specular: { writable: true, value: null },
    power: { writable: true, value: 0 },
    Set: {
        value: function (diffuse) {
            this.ambient.SetColor(diffuse);
            this.diffuse.SetColor(diffuse);
            this.specular.SetRgba(51, 51, 51, diffuse.a);
            this.power = 15;
        }
    },
    ToArray: {
        value: function (array, start) {
            array[start + 0] = this.ambient.r / 255.0;
            array[start + 1] = this.ambient.g / 255.0;
            array[start + 2] = this.ambient.b / 255.0;
            array[start + 3] = this.ambient.a / 255.0;
            array[start + 4] = this.diffuse.r / 255.0;
            array[start + 5] = this.diffuse.g / 255.0;
            array[start + 6] = this.diffuse.b / 255.0;
            array[start + 7] = this.diffuse.a / 255.0;
            array[start + 8] = this.specular.r / 255.0;
            array[start + 9] = this.specular.g / 255.0;
            array[start + 10] = this.specular.b / 255.0;
            array[start + 11] = this.specular.a / 255.0;
            array[start + 12] = this.power;
        }
    }
});
///////////////////////////////////////
//
// Fill
//
/** @constructor */
GLTFViewer.Utils.Fill = function() {
};
//GLTFViewer.Utils.Fill.prototype = Object.create(null, {
//});
// Static data
Object.defineProperties(GLTFViewer.Utils.Fill, {
    Empty: { value: 0 },
    Opaque: { value: 1 },
    OpaqueMetal: { value: 2 },
    Transparent: { value: 3 },
    Default: { value: 4 }
});
///////////////////////////////////////
//
// Line
//
/** @constructor */
GLTFViewer.Utils.Line = function(orgn, dir) {
    this.orgn = orgn;
    this.dir = dir;
};
GLTFViewer.Utils.Line.prototype = Object.create(null, {
    orgn: { writable: true, value: null },
    dir: { writable: true, value: null },
    Set: {
        value: function (ray) {
            this.orgn.Set(ray.orgn.x, ray.orgn.y, ray.orgn.z);
            this.dir.Set(ray.dir.x, ray.dir.y, ray.dir.z);
        }
    },
    Clone: {
        value: function () {
            return new GLTFViewer.Utils.Line(this.orgn.Clone(), this.dir.Clone());
        }
    },
    Transform: {
        value: function (trans) {
            if (!trans.IsIdentity()) {
                this.orgn.Transform(trans);
                this.dir.Transform(trans);
            }
        }
    },
    TransformCreate: {
        value: function (trans) {
            if (trans.IsIdentity())
                return this.Clone();
            return new GLTFViewer.Utils.Line(this.orgn.TransformCreate(trans), this.dir.TransformCreate(trans));
        }
    },
    Evaluate: {
        value: function (e, result) {
            result.x = this.orgn.x + this.dir.x * e;
            result.y = this.orgn.y + this.dir.y * e;
            result.z = this.orgn.z + this.dir.z * e;
        }
    },
    GetPoint: {
        value: function (ray, pnt) {
            var d = this.dir.CrossCreate(ray.dir).GetMagnitude();
            if (GLTFViewer.Utils.IslengthZero(d))
                return false;
            var a = this.dir.Dot(this.dir);
            var b = ray.dir.Dot(this.dir);
            var c = b;
            d = ray.dir.Dot(ray.dir);
            var v = GLTFViewer.Utils.Vec3.Create(this.orgn, ray.orgn);
            var x = this.dir.Dot(v);
            var y = ray.dir.Dot(v);
            c = b * c - a * d;
            a = b / c * y - d / c * x;
            pnt.x = this.orgn.x + a * this.dir.x;
            pnt.y = this.orgn.y + a * this.dir.y;
            pnt.z = this.orgn.z + a * this.dir.z;
            return true;
        }
    }
});
///////////////////////////////////////
//
// Plane
//
/** @constructor */
GLTFViewer.Utils.Plane = function(orgn, diz) {
    this.orgn = orgn.Clone();
    this.dix = diz.CreateArbitraryPerpendicular();
    this.diy = diz.CrossCreate(this.dix).GetDirection();
    this.diz = diz.Clone();
};
GLTFViewer.Utils.Plane.prototype = Object.create(null, {
    orgn: { writable: true, value: null },
    dix: { writable: true, value: null },
    diy: { writable: true, value: null },
    diz: { writable: true, value: null },
    Set: {
        value: function (orgn, diz) {
            this.orgn.x = orgn.x;
            this.orgn.y = orgn.y;
            this.orgn.z = orgn.z;
            this.dix = diz.CreateArbitraryPerpendicular();
            this.diy.x = diz.x;
            this.diy.y = diz.y;
            this.diy.z = diz.z;
            this.diy.Cross(this.dix).Normalize();
            this.diz.x = diz.x;
            this.diz.y = diz.y;
            this.diz.z = diz.z;
        }
    },
    Clone: {
        value: function () {
            return new GLTFViewer.Utils.Plane(this.orgn, this.diz);
        }
    },
    GetPoint: {
        value: function (ray, pnt) {
            var d = ray.dir.Dot(this.diz);
            var t;
            if (GLTFViewer.Utils.IslengthZero(d)) {
                d = ray.dir.Dot(this.dix);
                if (GLTFViewer.Utils.IslengthZero(d))
                    return false;
                t = this.dix.Dot(GLTFViewer.Utils.Vec3.Create(ray.orgn, this.orgn)) / d;
            } else
                t = this.diz.Dot(GLTFViewer.Utils.Vec3.Create(ray.orgn, this.orgn)) / d;
            ray.Evaluate(t, pnt);
            return true;
        }
    },
    Evaluate: {
        value: function (pnt, u, v) {
            pnt.x = this.orgn.x + u * this.dix.x + v * this.diy.x;
            pnt.y = this.orgn.y + u * this.dix.y + v * this.diy.y;
            pnt.z = this.orgn.z + u * this.dix.z + v * this.diy.z;
        }
    }
});
///////////////////////////////////////
//
// Box
//
/** @constructor */
GLTFViewer.Utils.Box = function(minX, minY, minZ, maxX, maxY, maxZ) {
    this.Set(minX, minY, minZ, maxX, maxY, maxZ);
};
GLTFViewer.Utils.Box.prototype = Object.create(null, {
    mix: { writable: true, value: 0 },
    miy: { writable: true, value: 0 },
    miz: { writable: true, value: 0 },
    max: { writable: true, value: 0 },
    may: { writable: true, value: 0 },
    maz: { writable: true, value: 0 },
    Reset: {
        value: function () {
            this.Set();
        }
    },
    Equals: {
        value: function (val) {
            return val &&
                   GLTFViewer.Utils.EqualDoubles(this.mix, val.mix) &&
                   GLTFViewer.Utils.EqualDoubles(this.miy, val.miy) &&
                   GLTFViewer.Utils.EqualDoubles(this.miz, val.miz) &&
                   GLTFViewer.Utils.EqualDoubles(this.max, val.max) &&
                   GLTFViewer.Utils.EqualDoubles(this.may, val.may) &&
                   GLTFViewer.Utils.EqualDoubles(this.maz, val.maz);
        }
    },
    Set: {
        value: function (minX, minY, minZ, maxX, maxY, maxZ) {
            if (GLTFViewer.Utils.IsNull(minX)) {
                this.mix = GLTFViewer.Utils.maxValue;
                this.miy = GLTFViewer.Utils.maxValue;
                this.miz = GLTFViewer.Utils.maxValue;
                this.max = -GLTFViewer.Utils.maxValue;
                this.may = -GLTFViewer.Utils.maxValue;
                this.maz = -GLTFViewer.Utils.maxValue;
            } else if (minX instanceof Array && minX.length === 3 &&
                       minY instanceof Array && minY.length === 3) {
                this.mix = minX[0] * 1;
                this.miy = minX[1] * 1;
                this.miz = minX[2] * 1;
                this.max = minY[0] * 1;
                this.may = minY[1] * 1;
                this.maz = minY[2] * 1;
            } else if (minX instanceof GLTFViewer.Utils.Vec3 &&
                       minY instanceof GLTFViewer.Utils.Vec3) {
                this.mix = minX.x;
                this.miy = minX.y;
                this.miz = minX.z;
                this.max = minY.x;
                this.may = minY.y;
                this.maz = minY.z;
            } else if (minX instanceof GLTFViewer.Utils.Box) {
                this.mix = minX.mix;
                this.miy = minX.miy;
                this.miz = minX.miz;
                this.max = minX.max;
                this.may = minX.may;
                this.maz = minX.maz;
            } else if (minX instanceof GLTFViewer.Utils.Vec3) {
                this.mix = minX.x;
                this.miy = minX.y;
                this.miz = minX.z;
                this.max = minX.x;
                this.may = minX.y;
                this.maz = minX.z;
            } else {
                this.mix = minX;
                this.miy = minY;
                this.miz = minZ;
                this.max = maxX;
                this.may = maxY;
                this.maz = maxZ;
            }
            return this;
        }
    },
    Clone: {
        value: function () {
            return new GLTFViewer.Utils.Box(this.mix, this.miy, this.miz, this.max, this.may, this.maz);
        }
    },
    GetCenter: {
        value: function (pnt) {
            var x = (this.mix + this.max) / 2;
            var y = (this.miy + this.may) / 2;
            var z = (this.miz + this.maz) / 2;
            if (pnt)
                pnt.Set(x, y, z);
            else
                return new GLTFViewer.Utils.Vec3(x, y, z);
        }
    },
    GetDiameter: {
        value: function () {
            var x = this.max - this.mix;
            var y = this.may - this.miy;
            var z = this.maz - this.miz;
            return Math.sqrt(x * x + y * y + z * z);
        }
    },
    GetCorners: {
        value: function () {
            return [
                new GLTFViewer.Utils.Vec3(this.mix, this.miy, this.miz),
                new GLTFViewer.Utils.Vec3(this.mix, this.miy, this.maz),
                new GLTFViewer.Utils.Vec3(this.mix, this.may, this.miz),
                new GLTFViewer.Utils.Vec3(this.mix, this.may, this.maz),
                new GLTFViewer.Utils.Vec3(this.max, this.miy, this.miz),
                new GLTFViewer.Utils.Vec3(this.max, this.miy, this.maz),
                new GLTFViewer.Utils.Vec3(this.max, this.may, this.miz),
                new GLTFViewer.Utils.Vec3(this.max, this.may, this.maz)
            ];
        }
    },
    IsEmpty: {
        value: function () {
            return this.mix === GLTFViewer.Utils.maxValue;
        }
    },
    IsSane: {
        value: function () {
            if (!this.IsEmpty()) {
                var d = this.GetDiameter();
                if (d > GLTFViewer.Utils.maxDouble)
                    return false;
                if (this.mix < -GLTFViewer.Utils.maxDouble || this.mix > GLTFViewer.Utils.maxDouble)
                    return false;
                if (this.miy < -GLTFViewer.Utils.maxDouble || this.miy > GLTFViewer.Utils.maxDouble)
                    return false;
                if (this.miz < -GLTFViewer.Utils.maxDouble || this.miz > GLTFViewer.Utils.maxDouble)
                    return false;
                if (this.max < -GLTFViewer.Utils.maxDouble || this.max > GLTFViewer.Utils.maxDouble)
                    return false;
                if (this.may < -GLTFViewer.Utils.maxDouble || this.may > GLTFViewer.Utils.maxDouble)
                    return false;
                if (this.maz < -GLTFViewer.Utils.maxDouble || this.maz > GLTFViewer.Utils.maxDouble)
                    return false;
            }
            return true;
        }
    },
    IsWithin: {
        value: function (pnt) {
            if (this.IsEmpty())
                return false;
            return  (pnt.x >= this.mix && pnt.x <= this.max &&
                     pnt.y >= this.miy && pnt.y <= this.may &&
                     pnt.z >= this.miz && pnt.z <= this.maz);
        }
    },
    Unite: {
        value: function (minX, minY, minZ, maxX, maxY, maxZ) {
            var newBox = new GLTFViewer.Utils.Box(minX, minY, minZ, maxX, maxY, maxZ);
            if (!newBox.IsEmpty()) {
                if (newBox.mix < this.mix)
                    this.mix = newBox.mix;
                if (newBox.max > this.max)
                    this.max = newBox.max;
                if (newBox.miy < this.miy)
                    this.miy = newBox.miy;
                if (newBox.may > this.may)
                    this.may = newBox.may;
                if (newBox.miz < this.miz)
                    this.miz = newBox.miz;
                if (newBox.maz > this.maz)
                    this.maz = newBox.maz;
            }
            return this;
        }
    },
    Multiply: {
        value: function (trans) {
            if (!this.IsEmpty() && !trans.IsIdentity()) {
                var corners = this.GetCorners();
                var box = new GLTFViewer.Utils.Box();
                for (var i = 0; i < corners.length; ++i) {
                    corners[i].Transform(trans);
                    box.Unite(corners[i]);
                }
                this.Set(box);
            }
            return this;
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.Box, {
    empty: {
        get: function() {
            return new GLTFViewer.Utils.Box();
        }
    }
});
///////////////////////////////////////
//
// Ball
//
/** @constructor */
GLTFViewer.Utils.Ball = function() {
    this.Reset();
};
GLTFViewer.Utils.Ball.prototype = Object.create(null, {
    n: { writable: true, value: 400 }, // this many pixels in 1/2 rotation
    cx: { writable: true, value: 0 },
    cy: { writable: true, value: 0 },
    dq: { writable: true, value: null }, // down quat
    nq: { writable: true, value: null },
    dp: { writable: true, value: null },
    cp: { writable: true, value: null },
    a: { writable: true, value: 0 }, // angle
    d: { writable: true, value: null }, // dir
    Reset: {
        value: function () {
            this.dq = GLTFViewer.Utils.Quat.Identity;
            this.nq = GLTFViewer.Utils.Quat.Identity;
        }
    },
    getScreenToVector: {
        value: function (cursorX, cursorY) {
            var x = (cursorX - this.cx) / this.n;
            var y = -(cursorY - this.cy) / this.n;
            var mag = (x * x) + (y * y);
            var z = Math.sqrt(1 - mag);
            return new GLTFViewer.Utils.Vec3(x, y, z);
        }
    },
    onBegin: {
        value: function (cursorX, cursorY) {
            this.Reset();
            this.cx = cursorX;
            this.cy = cursorY;
            this.dq = this.nq;
            this.dp = this.getScreenToVector(cursorX, cursorY);
        }
    },
    onMove: {
        value: function (cursorX, cursorY) {
            if (Math.abs(this.cx - cursorX) > this.n * 0.75 || Math.abs(this.cy - cursorY) > this.n * 0.75) {
                this.cx = cursorX;
                this.cy = cursorY;
                this.dq = this.nq;
                this.dp = this.getScreenToVector(cursorX, cursorY);
            }
            this.cp = this.getScreenToVector(cursorX, cursorY);
            var dot = this.dp.Dot(this.cp);
            var part = this.dp.CrossCreate(this.cp);
            var tmp = new GLTFViewer.Utils.Quat(part.x, part.y, part.z, dot);
            this.nq = tmp.MultiplyCreate(this.dq);
            var cos = this.nq.w;
            var t = 1 - cos * cos;
            var sin = 0;
            if (t > 0)
                sin = Math.sqrt(t);
            if (Math.abs(sin) < 0.0005)
                sin = 1;
            this.a = GLTFViewer.Utils.acos(cos) * 2;
            var xx = this.nq.x / sin;
            var yy = this.nq.y / sin;
            var zz = this.nq.z / sin;
            this.d = new GLTFViewer.Utils.Direction(xx, yy, zz);
        }
    }
});
//////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////
//
// Vector 3
//
/** @constructor */
GLTFViewer.Utils.Vec3 = function(x, y, z) {
    GLTFViewer.Utils.Vec3.prototype.Set.call(this, x, y, z);
};
GLTFViewer.Utils.Vec3.prototype = Object.create(null, {
    constructor: { value: GLTFViewer.Utils.Vec3 },
    //
    x: { writable: true, value: 0 },
    y: { writable: true, value: 0 },
    z: { writable: true, value: 0 },
    //
    Set: {
        value: function (x, y, z) {
            if (GLTFViewer.Utils.IsNull(x)) {
                this.x = 0;
                this.y = 0;
                this.z = 0;
            } else if (x instanceof Array && x.length === 3) {
                this.x = x[0] * 1;
                this.y = x[1] * 1;
                this.z = x[2] * 1;
            } else if (x instanceof GLTFViewer.Utils.Vec3) {
                this.x = x.x;
                this.y = x.y;
                this.z = x.z;
            } else {
                this.x = x;
                this.y = y;
                this.z = z;
            }
            return this;
        }
    },
    Clone: {
        value: function () {
            return new this.constructor(this.x, this.y, this.z);
        }
    },
    Equals: {
        value: function (val) {
            return GLTFViewer.Utils.EqualDoubles(this.x, val.x) &&
                   GLTFViewer.Utils.EqualDoubles(this.y, val.y) &&
                   GLTFViewer.Utils.EqualDoubles(this.z, val.z);
        }
    },
    Normalize: {
        value: function () {
            var lengthSq = this.x * this.x + this.y * this.y + this.z * this.z;
            if (lengthSq === 1) {
                // nothing
            } else if (lengthSq < GLTFViewer.Utils.lengthAccuracySquared) {
                this.x = 0;
                this.y = 0;
                this.z = 0;
            } else {
                var length = Math.sqrt(lengthSq);
                this.x = this.x / length;
                this.y = this.y / length;
                this.z = this.z / length;
            }
            return this;
        }
    },
    ToArray: {
        value: function (array, start) {
            var s = GLTFViewer.Utils.IsNull(start) ? 0 : start;
            array[s + 0] = this.x;
            array[s + 1] = this.y;
            array[s + 2] = this.z;
        }
    },
    Dot: {
        value: function (v) {
            return this.x * v.x + this.y * v.y + this.z * v.z;
        }
    },
    Negate: {
        value: function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
        }
    },
    NegateCreate: {
        value: function () {
            return this.Clone().Negate();
        }
    },
    Cross: {
        value: function (v) {
            // this has to be a Vector
            var _x = this.y * v.z - v.y * this.z;
            var _y = v.x * this.z - this.x * v.z;
            var _z = this.x * v.y - v.x * this.y;
            this.x = _x;
            this.y = _y;
            this.z = _z;
            return this;
        }
    },
    CrossCreate: {
        value: function (v) {
            // this has to be a Vector
            return this.Clone().Cross(v);
        }
    },
    Transform: {
        value: function (trans) {
            if (trans.IsIdentity())
                return this;
            var x = trans.a00 * this.x + trans.a10 * this.y + trans.a20 * this.z + trans.a30;
            var y = trans.a01 * this.x + trans.a11 * this.y + trans.a21 * this.z + trans.a31;
            var z = trans.a02 * this.x + trans.a12 * this.y + trans.a22 * this.z + trans.a32;
            var w = trans.a03 * this.x + trans.a13 * this.y + trans.a23 * this.z + trans.a33;
            this.x = x / w;
            this.y = y / w;
            this.z = z / w;
            return this;
        }
    },
    TransformCreate: {
        value: function (trans) {
            return this.Clone().Transform(trans);
        }
    },
    Add: {
        value: function (v) {
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            return this;
        }
    },
    Subtract: {
        value: function (v) {
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            return this;
        }
    },
    Scale: {
        value: function (s) {
            this.x *= s;
            this.y *= s;
            this.z *= s;
            return this;
        }
    },
    ScaleCreate: {
        value: function (s) {
            return this.Clone().Scale(s);
        }
    },
    IsZero: {
        value: function () {
            return (!this.x && !this.y && !this.z);
        }
    },
    GetDirection: {
        value: function () {
            return new GLTFViewer.Utils.Direction(this.x, this.y, this.z);
        }
    },
    GetMagnitude: {
        value: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
    },
    GetMagnitudeSquared: {
        value: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        }
    },
    IsLength: {
        value: function (length) {
            return GLTFViewer.Utils.EqualLengths(this.GetMagnitude(), length);
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.Vec3, {
    Origin: {
        get: function () {
            return new GLTFViewer.Utils.Vec3();
        }
    },
    Create: {
        value: function (start, end) {
            return new GLTFViewer.Utils.Vec3(end.x - start.x, end.y - start.y, end.z - start.z);
        }
    }
});
///////////////////////////////////////
//
// Direction Vector
//
/** @constructor */
GLTFViewer.Utils.Direction = function(x, y, z) {
    GLTFViewer.Utils.Vec3.call(this, x, y, z);
    this.Normalize();
};
GLTFViewer.Utils.Direction.prototype = Object.create(GLTFViewer.Utils.Vec3.prototype, {
    constructor: { value: GLTFViewer.Utils.Direction },
    Set: {
        value: function (x, y, z) {
            return GLTFViewer.Utils.Vec3.prototype.Set.call(this, x, y, z).Normalize();
        }
    },
    Subtract: {
        value: function (v) {
            return GLTFViewer.Utils.Vec3.prototype.Subtract.call(this, v).Normalize();
        }
    },
    Transform: {
        value: function (trans) {
            if (trans.IsIdentity())
                return this;
            var x = trans.a00 * this.x + trans.a10 * this.y + trans.a20 * this.z;
            var y = trans.a01 * this.x + trans.a11 * this.y + trans.a21 * this.z;
            var z = trans.a02 * this.x + trans.a12 * this.y + trans.a22 * this.z;
            this.x = x;
            this.y = y;
            this.z = z;
            return this.Normalize();
        }
    },
    TransformCreate: {
        value: function (trans) {
            return this.Clone().Transform(trans);
        }
    },
    GetComponent: {
        value: function (v) {
            var d = this.Dot(v);
            return new GLTFViewer.Utils.Vec3(this.x * d, this.y * d, this.z * d);
        }
    },
    SetArbitraryPerpendicular: {
        value: function () {
            if (this.z > -0.6 && this.z < 0.6) {
                var x = this.x;
                this.x = -this.y;
                this.y = x;
                this.z = 0;
            } else if (this.y > -0.6 && this.y < 0.6) {
                var x = this.x;
                this.x = this.z;
                this.y = 0;
                this.z = -x;
            } else {
                var y = this.y;
                this.x = 0;
                this.y = -this.z;
                this.z = y;
            }
            return this;
        }
    },
    CreateArbitraryPerpendicular: {
        value: function () {
            if (this.z > -0.6 && this.z < 0.6)
                return new GLTFViewer.Utils.Direction(-this.y, this.x, 0);
            if (this.y > -0.6 && this.y < 0.6)
                return new GLTFViewer.Utils.Direction(this.z, 0, -this.x);
            return new GLTFViewer.Utils.Direction(0, -this.z, this.y);
        }
    },
    RotateVectorCreate: {
        value: function (v, angle) {
            var parallel = this.GetComponent(v);
            var p1 = GLTFViewer.Utils.Vec3.Create(parallel, v);
            var p2 = new GLTFViewer.Utils.Vec3(this).CrossCreate(p1);
            parallel.Add(p1.ScaleCreate(Math.cos(angle)));
            return parallel.Add(p2.ScaleCreate(Math.sin(angle)));
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.Direction, {
    dix: {
        get: function () {
            return new GLTFViewer.Utils.Direction(1, 0, 0);
        }
    },
    diy: {
        get: function () {
            return new GLTFViewer.Utils.Direction(0, 1, 0);
        }
    },
    diz: {
        get: function () {
            return new GLTFViewer.Utils.Direction(0, 0, 1);
        }
    },
    Create: {
        value: function (startPoint, endPoint) {
            return new GLTFViewer.Utils.Direction(endPoint.x - startPoint.x, endPoint.y - startPoint.y, endPoint.z - startPoint.z);
        }
    },
    ScaleCreate: {
        value: function (dir, scale) {
            // this has to be a Vector
            return new GLTFViewer.Utils.Vec3(dir.x * scale, dir.y * scale, dir.z * scale);
        }
    }
});
//////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////
//
// Quaternion
//
/** @constructor */
GLTFViewer.Utils.Quat = function(x, y, z, w) {
    this.w = w;
    this.x = x;
    this.y = y;
    this.z = z;
};
GLTFViewer.Utils.Quat.prototype = Object.create(null, {
    x: { writable: true, value: 0 },
    y: { writable: true, value: 0 },
    z: { writable: true, value: 0 },
    w: { writable: true, value: 0 },
    Clone: {
        value: function () {
            return new GLTFViewer.Utils.Quat(this.x, this.y, this.z, this.w);
        }
    },
    // axisAngle: X, Y, Z, R
    SetFromAxisAngle: {
        value: function (axisAngle) {
            var s = Math.sin(axisAngle[3] / 2);
            var axis = new GLTFViewer.Utils.Direction(axisAngle[0] * 1, axisAngle[1] * 1, axisAngle[2] * 1);
            this.x = axis.x * s;
            this.y = axis.y * s;
            this.z = axis.z * s;
            this.w = Math.cos(axisAngle[3] / 2);
        }
    },
    Normalize: {
        value: function () {
            var lengthSq = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            if (lengthSq === 1) {
                // nothing
            } else if (lengthSq < GLTFViewer.Utils.lengthAccuracySquared) {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.z = 1;
            } else {
                var length = Math.sqrt(lengthSq);
                this.x = this.x / length;
                this.y = this.y / length;
                this.z = this.z / length;
                this.w = this.w / length;
            }
        }
    },
    MultiplyCreate: {
        value: function (b) {
            var ww = this.w * b.w - this.x * b.x - this.y * b.y - this.z * b.z;
            var xx = this.w * b.x + this.x * b.w + this.y * b.z - this.z * b.y;
            var yy = this.w * b.y + this.y * b.w + this.z * b.x - this.x * b.z;
            var zz = this.w * b.z + this.z * b.w + this.x * b.y - this.y * b.x;
            return new GLTFViewer.Utils.Quat(xx, yy, zz, ww);
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.Quat, {
    Identity: {
        get: function () {
            return new GLTFViewer.Utils.Quat(0, 0, 0, 1);
        }
    },
    Slerp: {
        value: function (a, b, t) {
            var aa = a.Clone();
            var cosHalfTheta = aa.w * b.w + aa.x * b.x + aa.y * b.y + aa.z * b.z;
            if (cosHalfTheta < 0) {
                aa.x *= -1;
                aa.y *= -1;
                aa.z *= -1;
                aa.w *= -1;
                cosHalfTheta *= -1;
            }
            if (Math.abs(cosHalfTheta) >= 1.0)
                return new GLTFViewer.Utils.Quat(aa.x, aa.y, aa.z, aa.w);
            var halfTheta = Math.acos(cosHalfTheta);
            var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
            if (Math.abs(sinHalfTheta) < 0.001)
                return new GLTFViewer.Utils.Quat((aa.x + b.x) / 2, (aa.y + b.y) / 2, (aa.z + b.z) / 2, (aa.w + b.w) / 2);
            var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
            var ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
            return new GLTFViewer.Utils.Quat(aa.x * ratioA + b.x * ratioB, aa.y * ratioA + b.y * ratioB, aa.z * ratioA + b.z * ratioB, aa.w * ratioA + b.w * ratioB);
        }
    }
});
//////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////
//
// 4x4 Matrix
// stored in row major order
// so
// a00 a01 a02 a03
// a10 a11 a12 a13
// a20 a21 a22 a23
// a30 a31 a32 a33
//
/** @constructor */
GLTFViewer.Utils.Matrix = function (a00, a01, a02, a03,
                             a10, a11, a12, a13,
                             a20, a21, a22, a23,
                             a30, a31, a32, a33) {
    this.Set(a00, a01, a02, a03,
             a10, a11, a12, a13,
             a20, a21, a22, a23,
             a30, a31, a32, a33);
};
GLTFViewer.Utils.Matrix.prototype = Object.create(null, {
    constructor: { value: GLTFViewer.Utils.Matrix },
    a00: { writable: true, value: 0 },
    a01: { writable: true, value: 0 },
    a02: { writable: true, value: 0 },
    a03: { writable: true, value: 0 },
    a10: { writable: true, value: 0 },
    a11: { writable: true, value: 0 },
    a12: { writable: true, value: 0 },
    a13: { writable: true, value: 0 },
    a20: { writable: true, value: 0 },
    a21: { writable: true, value: 0 },
    a22: { writable: true, value: 0 },
    a23: { writable: true, value: 0 },
    a30: { writable: true, value: 0 },
    a31: { writable: true, value: 0 },
    a32: { writable: true, value: 0 },
    a33: { writable: true, value: 0 },
    Set: {
        value: function (a00, a01, a02, a03,
                         a10, a11, a12, a13,
                         a20, a21, a22, a23,
                         a30, a31, a32, a33) {
            if (a00 instanceof GLTFViewer.Utils.Matrix) {
                this.a00 = a00.a00;
                this.a01 = a00.a01;
                this.a02 = a00.a02;
                this.a03 = a00.a03;
                this.a10 = a00.a10;
                this.a11 = a00.a11;
                this.a12 = a00.a12;
                this.a13 = a00.a13;
                this.a20 = a00.a20;
                this.a21 = a00.a21;
                this.a22 = a00.a22;
                this.a23 = a00.a23;
                this.a30 = a00.a30;
                this.a31 = a00.a31;
                this.a32 = a00.a32;
                this.a33 = a00.a33;
            } else if (((a00 instanceof Array) || (a00 instanceof Float32Array)) && a00.length === 16) {
                this.a00 = a00[0] * 1;
                this.a01 = a00[1] * 1;
                this.a02 = a00[2] * 1;
                this.a03 = a00[3] * 1;
                this.a10 = a00[4] * 1;
                this.a11 = a00[5] * 1;
                this.a12 = a00[6] * 1;
                this.a13 = a00[7] * 1;
                this.a20 = a00[8] * 1;
                this.a21 = a00[9] * 1;
                this.a22 = a00[10] * 1;
                this.a23 = a00[11] * 1;
                this.a30 = a00[12] * 1;
                this.a31 = a00[13] * 1;
                this.a32 = a00[14] * 1;
                this.a33 = a00[15] * 1;
            } else if (typeof a00 === "undefined") {
                this.a00 = 0;
                this.a01 = 0;
                this.a02 = 0;
                this.a03 = 0;
                this.a10 = 0;
                this.a11 = 0;
                this.a12 = 0;
                this.a13 = 0;
                this.a20 = 0;
                this.a21 = 0;
                this.a22 = 0;
                this.a23 = 0;
                this.a30 = 0;
                this.a31 = 0;
                this.a32 = 0;
                this.a33 = 0;
            } else {
                this.a00 = a00;
                this.a01 = a01;
                this.a02 = a02;
                this.a03 = a03;
                this.a10 = a10;
                this.a11 = a11;
                this.a12 = a12;
                this.a13 = a13;
                this.a20 = a20;
                this.a21 = a21;
                this.a22 = a22;
                this.a23 = a23;
                this.a30 = a30;
                this.a31 = a31;
                this.a32 = a32;
                this.a33 = a33;
            }
        }
    },
    Clone: {
        value: function () {
            return new this.constructor(this.a00, this.a01, this.a02, this.a03,
                                        this.a10, this.a11, this.a12, this.a13,
                                        this.a20, this.a21, this.a22, this.a23,
                                        this.a30, this.a31, this.a32, this.a33);
        }
    },
    IsIdentity: {
        value: function () {
            return this.a00 === 1 && this.a01 === 0 && this.a02 === 0 && this.a03 === 0 &&
                   this.a10 === 0 && this.a11 === 1 && this.a12 === 0 && this.a13 === 0 &&
                   this.a20 === 0 && this.a21 === 0 && this.a22 === 1 && this.a23 === 0 &&
                   this.a30 === 0 && this.a31 === 0 && this.a32 === 0 && this.a33 === 1;
        }
    },
    IsEqual: {
        value: function (trans) {
            if (this === trans)
                return true;
            var e = GLTFViewer.Utils.EqualDoubles(this.a00, trans.a00) &&
                    GLTFViewer.Utils.EqualDoubles(this.a01, trans.a01) &&
                    GLTFViewer.Utils.EqualDoubles(this.a02, trans.a02) &&
                    GLTFViewer.Utils.EqualDoubles(this.a03, trans.a03) &&
                    GLTFViewer.Utils.EqualDoubles(this.a10, trans.a10) &&
                    GLTFViewer.Utils.EqualDoubles(this.a11, trans.a11) &&
                    GLTFViewer.Utils.EqualDoubles(this.a12, trans.a12) &&
                    GLTFViewer.Utils.EqualDoubles(this.a13, trans.a13) &&
                    GLTFViewer.Utils.EqualDoubles(this.a20, trans.a20) &&
                    GLTFViewer.Utils.EqualDoubles(this.a21, trans.a21) &&
                    GLTFViewer.Utils.EqualDoubles(this.a22, trans.a22) &&
                    GLTFViewer.Utils.EqualDoubles(this.a23, trans.a23) &&
                    GLTFViewer.Utils.EqualDoubles(this.a30, trans.a30) &&
                    GLTFViewer.Utils.EqualDoubles(this.a31, trans.a31) &&
                    GLTFViewer.Utils.EqualDoubles(this.a32, trans.a32) &&
                    GLTFViewer.Utils.EqualDoubles(this.a33, trans.a33);
            return e;
        }
    },
    GetDeterminant: {
        value: function () {
            return   this.a03 * this.a12 * this.a21 * this.a30
                   + this.a02 * this.a13 * this.a20 * this.a31
                   + this.a01 * this.a10 * this.a23 * this.a32
                   - this.a03 * this.a11 * this.a22 * this.a30
                   - this.a00 * this.a13 * this.a22 * this.a31
                   - this.a02 * this.a11 * this.a20 * this.a33
                   - this.a00 * this.a11 * this.a23 * this.a32
                   - this.a00 * this.a12 * this.a21 * this.a33
                   - this.a01 * this.a10 * this.a22 * this.a33
                   + this.a00 * this.a11 * this.a22 * this.a33
                   - this.a02 * this.a13 * this.a21 * this.a30 - this.a03 * this.a12 * this.a20 * this.a31
                   - this.a01 * this.a12 * this.a23 * this.a30 - this.a03 * this.a10 * this.a21 * this.a32
                   - this.a02 * this.a10 * this.a23 * this.a31 - this.a01 * this.a13 * this.a20 * this.a32
                   + this.a03 * this.a10 * this.a22 * this.a31 + this.a01 * this.a13 * this.a22 * this.a30
                   + this.a02 * this.a11 * this.a23 * this.a30 + this.a03 * this.a11 * this.a20 * this.a32
                   + this.a00 * this.a12 * this.a23 * this.a31 + this.a00 * this.a13 * this.a21 * this.a32
                   + this.a01 * this.a12 * this.a20 * this.a33 + this.a02 * this.a10 * this.a21 * this.a33;
        }
    },
    Invert: {
        value: function () {
            var det = this.GetDeterminant();
            var a00 = (this.a12 * this.a23 * this.a31 + this.a13 * this.a21 * this.a32 - this.a13 * this.a22 * this.a31 - this.a12 * this.a21 * this.a33 - this.a11 * this.a23 * this.a32 + this.a11 * this.a22 * this.a33) / det;
            var a01 = (this.a03 * this.a22 * this.a31 - this.a02 * this.a23 * this.a31 - this.a03 * this.a21 * this.a32 + this.a01 * this.a23 * this.a32 + this.a02 * this.a21 * this.a33 - this.a01 * this.a22 * this.a33) / det;
            var a02 = (this.a02 * this.a13 * this.a31 - this.a03 * this.a12 * this.a31 + this.a03 * this.a11 * this.a32 - this.a01 * this.a13 * this.a32 - this.a02 * this.a11 * this.a33 + this.a01 * this.a12 * this.a33) / det;
            var a03 = (this.a03 * this.a12 * this.a21 - this.a02 * this.a13 * this.a21 - this.a03 * this.a11 * this.a22 + this.a01 * this.a13 * this.a22 + this.a02 * this.a11 * this.a23 - this.a01 * this.a12 * this.a23) / det;
            var a10 = (this.a13 * this.a22 * this.a30 - this.a12 * this.a23 * this.a30 - this.a13 * this.a20 * this.a32 + this.a10 * this.a23 * this.a32 + this.a12 * this.a20 * this.a33 - this.a10 * this.a22 * this.a33) / det;
            var a11 = (this.a02 * this.a23 * this.a30 - this.a03 * this.a22 * this.a30 + this.a03 * this.a20 * this.a32 - this.a00 * this.a23 * this.a32 - this.a02 * this.a20 * this.a33 + this.a00 * this.a22 * this.a33) / det;
            var a12 = (this.a03 * this.a12 * this.a30 - this.a02 * this.a13 * this.a30 - this.a03 * this.a10 * this.a32 + this.a00 * this.a13 * this.a32 + this.a02 * this.a10 * this.a33 - this.a00 * this.a12 * this.a33) / det;
            var a13 = (this.a02 * this.a13 * this.a20 - this.a03 * this.a12 * this.a20 + this.a03 * this.a10 * this.a22 - this.a00 * this.a13 * this.a22 - this.a02 * this.a10 * this.a23 + this.a00 * this.a12 * this.a23) / det;
            var a20 = (this.a11 * this.a23 * this.a30 - this.a13 * this.a21 * this.a30 + this.a13 * this.a20 * this.a31 - this.a10 * this.a23 * this.a31 - this.a11 * this.a20 * this.a33 + this.a10 * this.a21 * this.a33) / det;
            var a21 = (this.a03 * this.a21 * this.a30 - this.a01 * this.a23 * this.a30 - this.a03 * this.a20 * this.a31 + this.a00 * this.a23 * this.a31 + this.a01 * this.a20 * this.a33 - this.a00 * this.a21 * this.a33) / det;
            var a22 = (this.a01 * this.a13 * this.a30 - this.a03 * this.a11 * this.a30 + this.a03 * this.a10 * this.a31 - this.a00 * this.a13 * this.a31 - this.a01 * this.a10 * this.a33 + this.a00 * this.a11 * this.a33) / det;
            var a23 = (this.a03 * this.a11 * this.a20 - this.a01 * this.a13 * this.a20 - this.a03 * this.a10 * this.a21 + this.a00 * this.a13 * this.a21 + this.a01 * this.a10 * this.a23 - this.a00 * this.a11 * this.a23) / det;
            var a30 = (this.a12 * this.a21 * this.a30 - this.a11 * this.a22 * this.a30 - this.a12 * this.a20 * this.a31 + this.a10 * this.a22 * this.a31 + this.a11 * this.a20 * this.a32 - this.a10 * this.a21 * this.a32) / det;
            var a31 = (this.a01 * this.a22 * this.a30 - this.a02 * this.a21 * this.a30 + this.a02 * this.a20 * this.a31 - this.a00 * this.a22 * this.a31 - this.a01 * this.a20 * this.a32 + this.a00 * this.a21 * this.a32) / det;
            var a32 = (this.a02 * this.a11 * this.a30 - this.a01 * this.a12 * this.a30 - this.a02 * this.a10 * this.a31 + this.a00 * this.a12 * this.a31 + this.a01 * this.a10 * this.a32 - this.a00 * this.a11 * this.a32) / det;
            var a33 = (this.a01 * this.a12 * this.a20 - this.a02 * this.a11 * this.a20 + this.a02 * this.a10 * this.a21 - this.a00 * this.a12 * this.a21 - this.a01 * this.a10 * this.a22 + this.a00 * this.a11 * this.a22) / det;
            this.a00 = a00;
            this.a01 = a01;
            this.a02 = a02;
            this.a03 = a03;
            this.a10 = a10;
            this.a11 = a11;
            this.a12 = a12;
            this.a13 = a13;
            this.a20 = a20;
            this.a21 = a21;
            this.a22 = a22;
            this.a23 = a23;
            this.a30 = a30;
            this.a31 = a31;
            this.a32 = a32;
            this.a33 = a33;
            return this;
        }
    },
    Transpose: {
        value: function () {
            var t;
            t = this.a10; this.a10 = this.a01; this.a01 = t;
            t = this.a20; this.a20 = this.a02; this.a02 = t;
            t = this.a30; this.a30 = this.a03; this.a03 = t;
            t = this.a21; this.a21 = this.a12; this.a12 = t;
            t = this.a31; this.a31 = this.a13; this.a13 = t;
            t = this.a32; this.a32 = this.a23; this.a23 = t;
            return this;
        }
    },
    Multiply: {
        value: function (trans) {
            var a00 = this.a00 * trans.a00 + this.a01 * trans.a10 + this.a02 * trans.a02 + this.a03 * trans.a03;
            var a01 = this.a00 * trans.a01 + this.a01 * trans.a11 + this.a02 * trans.a12 + this.a03 * trans.a13;
            var a02 = this.a00 * trans.a02 + this.a01 * trans.a12 + this.a02 * trans.a22 + this.a03 * trans.a23;
            var a03 = this.a00 * trans.a03 + this.a01 * trans.a13 + this.a02 * trans.a32 + this.a03 * trans.a33;
            var a10 = this.a10 * trans.a00 + this.a11 * trans.a10 + this.a12 * trans.a02 + this.a13 * trans.a03;
            var a11 = this.a10 * trans.a01 + this.a11 * trans.a11 + this.a12 * trans.a12 + this.a13 * trans.a13;
            var a12 = this.a10 * trans.a02 + this.a11 * trans.a12 + this.a12 * trans.a22 + this.a13 * trans.a23;
            var a13 = this.a10 * trans.a03 + this.a11 * trans.a13 + this.a12 * trans.a32 + this.a13 * trans.a33;
            var a20 = this.a20 * trans.a00 + this.a21 * trans.a10 + this.a22 * trans.a02 + this.a23 * trans.a03;
            var a21 = this.a20 * trans.a01 + this.a21 * trans.a11 + this.a22 * trans.a12 + this.a23 * trans.a13;
            var a22 = this.a20 * trans.a02 + this.a21 * trans.a12 + this.a22 * trans.a22 + this.a23 * trans.a23;
            var a23 = this.a20 * trans.a03 + this.a21 * trans.a13 + this.a22 * trans.a32 + this.a23 * trans.a33;
            var a30 = this.a30 * trans.a00 + this.a31 * trans.a10 + this.a32 * trans.a02 + this.a33 * trans.a03;
            var a31 = this.a30 * trans.a01 + this.a31 * trans.a11 + this.a32 * trans.a12 + this.a33 * trans.a13;
            var a32 = this.a30 * trans.a02 + this.a31 * trans.a12 + this.a32 * trans.a22 + this.a33 * trans.a23;
            var a33 = this.a30 * trans.a03 + this.a31 * trans.a13 + this.a32 * trans.a32 + this.a33 * trans.a33;
            this.a00 = a00;
            this.a01 = a01;
            this.a02 = a02;
            this.a03 = a03;
            this.a10 = a10;
            this.a11 = a11;
            this.a12 = a12;
            this.a13 = a13;
            this.a20 = a20;
            this.a21 = a21;
            this.a22 = a22;
            this.a23 = a23;
            this.a30 = a30;
            this.a31 = a31;
            this.a32 = a32;
            this.a33 = a33;
            return this;
        }
    },
    MultiplyCreate: {
        value: function (trans) {
            var v = this.Clone();
            return v.Multiply(trans);
        }
    },
    ToArray: {
        value: function (array) {
            array[0] = this.a00;
            array[1] = this.a01;
            array[2] = this.a02;
            array[3] = this.a03;
            array[4] = this.a10;
            array[5] = this.a11;
            array[6] = this.a12;
            array[7] = this.a13;
            array[8] = this.a20;
            array[9] = this.a21;
            array[10] = this.a22;
            array[11] = this.a23;
            array[12] = this.a30;
            array[13] = this.a31;
            array[14] = this.a32;
            array[15] = this.a33;
        }
    },
    ToArray3x3: {
        value: function (array) {
            array[0] = this.a00;
            array[1] = this.a01;
            array[2] = this.a02;
            array[3] = this.a10;
            array[4] = this.a11;
            array[5] = this.a12;
            array[6] = this.a20;
            array[7] = this.a21;
            array[8] = this.a22;
        }
    }
});
///////////////////////////////////////
//
// Transform
// stored in column major order
// we store 1/scalefactor in a33, the translation is scaled by 1/scalefactor too.
// this causes the w of the xyzw transformation to be not 1, and when normalized, it scales the xyz
// this does mean that we might need to divide shader position by w
//
/** @constructor */
GLTFViewer.Utils.Transformation = function(a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33) {
    GLTFViewer.Utils.Matrix.call(this, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33);
};
GLTFViewer.Utils.Transformation.prototype = Object.create(GLTFViewer.Utils.Matrix.prototype, {
    constructor: { value: GLTFViewer.Utils.Transformation },
    Set: {
        value: function (a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33) {
            GLTFViewer.Utils.Matrix.prototype.Set.call(this, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33);
            if (GLTFViewer.Utils.IsNull(a00))
                this.a00 = this.a11 = this.a22 = this.a33 = 1;
        }
    },
    Multiply: {
        value: function (trans) {
            var a00 = this.a00 * trans.a00 + this.a10 * trans.a01 + this.a20 * trans.a02 + this.a30 * trans.a03;
            var a01 = this.a01 * trans.a00 + this.a11 * trans.a01 + this.a21 * trans.a02 + this.a31 * trans.a03;
            var a02 = this.a02 * trans.a00 + this.a12 * trans.a01 + this.a22 * trans.a02 + this.a32 * trans.a03;
            var a03 = this.a03 * trans.a00 + this.a13 * trans.a01 + this.a23 * trans.a02 + this.a33 * trans.a03;
            var a10 = this.a00 * trans.a10 + this.a10 * trans.a11 + this.a20 * trans.a12 + this.a30 * trans.a13;
            var a11 = this.a01 * trans.a10 + this.a11 * trans.a11 + this.a21 * trans.a12 + this.a31 * trans.a13;
            var a12 = this.a02 * trans.a10 + this.a12 * trans.a11 + this.a22 * trans.a12 + this.a32 * trans.a13;
            var a13 = this.a03 * trans.a10 + this.a13 * trans.a11 + this.a23 * trans.a12 + this.a33 * trans.a13;
            var a20 = this.a00 * trans.a20 + this.a10 * trans.a21 + this.a20 * trans.a22 + this.a30 * trans.a23;
            var a21 = this.a01 * trans.a20 + this.a11 * trans.a21 + this.a21 * trans.a22 + this.a31 * trans.a23;
            var a22 = this.a02 * trans.a20 + this.a12 * trans.a21 + this.a22 * trans.a22 + this.a32 * trans.a23;
            var a23 = this.a03 * trans.a20 + this.a13 * trans.a21 + this.a23 * trans.a22 + this.a33 * trans.a23;
            var a30 = this.a00 * trans.a30 + this.a10 * trans.a31 + this.a20 * trans.a32 + this.a30 * trans.a33;
            var a31 = this.a01 * trans.a30 + this.a11 * trans.a31 + this.a21 * trans.a32 + this.a31 * trans.a33;
            var a32 = this.a02 * trans.a30 + this.a12 * trans.a31 + this.a22 * trans.a32 + this.a32 * trans.a33;
            var a33 = this.a03 * trans.a30 + this.a13 * trans.a31 + this.a23 * trans.a32 + this.a33 * trans.a33;
            this.a00 = a00;
            this.a01 = a01;
            this.a02 = a02;
            this.a03 = a03;
            this.a10 = a10;
            this.a11 = a11;
            this.a12 = a12;
            this.a13 = a13;
            this.a20 = a20;
            this.a21 = a21;
            this.a22 = a22;
            this.a23 = a23;
            this.a30 = a30;
            this.a31 = a31;
            this.a32 = a32;
            this.a33 = a33;
            return this;
        }
    },
    Translate: {
        value: function (x, y, z) {
            var vec = new GLTFViewer.Utils.Vec3(x, y, z);
            var mat = new GLTFViewer.Utils.Transformation(1, 0, 0, 0, 
                                                   0, 1, 0, 0,
                                                   0, 0, 1, 0,
                                                   vec.x, vec.y, vec.z, 1);
            this.Multiply(mat);
            return this;
        }
    },
    Scale: {
        value: function (scale) {
            var mat = new GLTFViewer.Utils.Transformation(1, 0, 0, 0,
                                                   0, 1, 0, 0,
                                                   0, 0, 1, 0,
                                                   0, 0, 0, 1 / scale);
            this.Multiply(mat);
            return this;
        }
    },

    IsWellFormed: {
        value: function () {
            if (GLTFViewer.Utils.EqualDoubles(this.a33, 0))
                return false;
            var dirX = new GLTFViewer.Utils.Vec3(this.a00, this.a01, this.a02);
            var dirY = new GLTFViewer.Utils.Vec3(this.a10, this.a11, this.a12);
            var dirZ = new GLTFViewer.Utils.Vec3(this.a20, this.a21, this.a22);
            if (!dirX.IsLength(1))
                return false;
            if (!dirY.IsLength(1))
                return false;
            if (!dirZ.IsLength(1))
                return false;
            if (!GLTFViewer.Utils.IslengthZero(dirX.Dot(dirY)))
                return false;
            if (!GLTFViewer.Utils.IslengthZero(dirY.Dot(dirZ)))
                return false;
            if (!GLTFViewer.Utils.IslengthZero(dirZ.Dot(dirX)))
                return false;
            var tmp = dirX.CrossCreate(dirY);
            if (!tmp.IsLength(1))
                return false;
            return true;
        }
    },
    CreateWellFormed: {
        value: function () {
            var c0 = new GLTFViewer.Utils.Vec3(this.a00, this.a01, this.a02);
            var c1 = new GLTFViewer.Utils.Vec3(this.a10, this.a11, this.a12);
            var c2 = new GLTFViewer.Utils.Vec3(this.a20, this.a21, this.a22);
            var x = c0.GetDirection();
            var s = c1.Clone().Subtract(GLTFViewer.Utils.Direction.ScaleCreate(x, x.Dot(c1)));
            var y = s.GetDirection();
            var z = x.CrossCreate(y).GetDirection();
            if (z.Dot(c2) < 0)
                z.Negate();
            return new GLTFViewer.Utils.Transformation(x.x, x.y, x.z, this.a03,
                                                y.x, y.y, y.z, this.a13,
                                                z.x, z.y, z.z, this.a23,
                                                this.a30, this.a31, this.a32, this.a33);
        }
    },
    GetZDirection: {
        value: function () {
            return new GLTFViewer.Utils.Direction(this.a20, this.a21, this.a22);
        }
    },
    GetTranslationTransformation: {
        value: function () {
            return GLTFViewer.Utils.Transformation.TranslationCreate(this.a30, this.a31, this.a32);
        }
    },
    GetTranslation: {
        value: function () {
            return new GLTFViewer.Utils.Vec3(this.a30 / this.a33, this.a31 / this.a33, this.a32 / this.a33);
        }
    },
    GetRotationTransformation: {
        value: function () {
            return new GLTFViewer.Utils.Transformation(this.a00, this.a01, this.a02, 0,
                                                this.a10, this.a11, this.a12, 0,
                                                this.a20, this.a21, this.a22, 0,
                                                0, 0, 0, 1); 
        }
    },
    GetScale: {
        value: function () {
            return 1 / this.a33;
        }
    },
    TryGetRotationAxis: {
        value: function (axisDir) {
            var b1 = new GLTFViewer.Utils.Vec3(this.a00 - 1, this.a01, this.a02);
            var b2 = new GLTFViewer.Utils.Vec3(this.a10, this.a11 - 1, this.a12);
            var b3 = new GLTFViewer.Utils.Vec3(this.a20, this.a21, this.a22 - 1);
            var a1 = b1.CrossCreate(b2);
            var a2 = b1.CrossCreate(b3);
            var a3 = b2.CrossCreate(b3);
            var m1 = a1.GetMagnitudeSquared();
            var m2 = a2.GetMagnitudeSquared();
            var m3 = a3.GetMagnitudeSquared();
            if (m1 > m2) {
                if (m1 > m3)
                    axisDir.Set(a1.x, a1.y, a1.z);
                else
                    axisDir.Set(a3.x, a3.y, a3.z);
            } else {
                if (m2 > m3)
                    axisDir.Set(a2.x, a2.y, a2.z);
                else
                    axisDir.Set(a3.x, a3.y, a3.z);
            }
            axisDir.Normalize();            
            return !axisDir.IsZero();
        }
    },
    TryGetRotation: {
        value: function (direction) {
            var angle = 0;
            if (this.TryGetRotationAxis(direction)) {
                var dirX = direction.CreateArbitraryPerpendicular();
                var dirY = direction.CrossCreate(dirX).GetDirection();
                var t = dirX.TransformCreate(this);
                angle = Math.atan2(dirY.Dot(t), dirX.Dot(t));
                if (angle < 0)
                    direction.Negate();
                angle = Math.abs(angle);
            } else {
                angle = 0.0;
                direction.Set(0, 0, 1); //dirz
            }
            return angle;
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.Transformation, {
    Identity: {
        get: function () {
            return new GLTFViewer.Utils.Transformation();
        }
    },
    MultiplyCreate: {
        value: function (first, second) {
            var a00 = first.a00 * second.a00 + first.a10 * second.a01 + first.a20 * second.a02 + first.a30 * second.a03;
            var a01 = first.a01 * second.a00 + first.a11 * second.a01 + first.a21 * second.a02 + first.a31 * second.a03;
            var a02 = first.a02 * second.a00 + first.a12 * second.a01 + first.a22 * second.a02 + first.a32 * second.a03;
            var a03 = first.a03 * second.a00 + first.a13 * second.a01 + first.a23 * second.a02 + first.a33 * second.a03;
            var a10 = first.a00 * second.a10 + first.a10 * second.a11 + first.a20 * second.a12 + first.a30 * second.a13;
            var a11 = first.a01 * second.a10 + first.a11 * second.a11 + first.a21 * second.a12 + first.a31 * second.a13;
            var a12 = first.a02 * second.a10 + first.a12 * second.a11 + first.a22 * second.a12 + first.a32 * second.a13;
            var a13 = first.a03 * second.a10 + first.a13 * second.a11 + first.a23 * second.a12 + first.a33 * second.a13;
            var a20 = first.a00 * second.a20 + first.a10 * second.a21 + first.a20 * second.a22 + first.a30 * second.a23;
            var a21 = first.a01 * second.a20 + first.a11 * second.a21 + first.a21 * second.a22 + first.a31 * second.a23;
            var a22 = first.a02 * second.a20 + first.a12 * second.a21 + first.a22 * second.a22 + first.a32 * second.a23;
            var a23 = first.a03 * second.a20 + first.a13 * second.a21 + first.a23 * second.a22 + first.a33 * second.a23;
            var a30 = first.a00 * second.a30 + first.a10 * second.a31 + first.a20 * second.a32 + first.a30 * second.a33;
            var a31 = first.a01 * second.a30 + first.a11 * second.a31 + first.a21 * second.a32 + first.a31 * second.a33;
            var a32 = first.a02 * second.a30 + first.a12 * second.a31 + first.a22 * second.a32 + first.a32 * second.a33;
            var a33 = first.a03 * second.a30 + first.a13 * second.a31 + first.a23 * second.a32 + first.a33 * second.a33;
            return new GLTFViewer.Utils.Transformation(a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33);
        }
    },
    TranslationCreate: {
        value: function (x, y, z) {
            var vec = new GLTFViewer.Utils.Vec3(x, y, z);
            return new GLTFViewer.Utils.Transformation(1, 0, 0, 0, 
                                                0, 1, 0, 0,
                                                0, 0, 1, 0,
                                                vec.x, vec.y, vec.z, 1);
        }
    },
    RotationCreate: {
        value: function (a00, a01, a02, a10, a11, a12) {
            var A00 = a00;
            var A01 = a01;
            var A02 = a02;
            var A03 = 0;
            var A10 = a10;
            var A11 = a11;
            var A12 = a12;
            var A13 = 0;
            var A20 = a01 * a12 - a11 * a02;
            var A21 = a10 * a02 - a00 * a12;
            var A22 = a00 * a11 - a10 * a01;
            var A23 = 0;
            var A30 = 0;
            var A31 = 0;
            var A32 = 0;
            var A33 = 1;
            return new GLTFViewer.Utils.Transformation(A00, A01, A02, A03, A10, A11, A12, A13, A20, A21, A22, A23, A30, A31, A32, A33);
        }
    },
    ScaleCreate: {
        value: function (scale) {
            return new GLTFViewer.Utils.Transformation(1, 0, 0, 0,
                                                0, 1, 0, 0,
                                                0, 0, 1, 0,
                                                0, 0, 0, 1 / scale);
        }
    },
    RotationAboutAxisCreate: {
        value: function (axis, angle) {
            var orgn = axis.orgn;
            var axisDir = axis.dir;
            var dirX = axisDir.RotateVectorCreate(GLTFViewer.Utils.Direction.dix, angle).GetDirection();
            var dirY = axisDir.RotateVectorCreate(GLTFViewer.Utils.Direction.diy, angle).GetDirection();
            return GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(GLTFViewer.Utils.Vec3.Origin, orgn)).Multiply(GLTFViewer.Utils.Transformation.RotationCreate(dirX.x, dirX.y, dirX.z, dirY.x, dirY.y, dirY.z)).Multiply(GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(orgn, GLTFViewer.Utils.Vec3.Origin)));
        }
    },
    ScaleAboutPointCreate: {
        value: function (scale, x, y, z) {
            return GLTFViewer.Utils.Transformation.TranslationCreate(x, y, z).Multiply(GLTFViewer.Utils.Transformation.ScaleCreate(scale)).Multiply(GLTFViewer.Utils.Transformation.TranslationCreate(-x, -y, -z));
        }
    },
    lookAtRH: {
        value: function (eye, center, up) {
            var z = GLTFViewer.Utils.Vec3.Create(center, eye).Normalize(); // z = eye - center
            var x = up.CrossCreate(z).Normalize();
            var y = z.CrossCreate(x);
            return new GLTFViewer.Utils.Transformation(x.x,         y.x,         z.x,         0,
                                                x.y,         y.y,         z.y,         0,
                                                x.z,         y.z,         z.z,         0,
                                                -x.Dot(eye), -y.Dot(eye), -z.Dot(eye), 1);
        }
    },
    orthoRH: {
        value: function (width, height, nearPlane, farPlane) {
            var A00 = 2 / width;
            var A01 = 0;
            var A02 = 0;
            var A03 = 0;
            var A10 = 0;
            var A11 = 2 / height;
            var A12 = 0;
            var A13 = 0;
            var A20 = 0;
            var A21 = 0;
            //var A22 = 2 / (nearPlane - farPlane);
            var A22 = 1 / (nearPlane - farPlane);
            var A23 = 0;
            var A30 = 0;
            var A31 = 0;
            //var A32 = (farPlane + nearPlane) / (nearPlane - farPlane); // there is a problem with orthographic camera
            var A32 = nearPlane / (nearPlane - farPlane);
            var A33 = 1;
            return new GLTFViewer.Utils.Transformation(A00, A01, A02, A03, A10, A11, A12, A13, A20, A21, A22, A23, A30, A31, A32, A33);
        }
    },
    perspectiveRH: {
        value: function (width, height, nearPlane, farPlane) {
            var A00 = 2 * nearPlane / width;
            var A01 = 0;
            var A02 = 0;
            var A03 = 0;
            var A10 = 0;
            var A11 = 2 * nearPlane / height;
            var A12 = 0;
            var A13 = 0;
            var A20 = 0;
            var A21 = 0;
            var A22 = -(farPlane + nearPlane) / (farPlane - nearPlane);
            var A23 = -1;
            var A30 = 0;
            var A31 = 0;
            var A32 = -2 * nearPlane * farPlane / (farPlane - nearPlane);
            var A33 = 0;
            return new GLTFViewer.Utils.Transformation(A00, A01, A02, A03, A10, A11, A12, A13, A20, A21, A22, A23, A30, A31, A32, A33);
        }
    }
});
//////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////
//
// RGBA
//
/** @constructor */
GLTFViewer.Utils.RGBA = function(r, g, b, a) {
    if (typeof r === "undefined") {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 0;
    } else {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
};
GLTFViewer.Utils.RGBA.prototype = Object.create(null, {
    r: { writable: true, value: 0 },
    g: { writable: true, value: 0 },
    b: { writable: true, value: 0 },
    a: { writable: true, value: 255 },
    Clone: {
        value: function () {
            return new GLTFViewer.Utils.RGBA(this.r, this.g, this.b, this.a);
        }
    },
    Equals: {
        value: function (val) {
            return Math.round(this.r) === Math.round(val.r) &&
                   Math.round(this.g) === Math.round(val.g) &&
                   Math.round(this.b) === Math.round(val.b) &&
                   Math.round(this.a) === Math.round(val.a);
        }
    },
    SetHsv: {
        value: function (h, s, v, a) {
            var tHsv = new GLTFViewer.Utils.HSV(h, s, v, a);
            tHsv.SetColor(this);
        }
    },
    SetRgba: {
        value: function (r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
    },
    SetColor: {
        value: function (colr) {
            this.r = colr.r;
            this.g = colr.g;
            this.b = colr.b;
            this.a = colr.a;
        }
    },
    SetRawARGB: {
        value: function (argb) {
            this.r = (argb >> 16) & 0xff;
            this.g = (argb >> 8) & 0xff;
            this.b = argb & 0xff;
            this.a = (argb >> 24) & 0xff;
        }
    },
    GetARGB: {
        value: function () {
            return (this.a << 24) | (this.r << 16) | (this.g << 8) | this.b;
        }
    },
    SetRawABGR: {
        value: function (argb) {
            this.r = argb & 0xff;
            this.g = (argb >> 8) & 0xff;
            this.b = (argb >> 16) & 0xff;
            this.a = (argb >> 24) & 0xff;
        }
    },
    GetABGR: {
        value: function () {
            return (this.a << 24) | (this.b << 16) | (this.g << 8) | this.r;
        }
    },
    GetGray: {
        value: function () {
            return  (0.299 * this.r / 255) + (0.587 * this.g / 255) + (0.114 * this.b / 255);
        }
    },
    ToArray: {
        value: function (array, start) {
            array[start + 0] = this.r / 255.0;
            array[start + 1] = this.g / 255.0;
            array[start + 2] = this.b / 255.0;
            array[start + 3] = this.a / 255.0;
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.RGBA, {
    CreateFromHSL: {
        value: function (hsl) {
            function Hue_2_RGB(v1, v2, vH) {
                if (vH < 0) vH += 1;
                if (vH > 1) vH -= 1;
                if (6 * vH < 1) return v1 + (v2 - v1) * 6 * vH;
                if (2 * vH < 1) return v2;
                if (3 * vH < 2) return v1 + (v2 - v1) * (2 / 3 - vH) * 6;
                return v1;
            }

            var a = Math.round(255 * hsl.a);

            if (hsl.s === 0) {
                var v = Math.round(255 * hsl.l);
                return new GLTFViewer.Utils.RGBA(v, v, v, a);
            }

            var v2 = hsl.l < 0.5 ? hsl.l * (1 + hsl.s) : (hsl.l + hsl.s) - hsl.s * hsl.l;
            var v1 = 2 * hsl.l - v2;

            var r = Math.round(255 * Hue_2_RGB(v1, v2, hsl.h + 1 / 3));
            var g = Math.round(255 * Hue_2_RGB(v1, v2, hsl.h));
            var b = Math.round(255 * Hue_2_RGB(v1, v2, hsl.h - 1 / 3));

            return new GLTFViewer.Utils.RGBA(r, g, b, a);
        }
    }
});
///////////////////////////////////////
//
// HSV
//
/** @constructor */
GLTFViewer.Utils.HSV = function(h, s, v, a) {
    this.h = h;
    this.s = s;
    this.v = v;
    this.a = GLTFViewer.Utils.IsNull(a) ? 1.0 : a;
};
GLTFViewer.Utils.HSV.prototype = Object.create(null, {
    h: { writable: true, value: 0 },
    s: { writable: true, value: 0 },
    v: { writable: true, value: 0 },
    a: { writable: true, value: 1 },
    Set: {
        value: function (h, s, v, a) {
            this.h = h;
            this.s = s;
            this.v = v;
            this.a = GLTFViewer.Utils.IsNull(a) ? 1.0 : a;
        }
    },
    SetColor: {
        value: function (colr) {
            var red, green, blue;
            if (this.s === 0)    // grayscale
                red = green = blue = this.v;
            else {
                var h = this.h / 60;
                var i = Math.floor(h);
                var f = h - i;
                if ((i % 2) === 0)
                    f = 1 - f;
                var m = this.v * (1 - this.s);
                var n = this.v * (1 - this.s * f);
                switch (i) {
                    default:
                    case 0:
                        red = this.v;
                        green = n;
                        blue = m;
                        break;
                    case 1:
                        red = n;
                        green = this.v;
                        blue = m;
                        break;
                    case 2:
                        red = m;
                        green = this.v;
                        blue = n;
                        break;
                    case 3:
                        red = m;
                        green = n;
                        blue = this.v;
                        break;
                    case 4:
                        red = n;
                        green = m;
                        blue = this.v;
                        break;
                    case 5:
                        red = this.v;
                        green = m;
                        blue = n;
                        break;
                }
            }
            colr.r = Math.round(255.0 * red);
            colr.g = Math.round(255.0 * green);
            colr.b = Math.round(255.0 * blue);
            colr.a = Math.round(255.0 * this.a);
        }
    },
    GetHue: {
        value: function () {
            return this.h;
        }
    },
    SetHue: {
        value: function (h) {
            this.h = GLTFViewer.Utils.HSV.ClampHue(h);
        }
    },
    GetSaturation: {
        value: function () {
            return this.s;
        }
    },
    SetSaturation: {
        value: function (s) {
            this.s = GLTFViewer.Utils.HSV.ClampSaturation(s);
        }
    },
    GetValue: {
        value: function () {
            return this.v;
        }
    },
    SetValue: {
        value: function (v) {
            this.v = GLTFViewer.Utils.HSV.ClampValue(v);
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.HSV, {
    ClampHue: {
        value: function (hue) {
            hue = hue - Math.floor(hue / 360) * 360;
            return hue;
        }
    },
    ClampSaturation: {
        value: function (saturation) {
            if (saturation < 0)
                saturation = 0;
            else if (saturation > 1)
                saturation = 1;
            return saturation;
        }
    },
    ClampValue: {
        value: function (value) {
            if (value < 0)
                value = 0;
            else if (value > 1)
                value = 1;
            return value;
        }
    },
    CreateFromColor: {
        value: function (colr) {
            var red = colr.r / 255.0;
            var green = colr.g / 255.0;
            var blue = colr.b / 255.0;
            var alpha = colr.a / 255.0;
            var mi = red, ma = red;
            if (green < mi)
                mi = green;
            else if (green > ma)
                ma = green;
            if (blue < mi)
                mi = blue;
            else if (blue > ma)
                ma = blue;
            var value;
            var saturation;
            var hue;
            value = ma;
            if (ma === 0) {
                saturation = 0;
                hue = 0;
            } else if (ma === mi) {
                saturation = 0;
                hue = 0;
            } else {
                var delta = ma - mi;
                var saturation = delta / ma;
                var h = red === ma ? (green - blue) / delta :
                    green === ma ? 2 + (blue - red) / delta :
                    4 + (red - green) / delta;
                h *= 60;
                if (h < 0)
                    h += 360;
                hue = h;
            }
            return new GLTFViewer.Utils.HSV(hue, saturation, value, alpha);
        }
    },
    TransformColor: {
        value: function (colr) {
            if (colr.r === colr.g && colr.g === colr.b) {
                if (colr.r < 128) {
                    colr.r += 30;
                    colr.g += 30;
                    colr.b += 30;
                } else {
                    colr.r -= 30;
                    colr.g -= 30;
                    colr.b -= 30;
                }
            } else {
                var hsv = GLTFViewer.Utils.HSV.CreateFromColor(colr);
                hsv.SetSaturation(0.18);
                hsv.SetValue(0.685);
                hsv.SetColor(colr);
            }
        }
    }
});
////////////////////////////////////////
//
// HSL
//
/** @constructor */
GLTFViewer.Utils.HSL = function(h, s, l, a) {
    this.h = h;
    this.s = s;
    this.l = l;
    this.a = a;
};
GLTFViewer.Utils.HSL.prototype = Object.create(null, {
    h: { writable: true, value: 0 },
    s: { writable: true, value: 0 },
    v: { writable: true, value: 0 },
    a: { writable: true, value: 1 },
    Set: {
        value: function (h, s, l, a) {
            this.h = h;
            this.s = s;
            this.l = v;
            this.a = a;
        }
    },
    GetRgb: {
        value: function (a, b, c) {
            if (c < 0)
                c += 1;
            if (c > 1)
                c -= 1;
            if (c < 1 / 6)
                return a + (b - a) * 6 * c;
            if (c < 1 / 2)
                return b;
            if (c < 2 / 3)
                return a + (b - a) * (2 / 3 - c) * 6;
            return a;
        }
    },
    SetColor: {
        value: function (colr) {
            var r, g, b;
            if (this.s === 0)
                r = g = b = this.l;
            else {
                var B = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;
                var A = 2 * this.l - B;
                r = this.GetRgb(A, B, this.h + 1 / 3);
                g = this.GetRgb(A, B, this.h);
                b = this.GetRgb(A, B, this.h - 1 / 3);
            }
            colr.r = Math.round(255.0 * r);
            colr.g = Math.round(255.0 * g);
            colr.b = Math.round(255.0 * b);
            colr.a = this.a;
        }
    },
    GetHue: {
        value: function () {
            return this.h;
        }
    },
    SetHue: {
        value: function (h) {
            this.h = GLTFViewer.Utils.HSL.ClampHue(h);
        }
    },
    GetSaturation: {
        value: function () {
            return this.s;
        }
    },
    SetSaturation: {
        value: function (s) {
            this.s = GLTFViewer.Utils.HSL.ClampSaturation(s);
        }
    },
    GetLight: {
        value: function () {
            return this.l;
        }
    },
    SetLight: {
        value: function (l) {
            this.l = GLTFViewer.Utils.HSL.ClampLight(l);
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.HSL, {
    ClampHue: {
        value: function (hue) {
            hue = hue - Math.floor(hue / 360) * 360;
            return hue;
        }
    },
    ClampSaturation: {
        value: function (saturation) {
            if (saturation < 0)
                saturation = 0;
            else if (saturation > 1)
                saturation = 1;
            return saturation;
        }
    },
    ClampLight: {
        value: function (value) {
            if (value < 0)
                value = 0;
            else if (value > 1)
                value = 1;
            return value;
        }
    },
    CreateFromColor: {
        value: function (colr) {
            var r = colr.r / 255.0;
            var g = colr.g / 255.0;
            var b = colr.b / 255.0;
            var a = colr.a;
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var h, s, l = (max + min) / 2;
            if (max === min)
                h = s = 0;
            else {
                var d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return new GLTFViewer.Utils.HSL(h, s, l, a);
        }
    },
    XColor: {
        value: function (colr) {
            var hsl = GLTFViewer.Utils.HSL.CreateFromColor(colr);
            if (hsl.s < 0.0001)
                hsl.SetHue(120);
            else
                hsl.SetSaturation(hsl.s * 4);
            hsl.SetLight(hsl.l + .45);
            hsl.SetLight(hsl.l * .65);
            hsl.SetColor(colr);
        }
    },
    EColor: {
        value: function (colr) {
            var hsl = GLTFViewer.Utils.HSL.CreateFromColor(colr);
            if (hsl.l > .3)
                hsl.SetLight(.105);
            else
                hsl.SetLight(.6);
            if (hsl.s < 0.0001)
                hsl.SetHue(120);
            else
                hsl.SetHue(0.875);
            hsl.SetLight(hsl.l + .45);
            hsl.SetLight(hsl.l * .65);
            hsl.SetColor(colr);
            if (colr.a < 255)
                colr.a = 40;
            else
                colr.a = 80;
        }
    }
});
////////////////////////////////////////
//
// Temporary Directory
//
/** @constructor */
GLTFViewer.Utils.TempDir = function (basedir) {
    this._fs = require('fs');
    this._os = require('os');
    this._path = require('path');

    this._dirName = this._GenerateName(basedir);
    if (!this._MakeDir(this._dirName))
        throw new Error("Can't create temporary directory");
};
GLTFViewer.Utils.TempDir.prototype = Object.create(null, {
    // properties
    constructor: { value: GLTFViewer.Utils.TempDir },
    // private members
    _fs: { writable: true, value: null },
    _os: { writable: true, value: null },
    _path: { writable: true, value: null },
    _dirName: { writable: true, value: null },
    // public members
    name: {
        get: function () {
            return this._dirName;
        }
    },
    // private methods
    _GenerateName: {
        value: function (basedir) {
            var today = new Date();
            return this._path.join(basedir ? basedir : this._os.tmpdir(), "AnsysViewer_" + process.pid + "_" + today.getYear() + "_" + today.getMonth() + "_" + today.getDay() + "_" + today.getHours() + "_" + today.getMinutes() + "_" + today.getSeconds() + "_" + today.getMilliseconds() + "_" + parseInt(Math.random() * 10000));
        }
    },
    _MakeDir: {
        value: function (dirName) {
            this._fs.mkdirSync(dirName, parseInt('0700', 8));
            if (this._fs.existsSync(dirName))
                return true;
            return false;
        }
    },
    // public methods
    FindFile: {
        value: function (pattern) {
            if (this._fs.existsSync(this._dirName)) {
                var files = this._fs.readdirSync(this._dirName);
                for (var i = 0; i < files.length; ++i) {
                    var file = files[i];
                    var curName = this._path.join(this._dirName, file);
                    if (this._fs.lstatSync(curName).isFile() && file.match(pattern))
                        return curName;
                }
            }
            return null;
        }
    },
    FindAllFiles: {
        value: function (pattern) {
            var retVal = [];
            if (this._fs.existsSync(this._dirName)) {
                var files = this._fs.readdirSync(this._dirName);
                for (var i = 0; i < files.length; ++i) {
                    var file = files[i];
                    var curName = this._path.join(this._dirName, file);
                    if (this._fs.lstatSync(curName).isFile() && file.match(pattern))
                        retVal.push(curName);
                }
            }
            return retVal;
        }
    },
    Remove: {
        value: function (dirName) {
            if (GLTFViewer.Utils.IsNull(dirName))
                dirName = this._dirName;
            if (this._fs.existsSync(dirName)) {
                this._fs.readdirSync(dirName).forEach((function (file, index) {
                    var curDir = this._path.join(dirName, file);
                    if (this._fs.lstatSync(curDir).isDirectory())
                        this.Remove(curDir);
                    else
                        this._fs.unlinkSync(curDir);
                }).bind(this));
                this._fs.rmdirSync(dirName);
            }
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Touch = function (id, t, x, y) {
    this._id = id;
    this._start = new GLTFViewer.Utils.Touch.Entry(t, x, y);
    this._previous = new GLTFViewer.Utils.Touch.Entry(t, x, y);
    this._last = new GLTFViewer.Utils.Touch.Entry(t, x, y);
};
GLTFViewer.Utils.Touch.prototype = Object.create(null, {
    constructor: { value: GLTFViewer.Utils.Touch },
    // private members
    _id: { writable: true, value: null },
    _start: { writable: true, value: null },
    _previous: { writable: true, value: null },
    _last: { writable: true, value: null },
    _distance2: { writable: true, value: 0 },
    _time: { writable: true, value: 0 },
    // public methods
    Reset: {
        value: function () {
        }
    },
    Clear: {
        value: function () {
            GLTFViewer.Utils.Touch.prototype.Reset.call(this);
            this._id = null;
            this._start = null;
            this._previous = null;
            this._last = null;
        }
    },
    Update: {
        value: function (t, x, y) {
            this._previous.Set(this._last);
            this._last.Set(t, x, y);
            // check for movement;
            var dx = this._last.x - this._start.x;
            var dy = this._last.y - this._start.y;
            var dd = dx * dx + dy * dy;
            if (dd > this._distance2)
                this._distance2 = dd;
            // check time
            var dt = this._last.t - this._start.t;
            if (dt > this._time)
                this._time = dt;
        }
    },
    GetID: {
        value: function () {
            return this._id;
        }
    },
    GetStartLocation: {
        value: function () {
            if (!this._start)
                return null;
            return { t: this._start.t, x: this._start.x, y: this._start.y };
        }
    },
    GetLastLocation: {
        value: function () {
            if (!this._last)
                return null;
            return { t: this._last.t, x: this._last.x, y: this._last.y };
        }
    },
    GetPreviousLocation: {
        value: function () {
            if (!this._previous)
                return null;
            return { t: this._previous.t, x: this._previous.x, y: this._previous.y };
        }
    },
    GetElapsedTime: {
        value: function () {
            return this._time;
        }
    },
    GetDistanceMoved2: {
        value: function () {
            return this._distance2;
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.Touch, {
    TouchStart: { value: 1 },
    TouchMove: { value: 2 },
    TouchEnd: { value: 3 },
    MouseDown: { value: 4 },
    MouseMove: { value: 5 },
    MouseUp: { value: 6 }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Touch.Entry = function (t, x, y) {
    this.Set(t, x, y);
};
GLTFViewer.Utils.Touch.Entry.prototype = Object.create(null, {
    constructor: { value: GLTFViewer.Utils.Touch.Entry },
    x: { writable: true, value: 0 },
    y: { writable: true, value: 0 },
    t: { writable: true, value: 0 },
    // public methods
    Set: {
        value: function (t, x, y) {
            if (t instanceof GLTFViewer.Utils.Touch.Entry) {
                this.t = t.t;
                this.x = t.x;
                this.y = t.y;
//            } else if (typeof t === "undefined") {
//                this.t = 0;
//                this.x = 0;
//                this.y = 0;
            } else {
                this.t = t;
                this.x = x;
                this.y = y;
            }
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Touch.List = function (element, debugTouch) {
    this._touches = [];
    this._element = element;
    if (debugTouch)
        this._debugTouch = true;
};
GLTFViewer.Utils.Touch.List.prototype = Object.create(null, {
    constructor: { value: GLTFViewer.Utils.Touch.List },
    // private members
    _touches: { writable: true, value: null },
    _debugTouch: { writable: true, value: false },
    _element: { writable: true, value: null },
    // public methods
    Count: {
        value: function () {
            return this._touches.length;
        }
    },
    GetTouchById: {
        value: function (id) {
            if (!GLTFViewer.Utils.IsNull(id)) {
                for (var i = 0; i < this.Count(); ++i) {
                    if (this._touches[i].GetID() === id)
                        return this._touches[i];
                }
            }
            return null;
        }
    },
    GetIndexById: {
        value: function (id) {
            if (!GLTFViewer.Utils.IsNull(id)) {
                for (var i = 0; i < this.Count(); ++i) {
                    if (this._touches[i].GetID() === id)
                        return i;
                }
            }
            return -1;
        }
    },
    GetTouchByIndex: {
        value: function (index) {
            if (index < this.Count())
                return this._touches[index];
            return null;
        }
    },
    AddTouch: {
        value: function (id, t, x, y) {
            if (this.GetTouchById(id)) {
                GLTFViewer.Utils.WriteErr("ERROR(Touch.List.AddTouch): 'id' already defined");
                return false;
            }
            var touch = new GLTFViewer.Utils.Touch(id, t, x, y);
            this._touches.push(touch);
            return true;
        }
    },
    RemoveTouchById: {
        value: function (id) {
            var index = this.GetIndexById(id);
            if (index < 0)
                return false;
            this._touches.splice(index, 1);
            return true;
        }
    },
    UpdateTouchById: {
        value: function (id, t, x, y) {
            var touch = this.GetTouchById(id);
            if (!touch)
                return false;
            touch.Update(t, x, y);
            return true;
        }
    },
    Touches: {
        value: function (e, s) {
            var touches = [];
            if (e.touches)
                touches = e.touches;
            else if (e.pointerId)
                touches = [e];
            else {
                // probably mouse
                var mouseButtons = [1, 4, 2];
                var buttons = 0;
                for (var i = 0; i < this.Count(); ++i) {
                    var touch = this.GetTouchByIndex(i);
                    buttons = buttons | touch.GetID();
                }
                if (s === GLTFViewer.Utils.Touch.MouseDown || s === GLTFViewer.Utils.Touch.TouchStart) {
                    // add e.button
                    buttons = buttons | mouseButtons[e.button];
                } else if (s === GLTFViewer.Utils.Touch.MouseUp || s === GLTFViewer.Utils.Touch.TouchEnd) {
                    // remove e.button
                    buttons = buttons & ~mouseButtons[e.button];                    
                } 
                for (var i = 0; i < mouseButtons.length; ++i) {
                    if (buttons & mouseButtons[i])
                        touches.push({ timeStamp: e.timeStamp, clientX: e.clientX, clientY: e.clientY, mouseId: mouseButtons[i] });
                }
            }
            return touches;
        }
    },
    Update: {
        value: function (e, s) {
            var touches = this.Touches(e, s);

            function GetID(touch) {
                if (typeof touch.identifier != "undefined") return touch.identifier;
                if (typeof touch.pointerId != "undefined") return touch.pointerId;
                if (typeof touch.mouseId != "undefined") return touch.mouseId;
                return 0;
            }

            // remove
            // turn touches into map
            var touchMap = {};
            for (var i = 0; i < touches.length; i++) {
                var touch = touches[i];
                var id = GetID(touch);
                touchMap[id] = touch;
            }
            var ts = [];
            for (var i = 0; i < this.Count();) {
                var touch = this.GetTouchByIndex(i);
                var id = touch.GetID();
                if (GLTFViewer.Utils.IsNull(touchMap[id])) {
                    if (this.RemoveTouchById(id)) {
                        ts.push(touch);
                        if (e.pointerType && e.pointerType !== "mouse" && this._element.setPointerCapture)
                            this._element.releasePointerCapture(id);
                    }
                } else 
                    ++i;
            }

            // add/update
            for (var i = 0; i < touches.length; i++) {
                var touch = touches[i];
                var xy = GLTFViewer.Utils.GetClientXY(this._element[0], touch);
                var id = GetID(touch);
                if (this.GetTouchById(id)) {
                    // update
                    this.UpdateTouchById(id, xy.t, xy.x, xy.y);
                } else {
                    // add
                    if (this.AddTouch(id, xy.t, xy.x, xy.y)) {
                        if (e.pointerType && e.pointerType !== "mouse" && this._element.setPointerCapture)
                            this._element.setPointerCapture(id);
                    }
                }
            }

            return ts.length ? ts : null;
        }
    },
    // Average location of touches (center)
    GetStartLocation: {
        value: function (numTouchesToUse) {
            var n = this.Count();
            if (n < 1) return null;
            if (!numTouchesToUse) numTouchesToUse = 2;
            if (numTouchesToUse > n) numTouchesToUse = n;
            var v = { t: 0, x: 0, y: 0 };
            for (var i = 0; i < numTouchesToUse; ++i) {
                var t = this._touches[i].GetStartLocation();
                v.t += t.t;
                v.x += t.x;
                v.y += t.y;
            }
            v.t /= numTouchesToUse;
            v.x /= numTouchesToUse;
            v.y /= numTouchesToUse;
            return v;
        }
    },
    GetPreviousLocation: {
        value: function (numTouchesToUse) {
            var n = this.Count();
            if (n < 1) return null;
            if (!numTouchesToUse) numTouchesToUse = 2;
            if (numTouchesToUse > n) numTouchesToUse = n;
            var v = { t: 0, x: 0, y: 0 };
            for (var i = 0; i < numTouchesToUse; ++i) {
                var t = this._touches[i].GetPreviousLocation();
                v.t += t.t;
                v.x += t.x;
                v.y += t.y;
            }
            v.t /= numTouchesToUse;
            v.x /= numTouchesToUse;
            v.y /= numTouchesToUse;
            return v;
        }
    },
    GetLastLocation: {
        value: function (numTouchesToUse) {
            var n = this.Count();
            if (n < 1) return null;
            if (!numTouchesToUse) numTouchesToUse = 2;
            if (numTouchesToUse > n) numTouchesToUse = n;
            var v = { t: 0, x: 0, y: 0 };
            for (var i = 0; i < numTouchesToUse; ++i) {
                var t = this._touches[i].GetLastLocation();
                v.t += t.t;
                v.x += t.x;
                v.y += t.y;
            }
            v.t /= numTouchesToUse;
            v.x /= numTouchesToUse;
            v.y /= numTouchesToUse;
            return v;
        }
    },
    GetStartDelta: {
        value: function (numTouchesToUse) {
            var n = this.Count();
            if (n < 1) return null;
            if (!numTouchesToUse) numTouchesToUse = 2;
            if (numTouchesToUse > n) numTouchesToUse = n;
            var s = this.GetStartLocation(numTouchesToUse);
            var l = this.GetLastLocation(numTouchesToUse);
            return { t: l.t, x: l.x - s.x, y: l.y - s.y };
        }
    },
    GetLastDelta: {
        value: function (numTouchesToUse) {
            var n = this.Count();
            if (n < 1) return null;
            if (!numTouchesToUse) numTouchesToUse = 2;
            if (numTouchesToUse > n) numTouchesToUse = n;
            var p = this.GetPreviousLocation(numTouchesToUse);
            var l = this.GetLastLocation(numTouchesToUse);
            return { t: l.t, x: l.x - p.x, y: l.y - p.y };
        }
    },
    // Average separation of touches (diameter)
    GetStartSeparation: {
        value: function (numTouchesToUse) {
            var n = this.Count();
            if (n < 1) return 0;
            if (!numTouchesToUse) numTouchesToUse = 2;
            if (numTouchesToUse > n) numTouchesToUse = n;
            var center = this.GetStartLocation(numTouchesToUse);
            var r = 0;
            for (var i = 0; i < numTouchesToUse; ++i) {
                var t = this._touches[i].GetStartLocation();
                var dx = t.x - center.x;
                var dy = t.y - center.y;
                r += Math.sqrt(dx * dx + dy * dy);
            }
            return 2 * r / numTouchesToUse;
        }
    },
    GetPreviousSeparation: {
        value: function (numTouchesToUse) {
            var n = this.Count();
            if (n < 1) return 0;
            if (!numTouchesToUse) numTouchesToUse = 2;
            if (numTouchesToUse > n) numTouchesToUse = n;
            var center = this.GetPreviousLocation(numTouchesToUse);
            var r = 0;
            for (var i = 0; i < numTouchesToUse; ++i) {
                var t = this._touches[i].GetPreviousLocation();
                var dx = t.x - center.x;
                var dy = t.y - center.y;
                r += Math.sqrt(dx * dx + dy * dy);
            }
            return 2 * r / numTouchesToUse;
        }
    },
    GetLastSeparation: {
        value: function (numTouchesToUse) {
            var n = this.Count();
            if (n < 1) return 0;
            if (!numTouchesToUse) numTouchesToUse = 2;
            if (numTouchesToUse > n) numTouchesToUse = n;
            var center = this.GetLastLocation(numTouchesToUse);
            var r = 0;
            for (var i = 0; i < numTouchesToUse; ++i) {
                var t = this._touches[i].GetLastLocation();
                var dx = t.x - center.x;
                var dy = t.y - center.y;
                r += Math.sqrt(dx * dx + dy * dy);
            }
            return 2 * r / numTouchesToUse;
        }
    },
    // returns maximum time down by given touches
    GetElapsedTime: {
        value: function (numTouchesToUse) {
            var n = this.Count();
            if (n < 1) return 0;
            if (!numTouchesToUse) numTouchesToUse = 2;
            if (numTouchesToUse > n) numTouchesToUse = n;
            var v = this._touches[0].GetElapsedTime();
            for (var i = 1; i < numTouchesToUse; ++i) {
                var t = this._touches[i].GetElapsedTime();
                if (t > v) v = t;
            }
            return v;
        }
    },
    // returns maximum distance moved by given touches
    GetDistanceMoved2: {
        value: function (numTouchesToUse) {
            var n = this.Count();
            if (n < 1) return 0;
            if (!numTouchesToUse) numTouchesToUse = 2;
            if (numTouchesToUse > n) numTouchesToUse = n;
            var v = this._touches[0].GetDistanceMoved2();
            for (var i = 1; i < numTouchesToUse; ++i) {
                var t = this._touches[i].GetDistanceMoved2();
                if (t > v) v = t;
            }
            return v;
        }
    },
    Reset: {
        value: function () {
            this._touches = [];
        }
    },
    Clear: {
        value: function () {
            GLTFViewer.Utils.Touch.List.prototype.Reset.call(this);
            this._touches = null;            
            this._element = null;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.TouchHandler = function(viewer, element, start, move, finish, wheel, over, out, blur, context, debugTouch) {
    if (!element)
        return;
    var _this = this;
    this._viewer = viewer;
    this._document = viewer ? viewer.document : document;
    this._isMobile = viewer ? viewer.mobile : false;
    this._moveTolerance2 = this._isMobile ? 64 : 9;
    this._element = element;
    this._Start = start;
    this._Move = move;
    this._Finish = finish;
    this._Wheel = wheel;
    this._Over = over;
    this._Out = out;
    this._Blur = blur;
    this._Context = context;
    this._debugTouch = debugTouch;

    this._touches = new GLTFViewer.Utils.Touch.List(this._element, this._debugTouch);

    this._MouseOver = function (e) {
        _this._ContainerMouseOver(e);
    };
    this._MouseOut = function (e) {
        _this._ContainerMouseOut(e);
    };
    this._MouseWheel = function (e) {
        _this._ContainerMouseWheel(e);
    };
    this._MouseDown = function (e) {
        if (!_this._ContainerTouchStart(GLTFViewer.Utils.Touch.MouseDown, e))
            return;
        // capture mouse
        _this._element[0].removeEventListener('mousemove', _this._MouseMove);
        _this._document.addEventListener('mousemove', _this._MouseMove, true);
        _this._document.addEventListener('mouseup', _this._MouseUp, true);
    };
    this._TouchStart = function (e) {
        // going to put some code here to try to catch double tap or more and pass to OS
        if (!this._timer)
            this._timer = setTimeout((function(){this._timer = 0;}).bind(this), 600);
        else
            return;
        if (!_this._ContainerTouchStart(GLTFViewer.Utils.Touch.TouchStart, e))
            return;
        // capture touch/pointer
        if (_this._debugTouch) {
            _this._element[0].removeEventListener('mousemove', _this._TouchMove);
            _this._document.addEventListener('mousemove', _this._TouchMove, true);
            _this._document.addEventListener('mouseup', _this._TouchEnd, true);
        } else if (window.navigator.pointerEnabled) {
            _this._document.addEventListener('pointermove', _this._TouchMove, false);
            _this._document.addEventListener('pointerup', _this._TouchEnd, false);
            _this._document.addEventListener('pointercancel', _this._TouchEnd, false);
        } else {
            _this._document.addEventListener('touchmove', _this._TouchMove, false);
            _this._document.addEventListener('touchend', _this._TouchEnd, false);
            _this._document.addEventListener('touchcancel', _this._TouchEnd, false);
        }
    };
    this._MouseMove = function (e) {
        _this._ContainerTouchMove(GLTFViewer.Utils.Touch.MouseMove, e);
    };
    this._TouchMove = function (e) {
        _this._ContainerTouchMove(GLTFViewer.Utils.Touch.TouchMove, e);
    };
    this._MouseUp = function (e) {
        if (!_this._ContainerTouchEnd(GLTFViewer.Utils.Touch.MouseUp, e))
            return;
        // release mouse
        _this._document.removeEventListener('mousemove', _this._MouseMove, true);
        _this._document.removeEventListener('mouseup', _this._MouseUp, true);
        _this._element[0].addEventListener('mousemove', _this._MouseMove, false);
    };
    this._TouchEnd = function (e) {
        if (!_this._ContainerTouchEnd(GLTFViewer.Utils.Touch.TouchEnd, e))
            return;
        // release touch/pointer
        if (_this._debugTouch) {
            _this._document.removeEventListener('mousemove', _this._TouchMove, true);
            _this._document.removeEventListener('mouseup', _this._TouchEnd, true);
            _this._element[0].addEventListener('mousemove', _this._TouchMove, false);
        } else if (window.navigator.pointerEnabled) {
            _this._document.removeEventListener('pointermove', _this._TouchMove, false);
            _this._document.removeEventListener('pointerup', _this._TouchEnd, false);
            _this._document.removeEventListener('pointercancel', _this._TouchEnd, false);
        } else {
            _this._document.removeEventListener('touchmove', _this._TouchMove, false);
            _this._document.removeEventListener('touchend', _this._TouchEnd, false);
            _this._document.removeEventListener('touchcancel', _this._TouchEnd, false);
        }
    };

    if (this._debugTouch) {
        this._element[0].addEventListener('mousedown', this._TouchStart, false);
        this._element[0].addEventListener('mousemove', this._TouchMove, false);
    } else {
        this._element[0].addEventListener('mousedown', this._MouseDown, false);
        this._element[0].addEventListener('mousemove', this._MouseMove, false);
        this._element[0].addEventListener('mouseover', this._MouseOver, false);
        this._element[0].addEventListener('mouseout', this._MouseOut, false);
        this._element[0].addEventListener('mousewheel', this._MouseWheel, false);
        this._element[0].addEventListener('DOMMouseScroll', this._MouseWheel, false); // firefox
        if (window.navigator.pointerEnabled)
            this._element[0].addEventListener('pointerdown', this._TouchStart, false);
        else
            this._element[0].addEventListener('touchstart', this._TouchStart, false);
    }

    this._ElementBlur = function (e) {
        _this._ContainerBlur(e);
    };
    this._element[0].addEventListener("blur", this._ElementBlur, false);

    this._ElementContext = function (e) {
        _this._ContainerContext(e);
    };
    this._element[0].addEventListener("contextmenu", this._ElementContext, false);

    this._ElementSelectStart = function (e) {
            //e.preventDefault();
            e.stopPropagation();
    };
    this._element[0].addEventListener("selectstart", this._ElementSelectStart, false);
};
GLTFViewer.Utils.TouchHandler.prototype = Object.create(null, {
    // private members
    _isMobile: { writable: true, value: false },
    _moveTolerance2: { writable: true, value: 9 },
    _timer: { writable: true, value: 0 },
    _viewer: { writable: true, value: null },
    _element: { writable: true, value: null },
    _Start: { writable: true, value: null },
    _Move: { writable: true, value: null },
    _Finish: { writable: true, value: null },
    _Wheel: { writable: true, value: null },
    _Blur: { writable: true, value: null },
    _Context: { writable: true, value: null },
    _touchActive: { writable: true, value: false },
    _mouseOver: { writable: true, value: false },
    _touches: { writable: true, value: null },
    _debugTouch: { writable: true, value: false },
    _MouseMove: { writable: true, value: null },
    _MouseUp: { writable: true, value: null },
    _MouseDown: { writable: true, value: null },
    _MouseWheel: { writable: true, value: null },
    _MouseOver: { writable: true, value: null },
    _MouseOut: { writable: true, value: null },
    _TouchMove: { writable: true, value: null },
    _TouchUp: { writable: true, value: null },
    _TouchDown: { writable: true, value: null },
    _ElementBlur: { writable: true, value: null },
    _ElementContext: { writable: true, value: null },
    _ElementSelectStart: { writable: true, value: null },
    _longTouchTmrId: { writable: true, value: null },
    _longTouch: { writable: true, value: null },
    // public members
    TouchActive: {
        get: function () {
            return this._touchActive;
        }
    },
    Touches: {
        get: function () {
            return this._touches;
        }
    },
    // private methods
    _ContainerTouchStart: {
        value: function (how, e) {
            if (how === GLTFViewer.Utils.Touch.TouchStart && e.pointerType !== 'mouse')
                e.preventDefault(); // this would prevent "mousedown" event from happening
            e.stopPropagation();
            if (how === GLTFViewer.Utils.Touch.TouchStart && e.pointerType === 'mouse')
                return false;
            this._element.focus();
            this._touches.Update(e, how);
            var touchActive = this._touchActive;
            this._touchActive = true;
            if (this.Touches.Count() === 1)
                this._StartLongTouch(e);
            else 
                this.StopLongTouch();
            if (this._Start)
                setTimeout(this._Start(e), 0);
            return !touchActive;
        }
    },
    _ContainerTouchMove: {
        value: function (how, e) {
            e.preventDefault();
            e.stopPropagation();
            if (how === GLTFViewer.Utils.Touch.TouchMove && e.pointerType === 'mouse')
                return false;
            this._touches.Update(e, how);
            if (this.Touches.GetDistanceMoved2() >= this._moveTolerance2)
                this.StopLongTouch();
            if (this._Move)
                setTimeout(this._Move(e), 0);
            return true;
        }
    },
    _ContainerTouchEnd: {
        value: function (how, e) {
            e.preventDefault();
            e.stopPropagation();
            if (how === GLTFViewer.Utils.Touch.TouchEnd && e.pointerType === 'mouse')
                return false;
            var touches = this._touches.Update(e, how);
            var didLongTouch = (this._longTouch && this.Touches.Count() === 0);
            if (didLongTouch)
                this._ContainerContext(this._longTouch);
            if (this._Finish && !GLTFViewer.Utils.IsNull(touches))
                setTimeout(this._Finish(e, touches, didLongTouch), 0);
            this.StopLongTouch();
            this._touchActive = (this._touches.Count() !== 0);
            return !this._touchActive;
        }
    },
    _ContainerBlur: {
        value: function (e) {
//            this.keysDown = {};
//            this._touches.Reset();
//            this._touchActive = false;
            if (this._Blur)
                setTimeout(this._Blur(e), 0);
        }
    },
    _ContainerContext: {
        value: function (e) {
            if (this._viewer)
                this._viewer.CloseContextMenus();
            if (this._Context)
                setTimeout(this._Context(e), 0);
            else {
                e.preventDefault();
                e.stopPropagation();
            }
        }
    },
    _ContainerMouseWheel: {
        value: function (e) {
            e.preventDefault();
            e.stopPropagation();
            var delta = 0;
            if (e.wheelDelta) // WebKit / Opera / Explorer 9
                delta = e.wheelDelta;
            else if (e.detail) // Firefox
                delta = -e.detail;
            var xy = GLTFViewer.Utils.GetClientXY(this._element[0], e);
            if (this._Wheel)
                setTimeout(this._Wheel(e, xy, delta), 0);
        }
    },
    _ContainerMouseOver: {
        value: function (e) {
            if (!this._touchActive && this._Over)
                setTimeout(this._Over(e), 0);
        }
    },
    _ContainerMouseOut: {
        value: function (e) {
            if (!this._touchActive && this._Out)
                setTimeout(this._Out(e), 0);
        }
    },
    _StartLongTouch: {
        value: function (e) {
            function CallBack(e) {
                this._longTouchTmrId = null;
                this._longTouch = e;
            }
            this.StopLongTouch();
            if (this._isMobile)
                this._longTouchTmrId = setTimeout(CallBack.bind(this, e), 750);
        }
    },
    // public members
    StopLongTouch: {
        value: function () {
            if (this._longTouchTmrId) {
                clearTimeout(this._longTouchTmrId);
                this._longTouchTmrId = null;
            }
            this._longTouch = null;
        }
    },
    Clear: {
        value: function () {
            this.StopLongTouch();
            if (this._element) {
                if (this._debugTouch) {
                    this._element[0].removeEventListener('mousedown', this._TouchStart, false);
                    this._element[0].removeEventListener('mousemove', this._TouchMove, false);
                    this._document.removeEventListener('mousemove', this._TouchMove, true);
                    this._document.removeEventListener('mouseup', this._TouchEnd, true);
                } else {
                    this._element[0].removeEventListener('mousedown', this._MouseDown, false);
                    this._element[0].removeEventListener('mousemove', this._MouseMove, false);
                    this._element[0].removeEventListener('mouseover', this._MouseOver, false);
                    this._element[0].removeEventListener('mouseout', this._MouseOut, false);
                    this._element[0].removeEventListener('mousewheel', this._MouseWheel, false);
                    this._element[0].removeEventListener('DOMMouseScroll', this._MouseWheel, false);
                    this._document.removeEventListener('mousemove', this._MouseMove, true);
                    this._document.removeEventListener('mouseup', this._MouseUp, true);
                    if (window.navigator.pointerEnabled) {
                        this._element[0].removeEventListener('pointerdown', this._TouchStart, false);
                        this._document.removeEventListener('pointermove', this._TouchMove, false);
                        this._document.removeEventListener('pointerup', this._TouchEnd, false);
                        this._document.removeEventListener('pointercancel', this._TouchEnd, false);
                    } else {
                        this._element[0].removeEventListener('touchstart', this._TouchStart, false);
                        this._document.removeEventListener('touchmove', this._TouchMove, false);
                        this._document.removeEventListener('touchend', this._TouchEnd, false);
                        this._document.removeEventListener('touchcancel', this._TouchEnd, false);
                    }
                }
                this._element[0].removeEventListener("blur", this._ElementBlur, false);
                this._element[0].removeEventListener("contextmenu", this._ElementContext, false);
                this._element[0].removeEventListener("selectstart", this._ElementSelectStart, false);
            }

            this._viewer = null;
            this._element = null;
            this._Start = null;
            this._Move = null;
            this._Finish = null;
            this._Wheel = null;
            this._Over = null;
            this._Out = null;
            this._Blur = null;
            this._Context = null;
            if (this._touches) {
                this._touches.Clear();
                this._touches = null;
            }
            this._MouseMove = null;
            this._MouseUp = null;
            this._MouseDown = null;
            this._MouseWheel = null;
            this._MouseOver = null;
            this._MouseOut = null;
            this._TouchMove = null;
            this._TouchUp = null;
            this._TouchDown = null;
            this._ElementBlur = null;
            this._ElementContext = null;
            this._ElementSelectStart = null;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.SimpleContextMenu = function(viewer, parent, menuItemList, menuHelpList, callback, parentContext) {
    // find longest label
    function longestLabel(list) {
        var width = 0;
        var body = $("body");
        for (var i = 0; i < list.length; ++i) {
            var label = list[i];
            var hasSubmenu = false;
            if (label instanceof Array) {
                label = label[0];
                hasSubmenu = true;
            }
            if (label === "-")
                continue;
            // FF32 requires this to be inside loop, IE, Opera, Chrome, FF64, could have it outside loop and just set innerText
            body.append("<label style='font-size:12px;font-family:Segoe UI,Arial,Helvetica,sans-serif;top:-100px;'>" + label + ":</label>");
            var lab = $("label", body).last();
            var labelWidth = lab.width() + (hasSubmenu ? 10 : 0);
            lab.remove();

            width = Math.max(width, labelWidth);
        }

        return width;
    }

    var width = longestLabel(menuItemList) + 10;

    $(parent).append("<div class='AVDontPrint AVContextMenu' style='overflow:auto;display:none;position:fixed;z-index:99997;padding:1px 5px 5px 5px;width:" + width + "px;background-color:#efefff;border:solid 1px #98A8A9;box-shadow:3px 3px 3px rgba(100, 100, 100, 0.5);'></div>");
    this._contextMenu = $("div", parent).last();
    GLTFViewer.Utils.NoContext(viewer, this._contextMenu);

    this._parentContext = parentContext;
    this._items = [];

    this._contextMenu.append("<ul class='AVContextMenu' style='list-style:none;margin:0;padding:0;'></ul>");
    var ul = $("ul", this._contextMenu).last();
    var curYLoc = 5;
    var curXLoc = width + 10 - 8;
    for (var i = 0; i < menuItemList.length; ++i) {
        var label = menuItemList[i];
        var help = menuHelpList ? menuHelpList[i] : null;
        var subMenu = null;
        if (label instanceof Array) {
             function callback2(elemText, idx, callback, text, other) {
                text.push(elemText);
                text.push(idx);
                callback(text, other);
             }
            var itemList = label.slice(0);
            var text = itemList[0];
            itemList.splice(0, 1);

            var helpList = null;
            if (help instanceof Array)
                helpList = help.slice(1);
            subMenu = new GLTFViewer.Utils.SimpleContextMenu(viewer, parent, itemList, helpList, callback2.bind(this, text, i, callback), this);

            label = label[0];
        }
        ul.append("<li class='AVContextMenu' style='display:block;margin-bottom:4px;nowrap;'></li>");
        var li = $("li", ul).last();

        if (label === "-") {
            li.append("<div class='AVContextMenu' style='padding-left:5px;padding-right:5px;background:transparent;margin:0;border-bottom:1px solid black;'></div>");
            curXLoc += 5;
            continue;
        }

        this._items.push(li);
        li.append("<div class='AVContextMenu'></div>");
        var div = $('div', li).last();
        div.append("<label class='AVContextMenu' style='display:block;padding:4px 0 0 0;font-size:12px;font-family:Segoe UI,Arial,Helvetica,sans-serif;text-decoration:none;'></label>");
        var lab = $('label', div).last();
        lab.text(label);
        if (typeof help === 'string')
            lab.prop("title", help);
        if (subMenu)
            lab.append("<img class='AVContextMenu' src='" + viewer.imageDir + "closed.png' style='float:right;margin-top:4px;color:black;'></img>");
        li.__contextMenu__ = subMenu;
        li.__XOffset__ = curXLoc;
        li.__YOffset__ = curYLoc;
        curYLoc += 24;
        lab.hover((function (elem, lab, e) {
            if (GLTFViewer.GetElementEnable(elem)) {
                lab.css('color', '#3398DA');
                lab.css('cursor', 'pointer');
                var offset = lab.offset();
                if (elem.__contextMenu__) {
                    if (!GLTFViewer.GetElementVisible(elem.__contextMenu__._contextMenu)) {
                        this.CloseSubMenus();
                        e.clientX = elem.__XOffset__;
                        e.clientY = elem.__YOffset__;
                        elem.__contextMenu__.Show(3, e, null, this._other);
                    }
                } else
                   this .CloseSubMenus();
            } else
               this .CloseSubMenus();
        }).bind(this, li, lab), (function (elem, lab, e) {
            lab.css('color', 'black');
            lab.css('cursor', '');
        }).bind(this, li, lab));
        lab.bind("click", (function(idx, elem, e) {
            e.preventDefault();
            e.stopPropagation();
            if (GLTFViewer.GetElementEnable(elem)) {
                if (!elem.__contextMenu__) {
                    if (this._parentContext)
                        this._parentContext.Show(false);
                    else
                        this.Show(false);
                    callback([elem.text(), idx], this._other);
                    this._other = null;
                }
            }
        }).bind(this, i, li));
    }
    this._contextMenu.bind("click", (function(e) {
        e.preventDefault();
        e.stopPropagation();
    }).bind(this));
    if (!this._parentContext) {
        $(parent).bind("mousedown pointerdown touchstart", (function(e) {
            if (GLTFViewer.GetElementVisible(this._contextMenu)) {
                var c = e && e.target ? e.target.className : "";
                if (c.indexOf("AVContextMenu") !== -1)
                    return;
                this.Show(false);
            }
        }).bind(this));
    }

    $(window).on("resize", this.Show.bind(this, false));
    $(window).on("keyup", this.Show.bind(this, false));
};
GLTFViewer.Utils.SimpleContextMenu.prototype = Object.create(null, {
    constructor: { value: GLTFViewer.Utils.SimpleContextMenu },
    // private members
    _parentContext: { writable: true, value: null },
    _contextMenu: { writable: true, value: null },
    _other: { writable: true, value: null },
    _items: { writable: true, value: null },
    // public members
    // private methods
    _PositionMenu: {
        value: function (e) {
            if (!e)
                e = window.event;
            e = GLTFViewer.Utils.GetXY(e);
            var clickCoordsX = e.clientX;
            var clickCoordsY = e.clientY;
            var menuWidth = this._contextMenu.outerWidth(true);
            var menuHeight = this._contextMenu.outerHeight(true);
            var windowWidth = $(window).outerWidth(true);
            var windowHeight = $(window).outerHeight(true);
            if (menuWidth > windowWidth) {
                this._contextMenu.css("width", windowWidth + "px");
                menuWidth = windowWidth;
            }
            if (menuHeight > windowHeight) {
                this._contextMenu.css("height", windowHeight + "px");
                menuHeight = windowHeight;
            }

            this._contextMenu.__reverseX__ = false;
            if (this._parentContext) {
                if (this._parentContext._contextMenu.__reverseX__) {
                    clickCoordsX = this._parentContext._contextMenu[0].offsetLeft - menuWidth + 2;
                    this._contextMenu.__reverseX__ = true;
                } else
                    clickCoordsX += this._parentContext._contextMenu[0].offsetLeft;
                clickCoordsY += this._parentContext._contextMenu[0].offsetTop;
            }
            if (windowWidth - clickCoordsX < menuWidth) {
                if (this._parentContext) {
                    clickCoordsX = this._parentContext._contextMenu[0].offsetLeft - menuWidth + 2;
                } else
                    clickCoordsX = windowWidth - menuWidth;
                this._contextMenu.__reverseX__ = true;
            }
            if (windowHeight - clickCoordsY < menuHeight)
                clickCoordsY = windowHeight - menuHeight;

            this._contextMenu.css("left", clickCoordsX + "px");
            this._contextMenu.css("top", clickCoordsY + "px");
        }
    },
    // private methods
    Show: {
        value: function(onoff, e, enables, other) {
            if (onoff) {
                if (onoff !== 3) {
                    for (var i = 0; i < this._items.length; ++i) {
                        var enable = false;
                        if (!GLTFViewer.Utils.IsNull(enables)) {
                            var li = this._items[i];
                            enable = enables[li.text()];
                            if (GLTFViewer.Utils.IsNull(enable))
                                enable = 0;
                            if (enable && li.__contextMenu__)
                                li.__contextMenu__.Show(2, e, enables, other);
                        }
                        GLTFViewer.SetElementEnable(this._items[i], enable);
                    }
                }
                if (onoff !== 2) {
                    this._other = other;
                    this._contextMenu.css("display", "block");
                    if (e)
                        this._PositionMenu(e);
                }
            } else {
                for (var i = 0; i < this._items.length; ++i) {
                    var li = this._items[i];
                    if (li.__contextMenu__)
                        li.__contextMenu__.Show(false);
                }
                this._contextMenu.css("display", "none");
            }
        }
    },
    CloseSubMenus: {
        value: function() {
            for (var i = 0; i < this._items.length; ++i) {
                var li = this._items[i];
                if (li.__contextMenu__ && GLTFViewer.GetElementVisible(li.__contextMenu__._contextMenu)) {
                    li.__contextMenu__.Show(false);
                    return;
                }
            }
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.MessageHandler = function(viewer) {
    this._callbacks = [];
    this._messageIDs = [];
    this._viewer = viewer;
    this._receiver = this._Receive.bind(this);

    document.addEventListener(this._viewer.containerID + "ANSYSViewer", this._receiver, false);
};
GLTFViewer.Utils.MessageHandler.prototype = Object.create(null, {
    constructor: { value: GLTFViewer.Utils.MessageHandler },
    //
    _callbacks: { writable: true, value: null },
    _messageIDs: { writable: true, value: null },
    _viewer: { writable: true, value: null },

    _Receive: {
        value: function (data) {
            var from = data.detail.from;
            var messageID = data.detail.messageID;
            var message = data.detail.message;

            for (var i = 0; i < this._callbacks.length; ++i) {
                if (this._messageIDs[i] === messageID) {
                    setTimeout(this._callbacks[i](from, messageID, message), 0);
                    break;
                }
            }
        }
    },
    AddListener: {
        value: function (messageID, callback) {
            var id = this._callbacks.length;
            
            this._messageIDs.push(messageID);
            this._callbacks.push(callback);
            
            return id;            
        }
    },
    SendMessage: {
        value: function (messageID, message) {
            var event = document.createEvent('CustomEvent');
            event.initCustomEvent(this._viewer.containerID + "ANSYSViewer", true, true, { from: this._viewer.viewportNumber, messageID: messageID, message: message });
            document.dispatchEvent(event);
        }
    },
    Clear: {
        value: function () {
            document.removeEventListener(this._viewer.containerID + "ANSYSViewer", this._receiver);

            this._messageIDs = null;
            this._callbacks = null;
            this._viewer = null;
            this._receiver = null;
        }
    },
    Reset: {
        value: function () {

        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Dialog = function(title, data, modal, applyCallback, resetCallback, showButtons, wantApply, defLeft, defTop, defWidth, defHeight) {
    var results = {};
    var imgMargin = 4;

    var body = $("body");
    this._modal = GLTFViewer.Utils.IsNull(modal) ? true : modal;
    this._curFocus = $(document.activeElement);
    this._applyCallback = applyCallback;
    var hasReset = !GLTFViewer.Utils.IsNull(resetCallback);
    var docWidth = document.body.clientWidth;
    var docHeight = document.body.clientHeight;
    
    var container = this._modal ? GLTFViewer.Utils.CreateModalShield() : null;
    if (container)
        container.css("display", "block"); // modal shield is not initially shown
    this._container = container || body;
    this._container.append("<div style='position:fixed;background:white;width:" + docWidth + "px;height:" + docHeight + "px;border:1px solid " + GLTFViewer.BORDERCOLOR + ";display:flex;display:-webkit-flex;flex-direction:column;-webkit-flex-direction:column;z-index:99996;'></div>");
    this._dialog = $("div", this._container).last();
    container = container || this._dialog;
    GLTFViewer.Utils.NoContext(null, this._dialog);

    this._inputs = {};

    function ClickFunc(button, data, container, inputs, e) {
        e.preventDefault();
        e.stopPropagation();
        this._Apply(inputs, data, button !== "Cancel");
        if (button !== "Apply") {
            container.remove();
            this._curFocus.focus();
            this._Clear();
        }
    }

    // title  TRBL
    this._dialog.append("<div style='background:linear-gradient(#34485D,#283849);'></div>");
    this._titleBar = $("div", this._dialog).last();

    this._titleBarTouchHandler = new GLTFViewer.Utils.TouchHandler(null, this._titleBar, null, this._MoveTitleBar.bind(this));

    this._titleBar.append("<p style='margin:0;padding:3px 15px;color:white;font-size:12px;font-weight:600;font-family:Segoe UI,Arial,Helvetica,sans-serif;'>" + title + "</p>");
    var size = this._titleBar.height() - 2 * imgMargin;
    var url = GLTFViewer.Utils.Dialog.GenerateCloseURL(size, "white");
    this._titleBar.append("<img src='" + url + "' title='Close' style='position:absolute;right:" + imgMargin + "px;top:" + imgMargin + "px;background:transparent;border-radius:" + (size / 2) + "px;'></img>");
    var closeImg = $("img", this._titleBar).last();
    closeImg.hover(function () {
        closeImg.css('background', GLTFViewer.HOVERCOLOR);
        closeImg.css('cursor', 'pointer');
    }, function () {
        closeImg.css('background', 'transparent');
        closeImg.css('cursor', '');
    });
    closeImg.click(ClickFunc.bind(this, "Cancel", data, container, this._inputs));
    var height = this._titleBar.height() + 2; // top and bottom border
    this._minHeight = height;
    this._minWidth = 0;

    this._dialog.append("<div style='margin:0;padding:0;border:0;overflow:auto;background:white;flex:1;-webkit-flex:1;'></div>");
    this._scroll = $("div", this._dialog).last();
    this._scroll.append("<table style='margin:0;padding:0 5px 0 5px;border:0;font-size:12px;font-family:Segoe UI,Arial,Helvetica,sans-serif;flex:1;-webkit-flex:1;'></table>");
    this._table = $("table", this._scroll).last();
    if (data) {
        // find longest label
        var len = 0;
        for (var i = 0; i < data.length; ++i) {
            var dataType = data[i][1];
            if (dataType === GLTFViewer.Utils.Dialog.DATANONE)
                continue;
            // FF32 requires this to be inside loop, IE, Opera, Chrome, FF64, could have it outside loop and just set innerText
            body.append("<label style='font-size:12px;font-family:Segoe UI,Arial,Helvetica,sans-serif;top:-100px;'>" + data[i][0] + ":</label>");
            var lab = $("label", body).last();
            var labelWidth = lab.width() + 5;
            var labelHeight = lab.height();
            lab.remove();

            if (dataType !== GLTFViewer.Utils.Dialog.DATALABEL)
                len = Math.max(len, labelWidth); // labels do not affect input location
            if (dataType === GLTFViewer.Utils.Dialog.DATALABEL || dataType === GLTFViewer.Utils.Dialog.DATACHECKBOX)
                labelHeight += 4;
            else if (dataType === GLTFViewer.Utils.Dialog.DATATEXT || dataType === GLTFViewer.Utils.Dialog.DATANUMBER || dataType === GLTFViewer.Utils.Dialog.DATANUMBERVEC || dataType === GLTFViewer.Utils.Dialog.DATAINTEGER)
                labelHeight += 6; // 5 or 6
            else if (dataType === GLTFViewer.Utils.Dialog.DATALIST)
                labelHeight += 10; // 9 or 10
            if (i === 0)
                this._minHeight += labelHeight; // show at least 1 item
        }
        //len += 5;
        this._minWidth = len + 150; // 150 is width of input 
        for (var i = 0; i < data.length; ++i) {
            this._table.append("<tr style='margin:0;padding:0;border:0;'></tr>");
            var tr = $("tr", this._table).last();
            switch (data[i][1]) {
                default:
                case GLTFViewer.Utils.Dialog.DATALABEL:
                    if (data[i][0].length)
                        tr.append("<td colspan=2><fieldset style='display:block;margin:0;padding:0;border:0;border-top:1px solid black;text-align:center;'><legend><b>" + data[i][0] + "</b></legend></fieldset></td>");
                    else
                        tr.append("<td colspan=2></td>");
                    break;
                case GLTFViewer.Utils.Dialog.DATATEXT:
                    tr.append("<td style='width:" + len + "px;'>" + data[i][0] + ":</td>");
                    tr.append("<td><input type='text' value='" + data[i][2] + "' style='width:100%;padding:0;margin:0;border:1px solid black;'></input></td>");
                    this._inputs[i] = $("input", tr).last();
                    break;
                case GLTFViewer.Utils.Dialog.DATANUMBER: // does not validate number
                    tr.append("<td style='width:" + len + "px;'>" + data[i][0] + ":</td>");
                    tr.append("<td><input type='number' value='" + data[i][2] + "' style='width:100%;padding:0;margin:0;border:1px solid black;'></input></td>");
                    this._inputs[i] = $("input", tr).last();
                    break;
                case GLTFViewer.Utils.Dialog.DATANUMBERVEC: // does not validate number
                    tr.append("<td valign='top' style='width:" + len + "px;'>" + data[i][0] + ":</td>");
                    tr.append("<td style='padding:0;margin:0;border:0;'><table style='width:100%;padding:0;margin:0;border:0;border-spacing:0;border-collapse:collapse;'></table></td>");
                    var lst = $("table", tr).last();
                    this._inputs[i] = [];
                    var n = data[i][2].length;
                    var lstR = null;
                    for (var j = 0; j < n; ++j) {
                        if ((n <= 4 && j === 0) || (n === 9 && (j % 3) === 0) || (n === 16 && (j % 4) === 0)) {
                            lst.append("<tr style='margin:0;padding:0;border:0;'></tr>");
                            lstR = $("tr", lst).last();
                        }
                        lstR.append("<td><input type='number' value='" + data[i][2][j] + "' style='width:100%;padding:0;margin:0;border:1px solid black;'></input></td>");
                        this._inputs[i].push($("input", lstR).last());
                    }
                    break;
                case GLTFViewer.Utils.Dialog.DATAINTEGER: // does not validate number
                    tr.append("<td style='width:" + len + "px;'>" + data[i][0] + ":</td>");
                    tr.append("<td><input type='number' min='0' step='1' value='" + data[i][2] + "' style='width:100%;padding:0;margin:0;border:1px solid black;'></input></td>");
                    this._inputs[i] = $("input", tr).last();
                    break;
                case GLTFViewer.Utils.Dialog.DATACHECKBOX:
                    tr.append("<td style='width:" + len + "px;'>" + data[i][0] + ":</td>");
                    tr.append("<td><input type='checkbox'" + (data[i][2] ? " checked" : "") + " style='padding:0;margin:0;border:1px solid black;'></input></td>");
                    this._inputs[i] = $("input", tr).last();
                    break;
                case GLTFViewer.Utils.Dialog.DATALIST:
                    tr.append("<td style='width:" + len + "px;'>" + data[i][0] + ":</td>");
                    tr.append("<td><select></select></td>");
                    var sel = $("select", tr).last();
                    this._inputs[i] = sel;
                    for (var j = 0; j < data[i][3].length; ++j)
                        sel.append("<option value='" + data[i][3][j] + "' " + (data[i][3][j] === data[i][2] ? 'selected=\'selected\'' : '') + " >" + data[i][3][j] + "</option>");
                    break;
            }
        }
        height += this._table.height();

        this._minWidth = this._table.width() + 20; // scrollbar width
        this._table.width("100%"); // allow it to expand if made wider
    }

    if (GLTFViewer.Utils.IsNull(showButtons) || showButtons) {
        // bottom
        var BUTTONWIDTH = 60;
        this._dialog.append("<div align='center' style='background:transparent;border:0;border-top:1px solid " + GLTFViewer.BORDERCOLOR + ";flex-direction:row;-webkit-flex-direction:row;'></div>");
        var bottom = $("div", this._dialog).last();
        var bottomRight = bottom;
        var w = 0;

        if (hasReset) {
            bottom.append("<div style='float:left;background:transparent;border:0;margin:0;padding:0;'></div>");
            var bottomLeft = $("div", bottom).last();

            // reset
            bottomLeft.append("<button type='button' style='margin:10px 5px 10px 10px;width:" + BUTTONWIDTH + "px;height:20px;background:" + GLTFViewer.BUTTONCOLOR + ";color:black;border:1px solid " + GLTFViewer.BORDERCOLOR + ";border-radius:5px;'>Reset</button>");
            var resetButton = $("button", bottomLeft).last();
            resetButton.hover(function () {
                resetButton.css('border-color', GLTFViewer.HOVERCOLOR);
                resetButton.css('cursor', 'pointer');
            }, function () {
                resetButton.css('border-color', GLTFViewer.BORDERCOLOR);
                resetButton.css('cursor', '');
            });
            resetButton.click((function (callback, e) {
                callback(this._Reset.bind(this));
            }).bind(this, resetCallback));
            w += BUTTONWIDTH + 15; // LR margin is 5

            if (GLTFViewer.Utils.IsNull(wantApply) || wantApply) {
                var n = Object.keys(this._inputs).length;
                if (n > 1) {
                    // apply
                    bottomLeft.append("<button type='button' style='margin:10px 5px 10px 5px;width:" + BUTTONWIDTH + "px;height:20px;background:" + GLTFViewer.BUTTONCOLOR + ";color:black;border:1px solid " + GLTFViewer.BORDERCOLOR + ";border-radius:5px;'>Apply</button>");
                    var applyButton = $("button", bottomLeft).last();
                    applyButton.hover(function () {
                        applyButton.css('border-color', GLTFViewer.HOVERCOLOR);
                        applyButton.css('cursor', 'pointer');
                    }, function () {
                        applyButton.css('border-color', GLTFViewer.BORDERCOLOR);
                        applyButton.css('cursor', '');
                    });
                    applyButton.click(ClickFunc.bind(this, "Apply", data, container, this._inputs));
                    w += BUTTONWIDTH + 10; // LR margin is 5
                }
            }

            bottom.append("<div style='float:right;background:transparent;border:0;margin:0;padding:0;'></div>");
            bottomRight = $("div", bottom).last();
        }

        // ok
        bottomRight.append("<button type='button' style='margin:10px 5px 10px 5px;width:" + BUTTONWIDTH + "px;height:20px;background:" + GLTFViewer.BUTTONCOLOR + ";color:black;border:1px solid " + GLTFViewer.BORDERCOLOR + ";border-radius:5px;'>OK</button>");
        var okButton = $("button", bottomRight).last();
        okButton.hover(function () {
            okButton.css('border-color', GLTFViewer.HOVERCOLOR);
            okButton.css('cursor', 'pointer');
        }, function () {
            okButton.css('border-color', GLTFViewer.BORDERCOLOR);
            okButton.css('cursor', '');
        });
        okButton.click(ClickFunc.bind(this, "Ok", data, container, this._inputs));
        // cancel
        bottomRight.append("<button type='button' style='margin:10px 10px 10px 5px;width:" + BUTTONWIDTH + "px;height:20px;background:" + GLTFViewer.BUTTONCOLOR + ";color:black;border:1px solid " + GLTFViewer.BORDERCOLOR + ";border-radius:5px;'>Cancel</button>");
        var cancelButton = $("button", bottomRight).last();
        cancelButton.hover(function () {
            cancelButton.css('border-color', GLTFViewer.HOVERCOLOR);
            cancelButton.css('cursor', 'pointer');
        }, function () {
            cancelButton.css('border-color', GLTFViewer.BORDERCOLOR);
            cancelButton.css('cursor', '');
        });
        cancelButton.click(ClickFunc.bind(this, "Cancel", data, container, this._inputs));
        
        height += bottom.height() + 1;
        this._minHeight += bottom.height() + 1;
        w += 2 * (BUTTONWIDTH + 10) + 5; // LR margin is 5 + 5
        if (this._minWidth < w)
            this._minWidth = w;
    }
    if (this._minWidth < 50)
        this._minWidth = 50;

    // resize reticle
    url = GLTFViewer.Utils.Dialog.GenerateResizeURL(size, GLTFViewer.BORDERCOLOR);
    this._dialog.append("<img src='" + url + "' style='position:absolute;right:0;bottom:0;background:transparent;'></img>");
    var resizeImg = $("img", this._dialog).last();
    this._resizeTouchHandler = new GLTFViewer.Utils.TouchHandler(null, resizeImg, null, this._Resize.bind(this));

    resizeImg.hover(function () {
        $(this).css('cursor', 'nwse-resize');
    }, function () {
        $(this).css('cursor', '');
    });

    if (GLTFViewer.Utils.IsNull(defLeft))
        defLeft = Math.floor(docWidth * 0.1);
    if (GLTFViewer.Utils.IsNull(defWidth))
        defWidth = this._minWidth;
    if (defLeft + defWidth > docWidth) {
        defLeft = docWidth - defWidth;
        if (defLeft < 0) {
            defLeft = 0;
            defWidth = docWidth;
            if (defWidth < this._minWidth)
                this._minWidth = defWidth;
        }
    }

    if (GLTFViewer.Utils.IsNull(defTop))
        defTop = Math.floor(docHeight * 0.1);
    if (GLTFViewer.Utils.IsNull(defHeight))
        defHeight = height;
    if (defHeight < this._minHeight)
        defHeight = this._minHeight;
    if (defTop + defHeight > docHeight) {
        defTop = docHeight - defHeight;
        if (defTop < 0) {
            defTop = 0;
            defHeight = docHeight;
            if (defHeight < this._minHeight)
                this._minHeight = defHeight;
        }
    }

    this._dialog.css("left", defLeft + "px");
    this._dialog.css("top", defTop + "px");
    this._dialog.css("width", defWidth + "px");
    this._dialog.css("height", defHeight + "px");

    this._dialog.keypress((function (e) {
        if (e.charCode === 27)
            ClickFunc.bind(this, "Cancel", data, container, this._inputs)(e);
    }).bind(this));

    this._dialog.focus();

    this._valid = true;
};
GLTFViewer.Utils.Dialog.prototype = Object.create(null, {
    constructor: { value: GLTFViewer.Utils.Dialog },
    //
    _modal: { writable: true, value: true },
    _container: { writable: true, value: null }, // area in which to move box around
    _dialog: { writable: true, value: null }, // box to move around
    _applyCallback: { writable: true, value: null },
    _curFocus: { writable: true, value: null },
    _titleBar: { writable: true, value: null },
    _titleBarTouchHandler: { writable: true, value: null },
    _resizeTouchHandler: { writable: true, value: null },
    _valid: { writable: true, value: false },
    _minHeight: { writable: true, value: 100 },
    _minWidth: { writable: true, value: 100 },
    _table: { writable: true, value: null },
    _scroll: { writable: true, value: null },
    // private methods
    _Apply: {
        value: function (inputs, data, ok) {
            if (!this._applyCallback || !data)
                return;

            var results = [];
            for (var i = 0; i < data.length; ++i) {
                switch (data[i][1]) {
                    case GLTFViewer.Utils.Dialog.DATATEXT:
                    case GLTFViewer.Utils.Dialog.DATALIST:
                        results.push(inputs[i].val());
                        break;
                    case GLTFViewer.Utils.Dialog.DATANUMBER:
                        results.push(inputs[i].val() * 1);
                        break;
                    case GLTFViewer.Utils.Dialog.DATAINTEGER:
                        results.push(parseInt(inputs[i].val()) * 1);
                        break;
                    case GLTFViewer.Utils.Dialog.DATANUMBERVEC:
                        var res = [];
                        for (var j = 0; j < inputs[i].length; ++j)
                            res.push(inputs[i][j].val() * 1);
                        results.push(res);
                        break;
                    case GLTFViewer.Utils.Dialog.DATACHECKBOX:
                        results.push(inputs[i].prop('checked'));
                        break;
                    default:
                        results.push(null);
                        break;                            
                }
            }
            this._applyCallback(ok, results);
        }
    },
    _MoveTitleBar: {
        value: function (e) {
            var cnt = this._titleBarTouchHandler.Touches.Count();
            // no touches or mouse presses
            if (cnt === 0)
                return;
            // 1 touch or 1 mouse button pressed
            if (cnt === 1) {
                var touch = this._titleBarTouchHandler.Touches.GetTouchByIndex(0);
                var touchID = touch.GetID();
                if (touchID === 0 || touchID === 1) {
                    // move dialog
                    var t = this._titleBarTouchHandler.Touches.GetStartDelta(1);
                    var dialogWidth = this._dialog.outerWidth();
                    var dialogHeight = this._dialog.outerHeight();
                    var dialogOffset = this._dialog.offset();
                    var containerWidth = this._modal ? this._container.width() : this._container.prop("scrollWidth");
                    var containerHeight = this._modal ? this._container.height() : this._container.prop("scrollHeight");

                    var moveMargin = 20;
                    if (dialogOffset.left + t.x > containerWidth - moveMargin)
                        dialogOffset.left = containerWidth - moveMargin;
                    else if (dialogOffset.left + t.x < moveMargin - dialogWidth)
                        dialogOffset.left = moveMargin - dialogWidth;
                    else
                        dialogOffset.left += t.x;
                    if (dialogOffset.top + t.y > containerHeight - moveMargin)
                        dialogOffset.top = containerHeight - moveMargin;
                    else if (dialogOffset.top + t.y < 0)
                        dialogOffset.top = 0;
                    else
                        dialogOffset.top += t.y;
                    this._dialog.offset(dialogOffset);
                }
            }
        }
    },
    _Resize: {
        value: function (e) {
            var cnt = this._resizeTouchHandler.Touches.Count();
            // no touches or mouse presses
            if (cnt === 0)
                return;
            // 1 touch or 1 mouse button pressed
            if (cnt === 1) {
                var touch = this._resizeTouchHandler.Touches.GetTouchByIndex(0);
                var touchID = touch.GetID();
                if (touchID === 0 || touchID === 1) {
                    // resize dialog
                    var t = this._resizeTouchHandler.Touches.GetStartDelta(1);
                    var dialogWidth = this._dialog.width() + t.x;
                    var dialogHeight = this._dialog.height() + t.y;
                    if (dialogWidth < this._minWidth)
                        dialogWidth = this._minWidth;
                    if (dialogHeight < this._minHeight)
                        dialogHeight = this._minHeight;
                    this._dialog.width(dialogWidth);
                    this._dialog.height(dialogHeight);
                }
            }
        }
    },
    _Clear: {
        value: function () {
            this._valid = false;
            if (this._titleBarTouchHandler) {
                this._titleBarTouchHandler.Clear();
                this._titleBarTouchHandler = null;
            }
            if (this._resizeTouchHandler) {
                this._resizeTouchHandler.Clear();
                this._resizeTouchHandler = null;
            }
            this._container = null;
            this._dialog = null;
            this._curFocus = null;
            this._titleBar = null;
            this._table = null;
            this._scroll = null;
            this._applyCallback = null;
        }
    },
    _Reset: {
        value: function (data) {
            for (var i = 0; i < data.length; ++i) {
                switch (data[i][1]) {
                    case GLTFViewer.Utils.Dialog.DATATEXT:
                    case GLTFViewer.Utils.Dialog.DATANUMBER:
                    case GLTFViewer.Utils.Dialog.DATAINTEGER:
                    case GLTFViewer.Utils.Dialog.DATALIST:
                        this._inputs[i].val(data[i][2]);
                        break;
                    case GLTFViewer.Utils.Dialog.DATANUMBERVEC:
                        for (var j = 0; j < data[i][2].length; ++j)
                            this._inputs[i][j].val(data[i][2][j]);
                        break;
                    case GLTFViewer.Utils.Dialog.DATACHECKBOX:
                        this._inputs[i].prop("checked", data[i][2]);
                        break;
                    default:
                        break;                            
                }
            }
            this._Apply(this._inputs, data, false);
        }
    },
    // public functions
    AppendData: {
        value: function (str) {
            this._table.append("<tr style='margin:0;padding:0;border:0;'></tr>");
            var tr = $("tr", this._table).last();
            tr.append("<td>" + str + "</td>");
            this._scroll.scrollTop(this._scroll[0].scrollHeight);
        }
    }
});
Object.defineProperties(GLTFViewer.Utils.Dialog, {
    DATANONE: { value: 0 },
    DATATEXT: { value: 1 },
    DATANUMBER: { value: 2 },
    DATACHECKBOX: { value: 3 },
    DATALIST: { value: 4 },
    DATALABEL: { value: 5 },
    DATANUMBERVEC: { value: 6 },
    DATAINTEGER: { value: 7 },

    GenerateCloseURL: {
        value: function (size, color) {
            var body = $("body");
            body.append("<canvas style='position:absolute:top:-" + size + "px;left:-" + size + "px;width:" + size + "px;height:" + size + "px;background:transparent;'></canvas>");
            var canvas = $("canvas", body).last();
            canvas[0].width = canvas.width();
            canvas[0].height = canvas.height();
            var gx = canvas[0].getContext('2d');
            gx.clearRect(0, 0, size, size);
            gx.strokeStyle = color;

            var xMiddle = size / 2;
            var yMiddle = size / 2;
            var radius = size / 2;
            var halfLineLen = radius - 4;

            // circle
            gx.lineWidth = 2;
            gx.beginPath();
            gx.arc(xMiddle, yMiddle, radius, 0, 2 * Math.PI, false);
            gx.stroke();

            // x
            gx.lineWidth = 1;
            gx.beginPath();
            gx.moveTo(xMiddle + halfLineLen, yMiddle - halfLineLen);
            gx.lineTo(xMiddle - halfLineLen, yMiddle + halfLineLen);
            gx.moveTo(xMiddle - halfLineLen, yMiddle - halfLineLen);
            gx.lineTo(xMiddle + halfLineLen, yMiddle + halfLineLen);
            gx.stroke();

            var url = canvas[0].toDataURL();
            canvas.remove();
            return url;
        }
    },
    GenerateResizeURL: {
        value: function (size, color) {
            var body = $("body");
            body.append("<canvas style='position:absolute:top:-" + size + ";left:-" + size + ";width:" + size + "px;height:" + size + "px;background:transparent;'></canvas>");
            var canvas = $("canvas", body).last();
            canvas[0].width = canvas.width();
            canvas[0].height = canvas.height();
            var gx = canvas[0].getContext('2d');
            gx.clearRect(0, 0, size, size);
            gx.strokeStyle = color;

            var d = 0;
            gx.lineWidth = 2;
            gx.beginPath();
            for (var i = 0; i < 3; ++i) {
                d = i * size / 3;
                gx.moveTo(size, 0 + d);
                gx.lineTo(0 + d, size);
            }
            gx.stroke();

            var url = canvas[0].toDataURL();
            canvas.remove();
            return url;
        }
    },
    GeneratePanelResizeURL: {
        value: function (width, height, color) {
            var body = $("body");
            body.append("<canvas style='position:absolute:top:-" + height + ";left:-" + width + ";width:" + width + "px;height:" + height + "px;background:transparent;'></canvas>");
            var canvas = $("canvas", body).last();
            canvas[0].width = canvas.width();
            canvas[0].height = canvas.height();
            var gx = canvas[0].getContext('2d');
            gx.clearRect(0, 0, width, height);
            gx.strokeStyle = color;

            gx.fillStyle = "rgba(255, 255, 255, 1)";
            gx.beginPath();
            gx.moveTo(0, 0);
            gx.lineTo(0, height);
            gx.lineTo(width, height);
            gx.lineTo(width, 0);
            gx.fill();

            gx.lineWidth = 2;
            gx.beginPath();
            for (var i = 0; i <= width; i += 4) {
                gx.moveTo(i, 0);
                gx.lineTo(i, height);
            }
            gx.lineWidth = 1;
            gx.moveTo(0, 0);
            gx.lineTo(0, height);
            gx.lineTo(width, height);
            gx.lineTo(width, 0);
            gx.lineTo(0, 0);
            gx.stroke();

            var url = canvas[0].toDataURL();
            canvas.remove();
            return url;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Help = function() {
    // find where the help viewer is located, going to throw if fails
    var fs = require("fs");
    var viewerLoc = process.execPath;
    this._helpViewerLoc = GLTFViewer.Utils.ResolvePath(viewerLoc + "/../..") + "/commonfiles/help/HelpViewer/ANSYSHelpViewer.exe";

    this._BeforeUnload = (function (e) {
        this._CloseMe();
    }).bind(this);
    window.addEventListener('beforeunload', this._BeforeUnload, false); // we were closed
};
GLTFViewer.Utils.Help.prototype = Object.create(null, {
    constructor: { value: GLTFViewer.Utils.Help },
    // private members
    _helpViewerLoc: { writable: true, value: null },
    _port: { writable: true, value: null },
    _BeforeUnload: { writable: true, value: null },
    // public members
    // private methods
    _CloseMe: {
        value: function () {
            if (GLTFViewer.Utils.IsNull(this._port))
                return;
            this.Open("QUIT");
        }
    },
    _Create: {
        value: function (callback) {
            if (!GLTFViewer.Utils.IsNull(this._port)) {
                callback(this._port);
                return;
            }

            try {
                var child_process = require("child_process");
                var helpViewer = child_process.spawn(this._helpViewerLoc, ["--language", "en-us", "--sessionID", "ANSYSViewer"]);
                helpViewer.stdout.on('data', (function (callback, data) {
                    var port = parseInt(data);   
                    if (!this._port && port) {
                        this._port = port;
                        callback(this._port);
                    }
                }).bind(this, callback));
                helpViewer.on('close', (function (callback, code, signal) { // help viewer was closed
                    if (GLTFViewer.Utils.IsNull(this._port))                        
                        callback(null); // it closed without setting port
                    this._port = null;
                }).bind(this, callback));
            } catch (err) {
                callback(null); // spawn failed
            }
        }
    },
    // public methods
    Clear: {
        value: function () {
            this._CloseMe();
        }
    },
    Reset: {
        value: function () {
        }
    },
    Open: {
        value: function (page) {
            function callback(page, port) {
                if (GLTFViewer.Utils.IsNull(port))
                    return; // failed to open help

                try {
                    var net = require('net');
                    var client = net.createConnection(port, null, (function (page) { 
                        client.write(page + "\n");
                    }).bind(this, page));
                } catch (err) {
                }
            }

            this._Create(callback.bind(this, page));
        }
    }
});
// static data
Object.defineProperties(GLTFViewer.Utils.Help, {
    DATANONE: { value: 0 }
});
//
// utitilies
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// GLTFViewer.Utils.FileBaseClass
//
/** @constructor */
GLTFViewer.Utils.FileBaseClass = function(scene, fileType, data, other) {
    var gl = this._gl = scene.gl;
    this._scene = scene;
    this._navigator = scene.navigator;
    this._viewer = scene.viewer;
    this._progressBar = scene.progressBar;
    this._background = scene.background;
    this._hasLineWidthSupport = scene.lineWidthSupport;
    this._fileType = fileType;
    this._data = data;
    this._other = other;
    this._selectionMode = GLTFViewer.SELECTION_NONE;
    this._clip = new GLTFViewer.Utils.Clip(scene);
    this._hitByteData = new Uint8Array(16);
    this._hitFloatData = new Float32Array(this._hitByteData.buffer, 0, 4);
    this._sorthitTestShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.FileBaseClass._vsHitTestSort, GLTFViewer.Utils.FileBaseClass._fsHitTestSort);
    this._sortDat = new Float32Array(44);
    this._sortBuf = gl.createBuffer();
    this.CanClip = false;
    this.CanPeel = false;
    gl.bindBuffer(gl.ARRAY_BUFFER, this._sortBuf);
    gl.bufferData(gl.ARRAY_BUFFER, this._sortDat, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
};
GLTFViewer.Utils.FileBaseClass.prototype = Object.create(null, {
    constructor: { value: GLTFViewer.Utils.FileBaseClass },
    // private members
    _scene: { writable: true, value: null },
    _gl: { writable: true, value: null },
    _navigator: { writable: true, value: null },
    _viewer: { writable: true, value: null },
    _progressBar: { writable: true, value: null },
    _background: { writable: true, value: null },
    _hasLineWidthSupport: { writable: true, value: false },
    _fileType: { writable: true, value: null },
    _data: { writable: true, value: null }, // main data
    _other: { writable: true, value: null }, // other data
    _sorthitTestShader: { writable: true, value: null },
    _selectionMode: { writable: true, value: 0 },
    _selection: { writable: true, value: null },
    _width: { writable: true, value: 0 },
    _height: { writable: true, value: 0 },
    _worldBoundingBox: { writable: true, value: null },
    _hitDepthBuffer: { writable: true, value: null },
    _hitTextures: { writable: true, value: null },
    _hitFBuffers: { writable: true, value: null },
    _hitTextureCnt: { writable: true, value: 0 },
    _hitTextureWidth: { writable: true, value: 0 },
    _hitByteData: { writable: true, value: null },
    _hitFloatData: { writable: true, value: null },
    _sortBuf: { writable: true, value: null },
    _sortDat: { writable: true, value: null },
    _empty: { writable: true, value: true },
    _minSize: { writable: true, value: 1 },
    _clip: { writable: true, value: null },
    _canClip: { writable: true, value: false },
    _canPeel: { writable: true, value: false },
    _markup: { writable: true, value: null },
    _canMarkup: { writable: true, value: false },
    _canCreateViews: { writable: true, value: false },
    _canExplode: { writable: true, value: false },
    _exportFH: { writable: true, value: null },
    _exportType: { writable: true, value: null },
    _exportBuffer: { writable: true, value: null },
    _exportDataSize: { writable: true, value: 0 },
    // public members
    IsEmpty: { get: function () { return this._empty; } },
    MinSize: { get: function () { return this._minSize; } },
    Ruler: { get: function () { return null; } },
    SetExplosion: { value: function (val, update) { } },
    GetExplosion: { value: function () { return 0; } },
    CanExplode: {
        get: function () {
            return this._canExplode;
        },
        set: function (val) {
            this._canExplode = val;
            this._scene.viewer.ExplodeBtnState(null, val ? GLTFViewer.MENUSHOW : GLTFViewer.MENUHIDE);
        }
    },
    SetSelectionMode: {
        value: function (mode) {
            this._selectionMode = mode;
            this._scene.viewer.SelectionMenuBtnState(null, null, GLTFViewer.MENUUNCHECKALL);
            if (mode >= GLTFViewer.SELECTION_EDGE && mode <= GLTFViewer.SELECTION_BODY) {
                this._scene.viewer.SelectionMenuBtnState(mode, null, GLTFViewer.MENUCHECK);
                this._scene.viewer.SelectionBtnState(null, GLTFViewer.MENUICON, GLTFViewer.ICONSELECTIONEDGE + mode);
                this._scene.viewer.SelectionBtnState(null, GLTFViewer.MENUCHECK);
            } else
                this._scene.viewer.SelectionBtnState(null, GLTFViewer.MENUUNCHECK);
        }
    },
    GetSelectionMode: {
        value: function () {
            return this._selectionMode;
        }
    },
    CanPeel: {
        get: function () {
            return this._canPeel;
        },
        set: function (val) {
            this._canPeel = val;
        }
    },
    CanClip: {
        get: function () {
            return this._canClip;
        },
        set: function (val) {
            this._canClip = val;
            this._scene.viewer.ClipBtnState(null, val ? GLTFViewer.MENUSHOW : GLTFViewer.MENUHIDE);
        }
    },
    CanMarkup: {
        get: function () {
            return this._canMarkup;
        },
        set: function (val) {
            this._canMarkup = val;
            this._scene.viewer.MarkupBtnState(null, val ? GLTFViewer.MENUSHOW : GLTFViewer.MENUHIDE);
            if (GLTFViewer.Utils.IsApple())
                this._scene.viewer.MarkupMenuBtnState(GLTFViewer.markupMenuBtns3D, null, GLTFViewer.MENUDISABLE);
        }
    },
    CanCreateViews: {
        get: function () {
            return this._canCreateViews;
        },
        set: function (val) {
            this._canCreateViews = val;
           //this._scene.viewer.MarkupBtnState(null, val ? GLTFViewer.MENUSHOW : GLTFViewer.MENUHIDE);
        }
    },
    // private methods
    _ResetHitResources: {
        value: function () {
            if (this._hitTextureCnt > 0) {
                var gl = this._gl;
                gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);

                gl.deleteRenderbuffer(this._hitDepthBuffer);
                for (var i = 0; i < this._hitTextureCnt; i++) {
                    gl.deleteTexture(this._hitTextures[i]);
                    gl.deleteFramebuffer(this._hitFBuffers[i]);
                }
                this._hitTextureCnt = 0;
                this._hitTextureWidth = 0;
                this._hitTextures = null;
                this._hitFBuffers = null;
                this._hitDepthBuffer = null;
            }
        }
    },
    _UpdateHitResources: {
        value: function (width, height) {
            var gl = this._gl;
            var log2 = Math.log(2);
            var lw = Math.floor(Math.log(width) / log2);
            var tw = 1 << lw;
            if (tw < width)
                tw = 1 << ++lw;
            var lh = Math.floor(Math.log(height) / log2);
            var th = 1 << lh;
            if (th < height)
                th = 1 << ++lh;
            var txtureWidth = tw;
            var textureCount = lw + 1;
            if (txtureWidth < th) {
                txtureWidth = th;
                textureCount = lh + 1;
            }
            if (txtureWidth > 2048) {
                txtureWidth = 2048;
                textureCount = 12;
            }
            if (this._hitTextureWidth < txtureWidth) {
                this._ResetHitResources();
                this._hitTextureWidth = txtureWidth;
                this._hitTextureCnt = textureCount;
                this._hitTextures = [];
                this._hitFBuffers = [];
                var fmt = gl.FLOAT;
                for (var i = 0; i < textureCount; i++) {
                    //if (txtureWidth == 1)
                    //  fmt = gl.UNSIGNED_BYTE;
                    var txture = gl.createTexture();
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, txture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, txtureWidth, txtureWidth, 0, gl.RGBA, fmt, null);
                    this._hitTextures.push(txture);
                    var fbo = gl.createFramebuffer();
                    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, txture, 0);
                    if (i == 0) {
                        this._hitDepthBuffer = gl.createRenderbuffer();
                        gl.bindRenderbuffer(gl.RENDERBUFFER, this._hitDepthBuffer);
//                        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, txtureWidth, txtureWidth);
//                        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._hitDepthBuffer);
                        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, txtureWidth, txtureWidth);
                        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._hitDepthBuffer);
                        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {
                            GLTFViewer.Utils.WriteLn("ERROR(FileBaseClass.UpdateHitResources): fbo not complete");
                            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                            gl.bindTexture(gl.TEXTURE_2D, null);
                            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                            this._ResetHitResources();
                            return;
                        }
                        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                    }
                    gl.bindTexture(gl.TEXTURE_2D, null);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    this._hitFBuffers.push(fbo);
                    txtureWidth = txtureWidth >> 1;
                }
            }
        }
    },
    _SortHits: {
        value: function () {
            var gl = this._gl;
            var shader = this._sorthitTestShader;
            if (!shader.StartProgram())
                return null;
            var txtureWidth = this._hitTextureWidth;
            gl.disable(gl.DEPTH_TEST);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._sortBuf);
            gl.vertexAttribPointer(shader.aPos, 3, gl.FLOAT, false, 44, 0);
            gl.vertexAttribPointer(shader.aT0, 2, gl.FLOAT, false, 44, 12);
            gl.vertexAttribPointer(shader.aT1, 2, gl.FLOAT, false, 44, 20);
            gl.vertexAttribPointer(shader.aT2, 2, gl.FLOAT, false, 44, 28);
            gl.vertexAttribPointer(shader.aT3, 2, gl.FLOAT, false, 44, 36);
            var i = 0;
            var vtx = this._sortDat; // we probably should be allocating new memory for this
            // reduce _hitTextures[i] into _hitTextures[i + 1]
            while (txtureWidth > 1) {
                var tap = 0.5 / txtureWidth;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this._hitFBuffers[i + 1]);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this._hitTextures[i]);
                gl.uniform1i(shader.uSmp, 0);
                txtureWidth = txtureWidth >> 1;
                gl.viewport(0, 0, txtureWidth, txtureWidth);
                var vc = 0;
                // bottom left
                vtx[vc++] = -1; vtx[vc++] = -1; vtx[vc++] = 0;
                vtx[vc++] = 0 - tap; vtx[vc++] = 0 - tap; // center of pixels
                vtx[vc++] = 0 + tap; vtx[vc++] = 0 - tap;
                vtx[vc++] = 0 - tap; vtx[vc++] = 0 + tap;
                vtx[vc++] = 0 + tap; vtx[vc++] = 0 + tap;
                // bottom right
                vtx[vc++] = +1; vtx[vc++] = -1; vtx[vc++] = 0;
                vtx[vc++] = 1 - tap; vtx[vc++] = 0 - tap;
                vtx[vc++] = 1 + tap; vtx[vc++] = 0 - tap;
                vtx[vc++] = 1 - tap; vtx[vc++] = 0 + tap;
                vtx[vc++] = 1 + tap; vtx[vc++] = 0 + tap;
                // top left
                vtx[vc++] = -1; vtx[vc++] = +1; vtx[vc++] = 0;
                vtx[vc++] = 0 - tap; vtx[vc++] = 1 - tap;
                vtx[vc++] = 0 + tap; vtx[vc++] = 1 - tap;
                vtx[vc++] = 0 - tap; vtx[vc++] = 1 + tap;
                vtx[vc++] = 0 + tap; vtx[vc++] = 1 + tap;
                // top right
                vtx[vc++] = +1; vtx[vc++] = +1; vtx[vc++] = 0;
                vtx[vc++] = 1 - tap; vtx[vc++] = 1 - tap;
                vtx[vc++] = 1 + tap; vtx[vc++] = 1 - tap;
                vtx[vc++] = 1 - tap; vtx[vc++] = 1 + tap;
                vtx[vc++] = 1 + tap; vtx[vc++] = 1 + tap;
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._sortDat);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                i++;
            }
            gl.disableVertexAttribArray(shader.aPos);
            gl.disableVertexAttribArray(shader.aT0);
            gl.disableVertexAttribArray(shader.aT1);
            gl.disableVertexAttribArray(shader.aT2);
            gl.disableVertexAttribArray(shader.aT3);
            var b = this._hitFloatData;
            gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, b);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.enable(gl.DEPTH_TEST);
            if (b[0] === 0)
                return null;
            return b;
        }
    },
    // public virtual methods
    Render3D: { value: function(TVP, lighting, w, h, peelPass) { } },
    Render2D: { value: function(TVP, lighting, w, h) { } },
    Render2DOverlay: { value: function(w, h) { } },
    RenderClipCap: { value: function(TVP, lighting, w, h) { } },
    RenderExport: { value: function() { } },
    ResetHit: { value: function () { } },
    AnyHit: { value: function () { return false; } },
    HitPoint: { value: function () { return null; } },
    HitIndx: { value: function () { return null; } },
    CanSelect: { value: function() { return false; } },
    AnySelection: { value: function() { return false; } },
    UpdateSelection: { value: function (ctrlKey, altKey) { return false; } },
    ResetSelection: { value: function () { return false; } },
    RenderSelection: { value: function(TVP, w, h) { } },
    ReadFile: { value: function(callback, loadType, sceneState) { } },
    CreateScene: { value: function(name, fromSceneItem) { return false; } },
    DeleteScene: { value: function(index) { } },
    HitIndexTip: { value: function() { return null; } },
    HitTestFindClosestIndex: { value: function(pnt) { return false; } },
    HitTestFindClosestPos: { value: function(pnt) { return null; } },
    HitTest: { value: function(TVP, w, h, tCursorRay, dontIncludeMarkup) { return false; } },
    IsVisible: { value: function(sceneNodeItemIndex) { return false; } },
    RenderMarkup3D: { value: function(TVP) { } },
    RenderMarkup2D: { value: function(TVP) { } },
    ReadMarkups: { value: function(markupData, callback) { } },
    PostMarkups: { value: function() { } },
    SaveMarkups: { value: function(mupFile) { return false; } },
    ReadViews: { value: function(viewData, callback, sceneState) { } },
    PostViews: { value: function() { } },
    SaveViews: { value: function(viewFile) { return false; } },
    CurScene: { get: function () { return null; } },
    GetSceneBox: { value: function (dontExplode) { return GLTFViewer.Utils.Box.empty; } },
    HideBody: { value: function (body) { } },
    EditProperties: { value: function (body) { } },
    GetSceneState: { value: function() { return null; } },
    ResetScene: {
        value: function (sceneItem) {
            this._worldBoundingBox = null;
            this.UpdateWorldScale();
        }
    },
    // sets scenebox and world scale
    UpdateWorldScale: {
        value: function () {
            if (GLTFViewer.Utils.IsNull(this._worldBoundingBox))
                this._worldBoundingBox = new GLTFViewer.Utils.Box();
            this._worldBoundingBox.Unite(this.GetSceneBox());
            this._navigator.UpdateWorldScale(this._worldBoundingBox);
        }
    },
    // public methods
    Export: {
        value: function(fh, type) {
            var fs = require('fs');
            this._exportFH = fh;
            this._exportType = type;
            this._exportBuffer = new Buffer(1024);
            switch (type) {
                case "STL":
                    fs.writeSync(fh, "solid Object\n");
                    break;
                case "STLBIN":
                    this._exportBuffer.fill(0, 0, 80);
                    fs.writeSync(fh, this._exportBuffer, 0, 80);
                    this._exportBuffer.writeUInt32LE(0, 0);
                    fs.writeSync(fh, this._exportBuffer, 0, 4); // this needs to be filled in with number of triangles
                    break;
                default:
                    return;
            }

            this._exportDataSize = 0;
            this.RenderExport();

            switch (type) {
                case "STL":
                    fs.writeSync(fh, "endsolid Object\n");
                    break;
                case "STLBIN":
                    var numTriangles = this._exportDataSize / 50;
                    this._exportBuffer.writeUInt32LE(numTriangles, 0);
                    fs.writeSync(fh, this._exportBuffer, 0, 4, 80);
            }

            this._exportBuffer = null;
            this._exportFH = null;
        }
    },
    Resize: {
        value: function(width, height) {
            // if you override this method, you must call this base class version
            if (this._width === width && this._height === height)
                return;
            this._width = width;
            this._height = height;
            this._UpdateHitResources(width, height);
        }
    },
    Reset: { // clear to just created state
        value: function() {
            var gl = this._gl;
            this._width = 0;
            this._height = 0;
            if (this._hitTextureCnt > 0) {
                gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                for (var i = 0; i < this._hitTextureCnt; i++) {
                    gl.deleteTexture(this._hitTextures[i]);
                    gl.deleteFramebuffer(this._hitFBuffers[i]);
                }
                gl.deleteRenderbuffer(this._hitDepthBuffer);
                this._hitDepthBuffer = null;
                this._hitTextures = null;
                this._hitFBuffers = null;
                this._hitTextureCnt = 0;
                this._hitTextureWidth = 0;
            }
            this._empty = true;
            this._minSize = 1;
            this._clip.Reset();
            this._selection = null;
            this._worldBoundingBox = null;
        }
    },
    Clear: { // clear for deletion
        value: function() {
            var gl = this._gl;
            GLTFViewer.Utils.FileBaseClass.prototype.Reset.call(this);
            if (this._sorthitTestShader !== null) {                
                this._sorthitTestShader.DeleteProgram();
                this._sorthitTestShader = null;
            }
            this._scene = null;
            this._fileType = null;
            this._data = null;
            this._other = null;
            this._hitFloatData = null;
            this._hitByteData = null;
            this._sortDat = null;
            if (this._sortBuf) {
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.deleteBuffer(this._sortBuf);
                this._sortBuf = null;
            }
            this._navigator = null;
            this._viewer = null;
            this._background = null;
            this._progressBar = null;
            this._gl = null;
            this._clip.Clear();
        } 
    },
    GetTopParts: {
        value: function () {
            return null;
        }
    },
    GetBodies: {
        value: function () {
            return {};
        }
    },
    SetHighlightBodyState: {
        value: function (name, on) {
        }
    },
    GetPartName: {
        value: function (part) {
            return null;
        }
    },
    GetPartParent: {
        value: function (part) {
            return null;
        }
    },
    GetPartParts: {
        value: function (part) {
            return null;
        }
    },
    GetPartBodys: {
        value: function (part) {
            return null;
        }
    },
    GetBodyName: {
        value: function (body) {
            return null;
        }
    },
    GetRegions: {
        value: function () {
            return null;
        }
    },
    GetRegionName: {
        value: function (region) {
            return null;
        }
    },
    GetSelections: {
        value: function (region) {
            return null;
        }
    },
    GetParts: {
        value: function () {
            return [];
        }
    },
    GetIndexSelection: {
        value: function (region) {
            return null;
        }
    },
    GetClipPlane: {
        value: function (p) {
            return new GLTFViewer.Utils.Plane(GLTFViewer.Utils.Vec3.Origin, new GLTFViewer.Utils.Direction(0, 0, 1));
        }
    },
    ClipState: {
        get: function () {
            return this._clip.clipState;
        },
        set: function (state) {
            this._clip.clipState = state;
        }
    },
    ClipViewState: {
        get: function () { 
            return this._clip._clipViewState;
        }
    },
    ClipDrawMode: {
        get: function () {
            return this._clip.clipDrawMode; 
        },
        set: function (mode) {
            this._clip.clipDrawMode = mode;
        }
    },
    MarkupTextEvent: { value: function (type, e) {} },
    MarkupState: {
        get: function () {
            return GLTFViewer.Utils.Markup.STATE_DISABLED;
        },
        set: function (state) {
        }
    },
    MarkupLineShape: {
        get: function () {
            return GLTFViewer.Utils.Markup.LINE_SYMBOL_NONE;
        },
        set: function (shape) {
        }
    },
    MarkupLineType: {
        get: function () {
            return GLTFViewer.Utils.Markup.LINE_TYPE_2D;
        },
        set: function (typ) {
        }
    },
    MarkupLineColor: {
        get: function () {
            return new GLTFViewer.Utils.RGBA(0, 0, 0, 255);
        },
        set: function (col) {
        }
    },
    MarkupFontColor: {
        get: function () {
            return new GLTFViewer.Utils.RGBA(0, 0, 0, 255);
        },
        set: function (col) {
        }
    },
    MarkupFontSize: {
        get: function () {
            return GLTFViewer.DEFAULT_MARKUP_FONT_SIZE;
        },
        set: function (col) {
        }
    },
    MarkupBackColor: {
        get: function () {
            return new GLTFViewer.Utils.RGBA(255, 255, 255, 127);
        },
        set: function (col) {
        }
    },
    MarkupSelect: { get: function () { return 0; } },
    MarkupHit: { get: function () { return 0; } },
    MarkupStart: { value: function (x, y) { } },
    MarkupUpdate: { value: function (x, y) { } },
    MarkupEnd: { value: function (x, y) { } },
    MarkupCreate3D: { value: function () { } },
    MarkupDelete: { value: function (key) { } },
    MarkupEsc: { value: function () { } },
    MarkupTip: { get: function () { return null; } },
    MarkupEditable: { value: function (key) { return false; } },
    // returns null or point for !index
    // return null/false or true for index
    HitTestPos: {
        value: function (TVP, w, h, cursorRay, index) {
            if (this._hitTextureCnt === 0)
                return null; // resources not yet updated
            var gl = this._gl;
            gl.enable(gl.DEPTH_TEST);
            this._navigator.transViewProjTM.ToArray(TVP);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._hitFBuffers[0]);
            gl.viewport(0, 0, w, h);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            // calling render fills the framebuffer COLOR_ATTACHMENT RGBA with the R=distance to ray, G=X B=Y, A=Z in World Space
            //                                                                 or  X                  Y   Z    W     
            // it fills _hitTextures[0]
            if (!this._RenderFindClosest(TVP, w, h, index, cursorRay))
                return null;
            b = this._SortHits();
            if (b) {
                if (index)
                    return this.HitTestFindClosestIndex(b);
                else
                    return this.HitTestFindClosestPos(b);
            }
            return null;
        }
    },
    HasAnimation: {
        value: function () {
            return false;
        }
    }        ,
    AnimationMinTime: {
        value: function () {
            return 0;
        }
    },
    AnimationMaxTime: {
        value: function () {
            return 0;
        }
    },
    AnimationShowFrame: {
        value: function (time) {
            return false;
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.FileBaseClass, {
    // private members
    _vsHitTestSort: {
        value: "attribute vec3 aPos;\n" +
               "attribute vec2 aT0;\n" +
               "attribute vec2 aT1;\n" +
               "attribute vec2 aT2;\n" +
               "attribute vec2 aT3;\n" +
               "varying vec2 vT0;\n" +
               "varying vec2 vT1;\n" +
               "varying vec2 vT2;\n" +
               "varying vec2 vT3;\n" +
               "void main() {\n" +
                   "vT0 = aT0;\n" +
                   "vT1 = aT1;\n" +
                   "vT2 = aT2;\n" +
                   "vT3 = aT3;\n" +
                   "gl_Position = vec4(aPos, 1);\n" +
               "}"
    },
    _fsHitTestSort: {
        value: "uniform sampler2D uSmp;\n" +
               "varying vec2 vT0;\n" +
               "varying vec2 vT1;\n" +
               "varying vec2 vT2;\n" +
               "varying vec2 vT3;\n" +
               "void main() {\n" +
                   "vec4 t0 = texture2D(uSmp, vT0);\n" +
                   "vec4 t1 = texture2D(uSmp, vT1);\n" +
                   "vec4 t2 = texture2D(uSmp, vT2);\n" +
                   "vec4 t3 = texture2D(uSmp, vT3);\n" +
                   // biggest one that is != 0
                   "if (t1.x != 0.0 && (t0.x == 0.0 || t1.x > t0.x)) t0 = t1;\n" +
                   "if (t2.x != 0.0 && (t0.x == 0.0 || t2.x > t0.x)) t0 = t2;\n" +
                   "if (t3.x != 0.0 && (t0.x == 0.0 || t3.x > t0.x)) t0 = t3;\n" +
                   "gl_FragColor = t0;\n" +
               "}"
    }
    // public methods
});
//
// GLTFViewer.Utils.FileBaseClass
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// GLTFViewer.Utils.Scene
//
/** @constructor */
GLTFViewer.Utils.Scene = function (viewer, container, canvas, overlay, gl, gx, progress) {
    this._enableUpdate = [];
    this.imageDir = viewer.imageDir;
    this.viewer = viewer;
    this.container = container;
    this.canvas = canvas;
    this.overlay = overlay;
    this.gl = gl;
    this.gx = gx;
    this.progress = progress;

    // Pick the enum for the float textures
    this.float_buffer_enum = gl.UNSIGNED_BYTE;
    const OES_texture_float = gl.getExtension('OES_texture_float');
    const OES_texture_half_float = gl.getExtension('OES_texture_half_float');
    if (OES_texture_float) {
        // Full float support
        this.float_buffer_enum = gl.FLOAT;
    } else if (OES_texture_half_float) {
        // No floats, but half floats supported
        this.float_buffer_enum = OES_texture_half_float.HALF_FLOAT_OES;
    }

    var lwr = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);
    if (lwr[1] === lwr[0]) {
        this.lineWidthSupport = false;
        GLTFViewer.Utils.WriteLn("WARNING: Line Width not supported, range is " + lwr[0] + " to " + lwr[1]);
    }
    this.progressBar = new GLTFViewer.Utils.Scene.ProgressBar(this.progress, this.container);
    this.view = [];
    var x = new GLTFViewer.Utils.Direction(1 / GLTFViewer.Utils.root2, -1 / GLTFViewer.Utils.root6, 1 / GLTFViewer.Utils.root3);
    var y = new GLTFViewer.Utils.Direction(1 / GLTFViewer.Utils.root2, 1 / GLTFViewer.Utils.root6, -1 / GLTFViewer.Utils.root3);
    this.view.push(GLTFViewer.Utils.Transformation.RotationCreate(x.x, x.y, x.z, y.x, y.y, y.z)); //isometric
    x = new GLTFViewer.Utils.Direction(GLTFViewer.Utils.root3 / 2, -0.25, GLTFViewer.Utils.root3 / 4);
    y = new GLTFViewer.Utils.Direction(0.5, GLTFViewer.Utils.root3 / 4, -0.75);
    this.view.push(GLTFViewer.Utils.Transformation.RotationCreate(x.x, x.y, x.z, y.x, y.y, y.z)); //trimetric
    x = GLTFViewer.Utils.Direction.dix;
    y = GLTFViewer.Utils.Direction.diy;
    this.view.push(GLTFViewer.Utils.Transformation.RotationCreate(x.x, x.y, x.z, y.x, y.y, y.z).Invert()); //top
    this.view.push(GLTFViewer.Utils.Transformation.RotationCreate(x.x, x.y, x.z, -y.x, -y.y, -y.z).Invert()); //bottom
    x = GLTFViewer.Utils.Direction.diy;
    y = GLTFViewer.Utils.Direction.diz;
    this.view.push(GLTFViewer.Utils.Transformation.RotationCreate(-x.x, -x.y, -x.z, y.x, y.y, y.z).Invert()); //left
    this.view.push(GLTFViewer.Utils.Transformation.RotationCreate(x.x, x.y, x.z, y.x, y.y, y.z).Invert()); //right
    x = GLTFViewer.Utils.Direction.dix;
    y = GLTFViewer.Utils.Direction.diz;
    this.view.push(GLTFViewer.Utils.Transformation.RotationCreate(x.x, x.y, x.z, y.x, y.y, y.z).Invert()); //front
    this.view.push(GLTFViewer.Utils.Transformation.RotationCreate(-x.x, -x.y, -x.z, y.x, y.y, y.z).Invert()); //back
    this.navigator = new GLTFViewer.Utils.Navigator(this, this.container, this.view[0]);
    if (this.viewer.mobile)
        this._canPeel = false;
    this.ruler = new GLTFViewer.Utils.Ruler(gx, this.navigator);
    this.uLit = new Float32Array(16 * 2);
    this.lights = [new GLTFViewer.Utils.Light(), new GLTFViewer.Utils.Light()];
    this.defaultLightDirs = new Array(2);
    this.defaultLightDirs[0] = new GLTFViewer.Utils.Direction(-0.361, +0.361, +0.431);
    this.defaultLightDirs[1] = new GLTFViewer.Utils.Direction(-0.319, +0.324, +0.891);
    this._screenQuadDat = new Float32Array(16);
    this._screenQuadBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this._screenQuadBuf);
    gl.bufferData(gl.ARRAY_BUFFER, this._screenQuadDat, gl.DYNAMIC_DRAW);
    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthFunc(gl.LESS);
    gl.clearColor(0, 0, 0, 0);
    this.background = new GLTFViewer.Utils.Background(gl);
    this.screenShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.Scene._vsScreen, GLTFViewer.Utils.Scene._fsScreen);
    window.addEventListener('resize', this.Invalidate.bind(this, true), false); // will call resize event of "this"
    this._intervalTimer = setInterval(this.Timer.bind(this), 1000); // start a 1 second interval timer
    this._screenTexture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this._screenTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.bindTexture(gl.TEXTURE_2D, null);

    if (this._canPeel) {
        this.g_frontColorTexId = [];
        this.g_frontFboId = [];
        this.g_frontDepthId = gl.createRenderbuffer();
        for (var i = 0; i < 2; ++i) {
            this.g_frontColorTexId[i] = gl.createTexture();
            this.g_frontFboId[i] = gl.createFramebuffer();
        }
        this.g_frontColorBlenderTexId = gl.createTexture();
        this.g_frontColorBlenderFboId = gl.createFramebuffer();
        this.g_frontColorBlenderDepthId = gl.createRenderbuffer();
    }

    this.Loop();
};
GLTFViewer.Utils.Scene.prototype = Object.create(null, {
    // private members
    _screenQuadDat: { writable: true, value: null },
    _screenQuadBuf: { writable: true, value: null },
    _screenTexture: { writable: true, value: null },
    _intervalTimer: { writable: true, value: null },
    //
    _darkBorder: { writable: true, value: false },
    _animateLoop: { writable: true, value: false },
    _animateLastClockTime: { writable: true, value: null },
    _animateAllowed: { writable: true, value: false }, // frame time not available
    _animate: { writable: true, value: false }, // play animation
    _animateOnce: { writable: true, value: false }, // play 1 frame of animation
    _animateUpdateSlider: { writable: true, value: true },
    _animateCurTime: { writable: true, value: null }, // current time
    _animateSpeed: { writable: true, value: 1 },
    // public members
    g_frontColorTexId: { writable: true, value: null },
    g_frontFboId: { writable: true, value: null },
    g_frontDepthId: { writable: true, value: null },
    g_frontColorBlenderTexId: { writable: true, value: null },
    g_frontColorBlenderFboId: { writable: true, value: null },
    g_frontColorBlenderDepthId: { writable: true, value: null },
    handler: { writable: true, value: null },
    navigator: { writable: true, value: null },
    ruler: { writable: true, value: null },
    progressBar: { writable: true, value: null },
    _enableUpdate: { writable: true, value: null },
    paint: { writable: true, value: true },
    paintAll: { writable: true, value: true },
    _depthPeel: { writable: true, value: false },
    _canPeel: { writable: true, value: true },
    depthPeelPass: { writable: true, value: 0 },
    depthPeelPasses: { writable: true, value: 20 },
    viewer: { writable: true, value: null },
    canvas: { writable: true, value: null },
    gl: { writable: true, value: null },
    gx: { writable: true, value: null },
    lineWidthSupport: { writable: true, value: true },
    container: { writable: true, value: null }, // this is who we want to have focus
    overlay: { writable: true, value: null },
    progress: { writable: true, value: null },
    screenShader: { writable: true, value: null },
    logo: { writable: true, value: null },
    background: { writable: true, value: null },
    uLit: { writable: true, value: null },
    lights: { writable: true, value: null },
    defaultLightDirs: { writable: true, value: null },
    view: { writable: true, value: null },
    showFrameRate: { writable: true, value: false },
    frameCount: { writable: true, value: 0 },
    frameTime: { writable: true, value: 0 },
    frameCountLast: { writable: true, value: 0 },
    frameTimeLast: { writable: true, value: 0 },
    requestAnimationID: { writable: true, value: false },
    // private methods
    // public methods
    depthPeel: {
        get: function () {
            return this._canPeel && this._depthPeel;
        },
        set: function (val) {
            this._depthPeel = val;
        }
    },
    OkToShowContextMenu: {
        value: function () {
            return this.IsEmpty() || this.navigator.OkToShowContextMenu();
        }
    },
    Timer: {
        value: function () { // this is a 1 second interval timer
            var curTime = new Date().getTime();
            this.frameCountLast = this.frameCount;
            this.frameTimeLast = curTime - this.frameTime;
            this.frameCount = 0;
            this.frameTime = curTime;
        }
    },
    Resize: {
        value: function (width, height) {
            if (!this._canPeel)
                return;

            var gl = this.gl;

            // create 2 of everything so that we can alternate drawing to each one for each layer
            // use previous layer as basis for comparison when drawing next layer
            for (var i = 0; i < 2; ++i) {
                // create a texture for color
                gl.bindTexture(gl.TEXTURE_2D, this.g_frontColorTexId[i]);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, this.float_buffer_enum, null);

                // create a frame buffer
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.g_frontFboId[i]);
                // attach texture for color to color buffer GL_COLOR_ATTACHMENT0_EXT
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.g_frontColorTexId[i], 0);

                gl.bindRenderbuffer(gl.RENDERBUFFER, this.g_frontDepthId);
                //                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
                //                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.g_frontDepthId);
                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.g_frontDepthId);

                if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {
                    GLTFViewer.Utils.WriteLn("ERROR(Scene.Resize): fbo not complete");
                    this._canPeel = false;
                    gl.bindTexture(gl.TEXTURE_2D, null);
                    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    return;
                }
            }

            // create a texture for color, this will be used in the blender
            gl.bindTexture(gl.TEXTURE_2D, this.g_frontColorBlenderTexId);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, this.float_buffer_enum, null);

            // create a frame buffer for the blender
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.g_frontColorBlenderFboId);
            // attach texture for color to color buffer GL_COLOR_ATTACHMENT0_EXT
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.g_frontColorBlenderTexId, 0);

            gl.bindRenderbuffer(gl.RENDERBUFFER, this.g_frontColorBlenderDepthId);
            //            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
            //            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.g_frontColorBlenderDepthId);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.g_frontColorBlenderDepthId);

            if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {
                GLTFViewer.Utils.WriteLn("ERROR(Scene.Resize): fbo not complete");
                this._canPeel = false;
            }

            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
    },
    RenderScene: {
        value: function (time) {
            function RenderScreenQuad(gl, shader, width, height) {
                gl.uniform2f(shader.uSze, width, height);
                var vc = 0;
                var t = this._screenQuadDat;
                t[vc++] = 0; t[vc++] = 0; t[vc++] = 0; t[vc++] = 0;
                t[vc++] = width; t[vc++] = 0; t[vc++] = 1; t[vc++] = 0;
                t[vc++] = 0; t[vc++] = height; t[vc++] = 0; t[vc++] = 1;
                t[vc++] = width; t[vc++] = height; t[vc++] = 1; t[vc++] = 1;
                gl.bindBuffer(gl.ARRAY_BUFFER, this._screenQuadBuf);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._screenQuadDat);
                gl.vertexAttribPointer(shader.aPos, 2, gl.FLOAT, false, 16, 0);
                gl.vertexAttribPointer(shader.aTex, 2, gl.FLOAT, false, 16, 8);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
            }

            this.navigator.DoGamePad();

            if (this._enableUpdate.length || !this.viewer.IsVisible())
                return;

            time = (time ? time : new Date().getTime()) / 1000;
            if (!this._animateAllowed && time)
                this._animateAllowed = true;
            if (this._animate || this._animateOnce) { // animation is playing
                if (this._animateOnce) {
                    this._animateOnce = false;
                    this._animateLastClockTime = null;
                }
                var minTime = this.AnimationMinTime();
                var maxTime = this.AnimationMaxTime();
                var curTime = GLTFViewer.Utils.IsNull(this._animateCurTime) ? minTime : this._animateCurTime;
                var tOffset = GLTFViewer.Utils.IsNull(this._animateLastClockTime) ? 0 : time - this._animateLastClockTime;
                this._animateLastClockTime = time;
                var t = curTime + tOffset * this._animateSpeed;
                if (t >= maxTime) {
                    if (this._animateLoop) {
                        t = (t % maxTime) + minTime;
                        this._animateLastClockTime = time - t;
                    } else {
                        this._animate = false;
                        t = this.AnimationMaxTime();
                        if (this.viewer.animationDialog && this.viewer.animationDialog.pauseButton)
                            this.viewer.animationDialog.pauseButton.click();
                    }
                }
                if (!this.AnimationShowFrame(t))
                    this._animateLastClockTime = null; // this will stall animation (playing but not moving)
            }
            if (this.handler) {
                var enable = this.viewer.AnyAnnimationRunning() ? GLTFViewer.MENUDISABLE : GLTFViewer.MENUENABLE;
                if (enable === GLTFViewer.MENUDISABLE) {
                    this.viewer.GetMainUIViewer().FileManagerBtnState(null, GLTFViewer.MENUCLOSE);
                    this.viewer.MarkupBtnState(null, GLTFViewer.MENUCLOSE);
                    this.viewer.ExplodeBtnState(null, GLTFViewer.MENUCLOSE);
                    this.SetExplosion(0, true);
                }
                this.viewer.GetMainUIViewer().FileManagerBtnState(null, enable);
                this.viewer.MarkupBtnState(null, this.GetExplosion() ? GLTFViewer.MENUDISABLE : enable);
                this.viewer.ExplodeBtnState(null, enable);
            }

            if ((!this.paint && !this.paintAll) || !this.SetCanvasSize())
                return;
            //this.paint = false;
            // 3D render
            var gl = this.gl;
            var navigator = this.navigator;
            var width = navigator.canvasWidth;
            var height = navigator.canvasHeight;
            gl.enable(gl.DEPTH_TEST);
            gl.viewport(0, 0, width, height);
            if (this.paintAll) {
                var captureScreen = false;
                navigator.StartRender();
                this.SetupLights();
                if (!this.IsEmpty() && this.handler) {
                    var clip = this.ClipViewState === GLTFViewer.Utils.Clip.VIEWSTATE_PLANE;
                    if (!this.depthPeel || clip || !this.handler.CanPeel || navigator.active) {
                        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                        if (clip) {
                            if (!this.handler._clip.flipped) {
                                this.handler.RenderClipCap(navigator.uTVP, navigator.uEye, this.uLit, width, height);
                                gl.activeTexture(gl.TEXTURE0);
                                gl.bindTexture(gl.TEXTURE_2D, this.handler._clip.capTexture);
                                gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, width, height, 0);
                                gl.bindTexture(gl.TEXTURE_2D, null);
                            }
                            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                        }
                        if (this.background)
                            this.background.Render();
                        this.handler.Render3D(navigator.uTVP, navigator.uEye, this.uLit, width, height, -1);
                        if (clip) {
                            this.handler._clip.RenderCap(navigator.uTVP, navigator.uEye, this.uLit);
                            this.handler._clip.RenderPlane(navigator.uTVP);
                        }
                        this.handler.RenderMarkup3D(navigator.uTVP);
                        this.handler.Render2D(navigator.uTVP, navigator.uEye, this.uLit, width, height);
                        this.paintAll = false;
                        captureScreen = true;
                    } else if (this.depthPeelPass < this.depthPeelPasses) {
                        // combine g_frontColorTexId into g_frontColorBlenderTexId
                        function CompositeLayer(gl, width, height, texture) {
                            gl.enable(gl.BLEND);
                            gl.disable(gl.DEPTH_TEST);
                            var shader = this.screenShader;
                            if (shader.StartProgram()) {
                                gl.activeTexture(gl.TEXTURE0);
                                gl.bindTexture(gl.TEXTURE_2D, texture);
                                gl.uniform1i(shader.uSmp, 0);
                                RenderScreenQuad.call(this, gl, shader, width, height);
                                gl.bindTexture(gl.TEXTURE_2D, null);
                                gl.enable(gl.DEPTH_TEST);
                                gl.disable(gl.BLEND);
                            }
                        }

                        if (this.depthPeelPass === 0) {
                            // clear g_frontColorBlenderTexId
                            gl.bindFramebuffer(gl.FRAMEBUFFER, this.g_frontColorBlenderFboId);
                            gl.clear(gl.COLOR_BUFFER_BIT);

                            // set g_frontColorTexId[1] to top layer
                            gl.bindFramebuffer(gl.FRAMEBUFFER, this.g_frontFboId[1]);
                            gl.clear(gl.DEPTH_BUFFER_BIT);
                            this.handler.Render3D(navigator.uTVP, navigator.uEye, this.uLit, width, height, 1);
                        }

                        do {
                            var currId = this.depthPeelPass % 2;
                            var prevId = 1 - currId;

                            // Peel top layer into g_frontColorTexId[currId]
                            gl.bindFramebuffer(gl.FRAMEBUFFER, this.g_frontFboId[currId]);
                            gl.clear(gl.COLOR_BUFFER_BIT);
                            gl.enable(gl.BLEND);
                            gl.disable(gl.DEPTH_TEST);
                            this.handler.Render3D(navigator.uTVP, navigator.uEye, this.uLit, width, height, 2, this.g_frontColorTexId[prevId]);
                            gl.enable(gl.DEPTH_TEST);
                            gl.disable(gl.BLEND);

                            // composite layer from g_frontColorTexId[currId]
                            gl.bindFramebuffer(gl.FRAMEBUFFER, this.g_frontColorBlenderFboId);
                            gl.blendFuncSeparate(gl.ONE_MINUS_DST_ALPHA, gl.ONE, gl.ONE_MINUS_DST_ALPHA, gl.ONE);
                            CompositeLayer.call(this, gl, width, height, this.g_frontColorTexId[currId]);
                            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

                            // set g_frontColorTexId[currId] to next layer
                            gl.bindFramebuffer(gl.FRAMEBUFFER, this.g_frontFboId[currId]);
                            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                            this.handler.Render3D(navigator.uTVP, navigator.uEye, this.uLit, width, height, 3, this.g_frontColorTexId[prevId]);

                            ++this.depthPeelPass;
                        } while (this.depthPeelPass < 2 && this.depthPeelPass < this.depthPeelPasses);
                        // do first 2 passes, when want at least 2 passes
                        // sometimes the first pass, which is just the top layer, is quite different from the top 2 passes, and makes the display appear to flash

                        // render background
                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                        if (this.background)
                            this.background.Render();

                        // composite g_frontColorBlenderTexId
                        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                        CompositeLayer.call(this, gl, width, height, this.g_frontColorBlenderTexId);
                        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

                        this.handler.RenderMarkup3D(navigator.uTVP);
                        this.handler.Render2D(navigator.uTVP, navigator.uEye, this.uLit, width, height);

                        if (this.depthPeelPass >= this.depthPeelPasses)
                            this.paintAll = false;
                        captureScreen = true;
                    } else
                        this.paintAll = false;
                } else {
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    if (this.background)
                        this.background.Render();
                    if (this.handler)
                        this.handler.RenderMarkup3D(navigator.uTVP);
                    this.paintAll = false;
                    captureScreen = true;
                }
                if (captureScreen) {
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, this._screenTexture);
                    gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, width, height, 0);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                }
                this.frameCount++;
                navigator.UpdateAnimProjStep();
            } else {
                var shader = this.screenShader;
                if (shader.StartProgram()) {
                    gl.disable(gl.DEPTH_TEST);
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, this._screenTexture);
                    gl.uniform1i(shader.uSmp, 0);
                    RenderScreenQuad.call(this, gl, shader, width, height);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                    gl.enable(gl.DEPTH_TEST);
                }
            }
            if (this.handler) {
                this.handler.RenderSelection(navigator.uTVP, width, height);
                if (this.ClipViewState === GLTFViewer.Utils.Clip.VIEWSTATE_PREVIEW && this.ClipDrawMode > GLTFViewer.Utils.Clip.DRAWMODE_1_PT)
                    this.handler._clip.RenderPreview(navigator.uTVP, width, height);
                else if ((navigator.mouseOver || navigator.active) && this.ClipDrawMode >= GLTFViewer.Utils.Clip.DRAWMODE_MOVE && navigator.IsType(GLTFViewer.Utils.Navigator.NavNone))
                    this.handler._clip.RenderMoveHint(width, height, navigator._cursorRay);
            }
            navigator.Render3D(this.uLit);
            this._darkBorder = this.background && this.background.IsDark(GLTFViewer.Utils.Background.RIGHTTOP);
            var curLogo = this._darkBorder ? this.viewer.whtLogo : this.viewer.blkLogo;
            if (curLogo) {
                var wantLogo = this.viewer.isFull || (this.viewer.viewportLayout === 1 && this.viewer.viewportNumber === 0) || this.viewer.viewportNumber === 1;
                if (wantLogo) {
                    if (curLogo !== this.logo) {
                        this.logo = curLogo;
                        this.viewer.whtLogo.css("visibility", "hidden");
                        this.viewer.blkLogo.css("visibility", "hidden");
                        curLogo.css("visibility", "visible");
                    }
                } else {
                    this.logo = null;
                    this.viewer.whtLogo.css("visibility", "hidden");
                    this.viewer.blkLogo.css("visibility", "hidden");
                }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            // 2D render (dynamic)
            var gx = this.gx;
            gx.clearRect(0, 0, width, height);
            this.ruler.Render();
            if (this.handler) {
                this.handler.RenderMarkup2D(navigator.uTVP);
                this.handler.Render2DOverlay(width, height);
            }
            navigator.Render2D();
            if (this.depthPeel) {
                var fontHeight = 11;
                var containerInnerBorder = 0;
                var canvasInnerBorder = 10;
                var locX = canvasInnerBorder;
                var locY = height - canvasInnerBorder;
                gx.font = fontHeight + 'px Verdana';
                gx.textAlign = "start";
                gx.textBaseline = "top";
                var t = "Peel passes: " + this.depthPeelPass + "/" + this.depthPeelPasses;
                var s = gx.measureText(t);
                // draw container
                var w = s.width + 2 * containerInnerBorder;
                var h = 1.1 * fontHeight + 2 * containerInnerBorder; // font height does not include descenders
                var x = locX;
                var y = locY - h;
                gx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                gx.fillRect(x, y, w, h);
                // draw text
                x += containerInnerBorder;
                y += containerInnerBorder;
                gx.fillStyle = 'rgba(0, 0, 0, 1)';
                gx.fillText(t, x, y);
            } else if (this.AnyHit() ||
                       (this.MarkupState === GLTFViewer.Utils.Markup.STATE_ENABLED && this.MarkupLineType === GLTFViewer.Utils.Markup.LINE_TYPE_2D && !this.MarkupSelect) ||
                       (this.MarkupState === GLTFViewer.Utils.Markup.STATE_CREATE_LINE && this.MarkupTip())) {
                var xy = navigator.lastLocation;
                if (!GLTFViewer.Utils.IsNull(xy)) {
                    var x = xy.x;
                    var y = xy.y;
                    var tip = null;
                    if (navigator.mouseOver) {
                        if (this.MarkupState === GLTFViewer.Utils.Markup.STATE_ENABLED && this.MarkupLineType === GLTFViewer.Utils.Markup.LINE_TYPE_2D && !this.MarkupSelect)
                            tip = "(" + (x / width).toFixed(4) + ", " + (y / height).toFixed(4) + ")";
                        else if (this.MarkupState === GLTFViewer.Utils.Markup.STATE_CREATE_LINE)
                            tip = this.MarkupTip();
                        else
                            tip = this.handler ? this.handler.HitIndexTip() : null;
                    }
                    if (!GLTFViewer.Utils.IsNull(tip) && tip.length) {
                        var fontHeight = 11;
                        var lineSpacing = 2;
                        var lineHeight = (fontHeight + 3) + lineSpacing;
                        var tipPadding = 2;
                        var tipXOffset = 18;
                        var tipYOffset = 10;

                        var tipSpaceWidthRight = width - tipXOffset - 2 * tipPadding - 5 - x;
                        var tipSpaceWidthLeft = x - tipXOffset - 2 * tipPadding - 5;
                        var tipSpaceHeightBottom = height - tipYOffset - 2 * tipPadding - 5 - y;
                        var tipSpaceHeightTop = y - tipYOffset - 2 * tipPadding - 5;

                        gx.fillStyle = 'rgba(150, 150, 250, .25)';
                        gx.strokeStyle = 'rgba(250, 250, 250, .45)';
                        GLTFViewer.Utils.StrokeEllipse(gx, x - 8, y - 8, 16, 16);
                        GLTFViewer.Utils.FillEllipse(gx, x - 8, y - 8, 16, 16);
                        gx.font = fontHeight + 'px Verdana';

                        var _tipE = null;
                        var _heightE;
                        var _tipW = null;
                        var _heightW;
                        if (tipSpaceWidthRight > 20) {
                            _tipE = GLTFViewer.Utils.SplitLine(gx, tipSpaceWidthRight, tip);
                            _heightE = _tipE.data.length * lineHeight - lineSpacing;
                        }
                        if (tipSpaceWidthLeft > 20) {
                            _tipW = GLTFViewer.Utils.SplitLine(gx, tipSpaceWidthLeft, tip);
                            _heightW = _tipW.data.length * lineHeight - lineSpacing;
                        }
                        var fitSE = (_tipE && _tipE.width <= tipSpaceWidthRight && _heightE <= tipSpaceHeightBottom && (!_tipW || _tipE.width >= _tipW.width));
                        var fitSW = (_tipW && _tipW.width <= tipSpaceWidthLeft && _heightW <= tipSpaceHeightBottom && (!_tipE || _tipW.width >= _tipE.width));
                        var fitNW = (_tipW && _tipW.width <= tipSpaceWidthLeft && _heightW <= tipSpaceHeightTop && (!_tipE || _tipW.width >= _tipE.width));
                        var fitNE = (_tipE && _tipE.width <= tipSpaceWidthRight && _heightE <= tipSpaceHeightTop && (!_tipW || _tipE.width >= _tipW.width));

                        var toRight = (tipSpaceWidthRight > tipSpaceWidthLeft);
                        var toBottom = (tipSpaceHeightBottom > tipSpaceHeightTop);
                        var _tip = null;
                        if (fitSE) {
                            _tip = _tipE;
                            x += tipXOffset;
                            y += tipYOffset;
                        } else if (fitSW) {
                            _tip = _tipW;
                            x -= tipXOffset + _tipW.width;
                            y += tipYOffset;
                        } else if (fitNE) {
                            _tip = _tipE;
                            x += tipXOffset;
                            y -= tipYOffset + _heightE;
                        } else if (fitNW) {
                            _tip = _tipW;
                            x -= tipXOffset + _tipW.width;
                            y -= tipYOffset + _heightW;
                        }

                        if (_tip) {
                            var _width = _tip.width;
                            var _height = _tip.data.length * lineHeight - lineSpacing;
                            gx.fillStyle = 'rgba(255, 255, 200, .8)';
                            gx.fillRect(x, y, _width + 2 * tipPadding, _height + 2 * tipPadding);
                            gx.textAlign = "start";
                            gx.textBaseline = "top";
                            gx.fillStyle = 'rgba(0, 0, 0, 1)';
                            var offX = x + tipPadding;
                            var offY = y + tipPadding;
                            for (var i = 0; i < _tip.data.length; ++i) {
                                gx.fillText(_tip.data[i], offX, offY);
                                offY += lineHeight;
                            }
                        }
                    }
                }
            }
            if (this.showFrameRate && this.frameCountLast > 0) {
                var fontHeight = 11;
                var containerInnerBorder = 0;
                var canvasInnerBorder = 10;
                var locX = canvasInnerBorder;
                var locY = height - canvasInnerBorder;
                gx.font = fontHeight + 'px Verdana';
                var t = 'fps: ' + (this.frameCountLast / (this.frameTimeLast / 1000)).toFixed(2);
                var s = gx.measureText(t);
                // draw container
                var w = s.width + 2 * containerInnerBorder;
                var h = 1.1 * fontHeight + 2 * containerInnerBorder; // font height does not include descenders
                var x = locX;
                var y = locY - h;
                gx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                gx.fillRect(x, y, w, h);
                // draw text
                x += containerInnerBorder;
                y += containerInnerBorder;
                gx.fillStyle = 'rgba(0, 0, 0, 1)';
                gx.textAlign = "start";
                gx.textBaseline = "top";
                gx.fillText(t, x, y);
            }
            // border
            var border = this.viewer.DrawBorder();
            if (border[0]) {
                var w = border[1];
                var h = border[2];
                gx.strokeStyle = this._darkBorder ? 'rgba(192, 192, 192, 1)' : 'rgba(64, 64, 64, 1)';
                gx.lineWidth = 2;
                gx.beginPath();

                if (border[0] & 2) {
                    gx.moveTo(w - 1, 0);
                    gx.lineTo(w - 1, h);
                }
                if (border[0] & 4) {
                    gx.moveTo(0, h - 1);
                    gx.lineTo(w, h - 1);
                }
                gx.stroke();
            }
            if (this.viewer.wantPrint)
                this.viewer.SaveImage();
        }
    },
    GetImage: {
        value: function (callback) {
            function compositor(_callback, _data) {
                if (--_data.numImages > 0)
                    return;

                // there are some issues with some browsers relating to tainted canvases, "Chrome"
                // this is caused by rendering url's to the canvas
                // so determine if we have this problem
                {
                    var body = $("body");
                    body.append("<canvas style='position:absolute:top:-10px;left:-10px;width:10px;height:10px;background:transparent;'></canvas>");
                    var canvas = $("canvas", body).last();
                    canvas[0].width = 10; ;
                    canvas[0].height = 10;
                    var _gx = canvas[0].getContext('2d');
                    try {
                        _gx.drawImage(_data.image[0], 0, 0, 10, 10); // 3d
                        var imageData = canvas[0].toDataURL();
                    } catch (err) {
                        _data.image[0] = null;
                    }
                    try {
                        if (_data.maxImages > 2) {
                            _gx.drawImage(_data.image[2], 0, 0, 10, 10); // logo
                            var imageData = canvas[0].toDataURL();
                        }
                    } catch (err) {
                        _data.image[2] = null;
                    }
                    canvas.remove();
                }

                // composite them
                var width = this.navigator.canvasWidth;
                var height = this.navigator.canvasHeight;
                var gx = this.gx;
                gx.clearRect(0, 0, width, height);
                if (_data.image[0])
                    gx.drawImage(_data.image[0], 0, 0, width, height); // 3d
                gx.drawImage(_data.image[1], 0, 0, width, height); // 2d
                if (_data.maxImages > 2 && _data.image[2])
                    gx.drawImage(_data.image[2], width - (GLTFViewer.LOGOWIDTH + GLTFViewer.LOGORIGHTMARGIN), GLTFViewer.LOGOTOPMARGIN, GLTFViewer.LOGOWIDTH, GLTFViewer.LOGOHEIGHT); // logo

                var imageData;
                try {
                    imageData = this.overlay.toDataURL();
                } catch (err) {
                    // this should not happen
                }
                this.Invalidate(true);
                _callback(imageData);
            }
            function loadImage(_data, num, src, _callback) {
                _data.image[num] = new Image();
                _data.image[num].onload = _callback;
                _data.image[num].src = src;
            }

            var data = { image: [],
                numImages: 2,
                maxImages: 2
            };

            var image0;
            if (this.handler)
                image0 = this.canvas.toDataURL();
            else
                image0 = this.viewer.imageDir + "back.png"; // can't render this on chrome
            var image1 = this.overlay.toDataURL();
            var image2 = null;
            if (this.logo) {  // can't render logo on chrome
                image2 = this.logo[0].src;
                ++data.numImages;
                ++data.maxImages;
            }
            loadImage(data, 0, image0, compositor.bind(this, callback, data));
            loadImage(data, 1, image1, compositor.bind(this, callback, data));
            if (image2)
                loadImage(data, 2, image2, compositor.bind(this, callback, data));
        }
    },
    SetupLights: {
        value: function () {
            var v = this.defaultLightDirs[0].TransformCreate(this.navigator.projectionInvTM);
            this.lights[0].ambient.SetHsv(0, 0, 0);
            this.lights[0].diffuse.SetHsv(0, 0, 0);
            this.lights[0].specular.SetHsv(0, 0, .75);
            this.lights[0].dir.Set(v.x, v.y, v.z);
            v = this.defaultLightDirs[1].TransformCreate(this.navigator.projectionInvTM);
            this.lights[1].ambient.SetHsv(0, 0, 0.8);
            this.lights[1].diffuse.SetHsv(0, 0, 0.4);
            this.lights[1].specular.SetHsv(0, 0, .1);
            this.lights[1].dir.Set(v.x, v.y, v.z);
            var start = 0;
            for (var i = 0; i < 2; i++) {
                this.lights[i].ambient.ToArray(this.uLit, start);
                start += 4;
                this.lights[i].diffuse.ToArray(this.uLit, start);
                start += 4;
                this.lights[i].specular.ToArray(this.uLit, start);
                start += 4;
                this.lights[i].dir.ToArray(this.uLit, start);
                start += 4;
            }
        }
    },
    ReadFile: {
        value: function (handler, callback, loadType, sceneState) {
            if (handler !== this.handler)
                this.Reset();
            this.handler = handler;
            this.handler.ReadFile(callback, loadType, sceneState);
            this.Invalidate(true);
        }
    },
    SetCanvasSize: {
        value: function () {
            // var pr = window.devicePixelRatio || 1;
            // width and height must match viewer.c3d (canvas) width and height, so use current values
            var width = this.viewer.viewerWidth;
            var height = this.viewer.viewerHeight;
            if (width === 0 || height === 0)
                return false;
            if (this.handler)
                this.handler.Resize(width, height);
            if (this.navigator.canvasWidth === width && this.navigator.canvasHeight === height)
                return true; // no change
            this.Resize(width, height);
            this.navigator.SetSize(width, height);
            this.Invalidate(true);
            return true;
        }
    },
    Loop: {
        value: function (time) {
            this.RenderScene(time);
            this.requestAnimationID = requestAnimationFrame(this.Loop.bind(this));
        }
    },
    SetView: {
        value: function (view) {
            this.navigator.ZoomExtents(true, this.view[view]);
        }
    },
    MarkupTextEvent: {
        value: function (type, e) {
            if (this.handler)
                this.handler.MarkupTextEvent(type, e);
        }
    },
    MarkupState: {
        get: function () {
            if (!this.handler)
                return GLTFViewer.Utils.Markup.STATE_DISABLED;
            return this.handler.MarkupState;
        },
        set: function (state) {
            if (this.handler)
                this.handler.MarkupState = state;
        }
    },
    MarkupLineShape: {
        get: function () {
            if (!this.handler)
                return GLTFViewer.Utils.Markup.LINE_SYMBOL_NONE;
            return this.handler.MarkupLineShape;
        },
        set: function (shape) {
            if (this.handler)
                this.handler.MarkupLineShape = shape;
        }
    },
    MarkupLineType: {
        get: function () {
            if (!this.handler)
                return GLTFViewer.Utils.Markup.LINE_TYPE_2D;
            return this.handler.MarkupLineType;
        },
        set: function (typ) {
            if (this.handler)
                this.handler.MarkupLineType = typ;
        }
    },
    MarkupLineColor: {
        get: function () {
            if (!this.handler)
                return new GLTFViewer.Utils.RGBA(0, 0, 0, 255);
            return this.handler.MarkupLineColor;
        },
        set: function (col) {
            if (this.handler)
                this.handler.MarkupLineColor = col;
        }
    },
    MarkupFontColor: {
        get: function () {
            if (!this.handler)
                return new GLTFViewer.Utils.RGBA(0, 0, 0, 255);
            return this.handler.MarkupFontColor;
        },
        set: function (col) {
            if (this.handler)
                this.handler.MarkupFontColor = col;
        }
    },
    MarkupFontSize: {
        get: function () {
            if (!this.handler)
                return GLTFViewer.DEFAULT_MARKUP_FONT_SIZE;
            return this.handler.MarkupFontSize;
        },
        set: function (val) {
            if (this.handler)
                this.handler.MarkupFontSize = val;
        }
    },
    MarkupBackColor: {
        get: function () {
            if (!this.handler)
                return new GLTFViewer.Utils.RGBA(255, 255, 255, 127);
            return this.handler.MarkupBackColor;
        },
        set: function (col) {
            if (this.handler)
                this.handler.MarkupBackColor = col;
        }
    },
    MarkupSelect: {
        get: function () {
            if (!this.handler)
                return 0;
            return this.handler.MarkupSelect;
        }
    },
    MarkupHit: {
        get: function () {
            if (!this.handler)
                return 0;
            return this.handler.MarkupHit;
        }
    },
    MarkupStart: {
        value: function (x, y) {
            if (this.handler)
                this.handler.MarkupStart(x, y);
        }
    },
    MarkupUpdate: {
        value: function (x, y) {
            if (this.handler)
                this.handler.MarkupUpdate(x, y);
        }
    },
    MarkupEnd: {
        value: function (x, y) {
            if (this.handler)
                this.handler.MarkupEnd(x, y);
        }
    },
    MarkupCreate3D: {
        value: function () {
            if (this.handler) {
                this.UpdateHit(this.navigator._cursorRay, true);
                var x = this.navigator._cursorRay.x;
                var y = this.navigator._cursorRay.y;
                this.handler.MarkupCreate3D(x, y);
            }
        }
    },
    MarkupDelete: {
        value: function (key) {
            if (this.handler)
                this.handler.MarkupDelete(key);
        }
    },
    MarkupEsc: {
        value: function () {
            if (this.handler)
                this.handler.MarkupEsc();
        }
    },
    MarkupTip: {
        value: function () {
            if (!this.handler)
                return null;
            return this.handler.MarkupTip;
        }
    },
    MarkupEditable: {
        value: function (key) {
            if (!this.handler)
                return false;
            return this.handler.MarkupEditable(key);
        }
    },
    ClipState: {
        get: function () {
            if (!this.handler)
                return GLTFViewer.Utils.Clip.STATE_DISABLED;
            return this.handler.ClipState;
        },
        set: function (state) {
            if (this.handler)
                this.handler.ClipState = state;
        }
    },
    ClipViewState: {
        get: function () {
            if (!this.handler)
                return GLTFViewer.Utils.Clip.VIEWSTATE_NONE;
            return this.handler.ClipViewState;
        }
    },
    ClipDrawMode: {
        get: function () {
            if (!this.handler)
                return GLTFViewer.Utils.Clip.DRAWMODE_DONE;
            return this.handler.ClipDrawMode;
        },
        set: function (mode) {
            if (this.handler)
                this.handler.ClipDrawMode = mode;
        }
    },
    GetSceneBox: {
        value: function (dontExplode) {
            if (!this.handler)
                return GLTFViewer.Utils.Box.empty;
            return this.handler.GetSceneBox(dontExplode);
        }
    },

    EnableUpdate: {
        value: function (enable) {
            // do we want to do this, or how to we want to do this
            if (enable)
                this._enableUpdate.pop();
            else
                this._enableUpdate.push(1);
            if (this._enableUpdate.length === 0)
                this.Invalidate(true);
        }
    },
    Invalidate: {
        value: function (all) {
            if (all) {
                this.paintAll = true;
                this.depthPeelPass = 0;
            } else
                this.paint = true;
        }
    },
    IsEmpty: {
        value: function () {
            if (!this.handler)
                return true;
            return this.handler.IsEmpty;
        }
    },
    ResetProjection: {
        value: function () {
            if (this.navigator)
                this.navigator.projectionTM = this.view[0].Clone();
        }
    },
    SetExplosion: {
        value: function (val, update) {
            if (this.handler)
                this.handler.SetExplosion(val, update);
        }
    },
    GetExplosion: {
        value: function () {
            if (!this.handler)
                return 0;
            return this.handler.GetExplosion();
        }
    },
    ///////////////////////////////////////
    // hits
    AnyHit: {
        value: function () {
            if (!this.handler)
                return false;
            return this.handler.AnyHit();
        }
    },
    HitPoint: {
        value: function () {
            if (!this.handler)
                return null;
            return this.handler.HitPoint();
        }
    },
    HitIndx: {
        value: function () {
            if (!this.handler)
                return null;
            return this.handler.HitIndx();
        }
    },
    UpdateHit: {
        value: function (tCursorRay, updatePosition) {
            if (this.handler) {
                this.ResetHit();
                if (this.handler.HitTest(this.navigator.uTVP, this.navigator.canvasWidth, this.navigator.canvasHeight, tCursorRay, false)) {
                    if (updatePosition && this.AnyHit())
                        this.handler.HitTestPos(this.navigator.uTVP, this.navigator.canvasWidth, this.navigator.canvasHeight, tCursorRay);
                    this.Invalidate(); // have to do this to update ring around mouse
                } else if (this.MarkupState === GLTFViewer.Utils.Markup.STATE_ENABLED && this.MarkupLineType === GLTFViewer.Utils.Markup.LINE_TYPE_2D && !this.MarkupSelect)
                    this.Invalidate();
            }
        }
    },
    ResetHit: {
        value: function () {
            if (this.handler)
                this.handler.ResetHit();
        }
    },
    ///////////////////////////////////////
    // selections
    CanSelect: {
        value: function () {
            if (!this.handler)
                return false;
            return this.handler.CanSelect();
        }
    },
    SetSelectionMode: {
        value: function (mode) {
            if (this.handler)
                this.handler.SetSelectionMode(mode);
        }
    },
    GetSelectionMode: {
        value: function () {
            if (!this.handler)
                return GLTFViewer.SELECTION_BODY;
            return this.handler.GetSelectionMode();
        }
    },
    AnySelection: {
        value: function () {
            if (!this.handler)
                return false;
            return this.handler.AnySelection();
        }
    },
    UpdateSelection: {
        value: function (ctrlKey, altKey) {
            if (!this.handler)
                return false;
            return this.handler.UpdateSelection(ctrlKey, altKey);
        }
    },
    GetIndexSelection: {
        value: function() {
            if(!this.handler)
                return false;
            if (typeof this.handler.GetIndexSelection !== "function")
                return false;
            return this.handler.GetIndexSelection();
        }
    },
    ResetSelection: {
        value: function () {
            if (this.handler)
                if (this.handler.ResetSelection())
                    this.Invalidate();
        }
    },
    ///////////////////////////////////////
    GetTopParts: {
        value: function () {
            if (!this.handler)
                return null;
            return this.handler.GetTopParts();
        }
    },
    GetBodies: {
        value: function () {
            if (!this.handler)
                return null;
            return this.handler.GetBodies();
        }
    },
    SetHighlightBodyState: {
        value: function (name, on) {
            if (this.handler) {
                this.handler.SetHighlightBodyState(name, on);
                this.Invalidate();
            }
        }
    },
    GetPartName: {
        value: function (part) {
            if (!this.handler)
                return null;
            return this.handler.GetPartName(part);
        }
    },
    GetPartParent: {
        value: function (part) {
            if (!this.handler)
                return null;
            return this.handler.GetPartParent(part);
        }
    },
    GetPartParts: {
        value: function (part) {
            if (!this.handler)
                return null;
            return this.handler.GetPartParts(part);
        }
    },
    GetPartBodys: {
        value: function (part) {
            if (!this.handler)
                return null;
            return this.handler.GetPartBodys(part);
        }
    },
    GetBodyName: {
        value: function (body) {
            if (!this.handler)
                return null;
            return this.handler.GetBodyName(body);
        }
    },
    GetRegions: {
        value: function () {
            if (!this.handler)
                return null;
            return this.handler.GetRegions();
        }
    },
    GetRegionName: {
        value: function (region) {
            if (!this.handler)
                return null;
            return this.handler.GetRegionName(region);
        }
    },
    GetSelections: {
        value: function () {
            if (!this.handler)
                return null;
            return this.handler.GetSelections();
        }
    },
    GetParts: {
        value: function () {
            if (!this.handler)
                return null;
            return this.handler.GetParts();
        }
    },
    //
    // returns true if have an animation and allowed to play it
    HasAnimation: {
        value: function () {
            return this._animateAllowed && this.handler && this.handler.HasAnimation() && this.AnimationMaxTime() >= this.AnimationMinTime();
        }
    },
    AnimationSpeed: {
        value: function (val) {
            if (val > 0) {
                this._animateSpeed = val;
                // this._animateLastClockTime = null;
            }
        }
    },
    // returns the minimum time to show on slider control, you could normalize to 0
    AnimationMinTime: {
        value: function () {
            if (!this.handler)
                return 0;
            return this.handler.AnimationMinTime();
        }
    },
    // returns the maximum time to show on slider control
    AnimationMaxTime: {
        value: function () {
            if (!this.handler)
                return 0;
            return this.handler.AnimationMaxTime();
        }
    },
    // puts scene in position of given time
    AnimationShowFrame: {
        value: function (time) {
            this._animateCurTime = time;
            this.viewer.SetAnimationSlider(time, this._animateUpdateSlider);
            this._animateUpdateSlider = true;
            return this.handler && this.handler.AnimationShowFrame(time);
        }
    },
    AnimationPlayOneFrame: {
        value: function (time, updateSlider) {
            if (this.HasAnimation() && this._animateCurTime !== time) {
                this._animateOnce = true;
                // this._animateLastClockTime = null;
                this._animateUpdateSlider = updateSlider;
                this._animateCurTime = time;
            }
        }
    },
    // causes animation to play
    AnimationPlay: {
        value: function () {
            if (!this._animate && this.HasAnimation()) {
                this._animate = true;
                this._animateLastClockTime = null;
            }
        }
    },
    AnimationPause: {
        value: function () {
            this._animate = false;
        }
    },
    AnimationLoop: {
        get: function () {
            return this._animateLoop;
        },
        set: function (val) {
            this._animateLoop = val;
        }
    },
    AnimationStop: {
        value: function (dontPlayOne) {
            if (this.viewer && this.viewer.animationDialog && this.viewer.animationDialog.pauseButton)
                this.viewer.animationDialog.pauseButton.click();
            this.AnimationPause();
            if (!dontPlayOne)
                this.AnimationPlayOneFrame(this.AnimationMinTime(), true);
            else {
                this.viewer.SetAnimationSlider(this.AnimationMinTime(), true);
                this._animateCurTime = null;
            }
        }
    },
    AnimationStopped: {
        value: function () {
            return GLTFViewer.Utils.IsNull(this._animateCurTime) || this._animateCurTime === this.AnimationMinTime();
        }
    },
    ResetScene: {
        value: function (sceneItem) {
            this.AnimationStop(true);
            if (this.navigator && GLTFViewer.Utils.IsNull(sceneItem))
                this.navigator.Reset();
            if (this.handler)
                this.handler.ResetScene(sceneItem);
        }
    },
    //
    Reset: {
        value: function () {
            this.AnimationStop();
            this._animateLastClockTime = null;
            this._animateLoop = false;
            this._animate = false;
            this._animateOnce = false;
            this._animateUpdateSlider = false;
            this._animateCurTime = null;
            this.ResetProjection();
            if (this.ruler)
                this.ruler.Reset();
            if (this.navigator)
                this.navigator.Reset();
            if (this.handler) {
                this.handler.Clear();
                this.handler = null;
            }
            this._enableUpdate = [];
            this.paint = true;
            this.paintAll = true;
            this.depthPeel = false;
            this.depthPeelPasses = 20;
            this.depthPeelPass = 0;
            if (this.background)
                this.background.Reset();
            this.showFrameRate = false;
            this.frameCount = 0;
            this.frameTime = 0;
            this.frameCountLast = 0;
            this.frameTimeLast = 0;
            if (this.logoBlk)
                this.logoBlk.Reset();
            if (this.logoWht)
                this.logoWht.Reset();
        }
    },
    Clear: {
        value: function () {
            if (!GLTFViewer.Utils.IsNull(this._intervalTimer)) {
                clearInterval(this._intervalTimer);
                this._intervalTimer = null;
            }
            if (!GLTFViewer.Utils.IsNull(this.requestAnimationID)) {
                cancelAnimationFrame(this.requestAnimationID);
                this.requestAnimationID = null;
            }
            GLTFViewer.Utils.Scene.prototype.Reset.call(this);
            var gl = this.gl;
            if (this.ruler) {
                this.ruler.Clear();
                this.ruler = null;
            }
            if (this.navigator) {
                this.navigator.Clear();
                this.navigator = null;
            }
            this.progressBar = null;
            this.viewer = null;
            this.canvas = null;
            this.gx = null;
            this.container = null;
            this.overlay = null;
            this.progress = null;
            this._enableUpdate = null;

            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            if (!GLTFViewer.Utils.IsNull(this.g_frontColorBlenderDepthId)) {
                gl.deleteRenderbuffer(this.g_frontColorBlenderDepthId);
                this.g_frontColorBlenderDepthId = null;
            }
            if (!GLTFViewer.Utils.IsNull(this.g_frontColorBlenderFboId)) {
                gl.deleteFramebuffer(this.g_frontColorBlenderFboId);
                this.g_frontColorBlenderFboId = null;
            }
            if (!GLTFViewer.Utils.IsNull(this.g_frontColorBlenderTexId)) {
                gl.deleteTexture(this.g_frontColorBlenderTexId);
                this.g_frontColorBlenderTexId = null;
            }
            for (var i = 0; i < 2; ++i) {
                if (!GLTFViewer.Utils.IsNull(this.g_frontColorTexId))
                    gl.deleteTexture(this.g_frontColorTexId[i]);
                if (!GLTFViewer.Utils.IsNull(this.g_frontFboId))
                    gl.deleteFramebuffer(this.g_frontFboId[i]);
            }
            this.g_frontColorTexId = null;
            this.g_frontFboId = null;
            if (!GLTFViewer.Utils.IsNull(this.g_frontDepthId)) {
                gl.deleteRenderbuffer(this.g_frontDepthId);
                this.g_frontDepthId = null;
            }
            gl.deleteTexture(this._screenTexture);
            this._screenTexture = null;
            gl.deleteBuffer(this._screenQuadBuf);
            this._screenQuadBuf = null;

            if (this.screenShader !== null) {
                this.screenShader.DeleteProgram();
                this.screenShader = null;
            }
            if (this.logoBlk) {
                this.logoBlk.Clear();
                this.logoBlk = null;
            }
            if (this.logoWht) {
                this.logoWht.Clear();
                this.logoWht = null;
            }
            if (this.background) {
                this.background.Clear();
                this.background = null;
            }
            this._screenQuadDat = null;
            this.uLit = null;
            this.lights = null;
            this.defaultLightDirs = null;
            this.view = null;
            this.gl = null;
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.Scene, {
    // private members
    _vsScreen: {
        value: "uniform vec2 uSze;\n" +
               "attribute vec2 aPos;\n" +
               "attribute vec2 aTex;\n" +
               "varying vec2 vTex;\n" +
               "void main() {\n" +
                   "vec2 tmp = aPos / uSze * 2.0 - 1.0;\n" +
                   "vTex = aTex;\n" +
                   "gl_Position = vec4(tmp, 0, 1);\n" +
               "}"
    },
    _fsScreen: {
        value: "uniform sampler2D uSmp;\n" +
               "varying vec2 vTex;\n" +
               "void main(void) {\n" +
                   "gl_FragColor = texture2D(uSmp, vTex);\n" +
               "}"
    },
    // static methods
    Create: {
        value: function (viewer, container, canvas, overlay, progress) {
            var gl = null;
            gl = canvas.getContext("webgl", { antialias: true, preserveDrawingBuffer: true });
            if (!gl)
                gl = canvas.getContext("experimental-webgl", { antialias: true, preserveDrawingBuffer: true });
            if (gl) {
                var OES_texture_float = gl.getExtension('OES_texture_float');
                if (!OES_texture_float) {
                    var OES_texture_half_float = gl.getExtension('OES_texture_half_float');
                    if (!OES_texture_half_float) {
                        throw new Error("ERROR(Scene.Create): No support for OES_texture_float/OES_texture_half_float");
                    } else {
                        GLTFViewer.Utils.WriteErr("Note: low precision WebGL support has been detected.\nSome features have been disabled.");
                    }
                }        
                // Previously, failing this test resulted in an exception.  However, it is not
                // clear that failing this test is fatal, at least for the Fluent use-case.
                var WEBGL_color_buffer_float = gl.getExtension('WEBGL_color_buffer_float');
                if (!WEBGL_color_buffer_float) {
                    console.log("WARNING(Scene.Create): No support for WEBGL_color_buffer_float");
                }
            }
            if (!gl)
                throw new Error("ERROR(Scene.Create): No WebGL Support");
            var gx = overlay.getContext('2d');
            var scene = new GLTFViewer.Utils.Scene(viewer, container, canvas, overlay, gl, gx, progress);
            return scene;
        }
    }
    // public members
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Scene.ProgressBar = function (progressBar, container) {
    this._progressBar = progressBar;
    this._container = container;
};
GLTFViewer.Utils.Scene.ProgressBar.prototype = Object.create(null, {
    // private properties
    _totalBytes: { writable: true, value: 0 },
    // public properties
    // private methods
    // public methods
    Start: {
        value: function (totalBytes) {
            this._totalBytes = totalBytes;
            this._progressBar.value = 0;
            this._progressBar.style.visibility = 'visible';
            this._container.style.cursor = "wait";
        }
    },
    Update: {
        value: function (loaded) {
            if (this._totalBytes)
                this._progressBar.value = loaded / this._totalBytes;
        }
    },
    Stop: {
        value: function () {
            this._totalBytes = 0;
            this._progressBar.value = 0;
            this._progressBar.style.visibility = 'hidden';
            this._container.style.cursor = "default";
        }
    }
});
//
// GLTFViewer.Utils.Scene
//
///////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////
//
// Navigator
//
/** @constructor */
GLTFViewer.Utils.Navigator = function (scene, container, defaultProjectionTM) {
    this._scene = scene;
    this._container = container;
    this._type = GLTFViewer.Utils.Navigator.NavNone;
    this._defaultProjectionTM = defaultProjectionTM;
    this.projectionTM = defaultProjectionTM.Clone();
    this._navPtrs = {};
    this._navPtrs[GLTFViewer.Utils.Navigator.NavPan] = new GLTFViewer.Utils.Navigator.Pan(this);
    this._navPtrs[GLTFViewer.Utils.Navigator.NavZoom] = new GLTFViewer.Utils.Navigator.Zoom(this);
    this._navPtrs[GLTFViewer.Utils.Navigator.NavSpinXY] = new GLTFViewer.Utils.Navigator.SpinXY(this);
    this._navPtrs[GLTFViewer.Utils.Navigator.NavSpinZ] = new GLTFViewer.Utils.Navigator.SpinZ(this);
    this._navPtrs[GLTFViewer.Utils.Navigator.NavPinchRotate] = new GLTFViewer.Utils.Navigator.PinchRotate(this);
    this._navPtrs[GLTFViewer.Utils.Navigator.NavPinchZoom] = new GLTFViewer.Utils.Navigator.PinchZoom(this);
    this._navPtrs[GLTFViewer.Utils.Navigator.NavZoomBox] = new GLTFViewer.Utils.Navigator.ZoomBox(this);
    this._navTypes = Object.keys(this._navPtrs);
    this._cameraPos = new GLTFViewer.Utils.Vec3(0, 0, 3);
    this._nearPlane = 1;
    this._farPlane = 20;
    this._cameraUp = new GLTFViewer.Utils.Direction(0, 1, 0);
    this.cameraTM = GLTFViewer.Utils.Transformation.lookAtRH(this._cameraPos, GLTFViewer.Utils.Vec3.Origin, this._cameraUp);
    this.persp = false;
    this._animProjTranslation = new GLTFViewer.Utils.Vec3();
    this._animProjAxis = new GLTFViewer.Utils.Direction();
    this._touches = new GLTFViewer.Utils.Touch.List();
    this.keysDown = {};
    try {
        this._spinMarker = new GLTFViewer.Utils.Navigator.SpinMarker(scene.gl);
    } catch (err) {
    }
    try {
        this._triad = new GLTFViewer.Utils.Navigator.Triad(this, scene.gl);
    } catch (err) {
    }
    this._zoomBoxMarker = new GLTFViewer.Utils.Navigator.ZoomBoxMarker(this, scene.gx);
    this._isMobile = scene.viewer.mobile;
    this._moveTolerance2 = this._isMobile ? 64 : 9;
    this._cursorRay = new GLTFViewer.Utils.CursorRay(this);
    this._clipPlaneMoveDir = new GLTFViewer.Utils.Direction();
    this.uEye = new Float32Array(3);
    this.uTVP = new Float32Array(16);
    this.uTVPOrtho = new Float32Array(16);

    this._touchHandler = new GLTFViewer.Utils.TouchHandler(this._scene.viewer, $(this._container), this._ContainerStart.bind(this), this._ContainerMove.bind(this), this._ContainerFinish.bind(this),
                                                    this._ContainerWheel.bind(this), this._ContainerOver.bind(this), this._ContainerOut.bind(this), this._ContainerBlur.bind(this),
                                                    this._scene.viewer.ContainerContextMenu.bind(this._scene.viewer), this._debugTouch);

    this._container.addEventListener('keydown', this._KeyDown.bind(this), false);
    this._container.addEventListener('keyup', this._KeyUp.bind(this), false);
    this._container.__EKM__ = "EKM";
    this._scene.viewer.messageHandler.AddListener("Transform", this._Synchronize.bind(this, "READ"));
};
GLTFViewer.Utils.Navigator.prototype = Object.create(null, {
    // properties
    constructor: { value: GLTFViewer.Utils.Navigator },
    // private members
    _deleting: { writable: true, value: false },
    _debugTouch: { value: false }, // set to true to simulate touch with mouse click
    _clipPlaneOriginX: { writable: true, value: 0 },
    _clipPlaneOriginY: { writable: true, value: 0 },
    _clipPlaneOriginZ: { writable: true, value: 0 },
    _clipPlaneMoveDir: { writable: true, value: null },
    _scene: { writable: true, value: null },
    _container: { writable: true, value: null },
    _spinMarker: { writable: true, value: null },
    _triad: { writable: true, value: null },
    _zoomBoxMarker: { writable: true, value: null },
    _isMobile: { writable: true, value: false },
    _moveTolerance2: { writable: true, value: 9 },
    _type: { writable: true, value: null },
    _navPtrs: { writable: true, value: null },
    _navTypes: { writable: true, value: null },
    canvasWidth: { writable: true, value: 0 },
    canvasHeight: { writable: true, value: 0 },
    _normalizedWidth: { writable: true, value: 1 },
    _normalizedHeight: { writable: true, value: 1 },
    _cameraUp: { writable: true, value: null },
    _cameraPos: { writable: true, value: null },
    _nearPlane: { writable: true, value: 1.0 },
    _farPlane: { writable: true, value: 20.0 },
    _defaultProjectionTM: { writable: true, value: null },
    _projectionTM: { writable: true, value: null },         // projectionTM gets and sets
    _modelViewTM: { writable: true, value: null },          // modelViewTM gets and sets
    _transViewProjTM: { writable: true, value: null },      // transViewProj gets and sets
    _transViewProjOrthoTM: { writable: true, value: null }, // transViewProj gets and sets, only used for lighting of spin marker
    _worldScale: { writable: true, value: 1 },              // calling UpdateWorldScale sets this
    _animProjStart: { writable: true, value: null },
    _animProjEnd: { writable: true, value: null },
    _animProjCenter: { writable: true, value: null },
    _animProjTranslation: { writable: true, value: null },
    _animProjAxis: { writable: true, value: null },
    _animProjAngle: { writable: true, value: 0 },
    _animProjEndScale: { writable: true, value: 0 },
    _animProjStep: { writable: true, value: 0 },
    _animProjStepCount: { writable: true, value: 0 },
    _touches: { writable: true, value: null },
    _contextOK: { writable: true, value: true },
    _lastLocation: { writable: true, value: null },
    _lastState: { writable: true, value: null },
    // public members
    ps: { writable: true, value: 0 }, // pixel size
    persp: { writable: true, value: false },                // calling SetCamera sets this
    cameraTM: { writable: true, value: null },
    projectionGLTM: { writable: true, value: null },        // calling SetCamera2 sets this
    projection2DGLTM: { writable: true, value: null },      // calling SetCamera2 sets this
    modelViewInvTrp: { writable: true, value: null },       // calling modelViewTM sets this
    transViewProjInvTM: { writable: true, value: null },    // calling transViewProj sets this
    transViewProjOrthoInvTM: { writable: true, value: null },    // calling transViewProjOrthoTM sets this
    projectionInvTM: { writable: true, value: null },       // calling projectionTM sets this
    uEye: { writable: true, value: null },
    uTVP: { writable: true, value: null },
    uTVPOrtho: { writable: true, value: null }, // only used for lighting of spin marker
    mouseOver: { writable: true, value: false },
    keysDown: { writable: true, value: null },
    // private methods
    _ProcessStartEnd: {
        value: function (shiftKey, ctrlKey, altKey) {
            var cnt = this._touchHandler.Touches.Count();
            var newNav = GLTFViewer.Utils.Navigator.NavNone; // default is none
            if (cnt === 1) {
                if (this._isMobile)
                    newNav = GLTFViewer.Utils.Navigator.NavSpinXY;
                else {
                    var touch = this._touchHandler.Touches.GetTouchByIndex(0);
                    var touchID = this._debugTouch ? 1 : touch.GetID(); // 1 = LEFT, 4 = MIDDLE, 2 = RIGHT
                    var button = "";
                    if (ctrlKey)
                        button = button + (button.length ? "+" : "") + "CTRL";
                    if (shiftKey)
                        button = button + (button.length ? "+" : "") + "SHIFT";
                    button = button + (button.length ? "+" : "") + (touchID === 2 ? "RIGHT" : (touchID === 4 ? "MIDDLE" : "LEFT"));

                    var mm = this._scene.viewer.viewerState;
                    switch (mm[button]) {
                        case "Zoom":
                            newNav = GLTFViewer.Utils.Navigator.NavZoom;
                            break;
                        case "RotateXY":
                            newNav = GLTFViewer.Utils.Navigator.NavSpinXY;
                            break;
                        case "RotateZ":
                            newNav = GLTFViewer.Utils.Navigator.NavSpinZ;
                            break;
                        case "PanXY":
                            newNav = GLTFViewer.Utils.Navigator.NavPan;
                            break;
                        case "ZoomBox":
                            newNav = GLTFViewer.Utils.Navigator.NavZoomBox;
                            break;
                        default:
                        case "None":
                            break;
                    }
                }
            } else if (cnt > 1)
                newNav = GLTFViewer.Utils.Navigator.NavPan | GLTFViewer.Utils.Navigator.NavPinchZoom | GLTFViewer.Utils.Navigator.NavPinchRotate;
            for (var i = 0; i < this._navTypes.length; ++i) {
                if ((this._type & this._navTypes[i]) !== 0 && (newNav & this._navTypes[i]) === 0) {
                    // stop what needs to be stopped
                    this._navPtrs[this._navTypes[i]].MouseUp();
                    this._type &= ~this._navTypes[i];
                } else if ((this._type & this._navTypes[i]) === 0 && (newNav & this._navTypes[i]) !== 0) {
                    // start what needs to be started
                    this._navPtrs[this._navTypes[i]].MouseDown(this._touchHandler.Touches);
                    this._type |= this._navTypes[i];
                }
            }
        }
    },
    _KeyDown: {
        value: function (e) {
            if (this._deleting) return;
            this.keysDown[e.keyCode] = true;
            if (this.keysDown[27]) { // ESC
                this._scene.viewer.CloseContextMenus();
            } else if (!this.keysDown[16] && !this.keysDown[17] && this.keysDown[46]) { // Delete
                this._scene.MarkupDelete();
            } else if (this.keysDown[16] && !this.keysDown[17] && this.keysDown[68]) { // D
                this._scene.depthPeel = !this._scene.depthPeel; // depth peel
                this._scene.Invalidate(true);
            } else if (!this.keysDown[16] && !this.keysDown[17] && this.keysDown[107]) { // +
                ++this._scene.depthPeelPasses;
                this._scene.Invalidate(true);
            } else if (!this.keysDown[16] && !this.keysDown[17] && this.keysDown[109]) { // -
                if (--this._scene.depthPeelPasses < 1)
                    this._scene.depthPeelPasses = 1;
                this._scene.Invalidate(true);
            } else if (this.keysDown[16] && !this.keysDown[17] && this.keysDown[70]) // F
                this._scene.showFrameRate = !this._scene.showFrameRate; // frame rate display
            else if (!this.keysDown[16] && !this.keysDown[17] && this.keysDown[70]) // f
                this.ZoomExtents(true); // fit
            else if (!this.keysDown[16] && !this.keysDown[17] && this.keysDown[80]) // p
                this._scene.viewer.SaveImage(); // save image
            else if (!this.keysDown[16] && !this.keysDown[17] && this.keysDown[82]) // r
                this._scene.ResetScene(); // reset
            else if (!this.keysDown[16] && !this.keysDown[17] && this.keysDown[73]) // i
                this._scene.SetView(0); // isometric
            else if (this.keysDown[16] && !this.keysDown[17] && this.keysDown[88]) // X
                this._scene.SetView(4); // left
            else if (!this.keysDown[16] && !this.keysDown[17] && this.keysDown[88]) // x
                this._scene.SetView(5); // right
            else if (this.keysDown[16] && !this.keysDown[17] && this.keysDown[89]) // Y
                this._scene.SetView(6); // front
            else if (!this.keysDown[16] && !this.keysDown[17] && this.keysDown[89]) // y
                this._scene.SetView(7); // back
            else if (this.keysDown[16] && !this.keysDown[17] && this.keysDown[90]) // Z
                this._scene.SetView(3); // bottom
            else if (!this.keysDown[16] && !this.keysDown[17] && this.keysDown[90]) // z
                this._scene.SetView(2); // top
            else if (this.keysDown[37] || this.keysDown[38] || this.keysDown[39] || this.keysDown[40]) { // LEFT/UP/RIGHT/DOWN
                var degrees1or5 = 0.08726646259971647884618453842443 * (this.keysDown[16] ? 0.2 : 1);
                var ctr = GLTFViewer.Utils.Vec3.Origin;
                this._scene.GetSceneBox().GetCenter(ctr);
                if (!this.keysDown[17] && this.keysDown[37]) // LEFT
                    this.SceneRotate(new GLTFViewer.Utils.Direction(0, -1, 0), degrees1or5, ctr); // rotate left
                else if (!this.keysDown[17] && this.keysDown[38]) // UP
                    this.SceneRotate(new GLTFViewer.Utils.Direction(-1, 0, 0), degrees1or5, ctr); // rotate back
                else if (!this.keysDown[17] && this.keysDown[39]) // RIGHT
                    this.SceneRotate(new GLTFViewer.Utils.Direction(0, 1, 0), degrees1or5, ctr); // rotate right
                else if (!this.keysDown[17] && this.keysDown[40]) // DOWN
                    this.SceneRotate(new GLTFViewer.Utils.Direction(1, 0, 0), degrees1or5, ctr); // rotate forward
                else if (this.keysDown[17] && this.keysDown[38]) // CTRL-UP
                    this.SceneRotate(new GLTFViewer.Utils.Direction(0, 0, -1), degrees1or5, ctr); // rotate clockwise
                else if (this.keysDown[17] && this.keysDown[40]) // CTRL-DOWN
                    this.SceneRotate(new GLTFViewer.Utils.Direction(0, 0, 1), degrees1or5, ctr); // rotate counterclockwise
            }

            else if (!this.keysDown[16] && !this.keysDown[17] && this.keysDown[77]) { // M
                var mu = GLTFViewer.Utils.GetMemoryUsage();
                if (mu)
                    GLTFViewer.Utils.WriteLn("Memory: rss: " + mu.rss / 1024 + "   heapTotal: " + mu.heapTotal / 1024 + "   heapUsed: " + mu.heapUsed / 1024);
            }

            this._scene.Invalidate();
        }
    },
    _KeyUp: {
        value: function (e) {
            if (this._deleting) return;
            delete this.keysDown[e.keyCode];
            this._scene.Invalidate();
        }
    },
    _ProcessMove: {
        value: function () {
            if (this._deleting) return;
            for (var i = 0; i < this._navTypes.length; ++i) {
                if ((this._type & this._navTypes[i]) !== 0)
                    this._navPtrs[this._navTypes[i]].MouseMove(this._touchHandler.Touches);
            }
        }
    },
    _ProcessUpdate: {
        value: function () {
            if (this._deleting) return;
            for (var i = 0; i < this._navTypes.length; ++i) {
                if ((this._type & this._navTypes[i]) !== 0)
                    this._navPtrs[this._navTypes[i]].UpdateMouseDown(this._touchHandler.Touches);
            }
        }
    },
    _WorldToScreen: {
        value: function (worldTrans) {
            var projTransform;
            if (this.persp)
                projTransform = GLTFViewer.Utils.Transformation.perspectiveRH(this._normalizedWidth, this._normalizedHeight, this._nearPlane, this._farPlane);
            else
                projTransform = GLTFViewer.Utils.Transformation.orthoRH(this._normalizedWidth, this._normalizedHeight, this._nearPlane, this._farPlane);
            return projTransform.Multiply(this.cameraTM).Multiply(worldTrans);
        }
    },
    _UnprojectRay2: {
        value: function (pnt, dir, trans) {
            var p2 = pnt.Clone().Add(dir);
            this.UnProject(pnt, trans);
            this.UnProject(p2, trans);
            var v = GLTFViewer.Utils.Vec3.Create(pnt, p2);
            var d = v.GetDirection();
            dir.x = d.x;
            dir.y = d.y;
            dir.z = d.z;
        }
    },
    _ContainerBlur: {
        value: function (e) {
            this.keysDown = {};
        }
    },
    _ContainerOver: {
        value: function (e) {
            this.mouseOver = true;
            this._scene.Invalidate();
        }
    },
    _ContainerOut: {
        value: function (e) {
            this.mouseOver = false;
            this._scene.ResetHit();
        }
    },
    _ContainerWheel: {
        value: function (e, xy, delta) {
            if (this._scene.IsEmpty())
                return;
            var mm = this._scene.viewer.viewerState;
            if (mm[GLTFViewer.MOUSEBUTTONS[0]] !== "Zoom")
                return;
            var scale = 1.2;
            if (delta > 0)
                scale = 1 / scale;
            var pnt = new GLTFViewer.Utils.Vec3(xy.x, xy.y, 0);
            this.UnProject(pnt);
            var z = this.projectionTM.a33 / scale;
            if (z <= 1e-5)
                scale = this.projectionTM.a33 / 1e-5;
            else if (z >= 1e5)
                scale = this.projectionTM.a33 / 1e5;
            this.SetProjection(GLTFViewer.Utils.Transformation.MultiplyCreate(this.projectionTM, GLTFViewer.Utils.Transformation.ScaleCreate(scale)), false);
            var newPoint = new GLTFViewer.Utils.Vec3(xy.x, xy.y, 0);
            this.UnProject(newPoint);
            this.SetProjection(GLTFViewer.Utils.Transformation.MultiplyCreate(this.projectionTM, GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(pnt, newPoint))), false);
        }
    },
    _ContainerStart: {
        value: function (e) {
            this._scene.viewer.activeViewer = this._scene.viewer;
            var scene = this._scene;
            scene.viewer.CloseContextMenus();
            if (!this._isMobile)
                scene.viewer.MenuFade(true);
            var cnt = this._touchHandler.Touches.Count();
            this._lastLocation = this._touchHandler.Touches.GetLastLocation(); // 1 or more touches
            var x = this._lastLocation.x;
            var y = this._lastLocation.y;
            this._cursorRay.Update(x, y);
            this._contextOK = !scene.MarkupHit;

            if (cnt === 1) {
                if (scene.ClipDrawMode === GLTFViewer.Utils.Clip.DRAWMODE_MOVE) {
                    var pnt = new GLTFViewer.Utils.Vec3();
                    this._cursorRay.Update(x, y);
                    if (scene.handler._clip.clipPlane.GetPoint(this._cursorRay.ray, pnt)) {
                        // start moving clip plane
                        this._clipPlaneOriginX = scene.handler._clip.clipPlane.orgn.x;
                        this._clipPlaneOriginY = scene.handler._clip.clipPlane.orgn.y;
                        this._clipPlaneOriginZ = scene.handler._clip.clipPlane.orgn.z;
                        pnt = scene.handler._clip.clipPlane.orgn.Clone();
                        this.Project(pnt);
                        var xx = pnt.x;
                        var yy = pnt.y;
                        pnt.x = this._clipPlaneOriginX + scene.handler._clip.clipPlane.diz.x * this.ps;
                        pnt.y = this._clipPlaneOriginY + scene.handler._clip.clipPlane.diz.y * this.ps;
                        pnt.z = this._clipPlaneOriginZ + scene.handler._clip.clipPlane.diz.z * this.ps;
                        this.Project(pnt);
                        this._clipPlaneMoveDir.Set(pnt.x - xx, pnt.y - yy, 0);
                        scene.handler._clip.clipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_MOVING;
                    }
                    return;
                }

                scene.UpdateHit(this._cursorRay, true);
            }

            // some kind of navigation
            this._ProcessStartEnd(e.shiftKey, e.ctrlKey, e.altKey);
        }
    },
    _ContainerMove: {
        value: function (e) {
            var scene = this._scene;
            var cnt = this._touchHandler.Touches.Count();
            if (cnt)
                this._lastLocation = this._touchHandler.Touches.GetLastLocation(); // 1 or more touches
            else
                this._lastLocation = GLTFViewer.Utils.GetClientXY(this._container, e); // 0 touches
            var x = this._lastLocation.x;
            var y = this._lastLocation.y;
            var shiftKey = e.shiftKey;
            var ctrlKey = e.ctrlKey;
            var altKey = e.altKey;
            var didMove = (this._touchHandler.Touches.GetDistanceMoved2() >= this._moveTolerance2 || (this._touchHandler.Touches.GetElapsedTime() > 100 && this._touchHandler.Touches.GetDistanceMoved2() > 0));
            this._cursorRay.Update(x, y);
            if (cnt >= 1 && this._touchHandler.Touches.GetDistanceMoved2() >= this._moveTolerance2)
                this._contextOK = false;

            // no touches/mouse presses
            if (cnt === 0) {
                // do nothing if clip plane is in movable state
                if (scene.ClipDrawMode === GLTFViewer.Utils.Clip.DRAWMODE_MOVE) {
                    scene.Invalidate(); // need to redraw cursor
                    return;
                }

                // highlight
                scene.UpdateHit(this._cursorRay, scene.MarkupState !== GLTFViewer.Utils.Markup.STATE_DISABLED);

                return;
            }

            // 1 or more touches/mouse presses

            if (scene.ClipDrawMode === GLTFViewer.Utils.Clip.DRAWMODE_MOVING) {
                // move clip plane
                var t = this._touchHandler.Touches.GetStartDelta(1);
                var v = this._clipPlaneMoveDir.GetComponent(new GLTFViewer.Utils.Vec3(t.x, t.y, 0));
                var d = v.GetMagnitude();
                d = this.ps * d;
                var s = this._clipPlaneMoveDir.Dot(new GLTFViewer.Utils.Vec3(v.x, v.y, 0));
                if (s < 0)
                    d = -d;
                scene.handler._clip.clipPlane.orgn.x = this._clipPlaneOriginX + scene.handler._clip.clipPlane.diz.x * d;
                scene.handler._clip.clipPlane.orgn.y = this._clipPlaneOriginY + scene.handler._clip.clipPlane.diz.y * d;
                scene.handler._clip.clipPlane.orgn.z = this._clipPlaneOriginZ + scene.handler._clip.clipPlane.diz.z * d;
                scene.handler._clip.UpdateClip();
                scene.Invalidate(true);
                return;
            }

            if (cnt === 1) {
                if (scene.MarkupState === GLTFViewer.Utils.Markup.STATE_ENABLED && didMove) {
                    var shift = shiftKey && !ctrlKey;
                    var ctrl = !shiftKey && ctrlKey;
                    var none = !shiftKey && !ctrlKey;
                    if (none)
                        scene.MarkupStart(x, y);
                    if (scene.MarkupState === GLTFViewer.Utils.Markup.STATE_CREATE_LINE) // just created a markup
                        this._touchHandler.StopLongTouch();
                }

                if (scene.MarkupState === GLTFViewer.Utils.Markup.STATE_CREATE_LINE || scene.MarkupState === GLTFViewer.Utils.Markup.STATE_EDIT_MOVE) {
                    scene.MarkupUpdate(x, y);
                    return;
                }

                if (scene.MarkupState !== GLTFViewer.Utils.Markup.STATE_DISABLED)
                    return;
            }

            // some kind of navigation
            this._ProcessStartEnd(shiftKey, ctrlKey, altKey);
            if (cnt > 1 || didMove)
                this._ProcessMove();
            else
                this._ProcessUpdate();

            //              scene.ResetHit();
        }
    },
    _ContainerFinish: {
        value: function (e, touches, didLongTouch) {
            var scene = this._scene;
            var cnt = this._touchHandler.Touches.Count();
            var x = this._lastLocation.x;
            var y = this._lastLocation.y;
            var shiftKey = e.shiftKey;
            var ctrlKey = e.ctrlKey;
            var altKey = e.altKey;
            var didClick = (touches && touches.length > 0 && touches[0].GetDistanceMoved2() < this._moveTolerance2);
            this._cursorRay.Update(x, y);

            // end navigation
            if (this._type !== GLTFViewer.Utils.Navigator.NavNone)
                this._ProcessStartEnd(shiftKey, ctrlKey, altKey);

            if (cnt === 0) {
                // CLIPPING
                if (scene.ClipDrawMode === GLTFViewer.Utils.Clip.DRAWMODE_MOVING) {
                    scene.handler._clip.clipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_MOVE;
                    scene.Invalidate();
                    return;
                }

                if (didClick) {
                    if (scene.ClipViewState === GLTFViewer.Utils.Clip.VIEWSTATE_PREVIEW) {
                        scene.UpdateHit(this._cursorRay, true);
                        if (scene.handler._clip.clipDrawMode === GLTFViewer.Utils.Clip.DRAWMODE_1_PT)
                            scene.handler._clip.SetClipPoint(scene.handler.GetClipPlane());
                        else
                            scene.handler._clip.SetClipPoint(scene.HitPoint());
                        scene.Invalidate(true);
                        return;
                    }
                }

                // MARKUP
                if (scene.MarkupHit)
                    this._contextOK = false;
                if (scene.MarkupState === GLTFViewer.Utils.Markup.STATE_CREATE_LINE || scene.MarkupState === GLTFViewer.Utils.Markup.STATE_EDIT_MOVE) {
                    scene.MarkupEnd(x, y);
                    return;
                }

                if (didClick && !didLongTouch) {
                    if (scene.MarkupState !== GLTFViewer.Utils.Markup.STATE_DISABLED) {
                        var shift = shiftKey && !ctrlKey;
                        var ctrl = !shiftKey && ctrlKey;
                        var none = !shiftKey && !ctrlKey;
                        if (none) {
                            scene.UpdateHit(this._cursorRay, false);
                            if (scene.UpdateSelection(ctrlKey, altKey))
                                scene.Invalidate();
                            else {
                                scene.MarkupStart(x, y);
                                scene.MarkupEnd(x, y);
                            }
                        }
                        return;
                    }

                    // mouse click
                    scene.UpdateHit(this._cursorRay, false);
                    scene.UpdateSelection(ctrlKey, altKey);
                    // Selection of part
                    if (touches["0"]._id === 1) {
                        scene.GetIndexSelection();
                    }
                }

                scene.Invalidate(true);
                return;
            }
            // will pick up a change from many touches to lesser touches later
        }
    },
    _GetPixelSize: {
        value: function () {
            var x = this.canvasWidth / 2.0;
            var y = this.canvasHeight / 2.0;
            var rayPos = new GLTFViewer.Utils.Vec3(x, y, 0);
            var tmp = new GLTFViewer.Utils.Vec3(x + 1, y, 0);
            this.UnProject(rayPos);
            this.UnProject(tmp);
            return GLTFViewer.Utils.Vec3.Create(rayPos, tmp).GetMagnitude();
        }
    },
    // public methods
    active: {
        get: function () {
            return this._touchHandler.TouchActive; // || Object.keys(this.keysDown).length;        
        }
    },
    lastLocation: {
        get: function () {
            if (this._lastLocation)
                return this._lastLocation;
            return null;
        }
    },
    state: {
        get: function () {
            var val = {};
            val.projectionTM = this.projectionTM.Clone();
            val.worldScale = this._worldScale;
            val.persp = this.persp;

            return val;
        },
        set: function (val) {
            this.projectionTM = val.projectionTM.Clone();
            this._worldScale = val.worldScale;
            this.persp = val.persp;

            this.SetProjection(this.projectionTM, false);
        }
    },
    DoGamePad: {
        value: function () {
            // the gamepad can only apply to the selected viewer
            if (!document.hasFocus() || this._scene.viewer.activeViewer !== this._scene.viewer)
                return;
            var gamepads = ('function' == typeof navigator.getGamepads ? navigator.getGamepads() : void 0) ||
                ('function' == typeof navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : void 0) ||
                {};
            for (var i = 0; i < gamepads.length; ++i) {
                var gamepad = gamepads[i];
                if (!GLTFViewer.Utils.IsNull(gamepad)) {
                    if (gamepad.connected && gamepad.timestamp > 0 && gamepad.axes.length) {
                        var didRotate = false;
                        for (var j = 0; j < gamepad.axes.length && j < 6; ++j) {
                            var amt = 10 * gamepad.axes[j];
                            if (amt) {
                                var ctr = this._scene.GetSceneBox().GetCenter();
                                switch (j) {
                                    case 0: // slide left / right => pan x left / right
                                    case 2: // lift up / push down => pan y up / down
                                        var plane = new GLTFViewer.Utils.Plane(ctr, GLTFViewer.Utils.Direction.diz);
                                        var cursorRay = new GLTFViewer.Utils.CursorRay(this);
                                        plane.Set(ctr, this.projectionInvTM.GetZDirection());
                                        cursorRay.Update(0, 0);
                                        var p0 = new GLTFViewer.Utils.Vec3();
                                        plane.GetPoint(cursorRay.ray, p0);
                                        var p1 = new GLTFViewer.Utils.Vec3();
                                        cursorRay.Update(j === 0 ? amt : 0, j === 2 ? amt : 0);
                                        plane.GetPoint(cursorRay.ray, p1);
                                        var proj = GLTFViewer.Utils.Transformation.MultiplyCreate(this.projectionTM, GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(p0, p1)));
                                        this.SetProjection(proj, false);
                                        break;
                                    case 1: // slide backward / forward => zoom out / in
                                        var scale = Math.exp(amt / 160);
                                        var z = this.projectionTM.a33 / scale;
                                        if (z <= 1e-5)
                                            scale = this.projectionTM.a33 / 1e-5;
                                        else if (z >= 1e5)
                                            scale = this.projectionTM.a33 / 1e5;
                                        var proj = GLTFViewer.Utils.Transformation.MultiplyCreate(this.projectionTM, GLTFViewer.Utils.Transformation.ScaleCreate(scale));
                                        this.SetProjection(proj, false);
                                        break;
                                    case 3: // rotate back / forward => rotate y up / down
                                    case 4: // rotate CCW / CW => rotate x right / left
                                    case 5: // rotate left / right => rotate screen z up /down
                                        didRotate = true;
                                        var ball = new GLTFViewer.Utils.Ball();
                                        ball.onBegin(ctr.x, ctr.y);
                                        ball.onMove(ctr.x - (j === 5 ? amt : 0), ctr.y + (j !== 5 ? amt : 0));
                                        if (!ball.d.IsZero()) {
                                            if (j === 4) {
                                                ball.d.z = ball.d.x;
                                                ball.d.x = 0;
                                            }
                                            var alongAxis = ball.d.TransformCreate(this.projectionInvTM);
                                            var angle = ball.a;
                                            var proj = GLTFViewer.Utils.Transformation.MultiplyCreate(this.projectionTM, GLTFViewer.Utils.Transformation.RotationAboutAxisCreate(new GLTFViewer.Utils.Line(ctr, alongAxis.GetDirection()), angle));

                                            // need to ensure bounding box Z is at center
                                            var box = this._scene.GetSceneBox().Clone().Multiply(proj);
                                            proj = GLTFViewer.Utils.Transformation.MultiplyCreate(GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(new GLTFViewer.Utils.Vec3(0, 0, box.GetCenter().z), GLTFViewer.Utils.Vec3.Origin)), proj);

                                            this.SetProjection(proj, false);
                                        }
                                        break;
                                }
                            }
                        }
                        this._scene.UpdateHit(this._cursorRay, false);
                    }
                }
            }
        }
    },
    ClearKeys: {
        value: function () {
            this.keysDown = {};
        }
    },
    OkToShowContextMenu: {
        value: function () {
            return this._contextOK && this._touchHandler.Touches.Count() === 0;
        }
    },
    SetSize: {
        value: function (width, height) {
            this.canvasWidth = width;
            this.canvasHeight = height;
            this._normalizedWidth = width < height ? 1 : width / height;
            this._normalizedHeight = height < width ? 1 : height / width;
            this.SetCamera2();
        }
    },
    Reset: {
        value: function () {
            this._touchHandler.StopLongTouch();
            if (this._spinMarker)
                this._spinMarker.Reset();
            if (this._triad)
                this._triad.Reset();
            if (this._zoomBoxMarker)
                this._zoomBoxMarker.Reset();
            this._type = GLTFViewer.Utils.Navigator.NavNone;
            for (var i = 0; i < this._navTypes.length; ++i)
                this._navPtrs[this._navTypes[i]].Reset();
            this.projectionTM = this._defaultProjectionTM.Clone();
            this._worldScale = 1;
            this._animProjStep = 0;
            this._animProjStepCount = 0;
            this.ps = 0;
            this.lastState = null;
            this.persp = false;
        }
    },
    Clear: {
        value: function () {
            this._deleting = true;
            GLTFViewer.Utils.Navigator.prototype.Reset.call(this);
            if (this._spinMarker) {
                this._spinMarker.Clear();
                this._spinMarker = null;
            }
            if (this._triad) {
                this._triad.Clear();
                this._triad = null;
            }
            if (this._zoomBoxMarker) {
                this._zoomBoxMarker.Clear();
                this._zoomBoxMarker = null;
            }
            if (this._touches) {
                this._touches.Clear();
                this._touches = null;
            }
            for (var i = 0; i < this._navTypes.length; ++i) {
                this._navPtrs[this._navTypes[i]].Clear();
                this._navPtrs[this._navTypes[i]] = null;
            }
            this._navPtrs = null;
            this.keysDown = null;
            this._container = null;
            this._type = null;
            this._navTypes = null;
            this._cameraPos = null;
            this._cameraUp = null;
            this.cameraTM = null;
            this.projectionGLTM = null;
            this.projection2DGLTM = null;
            this._defaultProjectionTM = null;
            this._projectionTM = null;
            this._modelViewTM = null;
            this.modelViewInvTrp = null;
            this._transViewProjTM = null;
            this.transViewProjInvTM = null;
            this.transViewProjOrthoInvTM = null;
            this.uEye = null;
            this.uTVP = null;
            this.uTVPOrtho = null;
            this._animProjStart = null;
            this._animProjEnd = null;
            this._animProjCenter = null;
            this._animProjTranslation = null;
            this._animProjAxis = null;
            this._lastLocation = null;
            this._lastState = null;
            this._cursorRay = null;
            this._clipPlaneMoveDir = null;
            this._scene = null;
        }
    },
    StartRender: {
        // called before any rendering
        value: function () {
            if (this._deleting) return;
            this.ps = this._GetPixelSize();
            // define eye position
            var tPnt = new GLTFViewer.Utils.Vec3(0, 0, -100);
            this.UnProject(tPnt);
            tPnt.ToArray(this.uEye, 0);
            //
            this.transViewProjTM.ToArray(this.uTVP);
            if (this.persp)
                this.transViewProjOrthoTM.ToArray(this.uTVPOrtho);
        }
    },
    Render3D: {
        // perhaps there is some stuff that the navigator should render
        value: function (lighting) {
            if (this._deleting) return;
            if (this._spinMarker) {
                if (this.persp) {
                    var ctr = null;
                    if (this.IsType(GLTFViewer.Utils.Navigator.NavSpinXY) || this.IsType(GLTFViewer.Utils.Navigator.NavSpinZ) || this.IsType(GLTFViewer.Utils.Navigator.NavZoom))
                        ctr = this._navPtrs[this._type].GetCenter().Clone();
                    if (ctr) {
                        this.Project(ctr);
                        this.UnProject(ctr, this.transViewProjOrthoInvTM);
                        this._spinMarker.Render(this.uTVPOrtho, this.uEye, lighting, this.ps, this.canvasWidth, this.canvasHeight, ctr);
                    }
                } else {
                    if (this.IsType(GLTFViewer.Utils.Navigator.NavSpinXY) || this.IsType(GLTFViewer.Utils.Navigator.NavSpinZ) || this.IsType(GLTFViewer.Utils.Navigator.NavZoom))
                        this._spinMarker.Render(this.uTVP, this.uEye, lighting, this.ps, this.canvasWidth, this.canvasHeight, this._navPtrs[this._type].GetCenter());
                }
            }
        }
    },
    Render2D: {
        // perhaps there is some stuff that the navigator should render
        value: function () {
            if (this._deleting) return;
            if (this._triad && !this._scene.viewer._option["tn"])
                this._triad.Render(this.canvasWidth, this.canvasHeight);
            if (this._zoomBoxMarker && this.IsType(GLTFViewer.Utils.Navigator.NavZoomBox)) {
                // render zoom box
                var loc = this._navPtrs[GLTFViewer.Utils.Navigator.NavZoomBox].GetLoc();
                this._zoomBoxMarker.Render(loc[0], loc[1], loc[2], loc[3]);
            }
        }
    },
    zoom: {
        get: function () {
            return this.projectionTM.a33 / this._worldScale;
        }
    },
    projectionTM: {
        get: function () {
            return this._projectionTM;
        },
        set: function (v) {
            this._projectionTM = v;
            this.projectionInvTM = this._projectionTM.Clone().Invert();
        }
    },
    modelViewTM: {
        get: function () {
            return this._modelViewTM;
        },
        set: function (v) {
            this._modelViewTM = v;
            this.modelViewInvTrp = this._modelViewTM.Clone().Invert().Transpose();
        }
    },
    transViewProjTM: {
        get: function () {
            return this._transViewProjTM;
        },
        set: function (v) {
            this._transViewProjTM = v;
            this.transViewProjInvTM = this._transViewProjTM.Clone().Invert();
        }
    },
    transViewProjOrthoTM: {
        get: function () {
            return this._transViewProjOrthoTM;
        },
        set: function (v) {
            this._transViewProjOrthoTM = v;
            this.transViewProjOrthoInvTM = this._transViewProjOrthoTM.Clone().Invert();
        }
    },
    IsType: {
        value: function (type) {
            return (this._type & type) !== 0 || this._type === type;
        }
    },
    ZoomExtents: {
        value: function (animate, proj) {
            var box = this._scene.GetSceneBox();
            if (GLTFViewer.Utils.IsNull(proj))
                proj = this.projectionTM;
            if (!box.IsSane() || box.IsEmpty() || this.canvasHeight === 0 || this.canvasWidth === 0)
                return proj;
            var trans = proj.Clone();
            trans.a33 = this._worldScale;
            var tmpBox = box.Clone().Multiply(trans);
            trans = GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(tmpBox.GetCenter(), GLTFViewer.Utils.Vec3.Origin)).Multiply(trans);
            var mi = new GLTFViewer.Utils.Vec3(GLTFViewer.Utils.maxValue, GLTFViewer.Utils.maxValue, 0);
            var ma = new GLTFViewer.Utils.Vec3(-GLTFViewer.Utils.maxValue, -GLTFViewer.Utils.maxValue, 0);
            var worldToScreen = this._WorldToScreen(trans);
            var screenToWorld = worldToScreen.Clone().Invert();
            var center = box.GetCenter();
            this.Project(center, worldToScreen);
            var corners = box.GetCorners();
            for (var i = corners.length - 1; i >= 0; i--) {
                var pnt = corners[i];
                this.Project(pnt, worldToScreen);
                mi.x = Math.min(pnt.x, mi.x);
                mi.y = Math.min(pnt.y, mi.y);
                ma.x = Math.max(pnt.x, ma.x);
                ma.y = Math.max(pnt.y, ma.y);
            }
            var sizeX = ma.x - mi.x;
            var sizeY = ma.y - mi.y;
            var scale = 1.0;
            if (!GLTFViewer.Utils.IslengthZero(sizeX) && !GLTFViewer.Utils.IslengthZero(sizeY)) {
                var nH = this.canvasHeight;
                var nW = this.canvasWidth;
                var scaleNom, scaleDeNom;
                if (sizeX > sizeY) {
                    if (nH > nW) {
                        scaleNom = nW;
                        scaleDeNom = sizeX;
                    } else {
                        var viewRatio = nH / nW;
                        var sceneRatio = sizeY / sizeX;
                        if (sceneRatio < viewRatio) {
                            scaleNom = nW;
                            scaleDeNom = sizeX;
                        } else {
                            scaleNom = nH;
                            scaleDeNom = sizeY;
                        }
                    }
                } else {
                    if (nW > nH) {
                        scaleNom = nH;
                        scaleDeNom = sizeY;
                    } else {
                        var viewRatio = nW / nH;
                        var sceneRatio = sizeX / sizeY;
                        if (sceneRatio < viewRatio) {
                            scaleNom = nH;
                            scaleDeNom = sizeY;
                        } else {
                            scaleNom = nW;
                            scaleDeNom = sizeX;
                        }
                    }
                }
                scale = scaleNom / scaleDeNom;
            }
            var dX = (sizeX / 2.0 - (center.x - mi.x));
            var dY = (sizeY / 2.0 - (center.y - mi.y));
            var p0 = new GLTFViewer.Utils.Vec3(this.canvasWidth / 2.0, this.canvasHeight / 2.0, 0);
            var d0 = GLTFViewer.Utils.Direction.diz;
            this._UnprojectRay2(p0, d0, screenToWorld);
            var ray0 = new GLTFViewer.Utils.Line(p0, d0);
            var p1 = new GLTFViewer.Utils.Vec3(this.canvasWidth / 2.0 - dX, this.canvasHeight / 2.0 - dY, 0);
            var d1 = GLTFViewer.Utils.Direction.diz;
            this._UnprojectRay2(p1, d1, screenToWorld);
            var ray1 = new GLTFViewer.Utils.Line(p1, d1);
            var plane = new GLTFViewer.Utils.Plane(GLTFViewer.Utils.Vec3.Origin, trans.Clone().Invert().GetZDirection());
            plane.GetPoint(ray0, p0);
            plane.GetPoint(ray1, p1);
            trans.Multiply(GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(p0, p1)));
            scale *= 0.9; // add margin
            trans.a33 /= scale;

            this.SetProjection(trans, animate);
        }
    },
    ZoomView: {
        value: function (scale, downScreenX, downScreenY, downModelPoint, oldProjection) {
            var z = oldProjection.a33 / scale;
            if (z <= 1e-5)
                scale = oldProjection.a33 / 1e-5;
            else if (z >= 1e5)
                scale = oldProjection.a33 / 1e5;
            this.SetProjection(GLTFViewer.Utils.Transformation.MultiplyCreate(oldProjection, GLTFViewer.Utils.Transformation.ScaleCreate(scale)), false);
            var unprojectedCreatePoint = new GLTFViewer.Utils.Vec3(downScreenX, downScreenY, 0);
            this.UnProject(unprojectedCreatePoint);

            var proj = GLTFViewer.Utils.Transformation.MultiplyCreate(this.projectionTM, GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(downModelPoint, unprojectedCreatePoint)));

            this.SetProjection(proj, false);
        }
    },
    _Synchronize: {
        value: function (how, from, messageID, data) {
            if (how === "READ") {
                if (from !== this._scene.viewer.viewportNumber)
                    this.state = data;
            } else {
                if (this._scene.viewer.viewportLock && this._scene.viewer.IsVisible() &&
                       (GLTFViewer.Utils.IsNull(this._lastState) ||
                        !this._lastState.projectionTM.IsEqual(this.projectionTM) ||
                        this._lastState.worldScale !== this._worldScale ||
                        this._lastState.persp !== this.persp)) {
                    this._lastState = this.state;
                    this._scene.viewer.messageHandler.SendMessage("Transform", this.state);
                }
            }
        }
    },
    SetCamera2: {
        value: function () {
            // create a proper modelView matrix for GLTF
            this.modelViewTM = this.projectionTM.Clone();
            this.modelViewTM.a33 = 1; // projectionTM has scale in a33 element
            // move camera and scale into projection matrix
            var scale = 1 / this._worldScale;
            var trans = this.cameraTM.Clone().Multiply(new GLTFViewer.Utils.Transformation(scale, 0, 0, 0, 0, scale, 0, 0, 0, 0, scale, 0, 0, 0, 0, 1));
            if (this.persp) {
                this.projectionGLTM = GLTFViewer.Utils.Transformation.perspectiveRH(this._normalizedWidth * this.zoom, this._normalizedHeight * this.zoom, this._nearPlane, this._farPlane).Multiply(trans);
                var projectionOrtho = GLTFViewer.Utils.Transformation.orthoRH(this._normalizedWidth * this.zoom, this._normalizedHeight * this.zoom, this._nearPlane, this._farPlane).Multiply(trans);
                this.transViewProjOrthoTM = GLTFViewer.Utils.Transformation.MultiplyCreate(projectionOrtho, this.modelViewTM);
            } else
                this.projectionGLTM = GLTFViewer.Utils.Transformation.orthoRH(this._normalizedWidth * this.zoom, this._normalizedHeight * this.zoom, this._nearPlane, this._farPlane).Multiply(trans);
            this.projection2DGLTM = GLTFViewer.Utils.Transformation.orthoRH(this._normalizedWidth * 2, this._normalizedHeight * 2, this._nearPlane, this._farPlane);
            // combine modelview and projection matrix
            this.transViewProjTM = GLTFViewer.Utils.Transformation.MultiplyCreate(this.projectionGLTM, this.modelViewTM);
            this._Synchronize();
        }
    },
    SetCamera: {
        value: function (persp) {
            this.persp = persp;
        }
    },
    SetProjection: {
        value: function (proj, animate) {
            var scene = this._scene;
            if (animate) {
                if (!this.StartAnimProj(proj, scene.GetSceneBox().GetCenter()))
                    return false;
            } else {
                this.projectionTM = proj.CreateWellFormed();
                this.SetCamera2();
                if (scene.ClipViewState === GLTFViewer.Utils.Clip.VIEWSTATE_PLANE)
                    scene.handler._clip.UpdateClip();
            }
            scene.Invalidate(true);
            return true;
        }
    },
    UpdateWorldScale: {
        value: function (box) {
            var maxSize = 1;
            if (!GLTFViewer.Utils.IsNull(box) && !box.IsEmpty())
                maxSize = box.GetDiameter();
            if (this._worldScale != maxSize) {
                this._worldScale = maxSize;
                this.ZoomExtents(false);
            }
        }
    },
    Project: {
        value: function (pnt, TVP) {
            pnt.Transform(GLTFViewer.Utils.IsNull(TVP) ? this.transViewProjTM : TVP);
            pnt.x = (1.0 + pnt.x) * this.canvasWidth / 2.0;
            pnt.y = (1.0 - pnt.y) * this.canvasHeight / 2.0;
        }
    },
    UnProject: {
        value: function (pnt, TVP) {
            if (this.canvasWidth <= 0 || this.canvasHeight <= 0)
                return;
            pnt.x = (2.0 * pnt.x) / this.canvasWidth - 1.0;
            pnt.y = 1.0 - (2.0 * pnt.y) / this.canvasHeight;
            if (!GLTFViewer.Utils.IsNull(TVP))
                pnt.Transform(TVP);
            else if (!GLTFViewer.Utils.IsNull(this.transViewProjInvTM))
                pnt.Transform(this.transViewProjInvTM);
        }
    },
    StartAnimProj: {
        value: function (proj, center) {
            this._animProjStart = this.projectionTM;
            this._animProjEnd = proj;
            this._animProjCenter = center;
            var s = center.TransformCreate(this._animProjStart);
            var e = center.TransformCreate(this._animProjEnd);
            this._animProjTranslation.Set(e.x - s.x, e.y - s.y, e.z - s.z);
            var m = this._animProjStart.Clone().Invert();
            m.Multiply(proj);
            if (!m.IsWellFormed())
                m = m.CreateWellFormed();
            this._animProjAngle = m.TryGetRotation(this._animProjAxis);
            if (this._animProjAngle > Math.PI)
                this._animProjAngle = -(Math.PI * 2 - this._animProjAngle);
            var scale = m.GetScale();
            var dist = m.GetTranslation().GetMagnitude();
            if (Math.abs(this._animProjAngle) < .01 && GLTFViewer.Utils.WithinTolerance(scale, 1.0, .01) && dist < GLTFViewer.Utils.fitAccuracy * 10)
                return false;
            this._animProjEndScale = this._animProjEnd.GetScale() / this._animProjStart.GetScale();
            var scaleSteps = 1 + Math.round(Math.abs(Math.log(scale)) / .05);
            var angleSteps = 1 + Math.round(Math.abs(this._animProjAngle) / .12);
            var distSteps = 1 + Math.round(Math.abs(dist) / .07);
            var steps = Math.max(8, Math.max(Math.max(scaleSteps, angleSteps), distSteps));
            steps = Math.min(30, steps);
            if (steps == 0)
                steps = 1;
            this._animProjStep = this._animProjStepCount = steps;
            return true;
        }
    },
    UpdateAnimProjStep: {
        value: function () {
            if (this._animProjStep <= 0)
                return;
            this._animProjStep--;
            var proj = null;
            var ratio = (1.0 - (this._animProjStep * this._animProjStep) / (this._animProjStepCount * this._animProjStepCount));
            if (ratio == 1.0)
                proj = this._animProjEnd;
            else {
                var stepAngle = this._animProjAngle * ratio;
                var stepScale = 1 - ratio + this._animProjEndScale * ratio;
                var translation = GLTFViewer.Utils.Transformation.TranslationCreate(this._animProjTranslation.x * ratio, this._animProjTranslation.y * ratio, this._animProjTranslation.z * ratio);
                proj = GLTFViewer.Utils.Transformation.MultiplyCreate(translation, this._animProjStart);
                var rotation = GLTFViewer.Utils.Transformation.RotationAboutAxisCreate(new GLTFViewer.Utils.Line(this._animProjCenter, this._animProjAxis), stepAngle);
                proj.Multiply(rotation);
                var scale = GLTFViewer.Utils.Transformation.ScaleAboutPointCreate(stepScale, this._animProjCenter.x, this._animProjCenter.y, this._animProjCenter.z);
                proj.Multiply(scale);
                if (!proj.IsWellFormed())
                    proj = proj.CreateWellFormed();
            }
            this.SetProjection(proj, false);
        }
    },
    SceneRotate: {
        value: function (axis, angle, ctr) {
            var scene = this._scene;
            var alongAxis = axis.TransformCreate(this.projectionInvTM);
            var rotation = GLTFViewer.Utils.Transformation.RotationAboutAxisCreate(new GLTFViewer.Utils.Line(ctr, alongAxis.GetDirection()), angle);
            var proj = GLTFViewer.Utils.Transformation.MultiplyCreate(this.projectionTM, rotation);
            if (!proj.IsWellFormed())
                proj = proj.CreateWellFormed();
            var box = scene.GetSceneBox().Clone().Multiply(proj);
            proj = GLTFViewer.Utils.Transformation.MultiplyCreate(GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(new GLTFViewer.Utils.Vec3(0, 0, box.GetCenter().z), GLTFViewer.Utils.Vec3.Origin)), proj);
            this.SetProjection(proj, false);
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.Navigator, {
    NavNone: { value: 0 },
    NavZoom: { value: 1 },
    NavSpinXY: { value: 2 },
    NavSpinZ: { value: 4 },
    NavPan: { value: 8 }, // NavPinchPan
    NavPinchRotate: { value: 16 },
    NavPinchZoom: { value: 32 },
    NavZoomBox: { value: 64 }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Navigator.NavigatorBaseClass = function (navigator) {
    this._navigator = navigator;
};
GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype = Object.create(null, {
    constructor: { value: GLTFViewer.Utils.Navigator.NavigatorBaseClass },
    // private members
    _navigator: { writable: true, value: null },
    _ctr: { writable: true, value: null },
    // public members
    // private methods
    // public virtual methods
    GetCenter: {
        value: function () { 
            if (this._ctr)
                return this._ctr;
            return this._navigator._scene.GetSceneBox().GetCenter();
        }
    },
    MouseDown: {
        value: function (touches) {
            this.UpdateMouseDown(touches);
        }
    },
    UpdateMouseDown: { value: function (touches) { } },
    MouseMove: { value: function (touches) { } },
    MouseUp: { value: function () { } },
    // public methods
    Reset: { // clear to just created state
        value: function() {
        }
    },
    Clear: { // clear for deletion
        value: function() {
            GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype.Reset.call(this);
            this._navigator = null;
            this._ctr = null;
        } 
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Navigator.PinchRotate = function (navigator) {
    GLTFViewer.Utils.Navigator.NavigatorBaseClass.call(this, navigator);
    this._lastDir = new GLTFViewer.Utils.Direction();
};
GLTFViewer.Utils.Navigator.PinchRotate.prototype = Object.create(GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.Navigator.PinchRotate },
    // private members
    _lastDir: { writable: true, value: null },
    // public members
    // private methods
    // public methods
    Reset: {
        value: function() {
            GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype.Reset.call(this);
        }
    },
    Clear: {
        value: function() {
            GLTFViewer.Utils.Navigator.PinchRotate.prototype.Reset.call(this);
            this._lastDir = null;
            GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype.Clear.call(this);
        }
    },
    UpdateMouseDown: {
        value: function (touches) {
            var xy1 = touches.GetTouchByIndex(0).GetLastLocation();
            var xy2 = touches.GetTouchByIndex(1).GetLastLocation();
            this._lastDir.Set(xy2.x - xy1.x, xy2.y - xy1.y, 0);
        }
    },
    MouseMove: {
        value: function (touches) {
            var navigator = this._navigator;
            var scene = navigator._scene;
            var xy1 = touches.GetTouchByIndex(0).GetLastLocation();
            var xy2 = touches.GetTouchByIndex(1).GetLastLocation();
            var thisDir = new GLTFViewer.Utils.Direction(xy2.x - xy1.x, xy2.y - xy1.y, 0);
            var angle = Math.atan2(thisDir.y, thisDir.x) - Math.atan2(this._lastDir.y, this._lastDir.x);
            if (angle) {
                var xy = touches.GetLastLocation(2);
                var ctr = new GLTFViewer.Utils.Vec3(xy.x, xy.y, 0);
                navigator.UnProject(ctr);
                var dir = new GLTFViewer.Utils.Vec3(xy.x, xy.y, 1);
                navigator.UnProject(dir); // not sure if this is the right way to do this
                var rotDir = new GLTFViewer.Utils.Direction(dir.x - ctr.x, dir.y - ctr.y, dir.z - ctr.z);
                var rotation = GLTFViewer.Utils.Transformation.RotationAboutAxisCreate(new GLTFViewer.Utils.Line(ctr, rotDir), angle);
                var proj = GLTFViewer.Utils.Transformation.MultiplyCreate(navigator.projectionTM, rotation);
                if (!proj.IsWellFormed())
                    proj = proj.CreateWellFormed();

                var box = scene.GetSceneBox().Clone().Multiply(proj);
                proj = GLTFViewer.Utils.Transformation.MultiplyCreate(GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(new GLTFViewer.Utils.Vec3(0, 0, box.GetCenter().z), GLTFViewer.Utils.Vec3.Origin)), proj);

                navigator.SetProjection(proj, false);
            }
            this._lastDir.Set(thisDir.x, thisDir.y, thisDir.z);
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Navigator.PinchZoom = function (navigator) {
    GLTFViewer.Utils.Navigator.NavigatorBaseClass.call(this, navigator);
};
GLTFViewer.Utils.Navigator.PinchZoom.prototype = Object.create(GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.Navigator.PinchZoom },
    // private members
    _lastSep: { writable: true, value: 0 },
    // public members
    // private methods
    // public methods
    Reset: {
        value: function() {
            GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype.Reset.call(this);
        }
    },
    Clear: {
        value: function() {
            GLTFViewer.Utils.Navigator.PinchZoom.prototype.Reset.call(this);
            GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype.Clear.call(this);
        }
    },
    UpdateMouseDown: {
        value: function (touches) {
            this._lastSep = touches.GetLastSeparation(2);
        }
    },
    MouseMove: {
        value: function (touches) {
            var navigator = this._navigator;
            var curSep = touches.GetLastSeparation(2);
            var dragDist = curSep - this._lastSep;
            var xy = touches.GetLastLocation(2); // not even close to being correct
            var downModelpoint = new GLTFViewer.Utils.Vec3(xy.x, xy.y, 0);
            navigator.UnProject(downModelpoint);
            var scale = Math.exp(dragDist / 160);
            navigator.ZoomView(scale, xy.x, xy.y, downModelpoint, navigator.projectionTM);
            this._lastSep = curSep;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Navigator.Pan = function (navigator) {
    GLTFViewer.Utils.Navigator.NavigatorBaseClass.call(this, navigator);
    this._ctr = GLTFViewer.Utils.Vec3.Origin;
    this._plane = new GLTFViewer.Utils.Plane(this._ctr, GLTFViewer.Utils.Direction.diz);
    this._cursorRay = new GLTFViewer.Utils.CursorRay(navigator);
};
GLTFViewer.Utils.Navigator.Pan.prototype = Object.create(GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.Navigator.Pan },
    // private members
    _plane: { writable: true, value: null },
    _cursorRay: { writable: true, value: null },
    _x: { writable: true, value: 0 },
    _y: { writable: true, value: 0 },
    // public members
    // private methods
    // public methods
    Reset: {
        value: function () {
            GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype.Reset.call(this);
        }
    },
    Clear: {
        value: function () {
            GLTFViewer.Utils.Navigator.Pan.prototype.Reset.call(this);
            this._plane = null;
            this._cursorRay = null;
            GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype.Clear.call(this);
        }
    },
    MouseDown: {
        value: function (touches) {
            this._navigator._scene.GetSceneBox().GetCenter(this._ctr);
            this.UpdateMouseDown(touches);
        }
    },
    UpdateMouseDown: {
        value: function (touches) {
            var xy = touches.GetLastLocation(); // 1 or 2 touches
            this._x = xy.x;
            this._y = xy.y;
        }
    },
    MouseMove: {
        value: function (touches) {
            //GAW: this is overly complicated
            var navigator = this._navigator;
            this._plane.Set(this._ctr, navigator.projectionInvTM.GetZDirection());
            this._cursorRay.Update(this._x, this._y);
            var p0 = new GLTFViewer.Utils.Vec3();
            this._plane.GetPoint(this._cursorRay.ray, p0);
            var p1 = new GLTFViewer.Utils.Vec3();
            var xy = touches.GetLastLocation(); // 1 or 2 touches
            this._x = xy.x;
            this._y = xy.y;
            this._cursorRay.Update(xy.x, xy.y);
            this._plane.GetPoint(this._cursorRay.ray, p1);
            var translate = GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(p0, p1));
            var proj = GLTFViewer.Utils.Transformation.MultiplyCreate(navigator.projectionTM, translate);
            var pt = this._ctr.TransformCreate(proj);
            pt.x = pt.y = 0;
            proj = GLTFViewer.Utils.Transformation.MultiplyCreate(GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(pt, GLTFViewer.Utils.Vec3.Origin)), proj);

            navigator.SetProjection(proj, false);
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Navigator.Spin = function (navigator) {
    GLTFViewer.Utils.Navigator.NavigatorBaseClass.call(this, navigator);
    this._ctr = GLTFViewer.Utils.Vec3.Origin;
    this._ball = new GLTFViewer.Utils.Ball();
    this._cursorRay = new GLTFViewer.Utils.CursorRay(navigator);
};
GLTFViewer.Utils.Navigator.Spin.prototype = Object.create(GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.Navigator.Spin },
    // private members
    _oldProjection: { writable: true, value: null },
    _oldProjectionInv: { writable: true, value: null },
    _ball: { writable: true, value: null },
    _cursorRay: { writable: true, value: null },
    // public members
    // private methods
    // public methods
    Reset: {
        value: function() {
            GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype.Reset.call(this);
        }
    },
    Clear: {
        value: function() {
            GLTFViewer.Utils.Navigator.Spin.prototype.Reset.call(this);
            this._ball = null;
            this._cursorRay = null;
            GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype.Clear.call(this);
        }
    },
    MouseDown: {
        value: function (touches) {
            var navigator = this._navigator;
            var scene = navigator._scene;
            //scene.ResetHit();
            var xy = touches.GetLastLocation(1);
            this._cursorRay.Update(xy.x, xy.y);
            var b = scene.handler ? scene.handler.HitTestPos(navigator.uTVP, navigator.canvasWidth, navigator.canvasHeight, this._cursorRay) : null;
            if (b)
                this._ctr.Set(b.x, b.y, b.z);
            else
                scene.GetSceneBox().GetCenter(this._ctr);
            this.UpdateMouseDown(touches);
        }
    },
    UpdateMouseDown: {
        value: function (touches) {
            this._oldProjection = this._navigator.projectionTM;
            this._oldProjectionInv = this._navigator.projectionInvTM;
            var xy = touches.GetLastLocation(1);
            this._ball.onBegin(xy.x, xy.y);
        }
    }
});
/** @constructor */
GLTFViewer.Utils.Navigator.SpinXY = function (navigator) {
    GLTFViewer.Utils.Navigator.Spin.call(this, navigator);
};
GLTFViewer.Utils.Navigator.SpinXY.prototype = Object.create(GLTFViewer.Utils.Navigator.Spin.prototype, {
    constructor: { value: GLTFViewer.Utils.Navigator.SpinXY },
    // private members
    // public members
    // private methods
    // public methods
    Reset: {
        value: function() {
            GLTFViewer.Utils.Navigator.Spin.prototype.Reset.call(this);
        }
    },
    Clear: {
        value: function() {
            GLTFViewer.Utils.Navigator.SpinXY.prototype.Reset.call(this);
            GLTFViewer.Utils.Navigator.Spin.prototype.Clear.call(this);
        }
    },
    MouseMove: {
        value: function (touches) {
            var scene = this._navigator._scene;
            if (this._oldProjection !== null) {
                var xy = touches.GetLastLocation(1);
                this._ball.onMove(xy.x, xy.y);
                if (!this._ball.d.IsZero()) {
                    var alongAxis = this._ball.d.TransformCreate(this._oldProjectionInv);
                    var angle = this._ball.a;
                    var rotation = GLTFViewer.Utils.Transformation.RotationAboutAxisCreate(new GLTFViewer.Utils.Line(this._ctr, alongAxis.GetDirection()), angle);
                    var proj = GLTFViewer.Utils.Transformation.MultiplyCreate(this._oldProjection, rotation);
                    if (!proj.IsWellFormed())
                        proj = proj.CreateWellFormed();

                    var box = scene.GetSceneBox().Clone().Multiply(proj);
                    proj = GLTFViewer.Utils.Transformation.MultiplyCreate(GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(new GLTFViewer.Utils.Vec3(0, 0, box.GetCenter().z), GLTFViewer.Utils.Vec3.Origin)), proj);

                    this._navigator.SetProjection(proj, false);
                }
            }
        }
    }
});
/** @constructor */
GLTFViewer.Utils.Navigator.SpinZ = function (navigator) {
    GLTFViewer.Utils.Navigator.Spin.call(this, navigator);
};
GLTFViewer.Utils.Navigator.SpinZ.prototype = Object.create(GLTFViewer.Utils.Navigator.Spin.prototype, {
    constructor: { value: GLTFViewer.Utils.Navigator.SpinZ },
    // private members
    // public members
    // private methods
    // public methods
    Reset: {
        value: function() {
            GLTFViewer.Utils.Navigator.Spin.prototype.Reset.call(this);
        }
    },
    Clear: {
        value: function() {
            GLTFViewer.Utils.Navigator.SpinZ.prototype.Reset.call(this);
            GLTFViewer.Utils.Navigator.Spin.prototype.Clear.call(this);
        }
    },
    MouseMove: {
        value: function (touches) {
            var scene = this._navigator._scene;
            if (this._oldProjection !== null) {
                var xy = touches.GetLastLocation(1);
                this._ball.onMove(this._ball.cx, xy.y);
                if (!this._ball.d.IsZero()) {
                    this._ball.d.z = this._ball.d.x;
                    this._ball.d.x = 0;
                    var alongAxis = this._ball.d.TransformCreate(this._oldProjectionInv);
                    var angle = this._ball.a;
                    var rotation = GLTFViewer.Utils.Transformation.RotationAboutAxisCreate(new GLTFViewer.Utils.Line(this._ctr, alongAxis.GetDirection()), angle);
                    var proj = GLTFViewer.Utils.Transformation.MultiplyCreate(this._oldProjection, rotation);
                    if (!proj.IsWellFormed())
                        proj = proj.CreateWellFormed();

                    var box = scene.GetSceneBox().Clone().Multiply(proj);
                    proj = GLTFViewer.Utils.Transformation.MultiplyCreate(GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(new GLTFViewer.Utils.Vec3(0, 0, box.GetCenter().z), GLTFViewer.Utils.Vec3.Origin)), proj);

                    this._navigator.SetProjection(proj, false);
                }
            }
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Navigator.Zoom = function (navigator) {
    GLTFViewer.Utils.Navigator.NavigatorBaseClass.call(this, navigator);
};
GLTFViewer.Utils.Navigator.Zoom.prototype = Object.create(GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.Navigator.Zoom },
    // private members
    _x: { writable: true, value: 0 },
    _y: { writable: true, value: 0 },
    _oldProjection: { writable: true, value: null },
    // public members
    // private methods
    // public methods
    Reset: {
        value: function() {
            GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype.Reset.call(this);
        }
    },
    Clear: {
        value: function() {
            GLTFViewer.Utils.Navigator.Zoom.prototype.Reset.call(this);
            this._oldProjection = null;
            this._ctr = null;
            GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype.Clear.call(this);
        }
    },
    UpdateMouseDown: {
        value: function (touches) {
            var navigator = this._navigator;
            var xy = touches.GetLastLocation(1);
            this._x = xy.x;
            this._y = xy.y;
            this._oldProjection = navigator.projectionTM;
            this._ctr = new GLTFViewer.Utils.Vec3(this._x, this._y, 0);
            navigator.UnProject(this._ctr);
        }
    },
    MouseMove: {
        value: function (touches) {
            var xy = touches.GetLastLocation(1);
            var dragDist = xy.y - this._y;
            var scale = Math.exp(dragDist / 160);
            this._navigator.ZoomView(scale, this._x, this._y, this._ctr, this._oldProjection);
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Navigator.ZoomBox = function (navigator) {
    GLTFViewer.Utils.Navigator.NavigatorBaseClass.call(this, navigator);
    this._ctr = GLTFViewer.Utils.Vec3.Origin;
    this._plane = new GLTFViewer.Utils.Plane(this._ctr, GLTFViewer.Utils.Direction.diz);
    this._cursorRay = new GLTFViewer.Utils.CursorRay(navigator);
};
GLTFViewer.Utils.Navigator.ZoomBox.prototype = Object.create(GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.Navigator.ZoomBox },
    // private members
    _plane: { writable: true, value: null },
    _cursorRay: { writable: true, value: null },
    _startX: { writable: true, value: 0 },
    _startY: { writable: true, value: 0 },
    _curX: { writable: true, value: 0 },
    _curY: { writable: true, value: 0 },
    // public members
    // private methods
    // public methods
    Reset: {
        value: function () {
            GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype.Reset.call(this);
        }
    },
    Clear: {
        value: function () {
            GLTFViewer.Utils.Navigator.Zoom.prototype.Reset.call(this);
            this._plane = null;
            this._cursorRay = null;
            GLTFViewer.Utils.Navigator.NavigatorBaseClass.prototype.Clear.call(this);
        }
    },
    GetLoc: {
        value: function () {
            return [this._startX, this._startY, this._curX, this._curY];
        }
    },
    MouseDown: {
        value: function (touches) {
            this._navigator._scene.GetSceneBox().GetCenter(this._ctr);
            this.UpdateMouseDown(touches);
        }
    },
    UpdateMouseDown: {
        value: function (touches) {
            //var navigator = this._navigator;
            var xy = touches.GetLastLocation(1);
            this._startX = this._curX = xy.x;
            this._startY = this._curY = xy.y;
        }
    },
    MouseMove: {
        value: function (touches) {
            var navigator = this._navigator;
            var canvasWidth = navigator.canvasWidth;
            var canvasHeight = navigator.canvasHeight;
            var xy = touches.GetLastLocation(1);
            if (xy.x < 0)
                xy.x = 0;
            else if (xy.x >= canvasWidth)
                xy.x = canvasWidth - 1;
            if (xy.y < 0)
                xy.y = 0;
            else if (xy.y >= canvasHeight)
                xy.y = canvasHeight - 1;
            this._curX = xy.x;
            this._curY = xy.y;
        }
    },
    MouseUp: {
        value: function () {
            var navigator = this._navigator;
            var scene = navigator._scene;
            var canvasWidth = navigator.canvasWidth;
            var canvasHeight = navigator.canvasHeight;

            var w = Math.abs(this._curX - this._startX);
            var h = Math.abs(this._curY - this._startY);
            if (w < 3 || h < 3)
                return;

            // need to find a point on the object that is within the zoom box,
            //  use this to determine where to position object in screen Z direction
            var xC = (this._startX + this._curX) / 2;
            var yC = (this._startY + this._curY) / 2;
            // find closest point in scene to center of zoom box
            this._cursorRay.Update(xC, yC);
            var b = scene.handler ? scene.handler.HitTestPos(navigator.uTVP, canvasWidth, canvasHeight, this._cursorRay) : null;
            if (!b)
                return; // nothing
            // see if this point is inside zoom box
            var p0 = new GLTFViewer.Utils.Vec3(b.x, b.y, b.z);
            navigator.Project(p0);
            if (Math.abs(xC - p0.x) > w / 2 || Math.abs(yC - p0.y) > h / 2)
                return; // no
            // use the point Z, with the zoom box center, to get the object zoom box center
            p0.x = xC;
            p0.y = yC;
            navigator.UnProject(p0); //, navigator.transViewProjOrthoInvTM);

            var proj = navigator.projectionTM.Clone();

            if (false && navigator.persp) {
                //
                // for perspecitive, rotate scene as appropriate
                //

                // center of scene
                var p = new GLTFViewer.Utils.Vec3(canvasWidth / 2, canvasHeight / 2, 0);
                navigator.UnProject(p);
                var dir = GLTFViewer.Utils.Vec3.Create(p, p0).Normalize();
                var zDir = navigator.projectionInvTM.GetZDirection().Negate();
                var axis = dir.CrossCreate(zDir).Normalize();
                var d = Math.acos(dir.Dot(zDir));
                var line = new GLTFViewer.Utils.Line(p, new GLTFViewer.Utils.Direction(axis.x, axis.y, axis.z));
                proj = GLTFViewer.Utils.Transformation.MultiplyCreate(proj, GLTFViewer.Utils.Transformation.RotationAboutAxisCreate(line, d));
            } else {
                //
                // for orthographic, pan center of zoom box to center of viewport
                //

                // center of zoom box
                this._plane.Set(this._ctr, navigator.projectionInvTM.GetZDirection());
                //var p0 = new GLTFViewer.Utils.Vec3();
                //this._plane.GetPoint(this._cursorRay.ray, p0);
                // center of viewport
                var p1 = new GLTFViewer.Utils.Vec3();
                this._cursorRay.Update(canvasWidth / 2, canvasHeight / 2);
                this._plane.GetPoint(this._cursorRay.ray, p1);
                // translate
                var translate = GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(p0, p1));
                proj.Multiply(translate);
                var pt = this._ctr.TransformCreate(proj);
                pt.x = pt.y = 0;
                proj = GLTFViewer.Utils.Transformation.MultiplyCreate(GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(pt, GLTFViewer.Utils.Vec3.Origin)), proj);
            }

            //
            // zoom to required extents
            //
            {
                var scale = 1.0;
                if (w > h) {
                    if (canvasHeight > canvasWidth || h / w < canvasHeight / canvasWidth)
                        scale = canvasWidth / w;
                    else
                        scale = canvasHeight / h;
                } else {
                    if (canvasWidth > canvasHeight || w / h < canvasWidth / canvasHeight)
                        scale = canvasHeight / h;
                    else
                        scale = canvasWidth / w;
                }
                proj.a33 /= scale;
            }

            navigator.SetProjection(proj, false);
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Navigator.ZoomBoxMarker = function (navigator, gx) {
    this._navigator = navigator;
    this._gx = gx;
};
GLTFViewer.Utils.Navigator.ZoomBoxMarker.prototype = Object.create(null, {
    // private members
    _navigator: { writable: true, value: null },
    _gx: { writable: true, value: null },
    // private methods
    // public methods
    Reset: {
        value: function () {
        }
    },
    Clear: {
        value: function () {
            GLTFViewer.Utils.Navigator.ZoomBoxMarker.prototype.Reset.call(this);

            this._navigator = null;
            this._gx = null;
        }
    },
    Render: {
        value: function (x1, y1, x2, y2) {
            var navigator = this._navigator;
            var gx = this._gx;
            if (x1 > x2) {
                var t = x1;
                x1 = x2;
                x2 = t;
            }
            if (y1 > y2) {
                var t = y1;
                y1 = y2;
                y2 = t;
            }
            var w = x2 - x1;
            var h = y2 - y1;

            var darkBackground = navigator._scene.background && navigator._scene.background.IsDark(GLTFViewer.Utils.Background.RIGHTTOP);
            gx.strokeStyle = darkBackground ? 'rgba(255, 255, 255, 1)' : 'rgba(0, 0, 0, 1)';
            gx.lineWidth = 1;
            gx.strokeRect(x1, y1, w, h);
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Navigator.Triad = function (navigator, gl) {
    this._navigator = navigator;
};
GLTFViewer.Utils.Navigator.Triad.prototype = Object.create(null, {
    // private members
    _navigator: { writable: true, value: null },
    // private methods
    _RenderArm: {
        value: function (gx, start, end, width, height, str, color, background) {
            gx.font = height + 'px Verdana';
            gx.textAlign = "center";
            gx.textBaseline = "middle";

            if (background) {
                gx.lineCap = 'square';
                var background = "rgba(255, 255, 255, 0.5)";
                gx.strokeStyle = background;
                gx.fillStyle = background;

                gx.lineWidth = width + 4;
                gx.beginPath();
                gx.moveTo(start.x, start.y);
                gx.lineTo(start.x + (end.x - start.x) * 0.8, start.y + (end.y - start.y) * 0.8);
                gx.stroke();

                // circle
                gx.lineWidth = 0;
                gx.beginPath();
                var navigator = this._navigator;
                var t = Math.min(navigator.canvasWidth, navigator.canvasHeight);
                gx.arc(end.x, end.y, t * 0.012, 0, 2 * Math.PI, false);
                gx.fill();
            } else {
                gx.lineCap = 'round';
                gx.strokeStyle = color;
                gx.fillStyle = color;

                gx.lineWidth = width;
                gx.beginPath();
                gx.moveTo(start.x, start.y);
                gx.lineTo(start.x + (end.x - start.x) * 0.8, start.y + (end.y - start.y) * 0.8);
                gx.stroke();

                gx.fillText(str, end.x, end.y);
            }
        }
    },
    // public methods
    Reset: {
        value: function () {
        }
    },
    Clear: {
        value: function () {
            GLTFViewer.Utils.Navigator.Triad.prototype.Reset.call(this);
            this._navigator = null;
        }
    },
    Render: {
        value: function (w, h) {
            var navigator = this._navigator;
            var scene = navigator._scene;
            var gx = scene.gx;

            var t = Math.min(navigator._normalizedWidth, navigator._normalizedHeight);
            var rotationMatrix = navigator.projectionTM.Clone();
            rotationMatrix.a30 = 0;
            rotationMatrix.a31 = 0;
            rotationMatrix.a32 = 0;
            rotationMatrix.a33 = 1;
            var TRS = (new GLTFViewer.Utils.Transformation()).Translate(0.5 * navigator._normalizedWidth - 0.1 * t, -0.5 * navigator._normalizedHeight + 0.1 * t, 0).Multiply(rotationMatrix).Scale(0.08, 0.08, 0.08);
            var projection = GLTFViewer.Utils.Transformation.orthoRH(navigator._normalizedWidth, navigator._normalizedHeight, navigator._nearPlane, navigator._farPlane).Multiply(navigator.cameraTM).Multiply(TRS);

            var color = ["red", "green", "blue"];
            var text = ["X", "Y", "Z"];

            // determine order in which to draw axes
            var pnt = [];
            pnt[0] = new GLTFViewer.Utils.Vec3(1, 0, 0);
            navigator.Project(pnt[0], projection);
            var x = pnt[0].z;
            pnt[1] = new GLTFViewer.Utils.Vec3(0, 1, 0);
            navigator.Project(pnt[1], projection);
            var y = pnt[1].z;
            pnt[2] = new GLTFViewer.Utils.Vec3(0, 0, 1);
            navigator.Project(pnt[2], projection);
            var z = pnt[2].z;

            pnt[3] = new GLTFViewer.Utils.Vec3(0, 0, 0);
            navigator.Project(pnt[3], projection);

            var order = [];
            if (x <= y && x <= z) {
                order[2] = 0;
                if (y <= z) {
                    order[1] = 1;
                    order[0] = 2;
                } else {
                    order[1] = 2;
                    order[0] = 1;
                }
            } else if (y <= x && y <= z) {
                order[2] = 1;
                if (x <= z) {
                    order[1] = 0;
                    order[0] = 2;
                } else {
                    order[1] = 2;
                    order[0] = 0;
                }
            } else {
                order[2] = 2;
                if (x <= y) {
                    order[1] = 0;
                    order[0] = 1;
                } else {
                    order[1] = 1;
                    order[0] = 0;
                }
            }

            var width = Math.max(Math.sqrt(Math.min(navigator.canvasWidth, navigator.canvasHeight)) / 10, 1);
            var height = Math.max(Math.sqrt(Math.min(navigator.canvasWidth, navigator.canvasHeight)) / 2, 6);
            //for (var i = 0; i < 3; ++i)
            //    this._RenderArm(gx, pnt[3], pnt[order[i]], width, height, text[order[i]], color[order[i]], true);
            for (var i = 0; i < 3; ++i)
                this._RenderArm(gx, pnt[3], pnt[order[i]], width, height, text[order[i]], color[order[i]], false);
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Navigator.SpinMarker = function (gl) {
    this._gl = gl;
    this._phong2Shader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.Navigator.SpinMarker._vsPhong2, GLTFViewer.Utils.Navigator.SpinMarker._fsPhong2);
    this._quadShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.Navigator.SpinMarker._vsQuad, GLTFViewer.Utils.Navigator.SpinMarker._fsQuad);
    this._clipPointDat = new Float32Array(24);
    this._clipPointBuf = gl.createBuffer();
    this._uMtl = new Float32Array(16);
    this._uTex = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
    this._uClr = new Float32Array(4 * 2);
    this._uPos = new Float32Array([-1, 1, 1, 1, 1, -1, -1, -1]);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._clipPointBuf);
    gl.bufferData(gl.ARRAY_BUFFER, this._clipPointDat, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    this._cone = new GLTFViewer.Utils.Navigator.SpinMarker.Cylinder(gl, 1, 0, 1, 16, 2);

    var ballSize = 8;
    var image = GLTFViewer.Utils.MakeBallImage(ballSize / 2, 2);

    this._circleTexture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this._circleTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE_ALPHA, ballSize, ballSize, 0, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE, image);
    gl.bindTexture(gl.TEXTURE_2D, null);
};
GLTFViewer.Utils.Navigator.SpinMarker.prototype = Object.create(null, {
    // private members
    _gl: { writable: true, value: null },
    _phong2Shader: { writable: true, value: null },
    _quadShader: { writable: true, value: null },
    _cone: { writable: true, value: null },
    _clipPointBuf: { writable: true, value: null },
    _uMtl: { writable: true, value: null },
    _uTex: { writable: true, value: null },
    _uClr: { writable: true, value: null },
    _uPos: { writable: true, value: null },
    _circleTexture: { writable: true, value: null },
    // private methods
    _SetMaterialRgba: {
        value: function (r, g, b, a) {
            var tClr = new GLTFViewer.Utils.RGBA(r, g, b, a);
            var tMat = new GLTFViewer.Utils.Material(tClr);
            tMat.ToArray(this._uMtl, 0);
        }
    },
    // public methods
    Reset: {
        value: function () {
            this._cone.Reset();
        }
    },
    Clear: {
        value: function () {
            GLTFViewer.Utils.Navigator.SpinMarker.prototype.Reset.call(this);
            var gl = this._gl;
            if (this._phong2Shader !== null) {
                this._phong2Shader.DeleteProgram();
                this._phong2Shader = null;
            }
            if (this._quadShader !== null) {
                this._quadShader.DeleteProgram();
                this._quadShader = null;
            }
            if (this._clipPointBuf) {
                gl.deleteBuffer(this._clipPointBuf);
                this._clipPointBuf = null;
            }
            this._clipPointDat = null;
            if (this._cone) {
                this._cone.Clear();
                this._cone = null;
            }
            this._uMtl = null;
            this._uTex = null;
            this._uClr = null;
            this._uPos = null;
            if (this._circleTexture) {
                gl.deleteTexture(this._circleTexture);
                this._circleTexture = null;
            }
            this._gl = null;
        }
    },
    Render: {
        value: function (TVP, eye, lighting, ps, w, h, pos) {
            if (!this._circleTexture)
                return;
            var gl = this._gl;
            var shader = this._phong2Shader;
            if (shader.StartProgram()) {
                gl.uniformMatrix4fv(shader.uTWd, false, GLTFViewer.Utils.glMtxIdentity);
                gl.uniformMatrix4fv(shader.uTVP, false, TVP);
                gl.uniform3fv(shader.uEye, eye);
                gl.uniformMatrix4fv(shader.uLit, false, lighting);
                gl.enable(gl.BLEND);
                gl.enable(gl.CULL_FACE);
                gl.depthMask(false);
                gl.cullFace(gl.BACK);
                var a = 100;
                var r = ps * 1.5;
                var o0 = ps * 8;
                var o1 = ps * 25;
                gl.disable(gl.DEPTH_TEST);
                this._SetMaterialRgba(255, 0, 0, a);
                gl.uniformMatrix4fv(shader.uMtl, false, this._uMtl);
                var sp = new GLTFViewer.Utils.Vec3(pos.x + o0, pos.y, pos.z);
                var ep = new GLTFViewer.Utils.Vec3(pos.x + o1, pos.y, pos.z);
                this._cone.Render(gl, shader, sp, ep, r);
                sp.x = pos.x - o0;
                ep.x = pos.x - o1;
                this._cone.Render(gl, shader, sp, ep, r);
                this._SetMaterialRgba(0, 200, 0, a);
                gl.uniformMatrix4fv(shader.uMtl, false, this._uMtl);
                sp.Set(pos.x, pos.y + o0, pos.z);
                ep.Set(pos.x, pos.y + o1, pos.z);
                this._cone.Render(gl, shader, sp, ep, r);
                sp.y = pos.y - o0;
                ep.y = pos.y - o1;
                this._cone.Render(gl, shader, sp, ep, r);
                this._SetMaterialRgba(0, 0, 255, a);
                gl.uniformMatrix4fv(shader.uMtl, false, this._uMtl);
                sp.Set(pos.x, pos.y, pos.z + o0);
                ep.Set(pos.x, pos.y, pos.z + o1);
                this._cone.Render(gl, shader, sp, ep, r);
                sp.z = pos.z - o0;
                ep.z = pos.z - o1;
                this._cone.Render(gl, shader, sp, ep, r);
                // sec pass
                a = 250;
                gl.enable(gl.DEPTH_TEST);
                this._SetMaterialRgba(255, 0, 0, a);
                gl.uniformMatrix4fv(shader.uMtl, false, this._uMtl);
                sp.Set(pos.x + o0, pos.y, pos.z);
                ep.Set(pos.x + o1, pos.y, pos.z);
                this._cone.Render(gl, shader, sp, ep, r);
                sp.Set(pos.x - o0, pos.y, pos.z);
                ep.Set(pos.x - o1, pos.y, pos.z);
                this._cone.Render(gl, shader, sp, ep, r);
                this._SetMaterialRgba(0, 200, 0, a);
                gl.uniformMatrix4fv(shader.uMtl, false, this._uMtl);
                var sp = new GLTFViewer.Utils.Vec3(pos.x, pos.y + o0, pos.z);
                var ep = new GLTFViewer.Utils.Vec3(pos.x, pos.y + o1, pos.z);
                this._cone.Render(gl, shader, sp, ep, r);
                sp.Set(pos.x, pos.y - o0, pos.z);
                ep.Set(pos.x, pos.y - o1, pos.z);
                this._cone.Render(gl, shader, sp, ep, r);
                this._SetMaterialRgba(0, 0, 255, a);
                gl.uniformMatrix4fv(shader.uMtl, false, this._uMtl);
                var sp = new GLTFViewer.Utils.Vec3(pos.x, pos.y, pos.z + o0);
                var ep = new GLTFViewer.Utils.Vec3(pos.x, pos.y, pos.z + o1);
                this._cone.Render(gl, shader, sp, ep, r);
                sp.Set(pos.x, pos.y, pos.z - o0);
                ep.Set(pos.x, pos.y, pos.z - o1);
                this._cone.Render(gl, shader, sp, ep, r);
                gl.disable(gl.CULL_FACE);
            }

            // center of spin marker
            shader = this._quadShader;
            if (shader.StartProgram()) {
                gl.bindBuffer(gl.ARRAY_BUFFER, this._clipPointBuf);
                gl.vertexAttribPointer(shader.aPos, 3, gl.FLOAT, false, 16, 0);
                gl.vertexAttribPointer(shader.aTex, 1, gl.FLOAT, false, 16, 12);
                gl.uniformMatrix4fv(shader.uTWd, false, GLTFViewer.Utils.glMtxIdentity);
                gl.uniformMatrix4fv(shader.uTVP, false, TVP);
                gl.uniform2fv(shader.uPos, this._uPos);
                gl.uniform2fv(shader.uTex, this._uTex);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this._circleTexture);
                gl.disable(gl.DEPTH_TEST);
                var tClr = new GLTFViewer.Utils.RGBA(100, 100, 0, 180);
                tClr.ToArray(this._uClr, 0);
                tClr.SetRgba(255, 255, 200, 180);
                tClr.ToArray(this._uClr, 4);
                gl.uniform2f(shader.uSze, 6 / w, 6 / h);
                gl.uniform4fv(shader.uClr, this._uClr);
                var vc = 0;
                var t = this._clipPointDat;
                t[vc++] = pos.x; t[vc++] = pos.y; t[vc++] = pos.z; t[vc++] = 0;
                t[vc++] = pos.x; t[vc++] = pos.y; t[vc++] = pos.z; t[vc++] = 1;
                t[vc++] = pos.x; t[vc++] = pos.y; t[vc++] = pos.z; t[vc++] = 2;
                t[vc++] = pos.x; t[vc++] = pos.y; t[vc++] = pos.z; t[vc++] = 2;
                t[vc++] = pos.x; t[vc++] = pos.y; t[vc++] = pos.z; t[vc++] = 3;
                t[vc++] = pos.x; t[vc++] = pos.y; t[vc++] = pos.z; t[vc++] = 0;
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._clipPointDat);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.depthMask(true);
                gl.disable(gl.BLEND);
                gl.enable(gl.DEPTH_TEST);
            }
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.Navigator.SpinMarker.Cylinder = function (gl, r1, r2, len, slices, stacks) {
    this._gl = gl;
    var data = GLTFViewer.Utils.MakeFacedCylinder3D(r1, r2, len, slices, stacks);
    this._iCnt = data.size;
    this._vDat = data.vertices;
    this._iDat = data.indices;
    this._vBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vBuf);
    gl.bufferData(gl.ARRAY_BUFFER, this._vDat, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    this._iBuf = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._iBuf);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._iDat, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    this._tmpArray = new Float32Array(16);
};
GLTFViewer.Utils.Navigator.SpinMarker.Cylinder.prototype = Object.create(null, {
    _gl: { writable: true, value: null },
    _tmpArray: { writable: true, value: null },
    _vDat: { writable: true, value: null },
    _iDat: { writable: true, value: null },
    _vBuf: { writable: true, value: null },
    _iBuf: { writable: true, value: null },
    _iCnt: { writable: true, value: 0 },
    // public methods
    Reset: {
        value: function () {
        }
    },
    Clear: {
        value: function () {
            var gl = this._gl;
            GLTFViewer.Utils.Navigator.SpinMarker.Cylinder.prototype.Reset.call(this);
            if (this._vBuf) {
                gl.deleteBuffer(this._vBuf);
                this._vBuf = null;
            }
            if (this._iBuf) {
                gl.deleteBuffer(this._iBuf);
                this._iBuf = null;
            }
            _vDat = null;
            _iDat = null;
        }
    },
    Render: {
        value: function (gl, shader, sp, ep, r, c) {
            var line = GLTFViewer.Utils.Vec3.Create(ep, sp);
            var len = line.GetMagnitude();
            var mp = new GLTFViewer.Utils.Vec3((sp.x + ep.x) / 2, (sp.y + ep.y) / 2, (sp.z + ep.z) / 2);
            var tran = GLTFViewer.Utils.Transformation.TranslationCreate(mp.x, mp.y, mp.z);
            var dix = line.GetDirection();
            var diy = dix.Clone();
            diy.Cross(new GLTFViewer.Utils.Vec3(0, 0, 1)).Normalize();
            var rot;
            if (diy.IsZero()) {
                if (dix.Dot(new GLTFViewer.Utils.Vec3(0, 0, 1)) < 0)
                    rot = GLTFViewer.Utils.Transformation.RotationAboutAxisCreate(new GLTFViewer.Utils.Line(mp, GLTFViewer.Utils.Direction.diy), Math.PI);
                else
                    rot = GLTFViewer.Utils.Transformation.Identity;
            } else {
                var d = dix.Dot(new GLTFViewer.Utils.Vec3(0, 0, 1));
                var a = Math.PI * 2 - GLTFViewer.Utils.acos(d);
                rot = GLTFViewer.Utils.Transformation.RotationAboutAxisCreate(new GLTFViewer.Utils.Line(mp, diy), a);
            }
            tran = GLTFViewer.Utils.Transformation.MultiplyCreate(rot, tran);
            tran.Multiply(GLTFViewer.Utils.Transformation.ScaleCreate(r));
            tran.Multiply(new GLTFViewer.Utils.Transformation(1, 0, 0, 0,
                                                       0, 1, 0, 0,
                                                       0, 0, len / r, 0,
                                                       0, 0, 0, 1));
            tran.ToArray(this._tmpArray);
            gl.uniformMatrix4fv(shader.uTWd, false, this._tmpArray);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._vBuf);
            gl.vertexAttribPointer(shader.aPos, 3, gl.FLOAT, false, 24, 0);
            gl.vertexAttribPointer(shader.aNor, 3, gl.FLOAT, false, 24, 12);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._iBuf);
            gl.drawElements(gl.TRIANGLES, this._iCnt, gl.UNSIGNED_SHORT, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
    }
});
///////////////////////////////////////
// Static data
Object.defineProperties(GLTFViewer.Utils.Navigator.SpinMarker, {
    // private members
    _vsPhong2: {
        value: "uniform mat4 uTWd;\n" +
               "uniform mat4 uTVP;\n" +
               "uniform vec3 uEye;\n" +
               "attribute vec3 aPos;\n" +
               "attribute vec3 aNor;\n" +
               "varying vec3 vNor;\n" +
               "varying vec3 vDir;\n" +
               "void main(void) {\n" +
                   "vec4 pos = uTWd * vec4(aPos, 1.0);\n" +
                   "vNor = (uTWd * vec4(aNor, 0.0)).xyz;\n" +
                   "vDir = normalize(pos.xyz - uEye);\n" +
                   "gl_Position = uTVP * pos;\n" +
               "}"
    },
    _fsPhong2: {
        value: "uniform mat4 uLit[2];\n" +
               "uniform mat4 uMtl;\n" +
               "varying vec3 vNor;\n" +
               "varying vec3 vDir;\n" +
               "void main(void) {\n" +
                   "vec3 rgb = vec3(0);\n" +
                   "vec3 nor = normalize(vNor);\n" +
                   "nor *= -sign(dot(vDir, nor));\n" +
                   "vec3 r = reflect(uLit[0][3].xyz, nor);\n" +
                   "float s = pow(max(dot(r, vDir), 0.0), uMtl[3].x);\n" +
                   "float d = max(dot(uLit[0][3].xyz, nor), 0.0);\n" +
                   "vec3 sp = s * uMtl[2].rgb * uLit[0][2].rgb;\n" +
                   "vec3 di = d * uMtl[1].rgb * uLit[0][1].rgb;\n" +
                   "vec3 am = uMtl[0].rgb * uLit[0][0].rgb;\n" +
                   "rgb = am + di + sp;\n" +
                   "r = reflect(uLit[1][3].xyz, nor);\n" +
                   "s = pow(max(dot(r, vDir), 0.0), uMtl[3].x);\n" +
                   "d = max(dot(uLit[1][3].xyz, nor), 0.0);\n" +
                   "sp = s * uMtl[2].rgb * uLit[1][2].rgb;\n" +
                   "di = d * uMtl[1].rgb * uLit[1][1].rgb;\n" +
                   "am = uMtl[0].rgb * uLit[1][0].rgb;\n" +
                   "rgb = rgb + am + di + sp;\n" +
                   "gl_FragColor = vec4(rgb, uMtl[1].a);\n" +
               "}"
    },
    _vsQuad: {
        value: "uniform mat4 uTWd;\n" +
               "uniform mat4 uTVP;\n" +
               "uniform vec2 uPos[4];\n" +
               "uniform vec2 uTex[4];\n" +
               "uniform vec2 uSze;\n" +
               "attribute vec3 aPos;\n" +
               "attribute float aTex;\n" +
               "varying vec2 vTex;\n" +
               "void main() {\n" +
                   "int i = int(aTex);\n" +
                   "vTex = uTex[i];\n" +
                   "vec2 o = uPos[i] * uSze * uTWd[3][3] * uTVP[3][3];\n" +
                   "gl_Position = uTVP * uTWd * vec4(aPos, 1) + vec4(o, 0, 0);\n" +
               "}"
    },
    _fsQuad: {
        value: "uniform vec4 uClr[2];\n" +
               "uniform sampler2D uSmp;\n" +
               "varying vec2 vTex;\n" +
               "void main(void) {\n" +
                   "vec4 t = texture2D(uSmp, vTex);\n" +
                   "vec4 c = uClr[0] + uClr[1] * t.r;\n" +
                   "c.a *= t.a;\n" +
                   "gl_FragColor = c;\n" +
               "}"
    }
    // public methods
});
//
// Navigator
//
////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// GLTFViewer.Utils.FileGLTF
//
/** @constructor */
GLTFViewer.Utils.FileGLTF = function (scene, fileType, data, other) {
    GLTFViewer.Utils.FileBaseClass.call(this, scene, fileType, data, other);
    var gl = this._gl;
    this._colorName = "_u_color_";
    this._clipName = "_u_clipPlane_";
    this._objMatrixName = "_u_objMatrix_";
    this._POSITIONNAME = "POSITION";
    // have to do this like this, it does not work in static section
    this._glUniform = {};
    this._glUniform[5124] = { create: GLTFViewer.Utils.FileGLTF._Uniform1i, set: GLTFViewer.Utils.FileGLTF._SetUniform1i };
    this._glUniform[5126] = { create: GLTFViewer.Utils.FileGLTF._Uniform1f, set: GLTFViewer.Utils.FileGLTF._SetUniform1f };
    this._glUniform[35664] = { create: GLTFViewer.Utils.FileGLTF._Uniform2fv, set: GLTFViewer.Utils.FileGLTF._SetUniform2fv };
    this._glUniform[35665] = { create: GLTFViewer.Utils.FileGLTF._Uniform3fv, set: GLTFViewer.Utils.FileGLTF._SetUniform3fv };
    this._glUniform[35666] = { create: GLTFViewer.Utils.FileGLTF._Uniform4fv, set: GLTFViewer.Utils.FileGLTF._SetUniform4fv };
    this._glUniform[35667] = { create: GLTFViewer.Utils.FileGLTF._Uniform2iv, set: GLTFViewer.Utils.FileGLTF._SetUniform2iv };
    this._glUniform[35668] = { create: GLTFViewer.Utils.FileGLTF._Uniform3iv, set: GLTFViewer.Utils.FileGLTF._SetUniform3iv };
    this._glUniform[35669] = { create: GLTFViewer.Utils.FileGLTF._Uniform4iv, set: GLTFViewer.Utils.FileGLTF._SetUniform4iv };
    this._glUniform[35670] = { create: GLTFViewer.Utils.FileGLTF._Uniform1i, set: GLTFViewer.Utils.FileGLTF._SetUniform1i };
    this._glUniform[35675] = { create: GLTFViewer.Utils.FileGLTF._UniformMatrix3fv, set: GLTFViewer.Utils.FileGLTF._SetUniformMatrix3fv };
    this._glUniform[35676] = { create: GLTFViewer.Utils.FileGLTF._UniformMatrix4fv, set: GLTFViewer.Utils.FileGLTF._SetUniformMatrix4fv };
    this._glUniform[35678] = { create: GLTFViewer.Utils.FileGLTF._Sampler2D, set: GLTFViewer.Utils.FileGLTF._SetSampler2D };
    try {
        this._hitTestIndexShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.FileGLTF._hitTestIndxVs, GLTFViewer.Utils.FileGLTF._hitTestIndxFs);
        this._hitTestPositionShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.FileGLTF._hitTestPosVs, GLTFViewer.Utils.FileGLTF._hitTestPosFs);
    } catch (err) {
        GLTFViewer.Utils.WriteErr(err);
        if (this._hitTestIndexShader) {
            this._hitTestIndexShader.DeleteProgram();
            this._hitTestIndexShader = null;
        }
        if (this._hitTestPositionShader) {
            this._hitTestPositionShader.DeleteProgram();
            this._hitTestPositionShader = null;
        }
        throw err;
    }
    this._hitTestIndexClipShader = GLTFViewer.Utils.ShaderProgram.CreateClipableProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.ShaderProgram.RemoveComments(GLTFViewer.Utils.FileGLTF._hitTestIndxVs), GLTFViewer.Utils.ShaderProgram.RemoveComments(GLTFViewer.Utils.FileGLTF._hitTestIndxFs), this._objMatrixName, "aPos", this._clipName);
    if (this._hitTestIndexClipShader) {
        this._hitTestPositionClipShader = GLTFViewer.Utils.ShaderProgram.CreateClipableProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.ShaderProgram.RemoveComments(GLTFViewer.Utils.FileGLTF._hitTestPosVs), GLTFViewer.Utils.ShaderProgram.RemoveComments(GLTFViewer.Utils.FileGLTF._hitTestPosFs), this._objMatrixName, "aPos", this._clipName);
        if (!this._hitTestPositionClipShader) {
            this._hitTestIndexClipShader.DeleteProgram();
            this._hitTestIndexClipShader = null;
        }
    }
    this.CanClip = !GLTFViewer.Utils.IsNull(this._hitTestIndexClipShader) && !GLTFViewer.Utils.IsNull(this._hitTestPositionClipShader);
    this.CanPeel = true;
    this.CanMarkup = true;
    this.CanExplode = true;
    this.CanCreateViews = true;
    this._glCursorRay = new Float32Array(4 * 2);
    this._uViewport = new Float32Array(4);
    this._uTProj = new Float32Array(16);
    this._uTProj2 = new Float32Array(16);
    this._uModel = new Float32Array(16); // model -> modelviewMatrix = sceneTransform + model
    this._uView = new Float32Array(16); // view = sceneTransform
    this._uModelView = new Float32Array(16); // modelview matrix
    this._uModelViewInvTrp = new Float32Array(9); // normal matrix
    this._sceneNodeIndexToSceneNode = [];
    this._sceneCache = {};
    this._sceneCacheNameMap = {};
    this._animationCache = {};
    this._animationSamplerCache = {};
    this._markupCache = {};
    this._cameraCache = {};
    this._legendCache = {};
    this._meshCache = {};
    this._nodeCache = {};
    this._nodeCacheNameMap = {};
    this._attributeCache = {};
    this._indexCache = {};
    this._materialCache = {};
    this._techniqueCache = {};
    this._programCache = {};
    this._bufferViewCache = {};
    this._bufferCache = {};
    this._shaderCache = {};
    this._imageCache = {};
    this._samplerCache = {};
    this._textureCache = {};
    this._idMap = {};

    this.hit = new GLTFViewer.Utils.FileGLTF.Hit();
};
GLTFViewer.Utils.FileGLTF.prototype = Object.create(GLTFViewer.Utils.FileBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF },
    // private members
    _fileNum: { writable: true, value: 0 }, // really should be static

    _uTProj: { writable: true, value: null },
    _uTProj2: { writable: true, value: null },
    _uModel: { writable: true, value: null },
    _uModelView: { writable: true, value: null },
    _uModelViewInvTrp: { writable: true, value: null },
    _uView: { writable: true, value: null },
    _uViewport: { writable: true, value: null },
    _glCursorRay: { writable: true, value: null },
    _glUniform: { writable: true, value: null }, // kind of sucks putting this in here
    _colorName: { writable: true, value: null },
    _clipName: { writable: true, value: null },
    _objMatrixName: { writable: true, value: null },
    _POSITIONNAME: { writable: true, value: null },
    _anyTransparent: { writable: true, value: null },
    _anyOpaque: { writable: true, value: null },
    _any2D: { writable: true, value: null },
    _any2DOverlay: { writable: true, value: null },
    _progressTotal: { writable: true, value: 0 },
    _totalGLTFBytes: { writable: true, value: 0 },

    _hitTestIndexShader: { writable: true, value: null },
    _hitTestIndexClipShader: { writable: true, value: null },
    _hitTestPositionShader: { writable: true, value: null },
    _hitTestPositionClipShader: { writable: true, value: null },

    _sceneNodeIndexToSceneNode: { writable: true, value: null },
    _idMap: { writable: true, value: null },

    _animationInfo: { writable: true, value: null },

    _sceneCache: { writable: true, value: null }, // cache of Scenes
    _sceneCacheNameMap: { writable: true, value: null },
    _curScene: { writable: true, value: null }, // current scene we are displaying
    _cameraCache: { writable: true, value: null }, // cache of Cameras
    _animationCache: { writable: true, value: null }, // cache of Animations
    _animationSamplerCache: { writable: true, value: null }, // cache of Animation Samplers
    _markupCache: { writable: true, value: null }, // cache of Markups
    _legendCache: { writable: true, value: null }, // cache of Legends
    _meshCache: { writable: true, value: null }, // cache of MeshItems
    _nodeCache: { writable: true, value: null }, // cache of NodeItems
    _nodeCacheNameMap: { writable: true, value: null },
    _attributeCache: { writable: true, value: null }, // cache of AttributeItems
    _indexCache: { writable: true, value: null }, // cache of IndexItems
    _materialCache: { writable: true, value: null }, // cache of MaterialItems
    _techniqueCache: { writable: true, value: null }, // cache of TechniqueItems
    _programCache: { writable: true, value: null }, // cache of ProgramItems
    _bufferViewCache: { writable: true, value: null }, // cache of BufferViewItems
    _bufferCache: { writable: true, value: null }, // cache of BufferItems
    _shaderCache: { writable: true, value: null }, // cache of ShaderItems
    _imageCache: { writable: true, value: null }, // cache of ImageItems
    _samplerCache: { writable: true, value: null }, // cache of SamplerItems
    _textureCache: { writable: true, value: null }, // cache of TextureItems
    // public members
    FindSceneItemByName: {
        value: function (name) {
            for (var key in this._sceneCache) {
                var sceneItem = this._sceneCache[key];
                if (sceneItem.name === name)
                    return sceneItem;
            }
            return null;
        }
    },
    ShowNodeRefs: {
        value: function () {
            console.log("SceneCache:");
            for (var key in this._sceneCache) {
                var sceneItem = this._sceneCache[key];
                console.log("Scene: " + sceneItem.ID + "   " + sceneItem.name + "   refCount: " + sceneItem.refCount);
            }
            console.log("NodeCache:");
            for (var key in this._nodeCache) {
                var nodeItem = this._nodeCache[key];
                console.log("Node: " + nodeItem.ID + "   " + nodeItem.name + "   refCount: " + nodeItem.refCount);
            }
            console.log("IDMap:");
            for (var key in this._idMap) {
                console.log(key + " = " + this._idMap[key]);
            }
        }
    },
    IDMap: {
        value: function (ID) {
            var id = this._idMap[ID];
            return GLTFViewer.Utils.IsNull(id) ? ID : id;
        }
    },
    hit: { writable: true, value: null },
    GetSceneBox: {
        value: function (dontExplode) {
            if (this._curScene)
                return this._curScene.GetBoundingBox(dontExplode);
            return GLTFViewer.Utils.FileBaseClass.prototype.GetSceneBox.call(this, dontExplode);
        }
    },
    SetExplosion: {
        value: function (val, update) {
            this._viewer.ExplodeBtnState(null, val ? GLTFViewer.MENUCHECK : GLTFViewer.MENUUNCHECK);
            this._viewer.MarkupBtnState(null, val ? GLTFViewer.MENUDISABLE : GLTFViewer.MENUENABLE);
            if (update)
                this._viewer.SetExplodeSlider(val);
            this._scene.Invalidate(true);

            var sceneItem = this._curScene;
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return;
            sceneItem.explosion = val;
            sceneItem.UpdateBoundingBox();
        }
    },
    GetExplosion: {
        value: function () {
            var sceneItem = this._curScene;
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return 0;
            return sceneItem.explosion;
        }
    },
    ResetHit: {
        value: function () {
            this.hit.Reset();
        }
    },
    AnyHit: {
        value: function () {
            return !GLTFViewer.Utils.IsNull(this.hit.indx);
        }
    },
    HitPoint: {
        value: function () {
            return this.hit.pnt;
        }
    },
    HitIndx: {
        value: function () {
            return this.hit.indx;
        }
    },
    IsVisible: {
        value: function (sceneNodeItemIndex) {
            var sceneNodeItem = this._sceneNodeIndexToSceneNode[sceneNodeItemIndex];
            return !GLTFViewer.Utils.IsNull(sceneNodeItem) && sceneNodeItem.IsVisible();
        }
    },
    AddMarkupToVisibilitySelector: {
        value: function (sceneItem, line) {
            if (line._type === GLTFViewer.Utils.Markup.LINE_TYPE_2D && !GLTFViewer.Utils.IsNull(line._index))
                return null; // special 2D markup attached to a node, node visibility controls this
            if (!line.Editable && !sceneItem.markupVis)
                sceneItem.markupVis = this._viewer.AddEntryVisibilityList("Annotations", true, null, null, null, true);
            if (line.Editable && !sceneItem.markupVisEditable)
                sceneItem.markupVisEditable = this._viewer.AddEntryVisibilityList("Markups", true, null, null, null, true);

            function MarkupVisibilityCallback(line, visible) {
                line._visible = visible;
                this._scene.Invalidate(true);
            }

            return this._viewer.AddEntryVisibilityList("", line._visible, MarkupVisibilityCallback.bind(this, line), null,
                                                       line.Editable ? sceneItem.markupVisEditable : sceneItem.markupVis, true);
        }
    },
    BuildVisibilitySelector: {
        value: function () {
            function AddNodeItem(sceneNodeItem) {
                var nodeItem = sceneNodeItem.nodeItem;
                var fileInfo = nodeItem.fileInfo;
                if (sceneNodeItem.disconnect || (GLTFViewer.Utils.IsNull(nodeItem.BB) && (GLTFViewer.Utils.IsNull(fileInfo) || !this._IsMeshNode(fileInfo._jsonData, nodeItem.ID))))
                    return;
                var parentSceneNodeItem = sceneNodeItem.parent;
                var name = nodeItem.name;
                sceneNodeItem.visList = this._viewer.AddEntryVisibilityList(name, sceneNodeItem.IsVisible(), sceneNodeItem.SetVisibility, sceneNodeItem.EditProperties, parentSceneNodeItem ? parentSceneNodeItem.visList : null, nodeItem.meshList.length === 0);
                for (var key in sceneNodeItem.childList)
                    AddNodeItem.call(this, sceneNodeItem.childList[key]);
            }

            this._viewer.ClearVisibilityList();
            var sceneItem = this._curScene;
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return;
            for (var key in sceneItem.sceneNodeItems)
                AddNodeItem.call(this, sceneItem.sceneNodeItems[key]);

            sceneItem.markupVis = null;
            sceneItem.markupVisEditable = null;

            var markups = sceneItem.markup.GetLineKeys();
            for (var i = 0; i < markups.length; ++i) {
                var line = sceneItem.markup.GetLine(markups[i]);
                line.visList = this.AddMarkupToVisibilitySelector(sceneItem, line);
            }
        }
    },
    CreateMarkupLine: {
        value: function (sceneItem, editable, type, position, index, lineColor, lineShape, text, textOffset, textAttach, textSize, textfont, textColor, backColor) {
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return;
            var markup = sceneItem.markup;
            var key = markup.CreateMarkupLine(editable, type, position, index, lineColor, lineShape, text, textOffset, textAttach, textSize, textfont, textColor, backColor);
            if (this._curScene === sceneItem) {
                var line = markup.GetLine(key);
                line.visList = this.AddMarkupToVisibilitySelector(sceneItem, line);
                this._scene.Invalidate(true);
            }

            return key;
        }
    },
    DeleteMarkupLine: {
        value: function (sceneItem, key) {
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return;

            var markup = sceneItem.markup;
            var line = markup.GetLine(key);
            if (!line || !line.Editable)
                return;
            this._viewer.DeleteEntryVisibilityList(line.visList);
            markup.DeleteMarkupLine(key);
            var markups = sceneItem.markup.GetLineKeys();
            var len = markups.length;
            var anyEditable = false;
            if (len) {
                for (var i = 0; i < len; ++i) {
                    line = sceneItem.markup.GetLine(markups[i]);
                    if (line.Editable) {
                        anyEditable = true;
                        break;
                    }
                }
            }
            if (!anyEditable) {
                this._viewer.DeleteEntryVisibilityList(sceneItem.markupVisEditable);
                sceneItem.markupVisEditable = null;
            }

            this._scene.Invalidate(true);
        }
    },
    CheckMarkupHit: {
        value: function (tCursorRay) {
            var sceneItem = this._curScene;
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return false;
            var markup = sceneItem.markup;
            if (markup._state === GLTFViewer.Utils.Markup.STATE_DISABLED || markup._state === GLTFViewer.Utils.Markup.STATE_CREATE_LINE)
                return false;
            var pnt = new GLTFViewer.Utils.Vec3(tCursorRay.x, tCursorRay.y, 0);
            var hit = markup.HitMarkup(pnt);
            if (!hit)
                return false;

            this.hit.indx = -(hit + 100);
            this.hit.texture = null;

            return true;
        }
    },
    DeleteAllMarkups: {
        value: function () {
            for (var key in this._sceneCache) {
                var sceneItem = this._sceneCache[key];
                var markups = sceneItem.markup.GetLineKeys();
                for (var i = 0; i < markups.length; ++i) {
                    this.DeleteMarkupLine(sceneItem, markups[i]);
                }
            }

            for (var key in this._markupCache) {
                if (this._markupCache[key].editable)
                    this._markupCache[key].Clear();
            }
        }
    },
    DeleteAllViews: {
        value: function () {
            for (var key in this._sceneCache) {
                var sceneItem = this._sceneCache[key];
                if (sceneItem.editable)
                    this.DeleteScene(sceneItem);
            }
        }
    },
    CurScene: {
        get: function () {
            return this._curScene;
        }
    },
    Ruler: {
        get: function () {
            return this._curScene ? { units: this._curScene.rulerUnits, scale: this._curScene.rulerScale} : null;
        }
    },
    RenderMarkup3D: {
        value: function (TVP) {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem))
                sceneItem.markup.Render3D(TVP);
        }
    },
    RenderMarkup2D: {
        value: function (TVP) {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem))
                sceneItem.markup.Render2D(TVP);
        }
    },
    // get information about current scene
    GetSceneState: {
        value: function () {
            if (!this._curScene)
                return null;
            return { sceneName: this._curScene.name, navigatorState: this._navigator.state, clipState: this._clip.state, explosion: this.GetExplosion() };
        }
    },
    // resets current scene to just loaded state
    ResetScene: {
        value: function (sceneItem) {
            GLTFViewer.Utils.FileBaseClass.prototype.ResetScene.call(this);
            this.SetExplosion(0, true);
            if (!sceneItem)
                sceneItem = this._curScene;
            sceneItem.Reset();
            if (sceneItem === this._curScene)
                this.SelectScene(this._curScene); // this will fix up visibility dialog
        }
    },
    SelectScene: {
        value: function (sceneItem, sceneState) {
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return;

            // either switching to new scene and/or updating current scene state
            var switching = this._curScene !== sceneItem;
            var navigator = this._navigator;

            if (this._curScene) {
                if (switching) {
                    // switching to a new scene, so save current state
                    this._curScene.navigatorState = navigator.state;
                    this._curScene.clipState = this._clip.state;
                }
                this._curScene.markup.ResetSelection();
            }

            if (switching) {
                this._curScene = sceneItem;
                this._anyTransparent = null;
                this._anyOpaque = null;
                this._any2D = null;
                this._any2DOverlay = null;
            }

            if ((!sceneState || !sceneState.navigatorState) && !sceneItem.navigatorState) {
                // set state to scene node state
                navigator.Reset();
                this.UpdateWorldScale();
                this._viewer.ClipMenuBtnState(null, null, GLTFViewer.MENURESET);

                if (sceneItem.camera && this._cameraCache[sceneItem.camera.cameraID]) {
                    var camera = this._cameraCache[sceneItem.camera.cameraID];
                    navigator.SetCamera(camera.type === "perspective");
                }
                // set navigator projectionTM
                if (sceneItem.cameraMatrix)
                    navigator.SetProjection(sceneItem.cameraMatrix, false);

                // save current transforms
                sceneItem.navigatorState = navigator.state;
            } else {
                this.UpdateWorldScale();
                navigator.state = (sceneState && sceneState.navigatorState) ? sceneState.navigatorState : sceneItem.navigatorState;
            }

            if ((!sceneState || !sceneState.clipState) && !sceneItem.clipState) {
                if (sceneItem.clipP0 && sceneItem.clipP1 && sceneItem.clipP2) {
                    var p0 = sceneItem.clipP0;
                    var p1 = sceneItem.clipP1;
                    var p2 = sceneItem.clipP2;
                    var o = new GLTFViewer.Utils.Vec3((p0.x + p1.x + p2.x) / 3.0, (p0.y + p1.y + p2.y) / 3.0, (p0.z + p1.z + p2.z) / 3.0);
                    var v0 = new GLTFViewer.Utils.Vec3();
                    var v1 = new GLTFViewer.Utils.Vec3();
                    v0.Set(p2.x - p0.x, p2.y - p0.y, p2.z - p0.z);
                    v1.Set(p1.x - p0.x, p1.y - p0.y, p1.z - p0.z);
                    v0.Cross(v1);
                    var dir = v0.GetDirection();
                    if (!dir.IsZero()) {
                        this._clip.clipPlane = new GLTFViewer.Utils.Plane(o, dir);
                        this._clip._SetClipPointsFromPlane(this._clip.clipPlane);
                        this._clip.clipState = GLTFViewer.Utils.Clip.STATE_3PTS;
                        this._clip.clipDrawMode = GLTFViewer.Utils.Clip.DRAWMODE_DONE;
                        this._clip._clipViewState = GLTFViewer.Utils.Clip.VIEWSTATE_PLANE;
                        this._clip.UpdateClip();
                    }
                }

                sceneItem.clipState = this._clip.state;
            }
            this._clip.state = (sceneState && sceneState.clipState) ? sceneState.clipState : sceneItem.clipState; // this sets up GUI

            // fix what we screwed up
            if (!sceneState || !sceneState.explosion)
                this.SetExplosion(this.GetExplosion(), true);
            else
                this.SetExplosion(sceneState.explosion, true);

            this._scene.Invalidate(true);

            if (!switching)
                return;

            // switching to new scene
            this.BuildVisibilitySelector();
            if (sceneItem.background)
                this._SetBackColor(sceneItem.background);

            this._viewer.SetSelectionSceneList(sceneItem.sceneLI);

            // Let folks know we have (potentially) new objects
            const parts_event = new CustomEvent('parts-changed', {bubbles: true, detail: {}});
            this._scene.canvas.dispatchEvent(parts_event);
        }
    },
    UpdateScene: {
        value: function () {
            var navigator = this._navigator;
            var proj = navigator.projectionTM;

            // as in all viewer interactions, bounding box center must be centered in Z-direction
            var pt = this.GetSceneBox().GetCenter().TransformCreate(proj);
            pt.x = pt.y = 0;
            proj = GLTFViewer.Utils.Transformation.TranslationCreate(GLTFViewer.Utils.Vec3.Create(pt, GLTFViewer.Utils.Vec3.Origin)).Multiply(proj);

            navigator.projectionTM = proj;
            navigator.SetCamera2();

            this._scene.Invalidate(true);
        }
    },
    // private methods
    _UpdateLoadProgress: {
        value: function (loads) {
            if (!this._progressBar)
                return;
            var loaded = 0;
            var urls = Object.keys(loads);
            urls.forEach(function (url) {
                loaded += loads[url].loaded;
            }, this);
            if (this._progressTotal)
                loaded = this._progressTotal + this._progressTotal * 0.25 * loaded / this._totalGLTFBytes;
            this._progressBar.Update(loaded);
        }
    },
    _RenderFindClosest: {
        value: function (TVP, w, h, index, cursorRay) {
            var navigator = this._navigator;
            var gl = this._gl;
            var clip = this.ClipViewState === GLTFViewer.Utils.Clip.VIEWSTATE_PLANE;
            var shader = index ? (clip ? this._hitTestIndexClipShader : this._hitTestIndexShader) : (clip ? this._hitTestPositionClipShader : this._hitTestPositionShader);
            if (!shader.StartProgram())
                return false;
            cursorRay.ToArray(this._glCursorRay);
            gl.uniform4fv(shader.uCry, this._glCursorRay);
            gl.uniform2f(shader.uSze, w / 2, h / 2);
            gl.uniformMatrix4fv(shader.uTVP, false, TVP);
            var modelViewTM = navigator.modelViewTM;
            navigator.modelViewTM = GLTFViewer.Utils.Transformation.Identity; // TVP already has modelViewTM included
            this._RenderScene(index ? GLTFViewer.Utils.FileGLTF._renderType.RENDERPICKIDX : GLTFViewer.Utils.FileGLTF._renderType.RENDERPICKPOS, w, h, -1, null, shader);
            navigator.modelViewTM = modelViewTM;
            return true;
        }
    },
    // reads a shaderID
    _ReadShader: {
        value: function (fileInfo, shaderID, ShaderCallback) {
            function Callback(shaderItem, glslShader) {
                if (shaderItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!glslShader) {
                    shaderItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    shaderItem.DoCallbacks();
                    return;
                }

                try {
                    shaderItem.glslShader = GLTFViewer.Utils.ShaderProgram.RemoveComments(glslShader); // data read from stream
                } catch (err) {
                    shaderItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    shaderItem.DoCallbacks();
                    return;
                }

                shaderItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                shaderItem.DoCallbacks();
            }
            ///////////////////////////

            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(shaderID) || !jsonData.shaders[shaderID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadShader:" + shaderID + "):", "bad id");
                ShaderCallback(null); // bad shaderID
                return;
            }

            var shaderItem = this._shaderCache[shaderID];
            if (shaderItem) {
                shaderItem.DoCallbacks(ShaderCallback);
                return;
            }

            var shaderData = jsonData.shaders[shaderID];

            shaderItem = new GLTFViewer.Utils.FileGLTF.ShaderItem(this, shaderID, this._shaderCache);
            shaderItem.AddCallback(ShaderCallback);

            var path = shaderData.path;
            var files = fileInfo._files;
            if (fileInfo._fileType === GLTFViewer.Utils.FileGLTF.FILE_TYPE_LOCAL || fileInfo._fileType === GLTFViewer.Utils.FileGLTF.FILE_TYPE_UNZIP_TO_MEMORY)
                files = fileInfo._files[path];
            fileInfo._loader.LoadText(path, files, fileInfo._fileType, Callback.bind(this, shaderItem), this._UpdateLoadProgress.bind(this));
        }
    },
    // reads a imageID, passes a ImageItem to ImageCallback
    _ReadImage: {
        value: function (fileInfo, imageID, ImageCallback) {
            function Callback(imageItem, image) {
                if (imageItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!image) {
                    imageItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    imageItem.DoCallbacks();
                    return;
                }

                imageItem.image = image; // data read from stream

                imageItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                imageItem.DoCallbacks();
            }
            ///////////////////////////

            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(imageID) || !jsonData.images[imageID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadImage:" + imageID + "):", "bad id");
                ImageCallback(null); // bad imageID
                return;
            }

            var imageItem = this._imageCache[imageID];
            if (imageItem) {
                imageItem.DoCallbacks(ImageCallback);
                return;
            }

            var imageData = jsonData.images[imageID];

            imageItem = new GLTFViewer.Utils.FileGLTF.ImageItem(this, imageID, this._imageCache);
            imageItem.AddCallback(ImageCallback);
            imageItem.generateMipmap = imageData.generateMipmap;

            var path = imageData.path;
            var files = fileInfo._files;
            if (fileInfo._fileType === GLTFViewer.Utils.FileGLTF.FILE_TYPE_LOCAL || fileInfo._fileType === GLTFViewer.Utils.FileGLTF.FILE_TYPE_UNZIP_TO_MEMORY)
                files = fileInfo._files[path];
            fileInfo._loader.LoadImage(path, files, fileInfo._fileType, Callback.bind(this, imageItem), this._UpdateLoadProgress.bind(this));
        }
    },
    // reads a bufferID, passes a BufferItem to BufferCallback
    _ReadBuffer: {
        value: function (fileInfo, bufferID, BufferCallback) {
            function Callback(bufferItem, buffer) {
                if (bufferItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!buffer) {
                    bufferItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    bufferItem.DoCallbacks();
                    return;
                }

                bufferItem.byteLength = buffer.byteLength; // use the real byteLength
                bufferItem.buffer = buffer; // data read from stream

                bufferItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                bufferItem.DoCallbacks();
            }
            ///////////////////////////

            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(bufferID) || !jsonData.buffers[bufferID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadBuffer:" + bufferID + "):", "bad id");
                BufferCallback(null); // bad bufferID
                return;
            }

            var bufferItem = this._bufferCache[bufferID];
            if (bufferItem) {
                bufferItem.DoCallbacks(BufferCallback);
                return;
            }

            var bufferData = jsonData.buffers[bufferID];
            if (bufferData.byteLength <= 0) {
                BufferCallback(null); // buffer is empty
                return;
            }

            bufferItem = new GLTFViewer.Utils.FileGLTF.BufferItem(this, bufferID, this._bufferCache);
            bufferItem.AddCallback(BufferCallback);
            bufferItem.byteLength = bufferData.byteLength;

            var path = bufferData.path;
            var files = fileInfo._files;
            if (fileInfo._fileType === GLTFViewer.Utils.FileGLTF.FILE_TYPE_LOCAL || fileInfo._fileType === GLTFViewer.Utils.FileGLTF.FILE_TYPE_UNZIP_TO_MEMORY)
                files = fileInfo._files[path];
            fileInfo._loader.LoadBinary(path, files, fileInfo._fileType, Callback.bind(this, bufferItem), this._UpdateLoadProgress.bind(this));
        }
    },
    // reads a bufferViewID, passes BufferViewItem to BufferViewCallback
    _ReadBufferView: {
        value: function (fileInfo, bufferViewID, BufferViewCallback) {
            function Callback(bufferViewItem, bufferItem) {
                if (bufferViewItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!bufferItem) {
                    bufferViewItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    bufferViewItem.DoCallbacks();
                    return;
                }
                if (bufferViewItem.byteOffset + bufferViewItem.byteLength > bufferItem.byteLength) { // bufferview is larger than buffer
                    GLTFViewer.Utils.WriteErr("ERROR(ReadBufferView:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(bufferViewItem.ID) + "):", "buffer too small");
                    bufferViewItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    bufferViewItem.DoCallbacks();
                    return;
                }

                bufferViewItem.buffer = bufferItem; // we really should be turning this into a DataView of buffer

                bufferViewItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                bufferViewItem.DoCallbacks();
            }
            ///////////////////////////

            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(bufferViewID) || !jsonData.bufferViews[bufferViewID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadBufferView:" + bufferViewID + "):", "bad id");
                BufferViewCallback(null); // bad bufferViewID
                return;
            }

            var bufferViewItem = this._bufferViewCache[bufferViewID];
            if (bufferViewItem) {
                bufferViewItem.DoCallbacks(BufferViewCallback);
                return;
            }

            var bufferViewData = jsonData.bufferViews[bufferViewID];
            if (bufferViewData.byteLength <= 0) {
                BufferViewCallback(null); // bufferView is empty
                return;
            }

            bufferViewItem = new GLTFViewer.Utils.FileGLTF.BufferViewItem(this, bufferViewID, this._bufferViewCache);
            bufferViewItem.AddCallback(BufferViewCallback);
            bufferViewItem.byteLength = bufferViewData.byteLength;
            bufferViewItem.byteOffset = bufferViewData.byteOffset ? bufferViewData.byteOffset : 0; // defaults to 0
            bufferViewItem.target = bufferViewData.target;

            this._ReadBuffer(fileInfo, bufferViewData.buffer, Callback.bind(this, bufferViewItem));
        }
    },
    // reads an attributeID, passes AttributeItem to  AttributeCallback
    _ReadAttribute: {
        value: function (fileInfo, attributeID, AttributeCallback) {
            function Callback(attributeItem, bufferViewItem) {
                if (attributeItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!bufferViewItem) {
                    attributeItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    attributeItem.DoCallbacks();
                    return;
                }

                attributeItem.bufferView = bufferViewItem;
                attributeItem.baseType = GLTFViewer.Utils.FileGLTF._glType[attributeItem.type].baseGLType;
                attributeItem.size = GLTFViewer.Utils.FileGLTF._glType[attributeItem.type].size;
                var elementType = GLTFViewer.Utils.FileGLTF._glType[attributeItem.type].type;
                if (!attributeItem.byteStride)
                    attributeItem.byteStride = attributeItem.size * elementType.BYTES_PER_ELEMENT;

                if (attributeItem.byteStride * attributeItem.count > bufferViewItem.byteLength) { // will read past end of bufferView buffer
                    GLTFViewer.Utils.WriteLErr("ERROR(ReadAttribute:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(attributeItem.ID) + "):", "bufferview too small");
                    attributeItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    attributeItem.DoCallbacks();
                    return;
                }
                // javascript arrays cannot support mixed data types, so attributeItem.byteStride better be multiple of elementType.BYTES_PER_ELEMENT
                if (attributeItem.byteStride % elementType.BYTES_PER_ELEMENT !== 0) {
                    GLTFViewer.Utils.WriteErr("ERROR(ReadAttribute:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(attributeItem.ID) + "):", "incompatible bytestride");
                    attributeItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    attributeItem.DoCallbacks();
                    return;
                }

                var realByteOffset = bufferViewItem.byteOffset + attributeItem.byteOffset;
                var realCount = attributeItem.size * attributeItem.count;
                var gl = this._gl;
                try {
                    attributeItem.data = new elementType(bufferViewItem.buffer.buffer, realByteOffset, realCount);
                } catch (err) {
                    GLTFViewer.Utils.WriteErr("ERROR(ReadAttribute:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(attributeItem.ID) + "): " + (err.message ? err.message : err));
                    attributeItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    attributeItem.DoCallbacks();
                    return;
                }

                attributeItem.buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, attributeItem.buffer);
                gl.bufferData(gl.ARRAY_BUFFER, attributeItem.data, gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);

                attributeItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                attributeItem.DoCallbacks();
            }
            ///////////////////////////

            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(attributeID) || !jsonData.attributes[attributeID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadAttribute:" + attributeID + "):", "bad id");
                AttributeCallback(null); // bad attributeID
                return;
            }

            var attributeItem = this._attributeCache[attributeID];
            if (attributeItem) {
                attributeItem.DoCallbacks(AttributeCallback);
                return;
            }

            var attributeData = jsonData.attributes[attributeID];
            if (attributeData.count <= 0) {
                AttributeCallback(null); // attribute is empty
                return;
            }

            attributeItem = new GLTFViewer.Utils.FileGLTF.AttributeItem(this, attributeID, this._attributeCache);
            attributeItem.AddCallback(AttributeCallback);
            attributeItem.type = attributeData.type;
            attributeItem.byteStride = attributeData.byteStride;
            attributeItem.byteOffset = attributeData.byteOffset;
            attributeItem.count = attributeData.count;
            attributeItem.normalized = attributeData.normalized ? attributeData.normalized : 0; // defaults to 0
            attributeItem.mn = attributeData.min;
            attributeItem.mx = attributeData.max;

            this._ReadBufferView(fileInfo, attributeData.bufferView, Callback.bind(this, attributeItem));
        }
    },
    // reads an indexID, passes IndexItem to IndexCallback
    _ReadIndex: {
        value: function (fileInfo, indexID, IndexCallback) {
            function Callback(indexItem, bufferViewItem) {
                if (indexItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!bufferViewItem) {
                    indexItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    indexItem.DoCallbacks();
                    return;
                }
                if (bufferViewItem.target !== 34963) {
                    GLTFViewer.Utils.WriteErr("ERROR(ReadIndex:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(indexItem.ID) + "):", "bad bufferView target");
                    indexItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    indexItem.DoCallbacks();
                    return;
                }

                indexItem.bufferView = bufferViewItem;
                var elementSize = GLTFViewer.Utils.FileGLTF._glType[indexItem.type].size;
                var elementType = GLTFViewer.Utils.FileGLTF._glType[indexItem.type].type;
                var byteStride = elementSize * elementType.BYTES_PER_ELEMENT;

                if (byteStride * indexItem.count > bufferViewItem.byteLength) { // will read past end of bufferView buffer
                    GLTFViewer.Utils.WriteErr("ERROR(ReadIndex:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(indexItem.ID) + "):", "bufferview too small");
                    indexItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    indexItem.DoCallbacks();
                    return;
                }

                var realByteOffset = bufferViewItem.byteOffset + indexItem.byteOffset;
                var realCount = elementSize * indexItem.count;
                var gl = this._gl;
                try {
                    indexItem.data = new elementType(bufferViewItem.buffer.buffer, realByteOffset, realCount);
                } catch (err) {
                    GLTFViewer.Utils.WriteErr("ERROR(ReadIndex:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(indexItem.ID) + "): " + (err.message ? err.message : err));
                    indexItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    indexItem.DoCallbacks();
                    return;
                }

                indexItem.buffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexItem.buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexItem.data, gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                if (!this._viewer.hasNodeJS)
                    indexItem.data = null; // only need this if hasNodeJS

                indexItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                indexItem.DoCallbacks();
            }
            ///////////////////////////

            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(indexID) || !jsonData.indices[indexID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadIndex:" + indexID + "):", "bad id");
                IndexCallback(null); // bad indexID
                return;
            }

            var indexItem = this._indexCache[indexID];
            if (indexItem) {
                indexItem.DoCallbacks(IndexCallback);
                return;
            }

            var indexData = jsonData.indices[indexID];
            if (indexData.type !== 5123) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadIndex:" + indexID + "):", "bad type");
                IndexCallback(null); // bad type
                return;
            }
            if (indexData.count <= 0) {
                IndexCallback(null); // index is empty
                return;
            }

            indexItem = new GLTFViewer.Utils.FileGLTF.IndexItem(this, indexID, this._indexCache);
            indexItem.AddCallback(IndexCallback);
            indexItem.byteOffset = indexData.byteOffset;
            indexItem.count = indexData.count;
            indexItem.type = indexData.type;

            this._ReadBufferView(fileInfo, indexData.bufferView, Callback.bind(this, indexItem));
        }
    },
    // reads a samplerID, passes a SamplerItem to SamplerCallback
    _ReadSampler: {
        value: function (fileInfo, samplerID, SamplerCallback) {
            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(samplerID) || !jsonData.samplers[samplerID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadSampler:" + samplerID + "):", "bad id");
                SamplerCallback(null); // bad samplerID
                return;
            }

            var samplerItem = this._samplerCache[samplerID];
            if (samplerItem) {
                samplerItem.DoCallbacks(SamplerCallback);
                return;
            }
            var samplerData = jsonData.samplers[samplerID];

            var magFilter = samplerData.magFilter;
            var minFilter = samplerData.minFilter;
            var wrapS = samplerData.wrapS;
            var wrapT = samplerData.wrapT;
            if ((magFilter !== 9728 && magFilter !== 9729) ||
                (minFilter !== 9728 && minFilter !== 9729 && minFilter !== 9984 && minFilter !== 9986 && minFilter !== 9985 && minFilter !== 9987) ||
                (wrapS !== 10497 && wrapS !== 33071 && wrapS !== 33648) ||
                (wrapT !== 10497 && wrapT !== 33071 && wrapT !== 33648)) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadSampler:" + samplerID + "):", "bad settings");
                SamplerCallback(null); // bad parameters
                return;
            }

            samplerItem = new GLTFViewer.Utils.FileGLTF.SamplerItem(this, samplerID, this._samplerCache);
            samplerItem.AddCallback(SamplerCallback);
            samplerItem.magFilter = magFilter;
            samplerItem.minFilter = minFilter;
            samplerItem.wrapS = wrapS;
            samplerItem.wrapT = wrapT;

            // no reading required

            samplerItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
            samplerItem.DoCallbacks();
        }
    },
    // reads a textureID, passes a glCreateTexture object to TextureCallback
    _ReadTexture: {
        value: function (fileInfo, textureID, TextureCallback) {
            function Callback(textureItem, itemType, item) {
                if (textureItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!item) {
                    textureItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    textureItem.DoCallbacks();
                    return;
                }
                if (itemType === "Sampler")
                    textureItem.sampler = item;
                else
                    textureItem.image = item;
                if (--textureItem.numCallbacksToProcess > 0)
                    return;

                var gl = this._gl;
                textureItem.texture = gl.createTexture();
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(textureItem.target, textureItem.texture);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                gl.texImage2D(textureItem.target, 0, textureItem.format, textureItem.format, gl.UNSIGNED_BYTE, textureItem.image.image);
                gl.texParameteri(textureItem.target, gl.TEXTURE_MAG_FILTER, textureItem.sampler.magFilter);
                gl.texParameteri(textureItem.target, gl.TEXTURE_MIN_FILTER, textureItem.sampler.minFilter);
                gl.texParameteri(textureItem.target, gl.TEXTURE_WRAP_S, textureItem.sampler.wrapS);
                gl.texParameteri(textureItem.target, gl.TEXTURE_WRAP_T, textureItem.sampler.wrapT);
                //if (textureItem.image.generateMipMap) {
                //    gl.generateMipmap(textureItem.target);
                //}
                gl.bindTexture(textureItem.target, null);

                textureItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                textureItem.DoCallbacks();
            }
            ///////////////////////////

            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(textureID) || !jsonData.textures[textureID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadTexture:" + textureID + "):", "bad id");
                TextureCallback(null); // bad textureID
                return;
            }

            var textureItem = this._textureCache[textureID];
            if (textureItem) {
                textureItem.DoCallbacks(TextureCallback);
                return;
            }

            var textureData = jsonData.textures[textureID];
            var format = textureData.format;
            var target = textureData.target;
            if (format < 6406 || format > 6410 || target !== 3553) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadTexture:" + textureID + "):", "bad settings");
                TextureCallback(null); // bad parameters
                return;
            }

            textureItem = new GLTFViewer.Utils.FileGLTF.TextureItem(this, textureID, this._textureCache);
            textureItem.AddCallback(TextureCallback);
            textureItem.format = format;
            textureItem.target = target;

            textureItem.numCallbacksToProcess = 2;
            this._ReadSampler(fileInfo, textureData.sampler, Callback.bind(this, textureItem, "Sampler"));
            this._ReadImage(fileInfo, textureData.source, Callback.bind(this, textureItem, "Image"));
        }
    },
    // reads a programID, passes ProgramItem to ProgramCallback
    _ReadProgram: {
        value: function (fileInfo, programID, ProgramCallback) {
            function Callback(programItem, itemType, shaderItem) {
                if (programItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!shaderItem) {
                    programItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    programItem.DoCallbacks();
                    return;
                }
                if (itemType === "Vertex")
                    programItem.vertex = shaderItem;
                else
                    programItem.fragment = shaderItem;
                if (--programItem.numCallbacksToProcess > 0)
                    return;

                var gl = this._gl;
                try {
                    programItem.program = new GLTFViewer.Utils.ShaderProgram(gl, null, programItem.vertex.glslShader, programItem.fragment.glslShader);
                } catch (err) {
                    GLTFViewer.Utils.WriteErr(err);
                    programItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    programItem.DoCallbacks();
                    return;
                }

                programItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                programItem.DoCallbacks();
            }
            ///////////////////////////

            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(programID) || !jsonData.programs[programID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadProgram:" + programID + "):", "bad id");
                ProgramCallback(null); // bad programID
                return;
            }

            var programItem = this._programCache[programID];
            if (programItem) {
                programItem.DoCallbacks(ProgramCallback);
                return;
            }

            var programData = jsonData.programs[programID];

            programItem = new GLTFViewer.Utils.FileGLTF.ProgramItem(this, programID, this._programCache);
            programItem.AddCallback(ProgramCallback);

            programItem.numCallbacksToProcess = 2;
            this._ReadShader(fileInfo, programData.fragmentShader, Callback.bind(this, programItem, "Fragment"));
            this._ReadShader(fileInfo, programData.vertexShader, Callback.bind(this, programItem, "Vertex"));
        }
    },
    // reads a passID from passesData, passes a PassItem to PassCallback
    _ReadPass: {
        value: function (fileInfo, passID, passesData, PassCallback) {
            function Callback(passItem, programItem) {
                if (passItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!programItem) {
                    passItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    passItem.DoCallbacks();
                    return;
                }

                var is2D = false;

                // ensure that all program attributes have an entry in attributes
                var shaderAttributeNames = programItem.program.attribLocation ? Object.keys(programItem.program.attribLocation) : [];
                for (var i = 0; i < shaderAttributeNames.length; ++i) {
                    var shaderAttributeName = shaderAttributeNames[i];
                    if (!passItem.attributes || passItem.attributes[shaderAttributeName] === undefined) {
                        GLTFViewer.Utils.WriteErr("ERROR(ReadPass:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(passItem.ID) + "):", "program attribute " + shaderAttributeName + " not defined");
                        passItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                        passItem.DoCallbacks();
                        return;
                    }
                }
                // remove unused attributes
                for (var shaderAttributeName in passItem.attributes) {
                    if (programItem.program.attribLocation[shaderAttributeName] === undefined)
                        delete passItem.attributes[shaderAttributeName];
                }

                // ensure that all program uniforms have an entry in uniforms
                var shaderUniformNames = programItem.program.uniformLocation ? Object.keys(programItem.program.uniformLocation) : [];
                for (var i = 0; i < shaderUniformNames.length; ++i) {
                    var shaderUniformName = shaderUniformNames[i];
                    if (!passItem.uniforms || passItem.uniforms[shaderUniformName] === undefined) {
                        GLTFViewer.Utils.WriteErr("ERROR(ReadPass:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(passItem.ID) + "):", "program uniform " + shaderUniformName + " not defined");
                        passItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                        passItem.DoCallbacks();
                        return;
                    }
                    if (passItem.uniforms[shaderUniformName] === 'matrix2D')
                        is2D = true; // this is a hack that relies on an overlay having a parameter called matrix2D
                }
                // remove unused uniforms
                for (var shaderUniformName in passItem.uniforms) {
                    if (programItem.program.uniformLocation[shaderUniformName] === undefined)
                        delete passItem.uniforms[shaderUniformName];
                }

                passItem.program = programItem;
                passItem.is2D = is2D;

                passItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                passItem.DoCallbacks();
            }
            ///////////////////////////

            if (GLTFViewer.Utils.IsNull(passID) || !passesData || !passesData[passID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadPass:" + passID + "):", "bad id");
                PassCallback(null); // bad techniqueID
                return;
            }

            var passData = passesData[passID];
            var instanceProgram = passData.instanceProgram;

            // no need to cache passes, they are part of technique
            var passItem = new GLTFViewer.Utils.FileGLTF.PassItem(this, passID);
            passItem.AddCallback(PassCallback);
            passItem.attributes = instanceProgram.attributes;
            passItem.uniforms = instanceProgram.uniforms;
            passItem.states = passData.states;

            this._ReadProgram(fileInfo, instanceProgram.program, Callback.bind(this, passItem));
        }
    },
    // reads/parses a valueData object, passes ValueItem to ValueCallback
    _ReadValue: {
        value: function (fileInfo, valueName, valueData, ValueCallback, notTexture) {
            function Callback(valueItem, valueName, textureItem) {
                if (valueItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                // if string is not a textureid, then it must just be a string, so ignore bad texture
                if (textureItem)
                    valueItem.texture = textureItem;

                valueItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                valueItem.DoCallbacks();
            }
            ///////////////////////////

            // no need to cache values, they are part of material or technique
            var valueItem = new GLTFViewer.Utils.FileGLTF.ValueItem(this);
            valueItem.AddCallback(ValueCallback);
            valueItem.valueInitial = valueData;

            if (typeof valueData !== 'string' || notTexture) {
                valueItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                valueItem.DoCallbacks();
                return;
            }

            // if it gets here, it is probably a textureID

            this._ReadTexture(fileInfo, valueData, Callback.bind(this, valueItem, valueName));
        }
    },
    // passes ValueItem to ParameterCallback
    _ReadParameter: {
        value: function (fileInfo, parameterName, parameterData, ParameterCallback) {
            function Callback(parameterData, ParameterCallback, itemName, item) {
                if (!item) {
                    ParameterCallback(null);
                    return;
                }

                // add some additional information to item (ValueItem)
                item.semantic = parameterData.semantic;
                item.source = parameterData.source; // we are not making use of this, it is a nodeID
                item.type = parameterData.type;

                ParameterCallback(item); // passing item (ValueItem) to ParameterCallback
            }
            ///////////////////////////

            this._ReadValue(fileInfo, parameterName, parameterData.value, Callback.bind(this, parameterData, ParameterCallback, parameterName));
        }
    },
    // reads a techniqueID, passes a TechniqueItem to TechniqueCallback
    _ReadTechnique: {
        value: function (fileInfo, techniqueID, TechniqueCallback) {
            function Callback(techniqueItem, itemType, parameterName, item) {
                if (techniqueItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!item) {
                    techniqueItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    techniqueItem.DoCallbacks();
                    return;
                }
                if (itemType === "Pass")
                    techniqueItem.pass = item;
                else
                    techniqueItem.parameters[parameterName] = item;
                if (--techniqueItem.numCallbacksToProcess > 0)
                    return;

                if (GLTFViewer.Utils.IsNull(techniqueItem.is2D))
                    techniqueItem.is2D = techniqueItem.pass.is2D;

                techniqueItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                techniqueItem.DoCallbacks();
            }
            ///////////////////////////

            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(techniqueID) || !jsonData.techniques[techniqueID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadTechnique:" + techniqueID + "):", "bad id");
                TechniqueCallback(null); // bad techniqueID
                return;
            }

            var techniqueItem = this._techniqueCache[techniqueID];
            if (techniqueItem) {
                techniqueItem.DoCallbacks(TechniqueCallback);
                return;
            }

            var techniqueData = jsonData.techniques[techniqueID];
            var parametersData = techniqueData.parameters;
            var parameterNames = parametersData ? Object.keys(parametersData) : [];
            var numParameters = parameterNames.length;

            techniqueItem = new GLTFViewer.Utils.FileGLTF.TechniqueItem(this, techniqueID, this._techniqueCache);
            techniqueItem.AddCallback(TechniqueCallback);
            techniqueItem.is2D = techniqueData.is2D;

            techniqueItem.numCallbacksToProcess = numParameters + 1;
            this._ReadPass(fileInfo, techniqueData.pass, techniqueData.passes, Callback.bind(this, techniqueItem, "Pass", null));
            for (var i = 0; i < numParameters; ++i) {
                var parameterName = parameterNames[i];
                this._ReadParameter(fileInfo, parameterName, parametersData[parameterName], Callback.bind(this, techniqueItem, "Parameter", parameterName));
            }
        }
    },
    _GenerateClipProgram: {
        value: function (technique) {
            var parameters = technique.parameters;
            var pass = technique.pass;

            // look for position in shader
            var positionName = null;
            var shaderAttributeNames = pass.attributes;
            for (var shaderAttributeName in shaderAttributeNames) {
                var parameterName = shaderAttributeNames[shaderAttributeName];
                var parameterData = parameters[parameterName];
                var semantic = parameterData.semantic;
                var type = parameterData.type;
                if (semantic === this._POSITIONNAME) {
                    positionName = shaderAttributeName;
                    break;
                }
            }
            if (GLTFViewer.Utils.IsNull(positionName)) {
                GLTFViewer.Utils.WriteErr("ERROR(GenerateClipProgram): Can't create clip program");
                return false;
            }

            var program = pass.program;
            program.programClip = GLTFViewer.Utils.ShaderProgram.CreateClipableProgram(this._gl, null, program.vertex.glslShader, program.fragment.glslShader, this._objMatrixName, positionName, this._clipName);
            if (!program.programClip)
                return false;
            program.programCap = GLTFViewer.Utils.ShaderProgram.CreateClipableCapProgram(this._gl, null, program.vertex.glslShader, program.fragment.glslShader, this._objMatrixName, positionName, this._clipName, this._colorName);
            return true;
        }
    },
    _GeneratePeelProgram: {
        value: function (technique) {
            var parameters = technique.parameters;
            var pass = technique.pass;

            var program = pass.program;
            program.programPeel = GLTFViewer.Utils.ShaderProgram.CreatePeelProgram(this._gl, null, program.vertex.glslShader, program.fragment.glslShader);
            return program.programPeel ? true : false;
        }
    },
    // reads a materialID, passes MaterialItem to MaterialCallback
    _ReadMaterial: {
        value: function (fileInfo, materialID, MaterialCallback) {
            function Callback(fileInfo, materialItem, itemType, valueName, item) {
                if (materialItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!item) {
                    materialItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    materialItem.DoCallbacks();
                    return;
                }
                if (itemType === "Technique")
                    materialItem.technique = item;
                else {
                    materialItem.values[valueName] = item;
                    if (valueName === "solidColor") { // use this to cap solid objects
                        materialItem.solidColor = new Float32Array(4);
                        materialItem.solidColor[0] = materialItem.solidColor[1] = materialItem.solidColor[2] = materialItem.solidColor[3] = 1;
                        var v = item.value;
                        for (var i = 0; i < v.length && i < 4; ++i)
                            materialItem.solidColor[i] = v[i];
                    }
                }
                if (--materialItem.numCallbacksToProcess > 0)
                    return;

                materialItem.is2D = materialItem.technique.is2D;
                if (!this._GeneratePeelProgram(materialItem.technique))
                    this.CanPeel = false;
                if (!materialItem.is2D && this._viewer.wantClip && !this._GenerateClipProgram(materialItem.technique))
                    this.CanClip = false;
                materialItem.program = materialItem.technique.pass.program;

                // Attributes
                var shaderAttributeNames = materialItem.technique.pass.attributes;
                for (var shaderAttributeName in shaderAttributeNames) {
                    var location = materialItem.program.program.attribLocation[shaderAttributeName];
                    var parameterName = shaderAttributeNames[shaderAttributeName];
                    var parameterData = materialItem.technique.parameters[parameterName];
                    var semantic = parameterData.semantic; // attribute values come from mesh/primtives/attributes and must have a semantic
                    var type = parameterData.type;
                    if (GLTFViewer.Utils.IsNull(semantic) || GLTFViewer.Utils.IsNull(type) || !this._glUniform[type].set) {
                        GLTFViewer.Utils.WriteErr("ERROR(ReadMaterial:" + materialID + "):", "technique parameter " + shaderAttributeName + " bad semantic/type");
                        materialItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                        materialItem.DoCallbacks();
                        return;
                    }
                    var setter = this._glUniform[type].set;
                    materialItem.attributes.push(new GLTFViewer.Utils.FileGLTF.ShaderParams(type, semantic, setter, shaderAttributeName));
                }

                // Uniforms
                var jsonData = fileInfo._jsonData;
                materialItem.semanticUniforms = [];
                materialItem.valueUniforms = {};
                var shaderUniformNames = materialItem.technique.pass.uniforms;
                for (var shaderUniformName in shaderUniformNames) {
                    var location = materialItem.program.program[shaderUniformName];
                    var parameterName = shaderUniformNames[shaderUniformName];
                    var parameterData = materialItem.technique.parameters[parameterName];
                    var semantic = parameterData.semantic;
                    var type = parameterData.type;
                    if (GLTFViewer.Utils.IsNull(type) || !this._glUniform[type].set) {
                        GLTFViewer.Utils.WriteErr("ERROR(ReadMaterial:" + materialID + "):", "technique parameter " + shaderUniformName + " bad type");
                        materialItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                        materialItem.DoCallbacks();
                        return;
                    }
                    var setter = this._glUniform[type].set;

                    if (semantic === "MODEL") {
                        var data = this._uModel;
                        materialItem.semanticUniforms.push(new GLTFViewer.Utils.FileGLTF.ShaderParams(type, data, setter, shaderUniformName));
                    } else if (semantic === "VIEW") {
                        var data = this._uView;
                        materialItem.semanticUniforms.push(new GLTFViewer.Utils.FileGLTF.ShaderParams(type, data, setter, shaderUniformName));
                    } else if (semantic === "MODELVIEW") {
                        var data = this._uModelView;
                        materialItem.semanticUniforms.push(new GLTFViewer.Utils.FileGLTF.ShaderParams(type, data, setter, shaderUniformName));
                    } else if (semantic === "MODELVIEWINVERSETRANSPOSE") {
                        data = this._uModelViewInvTrp;
                        materialItem.semanticUniforms.push(new GLTFViewer.Utils.FileGLTF.ShaderParams(type, data, setter, shaderUniformName));
                    } else if (semantic === "VIEWPORT") {
                        data = this._uViewport;
                        materialItem.semanticUniforms.push(new GLTFViewer.Utils.FileGLTF.ShaderParams(type, data, setter, shaderUniformName));
                    } else if (semantic === "PROJECTION") {
                        var data;
                        if (materialItem.is2D)
                            data = this._uTProj2;
                        else
                            data = this._uTProj;
                        materialItem.semanticUniforms.push(new GLTFViewer.Utils.FileGLTF.ShaderParams(type, data, setter, shaderUniformName));
                    } else {
                        var data;
                        if (!GLTFViewer.Utils.IsNull(materialItem.values[parameterName])) {
                            var value = materialItem.values[parameterName];
                            if (!GLTFViewer.Utils.IsNull(value.texture))
                                data = value.texture.texture;
                            else
                                data = value.value;
                        } else if (!GLTFViewer.Utils.IsNull(parameterData.texture))
                            data = parameterData.texture.texture;
                        else if (!GLTFViewer.Utils.IsNull(parameterData.value))
                            data = parameterData.value;
                        else if (!GLTFViewer.Utils.IsNull(parameterData.source)) {
                            // NOTE: it is not entirely clear how source works
                            var node = jsonData.nodes[parameterData.source];
                            if (!node || !node.matrix) {
                                GLTFViewer.Utils.WriteErr("ERROR(ReadMaterial:" + materialID + "):", "technique parameter " + shaderUniformName + " bad source");
                                materialItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                                materialItem.DoCallbacks();
                                return;
                            }
                            data = node.matrix;
                        } else {
                            GLTFViewer.Utils.WriteErr("ERROR(ReadMaterial:" + materialID + "):", "technique parameter " + shaderUniformName + " value not defined");
                            materialItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                            materialItem.DoCallbacks();
                            return;
                        }
                        data = this._glUniform[type].create(data);
                        if (GLTFViewer.Utils.IsNull(data)) {
                            GLTFViewer.Utils.WriteErr("ERROR(ReadMaterial:" + materialID + "):", "technique parameter " + shaderUniformName + " bad value");
                            materialItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                            materialItem.DoCallbacks();
                            return;
                        }
                        materialItem.valueUniforms[parameterName] = new GLTFViewer.Utils.FileGLTF.ShaderParams(type, data, setter, shaderUniformName);
                    }
                }

                // GL State
                function SetStateValue(states, state, type, defVal) {
                    if (GLTFViewer.Utils.IsNull(states))
                        return { type: type, data: defVal, defaultValue: defVal };
                    var path = state.split("/");
                    var s = states;
                    for (var i = 0; i < path.length; ++i) {
                        s = s[path[i]];
                        if (GLTFViewer.Utils.IsNull(s))
                            return { type: type, data: defVal, defaultValue: defVal };
                    }
                    return { type: type, data: s, defaultValue: s };
                }
                var states = materialItem.technique.pass.states;
                materialItem.blendEnable = SetStateValue(states, "blendEnable", 35670, false);
                materialItem.cullFace = SetStateValue(states, "cullFace", "LIST", 1029); // GL_BACK
                materialItem.cullFaceEnable = SetStateValue(states, "cullFaceEnable", 35670, false);
                materialItem.depthFunc = SetStateValue(states, "depthFunc", "LIST", 513); // GL_LESS
                materialItem.depthMask = SetStateValue(states, "depthMask", 35670, true);
                materialItem.depthTestEnable = SetStateValue(states, "depthTestEnable", 35670, true); // this really should be false
                materialItem.frontFace = SetStateValue(states, "frontFace", "LIST", 2305); // GL_CCW
                materialItem.lineWidth = SetStateValue(states, "lineWidth", 5126, 1);
                materialItem.polygonOffsetFillEnable = SetStateValue(states, "polygonOffsetFillEnable", 35670, false);
                materialItem.polygonOffsetFactor = SetStateValue(states, "polygonOffset/factor", 5126, 0);
                materialItem.polygonOffsetUnits = SetStateValue(states, "polygonOffset/units", 5126, 0);

                materialItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                materialItem.DoCallbacks();
            }
            ///////////////////////////

            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(materialID) || !jsonData.materials[materialID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadMaterial:" + materialID + "):", "bad id");
                MaterialCallback(null); // bad materialID
                return;
            }

            var materialItem = this._materialCache[materialID];
            if (materialItem) {
                materialItem.DoCallbacks(MaterialCallback);
                return;
            }

            var materialData = jsonData.materials[materialID];

            var instanceTechnique = materialData.instanceTechnique;
            var techniqueID = instanceTechnique.technique;
            var numTechniques = !GLTFViewer.Utils.IsNull(techniqueID);
            if (numTechniques === 0) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadMaterial):", "bad instanceTechnique");
                MaterialCallback(null);
                return;
            }
            var valuesData = instanceTechnique.values;
            var valueNames = valuesData ? Object.keys(valuesData) : [];
            var numValues = valueNames.length;

            materialItem = new GLTFViewer.Utils.FileGLTF.MaterialItem(this, materialID, this._materialCache);
            materialItem.AddCallback(MaterialCallback);

            materialItem.numCallbacksToProcess = numValues + 1;
            this._ReadTechnique(fileInfo, techniqueID, Callback.bind(this, fileInfo, materialItem, "Technique", null));
            for (var i = 0; i < numValues; ++i) {
                var valueName = valueNames[i];
                this._ReadValue(fileInfo, valueName, valuesData[valueName], Callback.bind(this, fileInfo, materialItem, "Value", valueName));
            }
        }
    },
    // reads/parses a primitiveData object, passes PrimitiveItem to PrimitiveCallback
    _ReadPrimitive: {
        value: function (fileInfo, primitiveData, PrimitiveCallback) {
            function Callback(primitiveItem, itemType, attributeName, item) {
                if (primitiveItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!item) {
                    primitiveItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    primitiveItem.DoCallbacks();
                    return;
                }
                if (itemType === "Material")
                    primitiveItem.material = item;
                else if (itemType === "Index")
                    primitiveItem.indices = item;
                else // Attribute
                    primitiveItem.attributes[attributeName] = item;
                if (--primitiveItem.numCallbacksToProcess > 0)
                    return;

                // get min and max, have to do it here since need materialItem to be read in
                if (!primitiveItem.material.is2D) {
                    for (var attributeName in primitiveItem.attributes) {
                        if (attributeName === this._POSITIONNAME) {
                            var attributeItem = primitiveItem.attributes[attributeName];
                            if (attributeItem.mn && attributeItem.mn.length === 3 && attributeItem.mx && attributeItem.mx.length === 3)
                                primitiveItem.SetBoundingBox(attributeItem.mn, attributeItem.mx);
                            break;
                        }
                    }
                }

                primitiveItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                primitiveItem.DoCallbacks();
            }
            ///////////////////////////

            if (!primitiveData) {
                PrimitiveCallback(null);
                return;
            }

            // can't cache primitives, there is no way to identify them

            var mode = primitiveData.primitive;
            var materialID = primitiveData.material;
            var hasMaterial = !GLTFViewer.Utils.IsNull(materialID);
            var indexID = primitiveData.indices;
            var hasIndex = !GLTFViewer.Utils.IsNull(indexID);
            var attributesData = primitiveData.attributes;
            var attributeNames = attributesData ? Object.keys(attributesData) : [];
            var numAttributes = attributeNames.length;
            if (mode < 0 || mode > 6 || !hasMaterial || numAttributes === 0) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadPrimitive):", "bad primitive");
                PrimitiveCallback(null); // empty
                return;
            }

            var primitiveItem = new GLTFViewer.Utils.FileGLTF.PrimitiveItem(this);
            primitiveItem.AddCallback(PrimitiveCallback);
            primitiveItem.mode = mode;
            if (!GLTFViewer.Utils.IsNull(primitiveData.isPickable))
                primitiveItem.isPickable = primitiveData.isPickable;

            primitiveItem.numCallbacksToProcess = 1 + (hasIndex ? 1 : 0) + numAttributes;
            this._ReadMaterial(fileInfo, materialID, Callback.bind(this, primitiveItem, "Material", null));
            if (hasIndex)
                this._ReadIndex(fileInfo, indexID, Callback.bind(this, primitiveItem, "Index", null));
            for (var i = 0; i < numAttributes; ++i) {
                var attributeName = attributeNames[i];
                this._ReadAttribute(fileInfo, attributesData[attributeName], Callback.bind(this, primitiveItem, "Attribute", attributeName));
            }
        }
    },
    // reads a legendID, passes LegendItem to LegendCallback
    _ReadLegend: {
        value: function (fileInfo, legendID, LegendCallback) {
            function Callback(legendItem, imageItem) {
                if (legendItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!imageItem) {
                    legendItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    legendItem.DoCallbacks();
                    return;
                }

                legendItem.image = imageItem; // data read from stream

                legendItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                legendItem.DoCallbacks();
            }
            ///////////////////////////

            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(legendID) || (!this._legendCache[legendID] && (!jsonData.legends || !jsonData.legends[legendID]))) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadLegend:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(legendID) + "):", "bad id");
                LegendCallback(null); // bad legendID
                return;
            }

            var legendItem = this._legendCache[legendID];
            if (legendItem) {
                legendItem.DoCallbacks(LegendCallback);
                return;
            }

            var legendData = jsonData.legends[legendID];
            var orientation = legendData.orientation;
            if (!GLTFViewer.Utils.IsNull(orientation) && orientation !== "horizontal" && orientation !== "vertical") {
                GLTFViewer.Utils.WriteErr("ERROR(ReadLegend:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(legendID) + "):", "bad orientation");
                LegendCallback(null);
                return;
            }
            var foreground = legendData.foreground;
            var background = legendData.background;
            var title = legendData.title;
            var other = legendData.other;
            var imageID = legendData.image;

            legendItem = new GLTFViewer.Utils.FileGLTF.LegendItem(this, legendID, this._legendCache);
            legendItem.AddCallback(LegendCallback);

            legendItem.x = legendData.x ? legendData.x : 0;
            legendItem.y = legendData.y ? legendData.y : 0;
            legendItem.attachment = legendData.attachment ? legendData.attachment : 0;
            legendItem.size = legendData.size ? legendData.size : 0;
            legendItem.vertical = !GLTFViewer.Utils.IsNull(orientation) ? (orientation !== "horizontal") : true;
            legendItem.border = legendData.border ? 1 : 0;
            legendItem.foreground = (GLTFViewer.Utils.IsNull(foreground) || foreground.length < 3) ? new GLTFViewer.Utils.RGBA(0, 0, 0, 255) : new GLTFViewer.Utils.RGBA(foreground[0] * 255, foreground[1] * 255, foreground[2] * 255, foreground.length > 3 ? foreground[3] * 255 : 255);
            legendItem.background = (GLTFViewer.Utils.IsNull(background) || background.length < 3) ? new GLTFViewer.Utils.RGBA(255, 255, 255, 0) : new GLTFViewer.Utils.RGBA(background[0] * 255, background[1] * 255, background[2] * 255, background.length > 3 ? background[3] * 255 : 255);
            legendItem.title = (!GLTFViewer.Utils.IsNull(title) && title.length) ? title : [];
            legendItem.units = legendData.units;
            legendItem.other = (!GLTFViewer.Utils.IsNull(other) && other.length) ? other : [];
            legendItem.min = legendData.min;
            legendItem.max = legendData.max;
            legendItem.ticks = legendData.ticks;
            legendItem.valueLocation = legendData.valueLocation;
            legendItem.logarithmic = (GLTFViewer.Utils.IsNull(legendData.valueLocation) && !GLTFViewer.Utils.IsNull(legendData.logarithmic)) ? 1 : 0;

            this._ReadImage(fileInfo, imageID, Callback.bind(this, legendItem));
        }
    },
    // reads a meshID, passes MeshItem to MeshCallback
    _ReadMesh: {
        value: function (fileInfo, meshID, MeshCallback) {
            function Callback(meshItem, primitiveItem) {
                if (meshItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!primitiveItem) {
                    // can handle bad primitives
                } else
                    meshItem.AddPrimitive(primitiveItem);
                if (--meshItem.numCallbacksToProcess > 0)
                    return;

                if (meshItem.primitives.length == 0) {
                    meshItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    meshItem.DoCallbacks();
                    return;
                }

                meshItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                meshItem.DoCallbacks();
            }

            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(meshID) || (!this._meshCache[meshID] && (!jsonData.meshes || !jsonData.meshes[meshID]))) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadMesh:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(meshID) + "):", "bad id");
                MeshCallback(null); // bad meshID
                return;
            }

            var meshItem = this._meshCache[meshID];
            if (meshItem) {
                meshItem.DoCallbacks(MeshCallback);
                return;
            }

            var meshData = jsonData.meshes[meshID];
            var primitivesData = meshData.primitives;
            var numPrimitives = primitivesData ? primitivesData.length : 0;
            if (numPrimitives === 0) {
                MeshCallback(null); // empty
                return;
            }

            meshItem = new GLTFViewer.Utils.FileGLTF.MeshItem(this, meshID, this._meshCache);
            meshItem.AddCallback(MeshCallback);

            meshItem.numCallbacksToProcess = numPrimitives;
            for (var i = 0; i < numPrimitives; ++i)
                this._ReadPrimitive(fileInfo, primitivesData[i], Callback.bind(this, meshItem));
        }
    },
    //  Reads a nodeID, passes NodeItem to NodeCallback
    _ReadNode: {
        value: function (fileInfo, nodeID, NodeCallback, forceLoad, parentVisible) {
            function Callback(nodeItem, itemType, item) {
                if (nodeItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING && nodeItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_PARTIAL_LOADING)
                    return;

                if (!item) {
                    // can handle bad meshes/nodes
                } else {
                    if (itemType === "Legend")
                        nodeItem.AddLegend(item);
                    else if (itemType === "Mesh")
                        nodeItem.AddMesh(item);
                    else
                        nodeItem.AddChild(item);
                }
                if (--nodeItem.numCallbacksToProcess > 0)
                    return;

                if (nodeItem.meshList.length === 0 && Object.keys(nodeItem.childList).length === 0 && GLTFViewer.Utils.IsNull(nodeItem.legend)) {
                    nodeItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    nodeItem.DoCallbacks();
                    return;
                }

                nodeItem.state = nodeItem.state === GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING ? GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK : GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_PARTIAL_OK;
                nodeItem.DoCallbacks();
            }
            ///////////////////////////

            var numMeshes = 0;
            var meshIDs = [];
            var numChildren = 0;
            var childIDs = [];
            var legendID = null;

            var nodeItem = this._nodeCache[this.IDMap(nodeID)];
            var isLegendNode = false;
            if (!GLTFViewer.Utils.IsNull(nodeItem)) {
                // we could normally do the same as every other loader
                // and just call nodeItem.DoCallbacks(NodeCallback) and return
                // but nodes can be in a partial state
                if ((nodeItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_PARTIAL_OK || !forceLoad) && nodeItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_PARTIAL_LOADING) {
                    // really want a second instance of node
                    nodeItem.DoCallbacks(NodeCallback);
                    return;
                }

                if (nodeItem.state === GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_PARTIAL_LOADING) {
                    // need to wait for this to finish and then reload node
                    function CallBack2(fileInfo, nodeID, NodeCallback, forceLoad, parentVisible) {
                        this._ReadNode(fileInfo, nodeID, NodeCallback, forceLoad, parentVisible);
                    }

                    --nodeItem.refCount; // the readNode in Callback2 will increment as appropriate
                    nodeItem.DoCallbacks(CallBack2.bind(this, fileInfo, nodeID, NodeCallback, forceLoad, parentVisible));
                    return;
                }
                // else nodeItem.state === GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_PARTIAL_OK

                meshIDs = nodeItem.meshIDList;
                childIDs = nodeItem.childIDList;
                legendID = nodeItem.legendID;
                isLegendNode = !GLTFViewer.Utils.IsNull(legendID);

                numMeshes = meshIDs ? meshIDs.length : 0;
                numChildren = childIDs ? childIDs.length : 0;
                if (numMeshes === 0 && numChildren === 0 && GLTFViewer.Utils.IsNull(legendID)) {
                    nodeItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    NodeCallback(null); // empty
                    return;
                }

                --nodeItem.refCount; // AddCallback below will increment this
            } else {
                // first time trying to read node
                // build the nodeItem
                var jsonData = fileInfo._jsonData;
                if (GLTFViewer.Utils.IsNull(nodeID) || !jsonData.nodes || !jsonData.nodes[nodeID]) {
                    GLTFViewer.Utils.WriteErr("ERROR(ReadNode:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(nodeID) + "):", "bad id");
                    NodeCallback(null);
                    return;
                }

                var nodeData = jsonData.nodes[nodeID];
                var name = nodeData.name;
                var crc = nodeData.crc;
                // only deal with camera, legend or mesh nodes (ignore light nodes)
                var isCameraNode = this._IsCameraNode(jsonData, nodeID);
                isLegendNode = this._IsLegendNode(jsonData, nodeID);
                var isMeshNode = this._IsMeshNode(jsonData, nodeID);
                if (!isCameraNode) {
                    if (!isMeshNode && !isLegendNode) {
                        NodeCallback(null); // must be a light node
                        return;
                    }

                    // mesh or legend node
                    // maybe it exists with a different ID
                    if ((typeof name === 'string') && name.length) {
                        var nodeItem2 = this._nodeCacheNameMap[name];
                        if (nodeItem2 && !GLTFViewer.Utils.IsNull(crc) && nodeItem2.crc === crc) {
                            this._idMap[nodeID] = nodeItem2.ID;
                            NodeCallback(null); // node is exact same as existing node, just ignore the node
                            return;
                        }
                    }

                    if (!isLegendNode) {
                        if (nodeData.mesh)
                            meshIDs = [nodeData.mesh];
                        else if (nodeData.meshes && Object.prototype.toString.call(nodeData.meshes) === "[object Array]")
                            meshIDs = GLTFViewer.Utils.RemoveDuplicates(nodeData.meshes);
                        childIDs = GLTFViewer.Utils.RemoveDuplicates(nodeData['children']);
                    }
                }

                if (!this._ValidateNode(jsonData, nodeID, [])) {
                    GLTFViewer.Utils.WriteErr("ERROR(ReadNode:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(nodeID) + "):", "not valid");
                    NodeCallback(null);
                    return;
                }

                var visible = !GLTFViewer.Utils.IsNull(nodeData.visible) ? nodeData.visible : 1;
                var matrix = GLTFViewer.Utils.IsNull(nodeData.matrix) ? null : new GLTFViewer.Utils.Transformation(nodeData.matrix);
                var cameraID = nodeData.camera;
                legendID = nodeData.legend;

                nodeItem = new GLTFViewer.Utils.FileGLTF.NodeItem(this, nodeID, fileInfo, this._nodeCache);
                if ((typeof name === 'string') && name.length)
                    this._nodeCacheNameMap[name] = nodeItem;
                nodeItem.name = name;
                nodeItem.editable = fileInfo._editable;
                nodeItem.visible = visible;
                nodeItem.crc = crc;
                nodeItem.matrix = new GLTFViewer.Utils.FileGLTF.ValueItem(this, matrix);
                nodeItem.cameraID = cameraID;
                nodeItem.legendID = legendID;
                nodeItem.meshIDList = meshIDs;
                nodeItem.childIDList = childIDs;

                if (isCameraNode) {
                    // nothing more required for camera node
                    nodeItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                    nodeItem.DoCallbacks(NodeCallback);
                    return;
                }

                numMeshes = meshIDs ? meshIDs.length : 0;
                numChildren = childIDs ? childIDs.length : 0;
                if (numMeshes === 0 && numChildren === 0 && GLTFViewer.Utils.IsNull(legendID)) {
                    nodeItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    NodeCallback(null); // empty
                    return;
                }
            }
            this._idMap[nodeID] = nodeItem.ID;

            nodeItem.AddCallback(NodeCallback);

            // load meshes/children
            var visible2 = nodeItem.visible && (GLTFViewer.Utils.IsNull(parentVisible) || parentVisible);

            nodeItem.numCallbacksToProcess = numChildren;
            nodeItem.state = (visible2 || forceLoad) ? GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING : GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_PARTIAL_LOADING;
            if (isLegendNode && nodeItem.state === GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING) {
                nodeItem.numCallbacksToProcess += 1;
                this._ReadLegend(fileInfo, legendID, Callback.bind(this, nodeItem, "Legend"));
            } else if (numMeshes && nodeItem.state === GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING) {
                nodeItem.numCallbacksToProcess += numMeshes;
                for (var i = 0; i < numMeshes; ++i)
                    this._ReadMesh(fileInfo, meshIDs[i], Callback.bind(this, nodeItem, "Mesh"));
            } else if (numChildren === 0) {
                // only get here if there are meshes to be defer loaded
                nodeItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_PARTIAL_OK;
                nodeItem.DoCallbacks();
                return;
            }

            for (var i = 0; i < numChildren; ++i)
                this._ReadNode(fileInfo, childIDs[i], Callback.bind(this, nodeItem, "Node"), forceLoad, visible2);
        }
    },
    _ReadScene: {
        value: function (fileInfo, sceneID, SceneCallback) {
            function Callback(fileInfo, sceneItem, nodeItem) {
                if (sceneItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!nodeItem) {
                    // can handle bad nodes
                } else {
                    if (nodeItem.cameraID) { // camera node
                        sceneItem.cameraMatrix = nodeItem.matrix.value;
                        sceneItem.camera = nodeItem;
                    } else {
                        if (!nodeItem.HasName())
                            nodeItem.name = nodeItem.ID;
                        sceneItem.AddNode(nodeItem);
                    }
                }
                if (--sceneItem.numCallbacksToProcess > 0)
                    return;

                if (Object.keys(sceneItem.sceneNodeItems).length === 0 && sceneItem.__NEWSCENE__) {
                    sceneItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    sceneItem.DoCallbacks();
                    return;
                }
                delete sceneItem.__NEWSCENE__;

                // set camera
                if (sceneItem.__UPDATECAMERA__ && sceneItem.camera && this._cameraCache[sceneItem.camera.cameraID]) {
                    var camera = this._cameraCache[sceneItem.camera.cameraID];
                    sceneItem.navigatorState = null;
                    // turn cameraMatrix into scene transformation
                    if (sceneItem.cameraMatrix)
                        sceneItem.cameraMatrix = GLTFViewer.Utils.FileGLTF.CameraToProjection(camera.type, sceneItem.cameraMatrix, sceneItem.GetBoundingBox());
                }
                delete sceneItem.__UPDATECAMERA__;

                // create markups
                for (var key in this._markupCache) {
                    var markup = this._markupCache[key];
                    if (markup.state === GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK && this.IDMap(sceneItem.ID) === this.IDMap(markup.sceneID)) {
                        if (GLTFViewer.Utils.IsNull(markup._key)) {
                            // fix index
                            markup.index = this.MarkupToSceneNodeItemIndex(markup);
                            markup.Create(sceneItem);
                        } else if (markup.type === GLTFViewer.Utils.Markup.LINE_TYPE_3D && !GLTFViewer.Utils.IsNull(markup.index) && GLTFViewer.Utils.IsNull(this._sceneNodeIndexToSceneNode[markup.index])) {
                            // maybe it needs to be deleted
                            this.MarkupDelete(markup._key);
                        }
                    }
                }

                // set visibility
                sceneItem.SetVisibility();

                sceneItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                sceneItem.DoCallbacks();
            }
            ///////////////////////////

            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(sceneID) || !jsonData.scenes || !jsonData.scenes[sceneID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadScene:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(sceneID) + "):", "bad id");
                SceneCallback(null);
                return;
            }

            var sceneData = jsonData.scenes[sceneID];
            var name = GLTFViewer.Utils.FileGLTF.GetName(sceneID, sceneData);
            var nodeIDs = GLTFViewer.Utils.RemoveDuplicates(sceneData.nodes);
            if (GLTFViewer.Utils.IsNull(nodeIDs))
                nodeIDs = [];

            var sceneItem = this._sceneCache[this.IDMap(sceneID)];
            if (GLTFViewer.Utils.IsNull(sceneItem))
                sceneItem = this._sceneCacheNameMap[name];
            if (!GLTFViewer.Utils.IsNull(sceneItem)) {
                // scene exists
                if (fileInfo._loadType === GLTFViewer.LT_REPLACE) {
                    // ignore scene if already exists
                    SceneCallback(null);
                    return;
                }

                // appending or updating an already existing scene
                sceneItem.refCount = 0; // there can only be 1 reference to a sceneItem
                sceneItem.AddCallback(SceneCallback);
                this.SelectScene(sceneItem);
                sceneItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING;
                if (fileInfo._fileType === GLTFViewer.Utils.FileGLTF.FILE_TYPE_SECONDARY) {
                    // scene from file.view of already existing scene
                    // only care about camera nodes
                    var cameraNodes = [];
                    for (var i = 0; i < nodeIDs.length; ++i) {
                        if (this._IsCameraNode(jsonData, nodeIDs[i])) {
                            cameraNodes.push(nodeIDs[i]);
                            break;
                        }
                    }
                    nodeIDs = cameraNodes;
                    sceneItem.__UPDATECAMERA__ = 1;
                } else {
                    sceneItem.sceneLI = this._viewer.AddEntrySceneList(sceneItem, this.SelectScene.bind(this, sceneItem));
                    // scene from file.gltf of already existing scene
                    // don't care about camera nodes we are appending or updating mesh nodes
                    for (var i = 0; i < nodeIDs.length; ) {
                        if (this._IsCameraNode(jsonData, nodeIDs[i]))
                            nodeIDs.splice(i, 1);
                        else
                            ++i;
                    }

                    // remove existing nodes if not in scene
                    if (fileInfo._loadType !== GLTFViewer.LT_APPEND) {
                        var nodeData = jsonData.nodes;
                        for (var i = 0; i < nodeIDs.length; ++i) {
                            var nodeItem = nodeData[nodeIDs[i]];
                            var name = nodeItem.name;
                            if ((typeof name === 'string') && name.length) {
                                // check by name
                                nodeItem = this._nodeCacheNameMap[name];
                                if (!GLTFViewer.Utils.IsNull(nodeItem))
                                    nodeItem.__KEEPME__ = 1;
                            }
                        }
                        for (var key in sceneItem.sceneNodeItems) {
                            var sceneNodeItem = sceneItem.sceneNodeItems[key];
                            var nodeItem = sceneNodeItem.nodeItem;
                            if (nodeItem.__KEEPME__)
                                continue;
                            sceneItem.DeleteNode(nodeItem.ID);
                        }
                        var keys = Object.keys(this._nodeCache);
                        for (var i = 0; i < keys.length; ++i) {
                            var nodeItem = this._nodeCache[keys[i]];
                            delete nodeItem.__KEEPME__;
                        }
                    }
                }
            } else {
                // create new sceneItem
                sceneItem = new GLTFViewer.Utils.FileGLTF.SceneItem(this, sceneID, this._sceneCache);
                this._sceneCacheNameMap[name] = sceneItem;
                sceneItem.AddCallback(SceneCallback);
                sceneItem.editable = fileInfo._editable;
                sceneItem.name = name;
                sceneItem.__NEWSCENE__ = 1;
                sceneItem.__UPDATECAMERA__ = 1;
                sceneItem.sceneLI = this._viewer.AddEntrySceneList(sceneItem, this.SelectScene.bind(this, sceneItem));
                sceneItem.background = sceneData.background;
                if (sceneData.ruler)
                    sceneItem.SetRuler(sceneData.ruler);
            }
            this._idMap[sceneID] = sceneItem.ID;
            sceneItem.visibility = sceneData.visibility;
            var numNodesToProcess = nodeIDs.length;
            if (sceneData.clip) {
                sceneItem.clipState = null;
                if (GLTFViewer.Utils.IsNull(sceneData.clip.visible) || sceneData.clip.visible) {
                    var p0 = sceneData.clip.p0;
                    var p1 = sceneData.clip.p1;
                    var p2 = sceneData.clip.p2;
                    if (p0 && p0.length === 3 &&
                        p1 && p1.length === 3 &&
                        p2 && p2.length === 3) {
                        sceneItem.clipP0 = new GLTFViewer.Utils.Vec3(p0[0], p0[1], p0[2]);
                        sceneItem.clipP1 = new GLTFViewer.Utils.Vec3(p1[0], p1[1], p1[2]);
                        sceneItem.clipP2 = new GLTFViewer.Utils.Vec3(p2[0], p2[1], p2[2]);
                    }
                } else {
                    sceneItem.clipP0 = null;
                    sceneItem.clipP1 = null;
                    sceneItem.clipP2 = null;
                }
            }
            if (sceneData.explosion) {
                var explosion = sceneData.explosion * 1;
                if (explosion > 0 && explosion <= 2)
                    sceneItem.explosion = explosion;
            }

            if (numNodesToProcess) {
                sceneItem.numCallbacksToProcess = numNodesToProcess;
                for (var i = 0; i < numNodesToProcess; ++i)
                    this._ReadNode(fileInfo, nodeIDs[i], Callback.bind(this, fileInfo, sceneItem), !this._viewer.wantLazyLoad);
            } else
                Callback.call(this, fileInfo, sceneItem, null, null); // empty scene
        }
    },
    _ReadCamera: {
        value: function (fileInfo, cameraID, CameraCallback) {
            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(cameraID) || !jsonData.cameras[cameraID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadCamera:" + cameraID + "):", "bad id");
                CameraCallback(null);
                return;
            }

            var cameraItem = this._cameraCache[cameraID];
            if (cameraItem) {
                cameraItem.DoCallbacks(CameraCallback);
                return;
            }

            var cameraData = jsonData.cameras[cameraID];
            var type = cameraData.type;
            if (type !== "perspective" && type !== "orthographic") {
                GLTFViewer.Utils.WriteErr("ERROR(ReadCamera:" + cameraID + "):", "bad camera type");
                CameraCallback(null);
                return;
            }

            cameraItem = new GLTFViewer.Utils.FileGLTF.CameraItem(this, cameraID, this._cameraCache);
            cameraItem.AddCallback(CameraCallback);
            cameraItem.type = type;
            if (cameraData[type]) {
                // at the moment we do not use any of this information
                var data = cameraData[type];
                cameraItem.xmag = data.xmag;
                cameraItem.ymag = data.ymag;
                cameraItem.yfov = data.yfov;
                cameraItem.aspectRatio = data.aspect_ratio;
                cameraItem.zfar = data.zfar;
                cameraItem.znear = data.znear;
            }

            cameraItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
            cameraItem.DoCallbacks();
        }
    },
    // returns an attributeItem to ParameterCallback
    _ReadAnimationParameter: {
        value: function (fileInfo, animationData, parameterID, ParameterCallback) {
            if (GLTFViewer.Utils.IsNull(parameterID) || !animationData.parameters || !animationData.parameters[parameterID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadAnimationParameter:" + parameterID + "):", "bad id");
                ParameterCallback(null);
                return;
            }

            // no need to cache parameters, they refer to a attribute

            var attributeID = animationData.parameters[parameterID];

            this._ReadAttribute(fileInfo, attributeID, ParameterCallback);
        }
    },
    _ReadAnimationSampler: {
        value: function (fileInfo, animationID, animationData, samplerID, SamplerCallback) {
            function Callback(samplerItem, itemType, attributeItem) {
                if (samplerItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!attributeItem) {
                    samplerItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    samplerItem.DoCallbacks();
                    return;
                }
                if (itemType === "Input") {
                    if (attributeItem.type !== 5126) {
                        GLTFViewer.Utils.WriteErr("ERROR(ReadAnimationSampler:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(samplerItem.ID) + "): bad input type");
                        samplerItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                        samplerItem.DoCallbacks();
                        return;
                    }
                    samplerItem.input = attributeItem;
                } else // "Output"
                    samplerItem.output = attributeItem;
                if (--samplerItem.numCallbacksToProcess > 0)
                    return;

                //if (samplerItem.input.count !== samplerItem.output.count) {
                //    GLTFViewer.Utils.WriteErr("ERROR(ReadAnimationSampler:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(samplerItem.ID) + "): input size != output size");
                //    samplerItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                //    samplerItem.DoCallbacks();
                //    return;
                //}

                samplerItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                samplerItem.DoCallbacks();
            }
            ///////////////////////////

            if (GLTFViewer.Utils.IsNull(samplerID) || !animationData.samplers || !animationData.samplers[samplerID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadAnimationSampler:" + samplerID + "):", "bad id");
                SamplerCallback(null);
                return;
            }

            var samplerItem = this._animationSamplerCache[animationID + samplerID];
            if (samplerItem) {
                samplerItem.DoCallbacks(SamplerCallback);
                return;
            }

            var samplerData = animationData.samplers[samplerID];

            samplerItem = new GLTFViewer.Utils.FileGLTF.AnimationSamplerItem(this, animationID + samplerID, this._animationSamplerCache);
            samplerItem.AddCallback(SamplerCallback);
            samplerItem.interpolation = samplerData.interpolation;

            samplerItem.numCallbacksToProcess = 2;
            this._ReadAnimationParameter(fileInfo, animationData, samplerData.input, Callback.bind(this, samplerItem, "Input"));
            this._ReadAnimationParameter(fileInfo, animationData, samplerData.output, Callback.bind(this, samplerItem, "Output"));
        }
    },
    _ReadAnimationChannel: {
        value: function (fileInfo, animationID, animationData, channelData, ChannelCallback) {
            function Callback(channelItem, samplerItem) {
                if (channelItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!samplerItem) {
                    channelItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    channelItem.DoCallbacks();
                    return;
                }

                channelItem.sampler = samplerItem;

                channelItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                channelItem.DoCallbacks();
            }
            ///////////////////////////

            if (!channelData) {
                ChannelCallback(null);
                return;
            }

            // can't cache channels, there is no way to identify them

            var samplerID = channelData.sampler;
            var targetID = channelData.target ? channelData.target.id : null;
            var targetPath = channelData.target ? channelData.target.path : null;
            if (GLTFViewer.Utils.IsNull(samplerID) || GLTFViewer.Utils.IsNull(targetID) || GLTFViewer.Utils.IsNull(targetPath)) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadAnimationChannel):", "bad channel");
                ChannelCallback(null); // empty
                return;
            }

            var channelItem = new GLTFViewer.Utils.FileGLTF.AnimationChannelItem(this);
            channelItem.AddCallback(ChannelCallback);
            channelItem.targetID = targetID;
            channelItem.targetPath = targetPath;

            this._ReadAnimationSampler(fileInfo, animationID, animationData, samplerID, Callback.bind(this, channelItem));
        }
    },
    _ReadAnimation: {
        value: function (fileInfo, animationID, AnimationCallback) {
            function Callback(animationItem, channelItem) {
                if (animationItem.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING)
                    return;

                if (!channelItem) {
                    GLTFViewer.Utils.WriteErr("ERROR(ReadAnimation:" + GLTFViewer.Utils.FileGLTF.FileInfo.RealID(animationItem.ID) + "):", "bad channel");
                    animationItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
                    animationItem.DoCallbacks();
                    return;
                }

                animationItem.channelList.push(channelItem);

                if (--animationItem.numCallbacksToProcess > 0)
                    return;

                animationItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                animationItem.DoCallbacks();
            }
            ///////////////////////////

            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(animationID) || !jsonData.animations[animationID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadAnimation:" + animationID + "):", "bad id");
                AnimationCallback(null);
                return;
            }

            var animationItem = this._animationCache[animationID];
            if (animationItem) {
                animationItem.DoCallbacks(AnimationCallback);
                return;
            }

            var animationData = jsonData.animations[animationID];
            if (!animationData || !animationData.channels || animationData.channels.length === 0) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadAnimation:" + animationID + "):", "bad animation data");
                AnimationCallback(null);
                return;
            }
            var channels = animationData.channels;
            var numChannels = channels.length;

            animationItem = new GLTFViewer.Utils.FileGLTF.AnimationItem(this, animationID, this._animationCache);
            animationItem.AddCallback(AnimationCallback);

            animationItem.numCallbacksToProcess = numChannels;
            for (var i = 0; i < numChannels; ++i)
                this._ReadAnimationChannel(fileInfo, animationID, animationData, channels[i], Callback.bind(this, animationItem));
        }
    },
    _ReadMarkup: {
        value: function (fileInfo, markupID, MarkupCallback) {
            var jsonData = fileInfo._jsonData;
            if (GLTFViewer.Utils.IsNull(markupID) || !jsonData.markups[markupID]) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadMarkup:" + markupID + "):", "bad id");
                MarkupCallback(null);
                return;
            }
            var markupItem = this._markupCache[markupID];
            if (markupItem) {
                markupItem.DoCallbacks(MarkupCallback);
                return;
            }
            var markupData = jsonData.markups[markupID];

            var sceneID = markupData.scene;
            var type = GLTFViewer.Utils.IsNull(markupData.type) ? GLTFViewer.Utils.Markup.LINE_TYPE_2D : markupData.type;
            var path = markupData.path;
            var position = markupData.position;
            var lineColor = markupData.lineColor;
            var lineShape = GLTFViewer.Utils.IsNull(markupData.lineShape) ? GLTFViewer.Utils.Markup.LINE_SYMBOL_NONE : markupData.lineShape;
            var text = GLTFViewer.Utils.IsNull(markupData.text) ? "" : GLTFViewer.Utils.CRLFtoCR(markupData.text);
            var textOffset = markupData.textOffset;
            var textAttach = GLTFViewer.Utils.IsNull(markupData.textAttach) ? GLTFViewer.Utils.Markup.TEXT_ATTACH_AUTO : markupData.textAttach;
            var textSize = GLTFViewer.Utils.IsNull(markupData.textSize) ? 10 : markupData.textSize;
            var textFont = GLTFViewer.Utils.IsNull(markupData.textFont) ? "sans-serif" : markupData.textFont;
            var textColor = markupData.textColor;
            var backgroundColor = markupData.backgroundColor;
            if (!text.length ||
                (type < GLTFViewer.Utils.Markup.LINE_TYPE_2D || type > GLTFViewer.Utils.Markup.LINE_TYPE_3D) ||
                (type === 1 && (lineShape < GLTFViewer.Utils.Markup.LINE_SYMBOL_NONE || lineShape > GLTFViewer.Utils.Markup.LINE_SYMBOL_BALL)) ||
                (textAttach < GLTFViewer.Utils.Markup.TEXT_ATTACH_AUTO || textAttach > GLTFViewer.Utils.Markup.TEXT_ATTACH_SE)) {
                GLTFViewer.Utils.WriteErr("ERROR(ReadMarkup:" + markupID + "):", "bad settings");
                MarkupCallback(null); // bad parameters
                return;
            }

            markupItem = new GLTFViewer.Utils.FileGLTF.MarkupItem(this, markupID, this._markupCache);
            markupItem.AddCallback(MarkupCallback);
            markupItem.editable = fileInfo._editable;
            markupItem.type = type;
            markupItem.index = path;
            markupItem.sceneID = sceneID;
            markupItem.position = (GLTFViewer.Utils.IsNull(position) || position.length < 2) ? new GLTFViewer.Utils.Vec3(0, 0, 0) : new GLTFViewer.Utils.Vec3(position[0], position[1], position.length > 2 ? position[2] : 0);
            markupItem.lineColor = (GLTFViewer.Utils.IsNull(lineColor) || lineColor.length < 3) ? new GLTFViewer.Utils.RGBA(0, 0, 0, 255) : new GLTFViewer.Utils.RGBA(lineColor[0] * 255, lineColor[1] * 255, lineColor[2] * 255, lineColor.length > 3 ? lineColor[3] * 255 : 255);
            markupItem.lineShape = lineShape;
            markupItem.text = text;
            markupItem.textOffset = (GLTFViewer.Utils.IsNull(textOffset) || textOffset.length < 2) ? new GLTFViewer.Utils.Vec3(0, 0, 0) : new GLTFViewer.Utils.Vec3(textOffset[0], textOffset[1], 0);
            markupItem.textAttach = textAttach;
            markupItem.textSize = textSize;
            markupItem.textFont = textFont;
            markupItem.textColor = (GLTFViewer.Utils.IsNull(textColor) || textColor.length < 3) ? new GLTFViewer.Utils.RGBA(0, 0, 0, 255) : new GLTFViewer.Utils.RGBA(textColor[0] * 255, textColor[1] * 255, textColor[2] * 255, textColor.length > 3 ? textColor[3] * 255 : 255);
            markupItem.backgroundColor = (GLTFViewer.Utils.IsNull(backgroundColor) || backgroundColor.length < 3) ? new GLTFViewer.Utils.RGBA(255, 255, 255, 128) : new GLTFViewer.Utils.RGBA(backgroundColor[0] * 255, backgroundColor[1] * 255, backgroundColor[2] * 255, backgroundColor.length > 3 ? backgroundColor[3] * 255 : 255);

            // no reading required

            markupItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
            markupItem.DoCallbacks();
        }
    },
    _Readgltf: {
        value: function (jsonData, files, fileType, GLTFCallback, loadType, sceneState) {
            function Callback(fileInfo, gltfItem, itemType, item) {
                if (itemType === "Camera") {
                    // not doing anything with cameras
                    if (--gltfItem.numCamerasToProcess <= 0) {
                        if (gltfItem.markupIDs.length) {
                            // markups need to be read in before scenes
                            if (gltfItem.markupIDs.length) {
                                for (var i = 0; i < gltfItem.markupIDs.length; ++i)
                                    this._ReadMarkup(fileInfo, gltfItem.markupIDs[i], Callback.bind(this, fileInfo, gltfItem, "Markup"));
                                return;
                            }
                        } else {
                            // now read scenes, animations
                            if (gltfItem.animationIDs.length || gltfItem.sceneIDs.length) {
                                for (var i = 0; i < gltfItem.animationIDs.length; ++i)
                                    this._ReadAnimation(fileInfo, gltfItem.animationIDs[i], Callback.bind(this, fileInfo, gltfItem, "Animation"));
                                for (var i = 0; i < gltfItem.sceneIDs.length; ++i)
                                    this._ReadScene(fileInfo, gltfItem.sceneIDs[i], Callback.bind(this, fileInfo, gltfItem, "Scene"));
                                return;
                            }
                        }
                    }
                } else if (itemType === "Markup") {
                    if (--gltfItem.numMarkupsToProcess <= 0) {
                        // now read scenes and animations
                        if (gltfItem.animationIDs.length || gltfItem.sceneIDs.length) {
                            for (var i = 0; i < gltfItem.animationIDs.length; ++i)
                                this._ReadAnimation(fileInfo, gltfItem.animationIDs[i], Callback.bind(this, fileInfo, gltfItem, "Animation"));
                            for (var i = 0; i < gltfItem.sceneIDs.length; ++i)
                                this._ReadScene(fileInfo, gltfItem.sceneIDs[i], Callback.bind(this, fileInfo, gltfItem, "Scene"));
                            return;
                        }
                    }
                } else if (itemType === "Animation") {
                    // not doing anything with animations
                    --gltfItem.numAnimationsToProcess;
                } else {
                    if (!item) {
                        ; // ignore bad scene
                    } else {
                        if (GLTFViewer.Utils.IsNull(gltfItem.sceneItemName) || gltfItem.sceneID === item.ID)
                            gltfItem.sceneItemName = item.name;
                        item.__KEEPME__ = 1;
                    }
                    --gltfItem.numScenesToProcess;
                }

                if (gltfItem.numCamerasToProcess <= 0 && gltfItem.numMarkupsToProcess <= 0 && gltfItem.numAnimationsToProcess <= 0 && gltfItem.numScenesToProcess <= 0) {
                    this._progressBar.Stop();
                    this._empty = false;

                    for (var key in this._sceneCache) {
                        var sceneItem = this._sceneCache[key];
                        var keep = sceneItem.__KEEPME__;
                        delete sceneItem.__KEEPME__;
                        if (fileInfo._loadType !== GLTFViewer.LT_APPEND && !keep)
                            this.DeleteScene(sceneItem.visIndex);
                    }

                    var sceneState = fileInfo._sceneState;
                    var sceneItem = null;
                    if (sceneState && sceneState.sceneName) {
                        // try to find this scene
                        sceneItem = this.FindSceneItemByName(sceneState.sceneName);
                        if (GLTFViewer.Utils.IsNull(sceneItem))
                            sceneState = null;
                    }
                    if (!sceneItem && !GLTFViewer.Utils.IsNull(gltfItem.sceneItemName))
                        sceneItem = this.FindSceneItemByName(gltfItem.sceneItemName);
                    if (!sceneItem) {
                        var keys = Object.keys(this._sceneCache);
                        if (keys.length)
                            sceneItem = this._sceneCache[keys[0]];
                    }
                    if (sceneItem) {
                        this._curScene = null; // in case new nodes got added, need to rebuild visibility
                        sceneItem.navigatorState = null;
                        this.SelectScene(sceneItem, sceneState);
                    }
                    var animationKeys = Object.keys(this._animationCache);
                    if (animationKeys.length > 0)
                        this._animationInfo = new GLTFViewer.Utils.FileGLTF.AnimationInfo(this, fileInfo);
                    GLTFCallback(true);
                }
            }

            if (!jsonData) {
                GLTFViewer.Utils.WriteErr("ERROR(Readgltf):", "bad GLTF data");
                GLTFCallback(false);
                return;
            }
            if (fileType !== GLTFViewer.Utils.FileGLTF.FILE_TYPE_SECONDARY)
                ++this._fileNum;
            var fileInfo = new GLTFViewer.Utils.FileGLTF.FileInfo(this._fileNum, jsonData, files, fileType, fileType === GLTFViewer.Utils.FileGLTF.FILE_TYPE_SECONDARY, loadType, sceneState);

            this._SetFileSizes(fileInfo);

            this._progressTotal = (fileType === GLTFViewer.Utils.FileGLTF.FILE_TYPE_UNZIP_TO_MEMORY) ? files.totalZipFileBytes : 0;

            var cameras = jsonData.cameras;
            var cameraIDs = cameras ? Object.keys(cameras) : [];
            var numCameras = cameraIDs.length;

            var animations = jsonData.animations;
            var animationIDs = animations ? Object.keys(animations) : [];
            var numAnimations = animationIDs.length;

            var markups = jsonData.markups;
            var markupIDs = markups ? Object.keys(markups) : [];
            var numMarkups = markupIDs.length;

            var sceneID = jsonData.scene;
            var scenes = jsonData.scenes;
            var sceneIDs = scenes ? Object.keys(scenes) : (!GLTFViewer.Utils.IsNull(sceneID) ? [sceneID] : []);
            sceneIDs = GLTFViewer.Utils.RemoveDuplicates(sceneIDs);

            var numScenes = sceneIDs.length;
            if (numScenes === 0 && !this._curScene) {
                // can't do anything if have no scenes
                GLTFCallback(false);
                return;
            }
            if (GLTFViewer.Utils.IsNull(sceneID) && sceneIDs.length && !this._curScene)
                sceneID = sceneIDs[0];

            var nodeIDs = [];
            for (var i = 0; i < numScenes; ++i) {
                var sceneData = jsonData.scenes[sceneIDs[i]];
                nodeIDs = nodeIDs.concat(sceneData.nodes);
            }
            nodeIDs = GLTFViewer.Utils.RemoveDuplicates(nodeIDs);
            // need to look through scenegraph and calculate load sizes
            this._totalGLTFBytes = this._ComputeLoadSizes(fileInfo, nodeIDs, !this._viewer.wantLazyLoad);
            if (!this._progressTotal && this._totalGLTFBytes)
                this._progressBar.Start(this._totalGLTFBytes);

            var gltfItem = {};
            gltfItem.numCamerasToProcess = numCameras;
            gltfItem.numScenesToProcess = numScenes;
            gltfItem.numAnimationsToProcess = numAnimations;
            gltfItem.numMarkupsToProcess = numMarkups;
            gltfItem.sceneID = sceneID;
            gltfItem.sceneIDs = sceneIDs;
            gltfItem.animationIDs = animationIDs;
            gltfItem.markupIDs = markupIDs;
            gltfItem.sceneItemName = this._curScene ? this._curScene.name : null;
            // cameras need to be read in before scenes
            if (numCameras) {
                for (var i = 0; i < numCameras; ++i)
                    this._ReadCamera(fileInfo, cameraIDs[i], Callback.bind(this, fileInfo, gltfItem, "Camera"));
            } else if (numMarkups) {
                // markups need to be read in before scenes
                for (var i = 0; i < numMarkups; ++i)
                    this._ReadMarkup(fileInfo, markupIDs[i], Callback.bind(this, fileInfo, gltfItem, "Markup"));
            } else {
                for (var i = 0; i < numAnimations; ++i)
                    this._ReadAnimation(fileInfo, animationIDs[i], Callback.bind(this, fileInfo, gltfItem, "Animation"));
                for (var i = 0; i < numScenes; ++i)
                    this._ReadScene(fileInfo, sceneIDs[i], Callback.bind(this, fileInfo, gltfItem, "Scene"));
            }
        }
    },
    // looking for node circurlar references
    _ValidateNode: {
        value: function (jsonData, nodeID, path) {
            if (path.indexOf(nodeID) !== -1)
                return false;

            var nodeData = jsonData.nodes[nodeID];
            if (!nodeData)
                return false; // bad node

            var nodeIDs = nodeData['children'];
            if (nodeIDs && nodeIDs.length) {
                path.push(nodeID);
                var size = path.length;
                for (var i = 0; i < nodeIDs.length; ++i) {
                    if (!this._ValidateNode(jsonData, nodeIDs[i], path))
                        return false;
                    path = path.slice(0, size);
                }
            }

            return true;
        }
    },
    _IsCameraNode: {
        value: function (jsonData, nodeID) {
            if (GLTFViewer.Utils.IsNull(nodeID))
                return false;
            var nodeData = jsonData.nodes[nodeID];
            if (!nodeData)
                return false;
            var keys = Object.keys(nodeData);
            return keys.indexOf("camera") !== -1;
        }
    },
    _IsLegendNode: {
        value: function (jsonData, nodeID) {
            if (GLTFViewer.Utils.IsNull(nodeID))
                return false;
            var nodeData = jsonData.nodes[nodeID];
            if (!nodeData)
                return false;
            var keys = Object.keys(nodeData);
            return keys.indexOf("legend") !== -1;
        }
    },
    _IsLightNode: {
        value: function (jsonData, nodeID) {
            if (GLTFViewer.Utils.IsNull(nodeID))
                return false;
            var nodeData = jsonData.nodes[nodeID];
            if (!nodeData)
                return false;
            var keys = Object.keys(nodeData);
            return keys.indexOf("light") !== -1 || keys.indexOf("lights") !== -1;
        }
    },
    _IsMeshNode: {
        value: function (jsonData, nodeID) {
            return !this._IsCameraNode(jsonData, nodeID) && !this._IsLightNode(jsonData, nodeID);
        }
    },
    _SetBackColor: {
        value: function (bg) {
            try {
                if (bg.type === 0) { //solid
                    var r = Math.round(bg['color1'][0] * 255);
                    var g = Math.round(bg['color1'][1] * 255);
                    var b = Math.round(bg['color1'][2] * 255);
                    var color0 = new GLTFViewer.Utils.RGBA(r, g, b, 255).GetABGR();
                    this._background.SetSolidColors(color0, color0, color0, color0);
                } else if (bg.type === 1) { //top -> bottom
                    var r0 = Math.round(bg['color1'][0] * 255);
                    var g0 = Math.round(bg['color1'][1] * 255);
                    var b0 = Math.round(bg['color1'][2] * 255);
                    var r1 = Math.round(bg['color2'][0] * 255);
                    var g1 = Math.round(bg['color2'][1] * 255);
                    var b1 = Math.round(bg['color2'][2] * 255);
                    var color0 = new GLTFViewer.Utils.RGBA(r0, g0, b0, 255).GetABGR();
                    var color1 = new GLTFViewer.Utils.RGBA(r1, g1, b1, 255).GetABGR();
                    this._background.SetSolidColors(color0, color0, color1, color1);
                } else if (bg.type === 2) { //left -> right
                    var r0 = Math.round(bg['color1'][0] * 255);
                    var g0 = Math.round(bg['color1'][1] * 255);
                    var b0 = Math.round(bg['color1'][2] * 255);
                    var r1 = Math.round(bg['color2'][0] * 255);
                    var g1 = Math.round(bg['color2'][1] * 255);
                    var b1 = Math.round(bg['color2'][2] * 255);
                    var color0 = new GLTFViewer.Utils.RGBA(r0, g0, b0, 255).GetABGR();
                    var color1 = new GLTFViewer.Utils.RGBA(r1, g1, b1, 255).GetABGR();
                    this._background.SetSolidColors(color0, color1, color0, color1);
                } else if (bg.type === 3) { //topleft -> bottomright
                    var r0 = Math.round(bg['color1'][0] * 255);
                    var g0 = Math.round(bg['color1'][1] * 255);
                    var b0 = Math.round(bg['color1'][2] * 255);
                    var r1 = Math.round(bg['color2'][0] * 255);
                    var g1 = Math.round(bg['color2'][1] * 255);
                    var b1 = Math.round(bg['color2'][2] * 255);
                    var color0 = new GLTFViewer.Utils.RGBA(r0, g0, b0, 255).GetABGR();
                    var color1 = new GLTFViewer.Utils.RGBA(r1, g1, b1, 255).GetABGR();
                    this._background.SetSolidColors(color0, color1, color1, color0);
                }
            } catch (err) {
            }
        }
    },
    _ComputeLoadSizes: {
        value: function (fileInfo, nodeIDsToTotal, forceLoad) {
            var totalBytes = 0;
            var jsonData = fileInfo._jsonData;

            // get nodeIDs object, with value 1=load mesh, 0=no load mesh
            function AllNodes(jsonData, nodeID, nodeIDs, forceLoad, parentNodeVisible) {
                if (GLTFViewer.Utils.IsNull(nodeID) || !jsonData.nodes[nodeID])
                    return;
                var nodeData = jsonData.nodes[nodeID];
                var nodeVisible = GLTFViewer.Utils.IsNull(nodeData.visible) || nodeData.visible;
                var visible = forceLoad || (nodeVisible && parentNodeVisible);
                if (!nodeIDs[nodeID]) {
                    if (visible)
                        nodeIDs[nodeID] = 1;
                    var childNodes = nodeData.children;
                    if (childNodes && childNodes.length) {
                        for (var i = 0; i < childNodes.length; ++i) {
                            var childNodeID = childNodes[i];
                            AllNodes(jsonData, childNodeID, nodeIDs, forceLoad, visible);
                        }
                    }
                }
            }
            var nodeIDs = {};
            for (var i = 0; i < nodeIDsToTotal.length; ++i)
                AllNodes(jsonData, nodeIDsToTotal[i], nodeIDs, forceLoad, true);
            // get meshIDList
            var meshIDs = {};
            for (var nodeID in nodeIDs) {
                var nodeData = jsonData.nodes[nodeID];
                if (!nodeData)
                    continue;
                var meshIDList = [];
                if (nodeData.mesh)
                    meshIDList = [nodeData.mesh];
                else if (nodeData.meshes && Object.prototype.toString.call(nodeData.meshes) === "[object Array]")
                    meshIDList = nodeData.meshes;

                for (var j = 0; j < meshIDList.length; ++j) {
                    var meshID = meshIDList[j];
                    if (!meshIDs[meshID] && !this._meshCache[meshID])
                        meshIDs[meshID] = 1;
                }
            }
            var meshIDList = Object.keys(meshIDs);
            // get materialIDList, attributeIDList, indexIDList
            var materialIDs = {};
            var attributeIDs = {};
            var indexIDs = {};
            for (var i = 0; i < meshIDList.length; ++i) {
                var meshID = meshIDList[i];
                if (!jsonData.meshes)
                    continue;
                var meshData = jsonData.meshes[meshID];
                if (!meshData || !meshData.primitives || !meshData.primitives.length)
                    continue;
                var primitives = meshData.primitives;
                for (var j = 0; j < primitives.length; ++j) {
                    var primitiveData = primitives[j];
                    var materialID = primitiveData.material;
                    if (materialID !== undefined && !materialIDs[materialID] && !this._materialCache[materialID])
                        materialIDs[materialID] = 1;
                    var attributes = primitiveData.attributes;
                    if (attributes) {
                        for (var attributeName in attributes) {
                            var attributeID = attributes[attributeName];
                            if (attributeID !== undefined && !attributeIDs[attributeID] && !this._attributeCache[attributeID])
                                attributeIDs[attributeID] = 1;
                        }
                    }
                    var indexID = primitiveData.indices;
                    if (indexID !== undefined && !indexIDs[indexID] && !this._indexCache[indexID])
                        indexIDs[indexID] = 1;
                }
            }
            // get attributeIDs for animations
            for (var key in jsonData.animations) {
                var animation = jsonData.animations[key];
                if (animation.samplers && animation.parameters && animation.channels) {
                    for (var i = 0; i < animation.channels.length; ++i) {
                        var channel = animation.channels[i];
                        var samplerID = channel.sampler;
                        if (samplerID && animation.samplers[samplerID]) {
                            var sampler = animation.samplers[samplerID];
                            var inputID = sampler.input;
                            var outputID = sampler.output;
                            if (inputID) {
                                var attributeID = animation.parameters[inputID];
                                if (!GLTFViewer.Utils.IsNull(attributeID) && !attributeIDs[attributeID] && !this._attributeCache[attributeID])
                                    attributeIDs[attributeID] = 1;
                            }
                            if (outputID) {
                                var attributeID = animation.parameters[outputID];
                                if (!GLTFViewer.Utils.IsNull(attributeID) && !attributeIDs[attributeID] && !this._attributeCache[attributeID])
                                    attributeIDs[attributeID] = 1;
                            }
                        }
                    }
                }
            }
            var materialIDList = Object.keys(materialIDs);
            var attributeIDList = Object.keys(attributeIDs);
            var indexIDList = Object.keys(indexIDs);

            // get bufferViewsIDList
            var bufferViewIDs = {};
            for (var i = 0; i < attributeIDList.length; ++i) {
                var attributeID = attributeIDList[i];
                var attributeData = jsonData.attributes[attributeID];
                if (!attributeData)
                    continue;
                var bufferViewID = attributeData.bufferView;
                if (bufferViewID !== undefined && !bufferViewIDs[bufferViewID] && !this._bufferViewCache[bufferViewID])
                    bufferViewIDs[bufferViewID] = 1;
            }
            for (var i = 0; i < indexIDList.length; ++i) {
                var indexID = indexIDList[i];
                var indexData = jsonData.indices[indexID];
                if (!indexData)
                    continue;
                var bufferViewID = indexData.bufferView;
                if (bufferViewID !== undefined && !bufferViewIDs[bufferViewID] && !this._bufferCache[bufferID])
                    bufferViewIDs[bufferViewID] = 1;
            }
            var bufferViewIDList = Object.keys(bufferViewIDs);

            // get techniquesIDList, partial texturesIDList
            var techniquesIDs = {};
            var textureIDs = {};
            for (var i = 0; i < materialIDList.length; ++i) {
                var materialID = materialIDList[i];
                var materialData = jsonData.materials[materialID];
                if (!materialData || !materialData.instanceTechnique)
                    continue;
                var techniqueID = materialData.instanceTechnique.technique;
                if (techniqueID !== undefined && !techniquesIDs[techniqueID] && !this._techniqueCache[techniqueID])
                    techniquesIDs[techniqueID] = 1;
                var values = materialData.instanceTechnique.values;
                if (values) {
                    for (var valueName in values) {
                        var textureID = values[valueName];
                        if (typeof textureID === 'string') {
                            // probably a textureID
                            if (!textureIDs[textureID] && !this._textureCache[textureID])
                                textureIDs[textureID] = 1;
                        }
                    }
                }
            }
            var techniqueIDList = Object.keys(techniquesIDs);

            // get programIDList, rest of texturesIDList
            var programIDs = {};
            for (var i = 0; i < techniqueIDList.length; ++i) {
                var techniqueID = techniqueIDList[i];
                var techniqueData = jsonData.techniques[techniqueID];
                if (!techniqueData)
                    continue;
                var pass = techniqueData.pass;
                if (pass !== undefined && techniqueData.passes[pass] && techniqueData.passes[pass].instanceProgram) {
                    var passData = techniqueData.passes[pass].instanceProgram;
                    var programID = passData.program;
                    if (programID !== undefined && !programIDs[programID] && !this._programCache[programID])
                        programIDs[programID] = 1;
                }
                var parameters = techniqueData.parameters;
                if (parameters) {
                    for (var parameterName in parameters) {
                        var parameter = parameters[parameterName];
                        if (parameter) {
                            var textureID = parameter.value;
                            if (typeof textureID === 'string') {
                                // probably a textureID
                                if (!textureIDs[textureID] && !this._textureCache[textureID])
                                    textureIDs[textureID] = 1;
                            }
                        }
                    }
                }
            }
            var programIDList = Object.keys(programIDs);
            var textureIDList = Object.keys(textureIDs);

            // calculate total bytes to read
            // estimate 1000 bytes for a shader
            // estimate 10000 bytes for an image

            // get image sizes
            var imageIDs = {};
            for (var i = 0; i < textureIDList.length; ++i) {
                var textureID = textureIDList[i];
                var textureData = jsonData.textures[textureID];
                if (GLTFViewer.Utils.IsNull(textureData))
                    continue;
                var imageID = textureData.source;
                if (!GLTFViewer.Utils.IsNull(imageID) && !imageIDs[imageID] && !this._imageCache[imageID]) {
                    imageIDs[imageID] = 1;
                    var imageData = jsonData.images[imageID];
                    if (!GLTFViewer.Utils.IsNull(imageData))
                        totalBytes += fileInfo._loader.GetSize(imageData.path);
                }
            }

            // get shader sizes
            var shaderIDs = {};
            for (var i = 0; i < programIDList.length; ++i) {
                var programID = programIDList[i];
                var programData = jsonData.programs[programID];
                if (GLTFViewer.Utils.IsNull(programData))
                    continue;
                for (var j = 0; j < 2; ++j) {
                    var shaderID = (j === 0) ? programData.fragmentShader : programData.vertexShader;
                    if (!GLTFViewer.Utils.IsNull(shaderID) && !shaderIDs[shaderID] && !this._shaderCache[shaderID]) {
                        shaderIDs[shaderID] = 1;
                        var shaderData = jsonData.shaders[shaderID];
                        if (!GLTFViewer.Utils.IsNull(shaderData))
                            totalBytes += fileInfo._loader.GetSize(shaderData.path);
                    }
                }
            }

            // get bufferIDList
            var bufferIDs = {};
            for (var i = 0; i < bufferViewIDList.length; ++i) {
                var bufferViewID = bufferViewIDList[i];
                var bufferViewData = jsonData.bufferViews[bufferViewID];
                if (GLTFViewer.Utils.IsNull(bufferViewData))
                    continue;
                var bufferID = bufferViewData.buffer;
                if (!GLTFViewer.Utils.IsNull(bufferID) && !bufferIDs[bufferID] && !this._bufferCache[bufferID]) {
                    bufferIDs[bufferID] = 1;
                    var bufferData = jsonData.buffers[bufferID];
                    if (!GLTFViewer.Utils.IsNull(bufferData))
                        totalBytes += fileInfo._loader.GetSize(bufferData.path);
                }
            }

            return totalBytes;
        }
    },
    _SetFileSizes: {
        value: function (fileInfo) {
            var jsonData = fileInfo._jsonData;

            // calculate total bytes to read
            // estimate 1000 bytes for a shader
            // estimate 10000 bytes for an image

            // set image sizes
            var imageIDs = {};
            for (var imageID in jsonData.images) {
                if (!imageIDs[imageID]) {
                    imageIDs[imageID] = 1;
                    var imageData = jsonData.images[imageID];
                    if (!GLTFViewer.Utils.IsNull(imageData)) {
                        var imageURL = imageData.path;
                        if (!GLTFViewer.Utils.IsNull(imageURL))
                            fileInfo._loader.SetSize(imageURL, 10000); // estimate 10000 bytes
                    }
                }
            }

            // set shader sizes
            var shaderIDs = {};
            for (var shaderID in jsonData.shaders) {
                if (!shaderIDs[shaderID]) {
                    shaderIDs[shaderID] = 1;
                    var shaderData = jsonData.shaders[shaderID];
                    if (!GLTFViewer.Utils.IsNull(shaderData)) {
                        var shaderURL = shaderData.path;
                        if (!GLTFViewer.Utils.IsNull(shaderURL))
                            fileInfo._loader.SetSize(shaderURL, 1000); // estimate 1000 bytes
                    }
                }
            }

            // set buffer sizes
            var bufferIDs = {};
            for (var bufferID in jsonData.buffers) {
                if (!bufferIDs[bufferID]) {
                    bufferIDs[bufferID] = 1;
                    var bufferData = jsonData.buffers[bufferID];
                    if (!GLTFViewer.Utils.IsNull(bufferData)) {
                        var bufferURL = bufferData.path;
                        var byteLength = bufferData.byteLength ? bufferData.byteLength : 0;
                        if (!GLTFViewer.Utils.IsNull(bufferURL))
                            fileInfo._loader.SetSize(bufferURL, byteLength);
                    }
                }
            }
        }
    },
    _RenderScene: {
        value: function (how, w, h, peelPass, texture, shader) {
            if (!this._curScene)
                return false;
            var navigator = this._navigator;
            navigator.projectionGLTM.ToArray(this._uTProj);
            navigator.projection2DGLTM.ToArray(this._uTProj2);
            // we do not have a ToArray for vec4
            this._uViewport[0] = 0;
            this._uViewport[1] = 0;
            this._uViewport[2] = w;
            this._uViewport[3] = h;
            navigator.modelViewTM.ToArray(this._uView);
            this._curScene.Render(how, w, h, peelPass, texture, shader);
            return true;
        }
    },
    _MarkupsToJSON: {
        value: function () {
            // build the markups into object
            var mupObject = {};
            var numMups = 0;
            var markupID = GLTFViewer.Utils.FileGLTF.GenerateUniqueID(this._markupCache, "Markup");
            for (var key in this._sceneCache) {
                var sceneItem = this._sceneCache[key];
                var sceneID = GLTFViewer.Utils.FileGLTF.FileInfo.RealID(key);
                var markups = sceneItem.markup.GetLineKeys();
                for (var i = 0; i < markups.length; ++i) {
                    var key = markups[i];
                    var line = sceneItem.markup.GetLine(key);
                    if (line.Editable) {// || sceneItem.editable) {
                        var object = {};
                        if (line._type === GLTFViewer.Utils.Markup.LINE_TYPE_2D) {
                            object.position = [line._position.x, line._position.y];
                        } else if (line._type === GLTFViewer.Utils.Markup.LINE_TYPE_3D) {
                            object.position = [line._position.x, line._position.y, line._position.z];
                            object.lineColor = [line._lineColor.r / 255, line._lineColor.g / 255, line._lineColor.b / 255, line._lineColor.a / 255];
                            object.lineShape = line._lineShape;
                            object.textOffset = [line._textOffset.x, line._textOffset.y];
                            if (!GLTFViewer.Utils.IsNull(line._index)) {
                                var path = this.SceneNodeItemIndexToPath(line._index);
                                if (!GLTFViewer.Utils.IsNull(path))
                                    object.path = path;
                            }
                        } else
                            continue;

                        object.scene = sceneID;
                        object.type = line._type;
                        object.text = line._text;
                        object.textAttach = line._textAttach;
                        object.textSize = line._textSize;
                        object.textFont = line._textFont;
                        object.textColor = [line._textColor.r / 255, line._textColor.g / 255, line._textColor.b / 255, line._textColor.a / 255];
                        object.backgroundColor = [line._backColor.r / 255, line._backColor.g / 255, line._backColor.b / 255, line._backColor.a / 255];

                        ++numMups;
                        mupObject[markupID] = object;

                        markupID = GLTFViewer.Utils.FileGLTF.GenerateUniqueID(this._markupCache, GLTFViewer.Utils.FileGLTF.IncrementString(markupID));
                    }
                }
            }
            if (numMups === 0)
                return null;

            var object = { markups: mupObject };
            return JSON.stringify(object);
        }
    },
    _ViewsToJSON: {
        value: function () {
            // build the views into object
            // scenes/cameras/cameraNodes
            var scenes = {};
            var cameras = {};
            var nodes = {};
            var numScenes = 0;
            var cameraID = "Camera";
            var scene = GLTFViewer.Utils.FileGLTF.FileInfo.RealID(this._curScene.ID);
            var nodeID = "Node";
            var nodesToSave = [];
            for (var sceneID in this._sceneCache) {
                var sceneItem = this._sceneCache[sceneID];
                var editable = sceneItem.editable;
                var cameraObj = {};
                var nodeObj = {};
                var sceneObj = {};
                sceneObj.nodes = [];

                // camera
                var persp = false;
                if (sceneItem === this._curScene)
                    persp = this._navigator.persp;
                else if (sceneItem.navigatorState)
                    persp = sceneItem.navigatorState.persp;
                else if (sceneItem.camera && this._cameraCache[sceneItem.camera.cameraID])
                    persp = this._cameraCache[sceneItem.camera.cameraID].type === "perspective";
                cameraID = GLTFViewer.Utils.FileGLTF.GenerateUniqueID(this._cameraCache, cameraID);
                cameraObj.type = persp ? "perspective" : "orthographic";
                cameras[cameraID] = cameraObj;

                // cameraNode
                nodeID = GLTFViewer.Utils.FileGLTF.GenerateUniqueID(this._nodeCache, nodeID);
                nodeObj.name = GLTFViewer.Utils.FileGLTF.GenerateUniqueName(this._nodeCache, cameraID);
                nodeObj.camera = cameraID;
                var proj;
                if (sceneItem !== this._curScene) {
                    if (sceneItem.navigatorState)
                        proj = sceneItem.navigatorState.projectionTM;
                    else
                        proj = sceneItem.cameraMatrix;
                } else
                    proj = this._navigator.projectionTM;
                if (proj) {
                    var cameraMatrix = GLTFViewer.Utils.FileGLTF.ProjectionToCamera(cameraObj.type, proj);
                    nodeObj.matrix = [];
                    cameraMatrix.ToArray(nodeObj.matrix);
                }
                nodes[nodeID] = nodeObj;
                sceneObj.nodes.push(nodeID);

                // clip
                sceneObj.clip = {};
                var clipState = (sceneItem === this._curScene) ? this._clip.state : sceneItem.clipState;
                if (clipState) {
                    if (clipState.clipState === GLTFViewer.Utils.Clip.STATE_DISABLED)
                        sceneObj.clip.visible = 0;
                    else {
                        var pts = GLTFViewer.Utils.Clip.GetClipPointsFromPlane(clipState.clipPlane);
                        sceneObj.clip.p0 = [pts.p0.x, pts.p0.y, pts.p0.z];
                        sceneObj.clip.p1 = [pts.p1.x, pts.p1.y, pts.p1.z];
                        sceneObj.clip.p2 = [pts.p2.x, pts.p2.y, pts.p2.z];
                    }
                }
                sceneObj.explosion = sceneItem.explosion;

                // visibility
                sceneObj.visibility = sceneItem.GetVisibility();

                // scene
                if (sceneItem.editable) {
                    // this means it came from a ".view" file
                    sceneObj.name = sceneItem.name;
                    if (sceneItem.background) {
                        sceneObj.background = {};
                        sceneObj.background.type = sceneItem.background.type;
                        if (sceneItem.background.color1)
                            sceneObj.background.color1 = [sceneItem.background.color1[0], sceneItem.background.color1[1], sceneItem.background.color1[2]];
                        if (sceneItem.background.color2)
                            sceneObj.background.color2 = [sceneItem.background.color2[0], sceneItem.background.color2[1], sceneItem.background.color2[2]];
                    }
                    if (sceneItem.rulerScale) {
                        sceneObj.ruler = {};
                        sceneObj.ruler.units = sceneItem.rulerUnits;
                        sceneObj.ruler.scale = sceneItem.rulerScale;
                    }
                    for (var key in sceneItem.sceneNodeItems) {
                        if (GLTFViewer.Utils.IsNull(sceneItem.sceneNodeItems[key].nodeItem.camera))
                            sceneObj.nodes.push(GLTFViewer.Utils.FileGLTF.FileInfo.RealID(key));
                    }
                }

                scenes[GLTFViewer.Utils.FileGLTF.FileInfo.RealID(sceneID)] = sceneObj;
                ++numScenes;

                // we are not adding cameras/cameraNodes to cache, so need to generate new ID
                cameraID = GLTFViewer.Utils.FileGLTF.IncrementString(cameraID);
                nodeID = GLTFViewer.Utils.FileGLTF.IncrementString(nodeID);
            }
            if (numScenes === 0)
                return null;

            var object = { scene: scene, scenes: scenes, cameras: cameras, nodes: nodes };
            return JSON.stringify(object);
        }
    },
    // public methods
    MarkupTextEvent: {
        value: function (type, e) {
            var sceneItem = this._curScene;
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return;

            if (type === "blur")
                sceneItem.markup.OnTextInputBlur(e);
            else if (type === "keydown")
                sceneItem.markup.OnTextInputKeyDown(e);
            else if (type === "keyup")
                sceneItem.markup.OnTextInputKeyUp(e);
            else if (type === "mousedown")
                sceneItem.markup.OnTextInputMouseDown(e);
            else if (type === "mouseup")
                sceneItem.markup.OnTextInputMouseUp(e);
            else if (type === "mousemove")
                sceneItem.markup.OnTextInputMouseMove(e);
            else if (type === "paste")
                sceneItem.markup.OnTextInputOnPaste(e);
        }
    },
    MarkupState: {
        get: function () {
            var sceneItem = this._curScene;
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return GLTFViewer.Utils.Markup.STATE_DISABLED;
            return sceneItem.markup._state;
        },
        set: function (state) {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem)) {
                sceneItem.markup._state = state;
                if (state === GLTFViewer.Utils.Markup.STATE_DISABLED) {
                    sceneItem.markup.ResetSelection();
                    sceneItem.markup._hit = 0;
                    this._scene.Invalidate(true);
                }
            }
        }
    },
    MarkupLineShape: {
        get: function () {
            var sceneItem = this._curScene;
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return GLTFViewer.Utils.Markup.LINE_SYMBOL_NONE;
            return sceneItem.markup.LineShape;
        },
        set: function (shape) {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem))
                sceneItem.markup.LineShape = shape;
        }
    },
    MarkupLineType: {
        get: function () {
            var sceneItem = this._curScene;
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return GLTFViewer.Utils.Markup.LINE_TYPE_2D;
            return sceneItem.markup.LineType;
        },
        set: function (typ) {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem))
                sceneItem.markup.LineType = typ;
        }
    },
    MarkupLineColor: {
        get: function () {
            var sceneItem = this._curScene;
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return new GLTFViewer.Utils.RGBA(0, 0, 0, 255);
            return sceneItem.markup.LineColor;
        },
        set: function (col) {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem))
                sceneItem.markup.LineColor = col;
        }
    },
    MarkupFontColor: {
        get: function () {
            var sceneItem = this._curScene;
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return new GLTFViewer.Utils.RGBA(0, 0, 0, 255);
            return sceneItem.markup.FontColor;
        },
        set: function (col) {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem))
                sceneItem.markup.FontColor = col;
        }
    },
    MarkupFontSize: {
        get: function () {
            var sceneItem = this._curScene;
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return GLTFViewer.DEFAULT_MARKUP_FONT_SIZE;
            return sceneItem.markup.FontSize;
        },
        set: function (val) {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem))
                sceneItem.markup.FontSize = val;
        }
    },
    MarkupBackColor: {
        get: function () {
            var sceneItem = this._curScene;
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return new GLTFViewer.Utils.RGBA(255, 255, 255, 127);
            return sceneItem.markup.BackColor;
        },
        set: function (col) {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem))
                sceneItem.markup.BackColor = col;
        }
    },
    MarkupSelect: {
        get: function () {
            var sceneItem = this._curScene;
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return 0;
            return sceneItem.markup._select;
        }
    },
    MarkupHit: {
        get: function () {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem) && sceneItem.markup._hitWhat !== GLTFViewer.Utils.Markup.Line.HIT_NONE)
                return sceneItem.markup._hit;
            return 0;
        }
    },
    MarkupEditable: {
        value: function (key) {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem))
                return sceneItem.markup.Editable(key);
            return false;
        }
    },
    MarkupStart: {
        value: function (x, y) {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem))
                sceneItem.markup.Start(x, y);
        }
    },
    MarkupUpdate: {
        value: function (x, y) {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem))
                sceneItem.markup.Update(x, y);
        }
    },
    MarkupEnd: {
        value: function (x, y) {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem)) {
                var state = this.MarkupState;
                sceneItem.markup.End(x, y);
                if (state === GLTFViewer.Utils.Markup.STATE_CREATE_LINE)
                    this.CreateMarkupLine(sceneItem, true);
            }
        }
    },
    MarkupCreate3D: {
        value: function (x, y) {
            var sceneItem = this._curScene;
            if (GLTFViewer.Utils.IsNull(sceneItem))
                return;
            var hitIndex = this.HitIndx();
            var hitPos = this.HitPoint();
            var numSceneNodes = this._sceneNodeIndexToSceneNode.length;
            if (!this.AnyHit() || hitIndex < 0 || hitIndex >= numSceneNodes)
                return;

            var sceneNodeItem = this._sceneNodeIndexToSceneNode[this.HitIndx()];
            var hitText = "";
            if (this.hit.texture !== null)
                hitText += this.hit.texture.toPrecision(6) + " - ";
            hitText += sceneNodeItem.GetName();

            // create markup
            markupItem = new GLTFViewer.Utils.FileGLTF.MarkupItem(this, "0");
            markupItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
            markupItem.editable = true;
            markupItem.type = GLTFViewer.Utils.Markup.LINE_TYPE_3D;
            markupItem.index = hitIndex;
            markupItem.sceneID = this._curScene.ID;
            markupItem.position = hitPos;
            markupItem.lineColor = this.MarkupLineColor;
            markupItem.lineShape = GLTFViewer.Utils.Markup.LINE_SYMBOL_NONE;
            markupItem.text = hitText;
            markupItem.textOffset = new GLTFViewer.Utils.Vec3(0, 0, 0);
            markupItem.textAttach = GLTFViewer.Utils.Markup.TEXT_ATTACH_AUTO;
            markupItem.textSize = this.MarkupFontSize;
            markupItem.textFont = null;
            markupItem.textColor = this.MarkupFontColor;
            markupItem.backgroundColor = this.MarkupBackColor;
            markupItem.Create(sceneItem);
        }
    },
    MarkupDelete: {
        value: function (key) {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem)) {
                key = GLTFViewer.Utils.IsNull(key) ? sceneItem.markup._select : key;
                if (key)
                    this.DeleteMarkupLine(sceneItem, key);
            }
        }
    },
    MarkupEsc: {
        value: function () {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem) && sceneItem.markup.AnySelection())
                sceneItem.markup.EscMarkupLine();
        }
    },
    MarkupTip: {
        get: function () {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem))
                return sceneItem.markup._tip;
            return null;
        }
    },
    HasAnimation: {
        value: function () {
            return !GLTFViewer.Utils.IsNull(this._animationInfo) && this._animationInfo.maxTime >= this._animationInfo.minTime;
        }
    },
    AnimationMinTime: {
        value: function () {
            if (!this._animationInfo)
                return 0;
            return this._animationInfo.minTime;
        }
    },
    AnimationMaxTime: {
        value: function () {
            if (!this._animationInfo)
                return 0;
            return this._animationInfo.maxTime;
        }
    },
    AnimationShowFrame: {
        value: function (time) {
            if (!this._animationInfo)
                return false;
            return this._animationInfo.Show(time);
        }
    },
    //
    SetNodeVisibility: {
        value: function (sceneNodeItem, visible) {
            function Callback(sceneNodeItem, visible, progress, nodeItem) {
                if (progress)
                    this._progressBar.Stop();
                if (nodeItem) {
                    this._anyTransparent = null;
                    this._anyOpaque = null;
                    this._any2D = null;
                    this._any2DOverlay = null;
                    sceneNodeItem.visible.value = visible;
                    this._scene.Invalidate(true);
                    this._curScene.UpdateBoundingBox();
                    this.UpdateWorldScale();
                }
            }
            if (sceneNodeItem.visible.value === visible)
                return;

            var nodeItem = sceneNodeItem.nodeItem;
            if (nodeItem.state === GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_PARTIAL_OK) {
                var nodeIDs = [nodeItem.ID];
                var fileInfo = nodeItem.fileInfo;
                // need to look through scenegraph and calculate load sizes
                this._totalGLTFBytes = this._ComputeLoadSizes(fileInfo, nodeIDs, true);
                var wantBar = !this._progressTotal && this._totalGLTFBytes !== 0;
                if (wantBar)
                    this._progressBar.Start(this._totalGLTFBytes);
                this._ReadNode(fileInfo, nodeItem.ID, Callback.bind(this, sceneNodeItem, visible, wantBar), true);
            } else
                Callback.call(this, sceneNodeItem, visible, false, nodeItem);
        }
    },
    RenderClipCap: {
        value: function (TVP, eye, lighting, w, h) {
            this._RenderScene(GLTFViewer.Utils.FileGLTF._renderType.RENDEROPAQUECAP, w, h, -1, null);
            this._RenderScene(GLTFViewer.Utils.FileGLTF._renderType.RENDERTRANSPARENTCAP, w, h, -1, null);
        }
    },
    Render3D: {
        value: function (TVP, eye, lighting, w, h, peelPass, texture) {
            if (GLTFViewer.Utils.IsNull(this._anyOpaque) || this._anyOpaque) {
                this._anyRendered = false;
                if (this._RenderScene(GLTFViewer.Utils.FileGLTF._renderType.RENDEROPAQUE, w, h, peelPass, texture))
                    this._anyOpaque = this._anyRendered;
            }
            if (GLTFViewer.Utils.IsNull(this._anyTransparent) || this._anyTransparent) {
                this._anyRendered = false;
                if (this._RenderScene(GLTFViewer.Utils.FileGLTF._renderType.RENDERTRANSPARENT, w, h, peelPass, texture))
                    this._anyTransparent = this._anyRendered;
            }
        }
    },
    Render2D: {
        value: function (TVP, eye, lighting, w, h) {
            if (GLTFViewer.Utils.IsNull(this._any2D) || this._any2D) {
                this._anyRendered = false;
                if (this._RenderScene(GLTFViewer.Utils.FileGLTF._renderType.RENDER2D, w, h, -1, null))
                    this._any2D = this._anyRendered;
            }
        }
    },
    Render2DOverlay: {
        value: function (w, h) {
            if (GLTFViewer.Utils.IsNull(this._any2DOverlay) || this._any2DOverlay) {
                this._anyRendered = false;
                if (this._RenderScene(GLTFViewer.Utils.FileGLTF._renderType.RENDER2DOVERLAY, w, h, -1, null))
                    this._any2DOverlay = this._anyRendered;
            }
        }
    },
    RenderExport: {
        value: function () {
            this._RenderScene(GLTFViewer.Utils.FileGLTF._renderType.RENDEREXPORT);
        }
    },
    CanSelect: {
        value: function () {
            return true;
        }
    },
    AnySelection: {
        value: function () {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem))
                if (this._scene.MarkupState !== GLTFViewer.Utils.Markup.STATE_DISABLED)
                    return sceneItem.markup.AnySelection();
            return this._selection && Object.keys(this._selection).length;
        }
    },
    ResetSelection: {
        value: function () {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem)) {
                var retVal = this.AnySelection();
                sceneItem.markup.ResetSelection();
                this._selection = null;
                return retVal;
            }
            return false;
        }
    },
    UpdateSelection: {
        value: function (ctrlKey, altKey) {
            var sceneItem = this._curScene;
            if (!GLTFViewer.Utils.IsNull(sceneItem)) {
                if (this._scene.MarkupState !== GLTFViewer.Utils.Markup.STATE_DISABLED)
                    return sceneItem.markup.UpdateSelection(ctrlKey, altKey);

                return false; // disable selection

                if (this._selectionMode === GLTFViewer.SELECTION_NONE)
                    return false;
                var targt = this.hit;
                var targtIsEmpty = GLTFViewer.Utils.IsNull(this.hit.indx) || this.hit.indx < 0;
                var changed = false;
                if (!ctrlKey && targtIsEmpty) {
                    if (this._selection) {
                        this._selection = null;
                        changed = true;
                    }
                } else {
                    if (!this._selection)
                        this._selection = {};

                    if (!targtIsEmpty) {
                        var key = targt.indx;
                        var tmp = this._selection[key];
                        if (ctrlKey) {
                            if (tmp) {
                                delete this._selection[key];
                                return true;
                            }
                        } else if (!tmp)
                            this._selection = {};

                        if (!tmp) {
                            this._selection[key] = new GLTFViewer.Utils.FileGLTF.Hit(targt);
                            changed = true;
                        }
                    }
                }
                return changed;
            }
            return false;
        }
    },
    RenderSelection: {
        value: function (TVP, w, h) {
            if (!this.AnySelection() && !this.AnyHit())
                return;
            var gl = this._gl;
            var lw = 3;
            if (this._hasLineWidthSupport)
                gl.lineWidth(lw);

            if (this.AnySelection()) {
                // selection
                this._RenderScene(GLTFViewer.Utils.FileGLTF._renderType.RENDERSELECTION, w, h, -1, null);
            }
            var numSceneNodes = this._sceneNodeIndexToSceneNode.length;
            if (this._selectionMode !== GLTFViewer.SELECTION_NONE && this.AnyHit() && this.HitIndx() >= 0 && this.HitIndx() < numSceneNodes) {
                // highlight
                this._RenderScene(GLTFViewer.Utils.FileGLTF._renderType.RENDERHIT, w, h, -1, null);
            }

            if (this._hasLineWidthSupport)
                gl.lineWidth(1);
        }
    },
    HideBody: {
        value: function (sceneNodeIndx) {
            var numSceneNodes = this._sceneNodeIndexToSceneNode.length;
            if (sceneNodeIndx < 0 || sceneNodeIndx >= numSceneNodes)
                return;
            var sceneNodeItem = this._sceneNodeIndexToSceneNode[sceneNodeIndx];
            sceneNodeItem = sceneNodeItem.GetFirstNonDisconnected();
            var nodeItem = sceneNodeItem.nodeItem;
            for (var i = 0; i < nodeItem.sceneNodeItems.length; ++i) {
                var sNI = nodeItem.sceneNodeItems[i];
                if (sNI === sceneNodeItem) {
                    if (sceneNodeItem.visList)
                        sceneNodeItem.visList.ToggleFunc();
                }
            }
            //            sceneNodeItem.SetVisibility(0);
        }
    },
    EditProperties: {
        value: function (sceneNodeIndx) {
            var numSceneNodes = this._sceneNodeIndexToSceneNode.length;
            if (sceneNodeIndx < 0 || sceneNodeIndx >= numSceneNodes)
                return;
            var sceneNodeItem = this._sceneNodeIndexToSceneNode[sceneNodeIndx];
            sceneNodeItem = sceneNodeItem.GetFirstNonDisconnected();
            sceneNodeItem.EditProperties();
        }
    },
    //
    Reset: { // clear to just created state
        value: function (loadType) {
            this._progressTotal = 0;
            this._totalGLTFBytes = 0;
            this._anyTransparent = null;
            this._anyOpaque = null;
            this._any2D = null;
            this._any2DOverlay = null;
            this.hit.Reset();
            if (loadType === GLTFViewer.LT_APPEND || loadType === GLTFViewer.LT_UPDATE)
                return;
            var gl = this._gl;
            this._curScene = null;
            this._sceneNodeIndexToSceneNode = [];
            this._animationInfo = null;
            if (this._sceneCache) {
                for (var key in this._sceneCache)
                    this._sceneCache[key].Clear();
            }
            this._sceneCache = {};
            this._sceneCacheNameMap = {};
            if (this._cameraCache) {
                for (var key in this._cameraCache)
                    this._cameraCache[key].Clear();
            }
            this._cameraCache = {};
            if (this._markupCache) {
                for (var key in this._markupCache)
                    this._markupCache[key].Clear();
            }
            this._markupCache = {};
            if (this._animationCache) {
                for (var key in this._animationCache)
                    this._animationCache[key].Clear();
            }
            this._animationCache = {};
            if (this._animationSamplerCache) {
                for (var key in this._animationSamplerCache)
                    this._animationSamplerCache[key].Clear();
            }
            this._animationSamplerCache = {};
            if (this._legendCache) {
                for (var key in this._legendCache)
                    this._legendCache[key].Clear();
            }
            this._legendCache = {};
            if (this._meshCache) {
                for (var key in this._meshCache)
                    this._meshCache[key].Clear();
            }
            this._meshCache = {};
            if (this._nodeCache) {
                for (var key in this._nodeCache)
                    this._nodeCache[key].Clear();
            }
            this._nodeCache = {};
            this._nodeCacheNameMap = {};
            if (this._attributeCache) {
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                for (var key in this._attributeCache)
                    this._attributeCache[key].Clear();
            }
            this._attributeCache = {};
            if (this._indexCache) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                for (var key in this._indexCache)
                    this._indexCache[key].Clear();
            }
            this._indexCache = {};
            if (this._materialCache) {
                for (var key in this._materialCache)
                    this._materialCache[key].Clear();
            }
            this._materialCache = {};
            if (this._techniqueCache) {
                for (var key in this._techniqueCache)
                    this._techniqueCache[key].Clear();
            }
            this._techniqueCache = {};
            if (this._programCache) {
                for (var key in this._programCache)
                    this._programCache[key].Clear();
            }
            this._programCache = {};
            if (this._bufferViewCache) {
                for (var key in this._bufferViewCache)
                    this._bufferViewCache[key].Clear();
            }
            this._bufferViewCache = {};
            if (this._bufferCache) {
                for (var key in this._bufferCache)
                    this._bufferCache[key].Clear();
            }
            this._bufferCache = {};
            if (this._shaderCache) {
                for (var key in this._shaderCache)
                    this._shaderCache[key].Clear();
            }
            this._shaderCache = {};
            if (this._imageCache) {
                for (var key in this._imageCache)
                    this._imageCache[key].Clear();
            }
            this._imageCache = {};
            if (this._samplerCache) {
                for (var key in this._samplerCache)
                    this._samplerCache[key].Clear();
            }
            this._samplerCache = {};
            if (this._textureCache) {
                for (var key in this._textureCache)
                    this._textureCache[key].Clear();
            }
            this._textureCache = {};
            this._idMap = {};
            GLTFViewer.Utils.FileBaseClass.prototype.Reset.call(this);
        }
    },
    Clear: { // clear for deletion
        value: function () {
            GLTFViewer.Utils.FileGLTF.prototype.Reset.call(this);
            this._loader = null;
            if (this._hitTestIndexShader !== null) {
                this._hitTestIndexShader.DeleteProgram();
                this._hitTestIndexShader = null;
            }
            if (this._hitTestIndexClipShader !== null) {
                this._hitTestIndexClipShader.DeleteProgram();
                this._hitTestIndexClipShader = null;
            }
            if (this._hitTestPositionShader !== null) {
                this._hitTestPositionShader.DeleteProgram();
                this._hitTestPositionShader = null;
            }
            if (this._hitTestPositionClipShader !== null) {
                this._hitTestPositionClipShader.DeleteProgram();
                this._hitTestPositionClipShader = null;
            }
            this._glUniform = null;
            this._clipName = null;
            this._colorName = null;
            this._objMatrixName = null;
            this._POSITIONNAME = null;
            this.glCursorRay = null;
            this._uTProj = null;
            this._uTProj2 = null;
            this._uModel = null;
            this._uModelView = null;
            this._uModelViewInvTrp = null;
            this._uView = null;
            this._uViewport = null;
            this.hit.Clear();
            this.hit = null;
            this._idMap = null;
            GLTFViewer.Utils.FileBaseClass.prototype.Clear.call(this);
        }
    },
    AnyDirtyMarkups: {
        value: function () {
            for (var key in this._sceneCache) {
                var sceneItem = this._sceneCache[key];
                if (sceneItem.markup.IsDirty())
                    return true;
            }
            return false;
        }
    },
    ResetDirtyMarkups: {
        value: function () {
            for (var key in this._sceneCache) {
                var sceneItem = this._sceneCache[key];
                sceneItem.markup.ResetDirty();
            }
        }
    },
    PostMarkups: {
        value: function () {
            if (!this.AnyDirtyMarkups())
                return;

            this.ResetDirtyMarkups();

            // build the markups into object
            var str = this._MarkupsToJSON();
            if (typeof postMarkups !== 'undefined')
                postMarkups(str);
        }
    },
    SaveMarkups: {
        value: function (file) {
            if (!file)
                return false;

            // build the markups into object
            var str = this._MarkupsToJSON();
            try {
                var fs = require("fs");
                if (!str) {
                    try {
                        fs.unlinkSync(file);
                    } catch (e) { }
                } else {
                    fs.writeFileSync(file, str);
                    return true;
                }
            } catch (err) {
                GLTFViewer.Utils.WriteErr("ERROR(SaveMarkups:" + file + "): " + (err.message ? err.message : err));
            }

            return false;
        }
    },
    ReadMarkups: {
        value: function (markupData, callback) {
            function Callback(callback, state) {
                this._scene.EnableUpdate(true);
                if (state) {
                    for (var key in this._markupCache) {
                        var markup = this._markupCache[key];
                        if (markup.state === GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK && GLTFViewer.Utils.IsNull(markup._key)) {
                            for (var sceneKey in this._sceneCache) {
                                var sceneItem = this._sceneCache[sceneKey];
                                if (this.IDMap(sceneItem.ID) === this.IDMap(markup.sceneID)) {
                                    markup.index = this.MarkupToSceneNodeItemIndex(markup);
                                    markup.Create(sceneItem);
                                }
                            }
                        }
                    }
                }
                if (!GLTFViewer.Utils.IsNull(callback))
                    callback();
            }

            if (!this.CanMarkup) {
                if (!GLTFViewer.Utils.IsNull(callback))
                    callback();
                return;
            }
            this.DeleteAllMarkups();

            this._scene.EnableUpdate(false);
            this._Readgltf(markupData, null, GLTFViewer.Utils.FileGLTF.FILE_TYPE_SECONDARY, Callback.bind(this, callback), GLTFViewer.LT_APPEND);
        }
    },
    PostViews: {
        value: function () {
            // build the views into object
            var str = this._ViewsToJSON();
            if (typeof postViews !== 'undefined')
                postViews(str);
        }
    },
    SaveViews: {
        value: function (file) {
            if (!file)
                return false;

            // build the views into object
            var str = this._ViewsToJSON();
            try {
                var fs = require("fs");
                if (!str) {
                    try {
                        fs.unlinkSync(file);
                    } catch (e) { } // do not care if deleting file fails
                } else {
                    fs.writeFileSync(file, str);
                    return true;
                }
            } catch (err) {
                GLTFViewer.Utils.WriteErr("ERROR(SaveViews:" + file + "): " + (err.message ? err.message : err));
            }

            return false;
        }
    },
    ReadViews: {
        value: function (viewData, callback, sceneState) {
            function Callback(callback, state) {
                this._scene.EnableUpdate(true);
                if (!GLTFViewer.Utils.IsNull(callback))
                    callback();
            }

            if (!this.CanCreateViews) {
                if (!GLTFViewer.Utils.IsNull(callback))
                    callback();
                return;
            }
            this.DeleteAllViews();

            this._scene.EnableUpdate(false);
            this._Readgltf(viewData, null, GLTFViewer.Utils.FileGLTF.FILE_TYPE_SECONDARY, Callback.bind(this, callback), GLTFViewer.LT_UPDATE, sceneState);
        }
    },
    ReadFile: {
        value: function (callback, loadType, sceneState) {
            //loadType = GLTFViewer.Utils.IsNull(sceneState) ? loadType : GLTFViewer.LT_UPDATE;
            this.Reset(loadType);
            if (this._fileType === GLTFViewer.FT_GLTF) {
                if (this._other)
                    this._Readgltf(this._data, this._other, GLTFViewer.Utils.FileGLTF.FILE_TYPE_LOCAL, callback, loadType, sceneState);
                else
                    this._Readgltf(this._data, null, GLTFViewer.Utils.FileGLTF.FILE_TYPE_URL, callback, loadType, sceneState);
            } else if (this._fileType === GLTFViewer.FT_AVZ) {
                if (typeof this._other !== 'string')
                    this._Readgltf(this._data, this._other, GLTFViewer.Utils.FileGLTF.FILE_TYPE_UNZIP_TO_MEMORY, callback, loadType, sceneState);
                else
                    this._Readgltf(this._data, this._other, GLTFViewer.Utils.FileGLTF.FILE_TYPE_UNZIP_TO_DISK, callback, loadType, sceneState);
            }
        }
    },
    SceneNodeItemIndexToPath: {
        value: function (index) {
            var path = null;
            var sceneNodeItem = this._sceneNodeIndexToSceneNode[index];
            while (sceneNodeItem) {
                var nodeItem = sceneNodeItem.nodeItem;
                var ID = GLTFViewer.Utils.FileGLTF.FileInfo.RealID(nodeItem.ID);
                if (!path)
                    path = ID;
                else
                    path = ID + ";" + path;
                var sceneNodeItem = sceneNodeItem.parent;
            }
            return path;
        }
    },
    MarkupToSceneNodeItemIndex: {
        value: function (markup) {
            function GetMatchedNodeItemKeys(cache, ID) {
                var keys = [];
                ID = GLTFViewer.Utils.FileGLTF.FileInfo.RealID(ID);
                for (var key in cache) {
                    var realID = GLTFViewer.Utils.FileGLTF.FileInfo.RealID(key);
                    if (ID === realID)
                        keys.push(key);
                }
                return keys;
            }

            function FindSceneNodeItem(sceneItem, nodeCache, splitPath, spi) {
                if (spi < 0)
                    return null;
                var nodeItemKeys = GetMatchedNodeItemKeys(nodeCache, splitPath[spi]); // nodeItems that match splitPath[spi]
                if (nodeItemKeys.length === 0)
                    return null;
                var parentNodeItemKeys = [];
                if (spi > 0)
                    parentNodeItemKeys = GetMatchedNodeItemKeys(nodeCache, splitPath[spi - 1]); // parentNodeItems that match splitPath[spi - 1]
                // find a nodeItem in nodeItemKeys with a parent in parentNodeItemKeys, and return sceneNodeItem for nodeItemKeys
                for (var i = 0; i < nodeItemKeys.length; ++i) {
                    var nodeItem = nodeCache[nodeItemKeys[i]];
                    var sceneNodeItems = nodeItem.sceneNodeItems;
                    if (sceneNodeItems.length == 0)
                        continue;
                    for (var j = 0; j < sceneNodeItems.length; ++j) {
                        var sceneNodeItem = sceneNodeItems[j];
                        var parentSceneNodeItem = sceneNodeItem.parent;
                        if (parentNodeItemKeys.length === 0) {
                            if (GLTFViewer.Utils.IsNull(parentSceneNodeItem)) {
                                // at top of splitPath and found a sceneNodeItem with no parent
                                // check that we have the correct scene
                                if (sceneNodeItem === sceneItem.sceneNodeItems[sceneNodeItem.nodeItem.ID])
                                    return sceneNodeItem;
                            }
                            continue;
                        }
                        var index = parentNodeItemKeys.indexOf(parentSceneNodeItem.nodeItem.ID);
                        if (index >= 0) {
                            sceneNodeItem = FindSceneNodeItem(sceneItem, nodeCache, splitPath, spi - 1);
                            if (!GLTFViewer.Utils.IsNull(sceneNodeItem))
                                return sceneNodeItem.childList[splitPath[spi]];
                            return null;
                        }
                    }
                }

                return null;
            }

            var path = markup.index;
            var sceneID = markup.sceneID;
            if (typeof path !== 'string')
                return path;
            if (GLTFViewer.Utils.IsNull(path))
                return null;
            var splitPath = path.split(";");
            var sceneNodeItem = FindSceneNodeItem(this._sceneCache[this.IDMap(sceneID)], this._nodeCache, splitPath, splitPath.length - 1);
            if (sceneNodeItem)
                return sceneNodeItem.index;
            return null;
        }
    },
    GetSelections: {
        value: function () {
            if (!this.AnySelection())
                return null;
            var selections = [];
            for (key in this._selection) {
                var targt = this._selection[key];
                var s = targt.indx;
                var targtIsEmpty = GLTFViewer.Utils.IsNull(s) || s < 0;
                if (!targtIsEmpty)
                    selections.push(s);
            }
            return selections;
        }
    },
    _GetChildParts: {
        value: function (children, pathname, parts) {
            for( const node of Object.values(children)) {
                if (Object.keys(node.childList).length === 0) {
                    // Leaf node (record if actually a "mesh" item)
                    if (node.nodeItem.meshIDList.length) {
                        parts.push(pathname + ":" + node.nodeItem.name);
                    }
                } else {
                    // Recurse "Group" node
                    this._GetChildParts(node.childList, pathname + ":" + node.nodeItem.name, parts);
                }
            }
        }
    },
    GetParts: {
        value: function () {
            let parts = [];
            if (this.CurScene) {
                // Top level nodes
                for (const node of Object.values(this.CurScene.sceneNodeItems)) {
                    let pathname = node.nodeItem.name;
                    // Child nodes
                    this._GetChildParts(node.childList, pathname, parts);
                }
            }
            return parts;
        }
    },
    CreateScene: {
        value: function (name, fromSceneItem) {
            var selectScene = GLTFViewer.Utils.IsNull(fromSceneItem);
            fromSceneItem = selectScene ? this._curScene : fromSceneItem;
            if (!fromSceneItem)
                return;

            var sceneItem = fromSceneItem.Clone(name);

            sceneItem.sceneLI = this._viewer.AddEntrySceneList(sceneItem, this.SelectScene.bind(this, sceneItem));

            // there is an issue that the annotation and markup visibility are not correct
            var curScene = this._curScene;
            this.SelectScene(sceneItem);

            if (!selectScene)
                this._scene.EnableUpdate(false);
            if (fromSceneItem.markupVis && fromSceneItem.markupVis.displayedValue !== sceneItem.markupVis.displayedValue)
                sceneItem.markupVis.ToggleFunc();
            if (fromSceneItem.markupVisEditable && fromSceneItem.markupVisEditable.displayedValue !== sceneItem.markupVisEditable.displayedValue)
                sceneItem.markupVisEditable.ToggleFunc();

            if (!selectScene) {
                this._scene.EnableUpdate(true);
                this.SelectScene(curScene);
            }
        }
    },
    DeleteScene: {
        value: function (sceneItem) {
            var didDelete = false;
            var setScene = null;
            for (var key in this._sceneCache) {
                var item = this._sceneCache[key];
                if (item === sceneItem) {
                    item.Clear();
                    if (this._curScene)
                        return; // we can just return;
                    // deleting current scene, need to find a new current scene
                    this._curScene = null;
                    didDelete = true;
                    continue;
                }
                setScene = item;
                if (didDelete)
                    break;
            }
            this.SelectScene(setScene);
        }
    },
    HitIndexTip: {
        value: function () {
            if (this.HitIndx() < -100) {
                var sceneItem = this._curScene;
                if (GLTFViewer.Utils.IsNull(sceneItem))
                    return null;
                return sceneItem.markup.GetTip();
            }
            var numSceneNodes = this._sceneNodeIndexToSceneNode.length;
            if (!this.AnyHit() || this.HitIndx() < 0 || this.HitIndx() >= numSceneNodes)
                return null;
            var sceneNodeItem = this._sceneNodeIndexToSceneNode[this.HitIndx()];
            var name = "";
            if (this._scene.MarkupState === GLTFViewer.Utils.Markup.STATE_ENABLED && this.MarkupLineType === GLTFViewer.Utils.Markup.LINE_TYPE_3D) {
                var pnt = this.HitPoint();
                if (pnt)
                    name = "(" + pnt.x.toPrecision(4) + ", " + pnt.y.toPrecision(4) + ", " + pnt.z.toPrecision(4) + ")  ";
            }
            if (this.hit.texture !== null)
                name += this.hit.texture.toPrecision(6) + " - ";
            name += sceneNodeItem.GetName();
            return name;
        }
    },
    HitTestFindClosestIndex: {
        value: function (b) {
            var change = this.AnyHit() && !b;
            if (b) {
                // shader does not return entries with pnt.z >= 3
                this.hit.indx = Math.floor(b[2] + .5);
                this.hit.texture = b[1] ? b[3] : null;
                change = true; // have to do this since highlighted location keeps changing
            } else {
                this.hit.indx = null;
                this.hit.texture = null;
            }

            return change;
        }
    },
    HitTestFindClosestPos: {
        value: function (b) {
            if (b) {
                this.hit.SetPnt(b[1], b[2], b[3]);
                return this.HitPoint();
            }
            return null;
        }
    },
    HitTest: {
        value: function (TVP, w, h, tCursorRay, dontIncludeMarkup) {
            // check 
            if (!dontIncludeMarkup && this.CheckMarkupHit(tCursorRay))
                return true;
            return this.HitTestPos(TVP, w, h, tCursorRay, true);
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.FileGLTF, {
    FindByName: {
        value: function (cache, name) {
            for (var key in cache) {
                if (cache[key].name === name)
                    return cache[key];
            }
            return null;
        }
    },
    IncrementString: {
        value: function (str) {
            var match = str.match(/(.*)([^0-9])([0-9]*)/);
            if (match.length === 4 && match[3].length)
                return String(match[1]) + String(match[2]) + String(match[3] * 1 + 1);
            return str + String(1);
        }
    },
    GenerateUniqueID: {
        value: function (cache, ID) {
            ID = GLTFViewer.Utils.FileGLTF.FileInfo.RealID(ID);
            for (; ; ) {
                var found = false;
                for (var key in cache) {
                    var realID = GLTFViewer.Utils.FileGLTF.FileInfo.RealID(key);
                    if (ID === realID) {
                        found = true;
                        break;
                    }
                }
                if (!found)
                    return ID;
                ID = GLTFViewer.Utils.FileGLTF.IncrementString(ID);
            }
        }
    },
    GenerateUniqueName: {
        value: function (cache, name) {
            for (; ; ) {
                if (!GLTFViewer.Utils.FileGLTF.FindByName(cache, name))
                    return name;
                name = GLTFViewer.Utils.FileGLTF.IncrementString(name);
            }
        }
    },
    GetName: {
        value: function (ID, data) {
            if (GLTFViewer.Utils.IsNull(data))
                return "";
            var name = data.name;
            if (GLTFViewer.Utils.IsNull(name) || name.length === 0)
                name = GLTFViewer.Utils.FileGLTF.FileInfo.RealID(ID);
            return name;
        }
    }
});
///////////////////////////////////////
// Nested classes
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.FileInfo = function (fileNum, jsonData, files, fileType, editable, loadType, sceneState) {
    this._fileNum = fileNum;
    this._loader = new GLTFViewer.Utils.FileGLTF.Loader();
    this._FixGLTF(jsonData);
    this._jsonData = jsonData;
    this._files = files;
    this._fileType = fileType;
    this._editable = editable;
    this._loadType = loadType;
    this._sceneState = sceneState;
};
GLTFViewer.Utils.FileGLTF.FileInfo.prototype = Object.create(null, {
    _fileNum: { writable: true, value: null },
    _loader: { writable: true, value: null },
    _jsonData: { writable: true, value: null }, // GLTF json file
    _files: { writable: true, value: null }, // for loading from a list of local files
    _fileType: { writable: true, value: 0 },
    _editable: { writable: true, value: false },
    _loadType: { writable: true, value: 0 },
    _sceneState: { writable: true, value: null },
    // going to try to give all ID's a unique ID
    _RenameKeys: {
        value: function (object, prefix) {
            for (var key in object) {
                var newKey = prefix + key;
                object[newKey] = object[key];
                delete object[key];
            }
        }
    },
    _RenameValue: {
        value: function (object, parameter, prefix) {
            var p = parameter.split(".");
            var param = p[0];
            p.shift();
            for (var key in object) {
                if (param === "*" || key === param) {
                    if (typeof object[key] === "object") {
                        if (Object.prototype.toString.call(object[key]) === "[object Array]") {
                            for (var i = 0; i < object[key].length; ++i) {
                                if (typeof object[key][i] === "object") {
                                    this._RenameValue(object[key][i], p.join("."), prefix);
                                } else if (typeof object[key][i] === "string")
                                    object[key][i] = prefix + object[key][i];
                            }
                        } else
                            this._RenameValue(object[key], p.join("."), prefix);
                    } else if (typeof object[key] === "string")
                        object[key] = prefix + object[key];
                    if (param !== "*")
                        break;
                }
            }
        }
    },
    _RenameString: {
        value: function (object, parameter, split, prefix) {
            var p = parameter.split(".");
            var param = p[0];
            p.shift();
            for (var key in object) {
                if (param === "*" || key === param) {
                    if (typeof object[key] === "string") {
                        if (!GLTFViewer.Utils.IsNull(split)) {
                            var o = object[key].split(split);
                            var s = "";
                            for (var i = 0; i < o.length; ++i) {
                                if (i > 0)
                                    s += split;
                                s += prefix + o[i];
                            }
                            object[key] = s;
                        } else
                            object[key] = prefix + object[key];
                    }
                    if (param !== "*")
                        break;
                }
            }
        }
    },
    _FixGLTF: {
        value: function (object) {
            if (!object)
                return;
            // this is an attempt to read GLTF1 files
            if (object.accessors) {
                // fix cameras
                for (var key in object.cameras) {
                    var camera = object.cameras[key];
                    if (camera.perspective && camera.perspective.yfov) {
                        camera.perspective.yfov = camera.perspective.yfov * 180 / Math.PI;
                    }
                }
                // fix accessors
                for (var key in object.accessors) {
                    var accessor = object.accessors[key];
                    if (accessor.componentType) {
                        var type = accessor.componentType;
                        switch (accessor.type) {
                            case 'VEC2':
                                type = type === 5124 ? 35667 : 35664;
                                break;
                            case 'VEC3':
                                type = type === 5124 ? 35668 : 35665;
                                break;
                            case 'VEC4':
                                type = type === 5124 ? 35669 : 35666;
                                break;
                            case 'MAT3':
                                type = 35675;
                                break;
                            case 'MAT4':
                                type = 35676;
                                break;
                        }
                        accessor.type = type;
                        delete accessor.componentType;
                    }
                }

                // fix buffers
                if (object.buffers) {
                    for (var key in object.buffers) {
                        if (object.buffers[key].uri) {
                            object.buffers[key].path = object.buffers[key].uri;
                            delete object.buffers[key].uri;
                        }
                    }
                }
                // fix images
                if (object.images) {
                    for (var key in object.images) {
                        if (object.images[key].uri) {
                            object.images[key].path = object.images[key].uri;
                            delete object.images[key].uri;
                        }
                    }
                }
                // fix shaders
                if (object.shaders) {
                    for (var key in object.shaders) {
                        if (object.shaders[key].uri) {
                            object.shaders[key].path = object.shaders[key].uri;
                            delete object.shaders[key].uri;
                        }
                    }
                }
                // create indices, move from accessors to indices
                if (object.meshes) {
                    object.indices = {};
                    for (var key in object.meshes) {
                        var primitives = object.meshes[key].primitives;
                        for (var i = 0; i < primitives.length; ++i) {
                            // fix primitives
                            primitives[i].primitive = primitives[i].mode;
                            delete primitives[i].mode;
                            if (primitives[i].indices && object.accessors[primitives[i].indices]) {
                                object.indices[primitives[i].indices] = object.accessors[primitives[i].indices];
                                delete object.accessors[primitives[i].indices];
                            }
                        }
                    }
                }
                // turn rest of accessors into attributes
                object.attributes = {};
                for (var key in object.accessors) {
                    object.attributes[key] = object.accessors[key];
                    delete object.accessors[key];
                }
                delete object.accessors;
                // fix materials
                for (var key in object.materials) {
                    var material = object.materials[key];
                    var instanceTechnique = {};
                    for (var key in material) {
                        instanceTechnique[key] = material[key];
                        delete material[key];
                    }
                    material.instanceTechnique = instanceTechnique;
                }
                // fix techniques
                for (var key in object.techniques) {
                    var technique = object.techniques[key];
                    technique.passes = {
                        defaultPass: {
                            states: {},
                            instanceProgram: {
                                attributes: {},
                                uniforms: {}
                            }
                        }
                    };
                    technique.pass = 'defaultPass';
                    technique.passes.defaultPass.instanceProgram.attributes = technique.attributes;
                    delete technique.attributes;
                    technique.passes.defaultPass.instanceProgram.uniforms = technique.uniforms;
                    delete technique.uniforms;
                    technique.passes.defaultPass.instanceProgram.program = technique.program;
                    delete technique.program;
                    // states is a bit more complicated
                    if (technique.states) {
                        var newStates = {};
                        if (technique.states.enable) {
                            for (var i = 0; i < technique.states.enable.length; ++i) {
                                switch (technique.states.enable[i]) {
                                    case 2884: // ST_CULLFACEENABLE
                                        newStates.cullFaceEnable = 1;
                                        break;
                                    case 2929: // ST_DEPTHTESTENABLE
                                        newStates.depthTestEnable = 1;
                                        break;
                                    case 3042: // ST_BLENDENABLE
                                        newStates.blendEnable = 1;
                                        break;
                                    case 32823: // ST_POLYGONOFFSETFILLENABLE
                                        newStates.polygonOffsetFillEnable = 1;
                                        break;
                                };
                            }
                        }
                        if (technique.states.functions) {
                            for (var key2 in technique.states.functions) {
                                switch (key2) {
                                    case "cullFace": // ST_CULLFACE
                                        newStates.cullFace = technique.states.functions[key2][0];
                                        break;
                                    case "depthFunc": // ST_DEPTHFUNC
                                        newStates.depthFunc = technique.states.functions[key2][0];
                                        break;
                                    case "frontFace": // ST_FRONTFACE
                                        newStates.frontFace = technique.states.functions[key2][0];
                                        break;
                                    case "lineWidth": // ST_LINEWIDTH
                                        newStates.lineWidth = technique.states.functions[key2][0];
                                        break;
                                    case "depthMask": // ST_DEPTHMASK
                                        newStates.depthMask = technique.states.functions[key2][0] ? 1 : 0;
                                        break;
                                    case "polygonOffset": // ST_POLYGONOFFSET
                                        newStates.polygonOffset = '[' + technique.states.functions[key2][0] + ', ' + technique.states.functions[key2][1] + ']';
                                        break;
                                }
                            }
                        }

                        delete technique.states;
                        technique.passes.defaultPass.states = newStates;
                    }
                }
            }
            var prefix = "__" + this._fileNum + "__";
            for (var key in object) {
                switch (key) {
                    case "buffers":
                    case "images":
                    case "samplers":
                    case "shaders":
                    case "cameras":
                    case "lights":
                        this._RenameKeys(object[key], prefix);
                        break;
                    case "bufferViews":
                        this._RenameKeys(object[key], prefix);
                        for (var k in object[key])
                            this._RenameValue(object[key][k], "buffer", prefix);
                        break;
                    case "markups":
                        this._RenameKeys(object[key], prefix);
                        for (var k in object[key]) {
                            this._RenameValue(object[key][k], "scene", prefix);
                            this._RenameString(object[key][k], "path", ";", prefix);
                        }
                        break;
                    case "legends":
                        this._RenameKeys(object[key], prefix);
                        for (var k in object[key])
                            this._RenameValue(object[key][k], "image", prefix);
                        break;
                    case "textures":
                        this._RenameKeys(object[key], prefix);
                        for (var k in object[key]) {
                            this._RenameValue(object[key][k], "sampler", prefix);
                            this._RenameValue(object[key][k], "source", prefix);
                        }
                        break;
                    case "programs":
                        this._RenameKeys(object[key], prefix);
                        for (var k in object[key]) {
                            this._RenameValue(object[key][k], "fragmentShader", prefix);
                            this._RenameValue(object[key][k], "vertexShader", prefix);
                        }
                        break;
                    case "techniques":
                        this._RenameKeys(object[key], prefix);
                        for (var k in object[key]) {
                            this._RenameValue(object[key][k], "parameters.*.value", prefix);
                            this._RenameValue(object[key][k], "parameters.*.source", prefix);
                            this._RenameValue(object[key][k], "passes.*.instanceProgram.program", prefix);
                        }
                        break;
                    case "materials":
                        this._RenameKeys(object[key], prefix);
                        for (var k in object[key]) {
                            this._RenameValue(object[key][k], "instanceTechnique.technique", prefix);
                            this._RenameValue(object[key][k], "instanceTechnique.values.*", prefix);
                        }
                        break;
                    case "indices":
                    case "attributes":
                        this._RenameKeys(object[key], prefix);
                        for (var k in object[key])
                            this._RenameValue(object[key][k], "bufferView", prefix);
                        break;
                    case "meshes":
                        this._RenameKeys(object[key], prefix);
                        for (var k in object[key]) {
                            this._RenameValue(object[key][k], "primitives.material", prefix);
                            this._RenameValue(object[key][k], "primitives.indices", prefix);
                            this._RenameValue(object[key][k], "primitives.attributes.*", prefix);
                        }
                        break;
                    case "nodes":
                        this._RenameKeys(object[key], prefix);
                        for (var k in object[key]) {
                            this._RenameValue(object[key][k], "mesh", prefix);
                            this._RenameValue(object[key][k], "camera", prefix);
                            this._RenameValue(object[key][k], "legend", prefix);
                            this._RenameValue(object[key][k], "light", prefix);
                            this._RenameValue(object[key][k], "meshes", prefix);
                            this._RenameValue(object[key][k], "lights", prefix);
                            this._RenameValue(object[key][k], "children", prefix);
                        }
                        break;
                    case "animations":
                        this._RenameKeys(object[key], prefix);
                        for (var k in object[key]) {
                            this._RenameKeys(object[key][k]["samplers"], prefix);
                            this._RenameValue(object[key][k], "parameters.*", prefix);
                            if (object[key][k]["channels"]) {
                                for (var k1 = 0; k1 < object[key][k]["channels"].length; ++k1) {
                                    this._RenameValue(object[key][k]["channels"][k1], "sampler", prefix);
                                    this._RenameValue(object[key][k]["channels"][k1], "target.id", prefix);
                                }
                            }
                        }
                        break;
                    case "scenes":
                        this._RenameKeys(object[key], prefix);
                        for (var k in object[key]) {
                            function DoChildren(objects, prefix) {
                                this._RenameKeys(objects, prefix);
                                for (var k2 in objects)
                                    DoChildren.call(this, objects[k2].children, prefix);
                            }
                            this._RenameValue(object[key][k], "nodes", prefix);
                            DoChildren.call(this, object[key][k].visibility, prefix);
                        }
                        break;
                    case "scene":
                        this._RenameValue(object, "scene", prefix);
                        break;
                }
            }
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.FileGLTF.FileInfo, {
    // the ID has __#*__ prepended to it
    RealID: {
        value: function (ID) {
            var re = /^__[^_]*__/;
            var s = ID.match(re);
            if (s && s.length)
                return ID.substr(s[0].length);
            return ID;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.ItemBaseClass = function (gltf, ID, cache) {
    this.gltf = gltf;
    this.ID = ID;
    this.cache = cache;
    this.Callbacks = [];
    if (!GLTFViewer.Utils.IsNull(cache))
        cache[ID] = this;
};
GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype = Object.create(null, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.ItemBaseClass },
    //
    gltf: { writable: true, value: null },
    numCallbacksToProcess: { writable: true, value: 0 }, // number of secondary calls with callback to complete object
    Callbacks: { writable: true, value: null },
    cache: { writable: true, value: null },
    ID: { writable: true, value: null },
    state: { writable: true, value: 1 }, // -1:BAD, 0:OK, 1:LOADING, 2:NOT_LOADING
    refCount: { writable: true, value: 0 },
    editable: { writable: true, value: false },
    //
    Reset: { // clear to just created state
        value: function () {
        }
    },
    Clear: { // clear for deletion
        value: function () {
            if (this.refCount <= 0)
                return false; // already cleared
            if (--this.refCount > 0)
                return false;
            if (this.cache && !GLTFViewer.Utils.IsNull(this.ID))
                delete this.cache[this.ID];
            this.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD;
            this.DoCallbacks(); // tell anyone waiting for this, that it is bad
            return true;
        }
    },
    AddCallback: {
        value: function (Callback) {
            if (GLTFViewer.Utils.IsNull(Callback))
                return;

            // this should never happen
            if (this.Callbacks.indexOf(Callback) >= 0)
                return;

            ++this.refCount;
            this.Callbacks.push(Callback);
        }
    },
    DoCallbacks: {
        value: function (Callback) {
            this.AddCallback(Callback);
            if (this.state === GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING || this.state === GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_PARTIAL_LOADING || this.Callbacks.length === 0)
                return; // nothing to do yet
            // either STATE_OK or STATE_BAD
            var val = this.state === GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_BAD ? null : this;
            // need to prevent recursive cascade failure
            var callbacks = this.Callbacks;
            this.Callbacks = [];
            for (var i = 0; i < callbacks.length; ++i)
                callbacks[i](val);
        }
    }
});
// Static data
Object.defineProperties(GLTFViewer.Utils.FileGLTF.ItemBaseClass, {
    STATE_BAD: { value: -1 }, // failure to load
    STATE_OK: { value: 0 }, // loaded
    STATE_LOADING: { value: 1 }, // being loaded
    STATE_PARTIAL_OK: { value: 2 }, // partially loaded (when not visible)
    STATE_PARTIAL_LOADING: { value: 3 } // being partially loaded (when not visible)
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.ShaderItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
};
GLTFViewer.Utils.FileGLTF.ShaderItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.ShaderItem },
    //
    glslShader: { writable: true, value: null }, // data read from file or server
    //
    Clear: { // clear for deletion
        value: function () {
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            this.glslShader = null;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.ImageItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
};
GLTFViewer.Utils.FileGLTF.ImageItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.ImageItem },
    //
    image: { writable: true, value: null }, // replaces path with data read from file or server
    generateMipmap: { writable: true, value: 1 },
    //
    Clear: { // clear for deletion
        value: function () {
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            this.image = null;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.BufferItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
};
GLTFViewer.Utils.FileGLTF.BufferItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.BufferItem },
    //
    byteLength: { writable: true, value: 0 },
    buffer: { writable: true, value: null }, // replaces path with data read from file or server
    //
    Clear: { // clear for deletion
        value: function () {
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            this.buffer = null;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.BufferViewItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
};
GLTFViewer.Utils.FileGLTF.BufferViewItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.BufferViewItem },
    //
    byteLength: { writable: true, value: 0 },
    byteOffset: { writable: true, value: 0 },
    buffer: { writable: true, value: null }, // BufferItem
    target: { writable: true, value: 0 },
    //
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            if (this.buffer)
                this.buffer.Reset();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            if (this.buffer) {
                this.buffer.Clear();
                this.buffer = null;
            }
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.AttributeItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
};
GLTFViewer.Utils.FileGLTF.AttributeItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.AttributeItem },
    //
    byteStride: { writable: true, value: 0 },
    byteOffset: { writable: true, value: 0 },
    count: { writable: true, value: 0 },
    type: { writable: true, value: 0 },
    size: { writable: true, value: 0 },
    baseType: { writable: true, value: 0 },
    bufferView: { writable: true, value: null }, // BufferViewItem
    data: { writable: true, value: null }, // this is the bufferView turned into _glType.type
    buffer: { writable: true, value: null }, // this is a glCreateBuffer object
    normalized: { writable: true, value: false },
    _mn: { writable: true, value: null },
    mn: {
        get: function () {
            if (!GLTFViewer.Utils.IsNull(this._mn))
                return this._mn;
            this._CalculateMinMax();
            return this._mn;
        },
        set: function (mn) {
            this._mn = mn;
        }
    },
    _mx: { writable: true, value: null },
    mx: {
        get: function () {
            if (!GLTFViewer.Utils.IsNull(this._mx))
                return this._mx;
            this._CalculateMinMax();
            return this._mx;
        },
        set: function (mx) {
            this._mx = mx;
        }
    },
    //
    _CalculateMinMax: {
        value: function () {
            this._mn = [];
            this._mx = [];
            var loc = 0;
            for (var i = 0; i < this.count; ++i) {
                for (var j = 0; j < this.size; ++j, ++loc) {
                    var val = this.data[loc];
                    if (i === 0)
                        this._mn[j] = this._mx[j] = val;
                    else {
                        this._mn[j] = Math.min(this._mn[j], val);
                        this._mx[j] = Math.max(this._mx[j], val);
                    }
                }
            }
        }
    },
    //
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            if (this.bufferView)
                this.bufferView.Reset();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            var gltf = this.gltf;
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            if (this.bufferView) {
                this.bufferView.Clear();
                this.bufferView = null;
            }
            if (this.buffer) {
                gltf._gl.bindBuffer(gltf._gl.ARRAY_BUFFER, null);
                gltf._gl.deleteBuffer(this.buffer);
                this.buffer = null;
            }
            this.data = null;
            this._mn = null;
            this._mx = null;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.IndexItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
};
GLTFViewer.Utils.FileGLTF.IndexItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.IndexItem },
    //
    bufferView: { writable: true, value: null }, // BufferViewItem
    data: { writable: true, value: null }, // this is the bufferView turned into _glType.type
    buffer: { writable: true, value: null }, // this is a glCreateBuffer object
    byteOffset: { writable: true, value: 0 },
    count: { writable: true, value: 0 },
    type: { writable: true, value: 0 },
    //
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            if (this.bufferView)
                this.bufferView.Reset();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            var gltf = this.gltf;
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            if (this.bufferView) {
                this.bufferView.Clear();
                this.bufferView = null;
            }
            if (this.buffer) {
                gltf._gl.bindBuffer(gltf._gl.ELEMENT_ARRAY_BUFFER, null);
                gltf._gl.deleteBuffer(this.buffer);
                this.buffer = null;
            }
            this.data = null;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.SamplerItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
};
GLTFViewer.Utils.FileGLTF.SamplerItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.SamplerItem },
    //
    magFilter: { writable: true, value: 0 },
    minFilter: { writable: true, value: 0 },
    wrapS: { writable: true, value: 0 },
    wrapT: { writable: true, value: 0 }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.TextureItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
};
GLTFViewer.Utils.FileGLTF.TextureItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.TextureItem },
    //
    format: { writable: true, value: 0 },
    target: { writable: true, value: 0 },
    sampler: { writable: true, value: null }, // SamplerItem
    image: { writable: true, value: null }, // ImageItem
    texture: { writable: true, value: null },
    //
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            if (this.sampler)
                this.sampler.Reset();
            if (this.image)
                this.image.Reset();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            var gltf = this.gltf;
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            if (this.sampler) {
                this.sampler.Clear();
                this.sampler = null;
            }
            if (this.image) {
                this.image.Clear();
                this.image = null;
            }
            if (this.texture) {
                gltf._gl.bindTexture(this.target, null);
                gltf._gl.deleteTexture(this.texture);
                this.texture = null;
            }
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.ProgramItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
};
GLTFViewer.Utils.FileGLTF.ProgramItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.ProgramItem },
    //
    fragment: { writable: true, value: null }, // ShaderItem
    vertex: { writable: true, value: null }, // ShaderItem
    program: { writable: true, value: null }, // replaces both fragmentShader and vertexShader, ShaderProgram wrapper around glCreateProgram
    programClip: { writable: true, value: null }, // replaces both fragmentShader and vertexShader, ShaderProgram wrapper around glCreateProgram
    programCap: { writable: true, value: null }, // replaces both fragmentShader and vertexShader, ShaderProgram wrapper around glCreateProgram
    programPeel: { writable: true, value: null }, // replaces both fragmentShader and vertexShader, ShaderProgram wrapper around glCreateProgram
    //
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            if (this.fragment)
                this.fragment.Reset();
            if (this.vertex)
                this.vertex.Reset();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            if (this.fragment) {
                this.fragment.Clear();
                this.fragment = null;
            }
            if (this.vertex) {
                this.vertex.Clear();
                this.vertex = null;
            }
            if (this.program) {
                this.program.DeleteProgram();
                this.program = null;
            }
            if (this.programClip) {
                this.programClip.DeleteProgram();
                this.programClip = null;
            }
            if (this.programCap) {
                this.programCap.DeleteProgram();
                this.programCap = null;
            }
            if (this.programPeel) {
                this.programPeel.DeleteProgram();
                this.programPeel = null;
            }
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.PassItem = function (gltf, ID) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID);
    this.attributes = {};
    this.uniforms = {};
    this.states = {};
};
GLTFViewer.Utils.FileGLTF.PassItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.PassItem },
    //
    attributes: { writable: true, value: null },
    uniforms: { writable: true, value: null },
    program: { writable: true, value: null }, // ProgramItem
    states: { writable: true, value: null },
    is2D: { writable: true, value: false },
    //
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            if (this.program)
                this.program.Reset();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            if (this.program) {
                this.program.Clear();
                this.program = null;
            }
            this.attributes = null;
            this.uniforms = null;
            this.states = null;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.ValueItem = function (gltf, val) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf);
    if (!GLTFViewer.Utils.IsNull(val)) {
        // special case of constructing a valueitem with an initial value
        this.valueInitial = val;
        this.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
    }
};
// technique parameter or material value
GLTFViewer.Utils.FileGLTF.ValueItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.ValueItem },
    //
    //    value: { writable: true, value: null },
    _valueInitialSet: { writable: true, value: false },
    _valueInitial: { writable: true, value: null },
    _value: { writable: true, value: null },
    valueInitial: {
        get: function () {
            return this._valueInitial;
        },
        set: function (v) {
            this._valueInitialSet = true;
            this._valueInitial = v;
            this._value = v;
        }
    },
    value: {
        get: function () {
            return this._value;
        },
        set: function (v) {
            this._value = v;
        }
    },
    texture: { writable: true, value: null }, // TextureItem
    // unique to technique parameter
    semantic: { writable: true, value: null },
    source: { writable: true, value: null },
    type: { writable: true, value: 0 },
    //
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            this._value = this._valueInitialSet ? this._valueInitial : null;
            if (this.texture)
                this.texture.Reset();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            this._valueInitialSet = false;
            this._valueInitial = null;
            this._value = null;
            if (this.texture) {
                this.texture.Clear();
                this.texture = null;
            }
            this.semantic = null;
            this.source = null;
        }
    },
    Clone: {
        value: function () {
            var valueItem = new GLTFViewer.Utils.FileGLTF.ValueItem(this.gltf, this.valueInitial);
            valueItem.refCount = 1;
            valueItem.editable = true;
            valueItem.texture = this.texture;
            valueItem.semantic = this.semantic;
            valueItem.source = this.source;
            valueItem.type = this.type;
            valueItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
            return valueItem;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.TechniqueItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
    this.parameters = {};
};
GLTFViewer.Utils.FileGLTF.TechniqueItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.TechniqueItem },
    //
    pass: { writable: true, value: null }, // PassItem
    parameters: { writable: true, value: null }, // object of ParameterItems
    is2D: { writable: true, value: null },
    //
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            if (this.pass)
                this.pass.Reset();
            for (var key in this.parameters)
                this.parameters[key].Reset();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            if (this.pass) {
                this.pass.Clear();
                this.pass = null;
            }
            for (var key in this.parameters)
                this.parameters[key].Clear();
            this.parameters = null;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.MaterialItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
    this.values = {};
    this.attributes = [];
    this.semanticUniforms = [];
    this.valueUniforms = {};
};
GLTFViewer.Utils.FileGLTF.MaterialItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.MaterialItem },
    //
    technique: { writable: true, value: null }, // TechniqueItem
    values: { writable: true, value: null }, // object of ValueItems
    attributes: { writable: true, value: null }, // array of ShaderParams
    semanticUniforms: { writable: true, value: null }, // array of ShaderParams
    valueUniforms: { writable: true, value: null }, // object of ShaderParams
    //
    program: { writable: true, value: null }, // reference to technique.pass.program
    // GL State
    frontFace: { writable: true, value: null }, // CCW
    blendEnable: { writable: true, value: null }, // indicates transparency
    cullFaceEnable: { writable: true, value: null },
    cullFace: { writable: true, value: null }, // GL_BACK 
    depthTestEnable: { writable: true, value: null },
    depthMask: { writable: true, value: null }, // indicates no transparency
    lineWidth: { writable: true, value: null },
    polygonOffsetFillEnable: { writable: true, value: null },
    polygonOffsetFactor: { writable: true, value: null },
    polygonOffsetUnits: { writable: true, value: null },
    // other state
    is2D: { writable: true, value: false },
    solidColor: { writable: true, value: null }, // RGBA color of solid material
    //
    /*
    GetEditableValues: {
        value: function () {
            return Object.keys(this.valueUniforms);
        }
    },
    GetEditableValue: {
        value: function (name) {
            //return this.valueUniforms[name];
            return { value: this.values[name], valueUniform: this.valueUniforms[name] };
        }
    },
    */
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            if (this.technique)
                this.technique.Reset();
            for (var key in this.values) {
                var value = this.values[key];
                value.Reset();
                var valueUniform = this.valueUniforms[key];
                if (valueUniform) {
                    if (!GLTFViewer.Utils.IsNull(valueUniform.data.length) && valueUniform.data.length === value.value.length) {
                        for (var i = 0; i < value.value.length; ++i)
                            valueUniform.data[i] = this.values[key].value[i];
                    } else if (typeof valueUniform.data === "number" && typeof this.values[key].value === "number")
                        valueUniform.data = this.values[key].value;
                }
            }
        }
    },
    Clear: { // clear for deletion
        value: function () {
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            if (this.technique) {
                this.technique.Clear();
                this.technique = null;
            }
            for (var key in this.values)
                this.values[key].Clear();
            this.values = null;
            if (this.attributes) {
                for (var i = 0; i < this.attributes.length; ++i)
                    this.attributes[i].Clear();
                this.attributes = null;
            }
            if (this.semanticUniforms) {
                for (var i = 0; i < this.semanticUniforms.length; ++i)
                    this.semanticUniforms[i].Clear();
                this.semanticUniforms = null;
            }
            if (this.valueUniforms) {
                for (var key in this.valueUniforms)
                    this.valueUniforms[key].Clear();
                this.valueUniforms = null;
            }
            this.program = null;
            this.solidColor = null;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.PrimitiveItem = function (gltf) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf);
    this.attributes = {};
    this._bbox = new GLTFViewer.Utils.Box();
};
GLTFViewer.Utils.FileGLTF.PrimitiveItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.PrimitiveItem },
    //
    mode: { writable: true, value: 0 },
    material: { writable: true, value: null }, // MaterialItem
    indices: { writable: true, value: null }, // IndexItem
    isPickable: { writable: true, value: null },
    attributes: { writable: true, value: null }, // object of AttributeItems {POSITION|NORMAL|COLOR|...}
    //
    _bbox: { writable: true, value: null },
    activeTexture: { writable: true, value: 0 },
    //
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            if (this.material)
                this.material.Reset();
            if (this.indices)
                this.indices.Reset();
            for (var key in this.attributes)
                this.attributes[key].Reset();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            if (this.material) {
                this.material.Clear();
                this.material = null;
            }
            if (this.indices) {
                this.indices.Clear();
                this.indices = null;
            }
            for (var key in this.attributes)
                this.attributes[key].Clear();
            this.attributes = null;
            this.isPickable = null;
            this._bbox = null;
        }
    },
    SetBoundingBox: {
        value: function (mn, mx) {
            this._bbox.Set(mn, mx);
        }
    },
    BoundingBox: {
        value: function (matrix) {
            var box = this._bbox.Clone();
            if (matrix && !matrix.IsIdentity())
                box.Multiply(matrix);
            return box;
        }
    },
    RenderExport: {
        value: function (name) {
            var mat = this.material;
            if ((this.mode !== 4 && this.mode !== 5 && this.mode !== 6) || mat.is2D)
                return; // (not triangles, triangle_strip, triangle_fan) or is2D

            var fs = require('fs');
            var gltf = this.gltf;

            var indices = this.indices;

            // find position and normal
            var mat = this.material;
            var positionAttr = null;
            var normalAttr = null;
            for (var i = 0; i < mat.attributes.length; i++) {
                var param = mat.attributes[i];
                var attr = this.attributes[param.data];
                if (param.data === gltf._POSITIONNAME) {
                    if (attr.type !== 35665) {
                        GLTFViewer.Utils.WriteErr("ERROR(RenderExport:" + name + "):", "bad POSITION");
                        return;
                    }
                    positionAttr = attr;
                } else if (param.data === "NORMAL") {
                    if (attr.type !== 35665) {
                        GLTFViewer.Utils.WriteErr("ERROR(RenderExport:" + name + "):", "bad NORMAL");
                        return;
                    }
                    normalAttr = attr;
                }
            }
            if (GLTFViewer.Utils.IsNull(positionAttr)) // || GLTFViewer.Utils.IsNull(normalAttr))
                return;

            var matrix = new GLTFViewer.Utils.Transformation(gltf._uModel);

            function TriangleNormal(i1, i2, i3) {
                var v1 = new GLTFViewer.Utils.Vec3(positionAttr.data[3 * i1 + 0], positionAttr.data[3 * i1 + 1], positionAttr.data[3 * i1 + 2]);
                var v2 = new GLTFViewer.Utils.Vec3(positionAttr.data[3 * i2 + 0], positionAttr.data[3 * i2 + 1], positionAttr.data[3 * i2 + 2]);
                var v3 = new GLTFViewer.Utils.Vec3(positionAttr.data[3 * i3 + 0], positionAttr.data[3 * i3 + 1], positionAttr.data[3 * i3 + 2]);
                v2.Subtract(v1);
                v3.Subtract(v1);
                return v2.CrossCreate(v3);
            }
            function VertexOut(idx) {
                var v = new GLTFViewer.Utils.Vec3(positionAttr.data[3 * idx + 0], positionAttr.data[3 * idx + 1], positionAttr.data[3 * idx + 2]);
                v.Transform(matrix);
                switch (gltf._exportType) {
                    case "STL":
                        fs.writeSync(gltf._exportFH, "vertex " + v.x + " " + v.y + " " + v.z + "\n");
                        break;
                    case "STLBIN":
                        gltf._exportBuffer.writeFloatLE(v.x, 0);
                        gltf._exportBuffer.writeFloatLE(v.y, 4);
                        gltf._exportBuffer.writeFloatLE(v.z, 8);
                        fs.writeSync(gltf._exportFH, gltf._exportBuffer, 0, 12);
                        gltf._exportDataSize += 12;
                        break;
                }
            }
            if (indices) {
                var v1 = 0;
                var v2 = 1;
                var v3 = 2;
                while (v3 < indices.count) {
                    switch (gltf._exportType) {
                        case "STL":
                            //var n = TriangleNormal(v1, v2, v3);
                            var n = new GLTFViewer.Utils.Vec3(0, 0, 0);
                            fs.writeSync(gltf._exportFH, "facet normal " + n.x + " " + n.y + " " + n.z + "\n");
                            fs.writeSync(gltf._exportFH, "outer loop\n");
                            break;
                        case "STLBIN":
                            //var n = TriangleNormal(v1, v2, v3);
                            var n = new GLTFViewer.Utils.Vec3(0, 0, 0);
                            gltf._exportBuffer.writeFloatLE(n.x, 0);
                            gltf._exportBuffer.writeFloatLE(n.y, 4);
                            gltf._exportBuffer.writeFloatLE(n.z, 8);
                            fs.writeSync(gltf._exportFH, gltf._exportBuffer, 0, 12);
                            gltf._exportDataSize += 12;
                            break;
                    }
                    VertexOut(indices.data[v1]);
                    VertexOut(indices.data[v2]);
                    VertexOut(indices.data[v3]);
                    switch (gltf._exportType) {
                        case "STL":
                            fs.writeSync(gltf._exportFH, "endloop\n");
                            fs.writeSync(gltf._exportFH, "endfacet\n");
                            break;
                        case "STLBIN":
                            gltf._exportBuffer.writeUInt16LE(0, 0);
                            fs.writeSync(gltf._exportFH, gltf._exportBuffer, 0, 2);
                            gltf._exportDataSize += 2;
                            break;
                    }
                    switch (this.mode) {
                        case 5: // strip
                            if (i % 2 == 1)
                                v1 = v3;
                            else
                                v2 = v3;
                            ++v3;
                            break;
                        case 6: // fan
                            v2 = v3;
                            ++v3;
                            break;
                        default: //triangles
                            v1 += 3;
                            v2 += 3;
                            v3 += 3;
                            break;
                    }
                }
            } else if (this.mode === 4) { // only support triangles
                // no indices
                var numAttributes = positionAttr.count;
                for (var i = 0; i < numAttributes - 2; i += 3) {
                    switch (gltf._exportType) {
                        case "STL":
                            //var n = TriangleNormal(v1, v2, v3);
                            var n = new GLTFViewer.Utils.Vec3(0, 0, 0);
                            fs.writeSync(gltf._exportFH, "facet normal " + n.x + " " + n.y + " " + n.z + "\n");
                            fs.writeSync(gltf._exportFH, "outer loop\n");
                            break;
                        case "STLBIN":
                            //var n = TriangleNormal(v1, v2, v3);
                            var n = new GLTFViewer.Utils.Vec3(0, 0, 0);
                            gltf._exportBuffer.writeFloatLE(n.x, 0);
                            gltf._exportBuffer.writeFloatLE(n.y, 4);
                            gltf._exportBuffer.writeFloatLE(n.z, 8);
                            fs.writeSync(gltf._exportFH, gltf._exportBuffer, 0, 12);
                            gltf._exportDataSize += 12;
                            break;
                    }
                    VertexOut(i);
                    VertexOut(i + 1);
                    VertexOut(i + 2);
                    switch (gltf._exportType) {
                        case "STL":
                            fs.writeSync(gltf._exportFH, "endloop\n");
                            fs.writeSync(gltf._exportFH, "endfacet\n");
                            break;
                        case "STLBIN":
                            gltf._exportBuffer.writeUInt16LE(0, 0);
                            fs.writeSync(gltf._exportFH, gltf._exportBuffer, 0, 2);
                            gltf._exportDataSize += 2;
                            break;
                    }
                }
            }
        }
    },
    Render: {
        value: function (name, index, how, w, h, peelPass, texture, shader) {
            if (how === GLTFViewer.Utils.FileGLTF._renderType.RENDEREXPORT) {
                this.RenderExport(name);
                return;
            }
            var gltf = this.gltf;
            var mat = this.material;
            var wantCap = (how === GLTFViewer.Utils.FileGLTF._renderType.RENDEROPAQUECAP || how === GLTFViewer.Utils.FileGLTF._renderType.RENDERTRANSPARENTCAP);
            var wantHighlight = (how === GLTFViewer.Utils.FileGLTF._renderType.RENDERHIT);
            var wantSelection = (how === GLTFViewer.Utils.FileGLTF._renderType.RENDERSELECTION);
            var isPickable = (!GLTFViewer.Utils.IsNull(this.isPickable) ? this.isPickable : true) && !mat.is2D;
            if ((wantHighlight || wantSelection) && !mat.program.programCap) // we can use programCap to do highlighting
                return;
            if (wantCap && (!mat.program.programCap || GLTFViewer.Utils.IsNull(mat.solidColor) || this.mode < 4))
                return; // want cap for solid objects and this is not solid
            if ((how === GLTFViewer.Utils.FileGLTF._renderType.RENDERPICKPOS || how === GLTFViewer.Utils.FileGLTF._renderType.RENDERPICKIDX) && !isPickable)
                return; // no picking 2D objects
            if (how === GLTFViewer.Utils.FileGLTF._renderType.RENDER2D && !mat.is2D)
                return; // want 2D and this is not 2D
            if ((how === GLTFViewer.Utils.FileGLTF._renderType.RENDEROPAQUE || how === GLTFViewer.Utils.FileGLTF._renderType.RENDEROPAQUECAP) && mat.blendEnable.data)
                return; // want opaque and this is transparent
            if ((how === GLTFViewer.Utils.FileGLTF._renderType.RENDERTRANSPARENT || how === GLTFViewer.Utils.FileGLTF._renderType.RENDERTRANSPARENTCAP) && !mat.blendEnable.data)
                return; // want transparent and this is opaque

            var isPickIdx = (how === GLTFViewer.Utils.FileGLTF._renderType.RENDERPICKIDX);
            var isPickAny = (isPickIdx || how === GLTFViewer.Utils.FileGLTF._renderType.RENDERPICKPOS);
            var gl = gltf._gl;
            this.activeTexture = 0;
            var clip = gltf.ClipViewState === GLTFViewer.Utils.Clip.VIEWSTATE_PLANE;
            // start shader
            if (!isPickAny) {
                shader = (peelPass > 0) ? mat.program.programPeel : mat.program.program;
                if (wantCap || wantHighlight || wantSelection)
                    shader = mat.program.programCap;
                else if (clip) {
                    if (mat.program.programClip)
                        shader = mat.program.programClip;
                    else
                        clip = false;
                }
                if (!shader.StartProgram())
                    return;
                if (peelPass > 0) {
                    gl.uniform2f(shader.uSze, w, h);
                    gl.uniform1i(shader.uPass, peelPass);

                    if (peelPass > 1) {
                        gl.activeTexture(gl.TEXTURE0 + this.activeTexture);
                        gl.bindTexture(gl.TEXTURE_2D, texture);
                        gl.uniform1i(shader.DepthTex, this.activeTexture++);
                    }
                }
            }
            // set attributes
            var hasTexture = false;
            var positionParam = null;
            for (var i = 0; i < mat.attributes.length; i++) {
                var param = mat.attributes[i];
                var attr = this.attributes[param.data];
                if (!isPickAny) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, attr.buffer);
                    gl.vertexAttribPointer(shader[param.name], attr.size, attr.baseType, attr.normalized, attr.byteStride, attr.byteOffset);
                } else {
                    // we have special pick shaders, that only handle POSITION and TEXCOORD0
                    if (param.data === gltf._POSITIONNAME) {
                        if (attr.type !== 35665) {
                            GLTFViewer.Utils.WriteErr("ERROR(PICK:" + name + "):", "bad POSITION");
                            return;
                        }
                        gl.bindBuffer(gl.ARRAY_BUFFER, attr.buffer);
                        gl.vertexAttribPointer(shader.aPos, attr.size, attr.baseType, attr.normalized, attr.byteStride, attr.byteOffset);
                    }
                    if (isPickIdx && param.data === 'TEXCOORD0') {
                        if (attr.type === 5126) {
                            gl.bindBuffer(gl.ARRAY_BUFFER, attr.buffer);
                            gl.vertexAttribPointer(shader.aTexCoord0, 1, attr.baseType, attr.normalized, attr.byteStride, attr.byteOffset);
                            hasTexture = true;
                        }
                    }
                }
            }
            if (!hasTexture && isPickIdx) {
                // we need to set up a bad texture for the pick shader
                // this texture is not used, but FireFox fails without doing this
                // use the position buffer to set up the texture buffer
                var attr = this.attributes[gltf._POSITIONNAME];
                gl.bindBuffer(gl.ARRAY_BUFFER, attr.buffer);
                gl.vertexAttribPointer(shader.aTexCoord0, 1, attr.baseType, attr.normalized, attr.byteStride, attr.byteOffset);
            }
            var numAttributes = this.attributes[gltf._POSITIONNAME].count;
            if (this.indices)
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indices.buffer);
            // set uniforms
            if (!isPickAny) {
                for (var i = 0; i < mat.semanticUniforms.length; i++) {
                    var param = mat.semanticUniforms[i];
                    param.setter(gl, shader[param.name], param.data, this);
                }
                for (var key in mat.valueUniforms) {
                    var param = mat.valueUniforms[key];
                    param.setter(gl, shader[param.name], param.data, this);
                }
            } else {
                gl.uniform1i(shader.uHasTexture, hasTexture);
                gl.uniformMatrix4fv(shader.uTWd, false, gltf._uModelView);
                if (isPickIdx)
                    gl.uniform1f(shader.uIdx, index);
            }
            if (wantHighlight || wantSelection) {
                var c = new Float32Array(4);
                c[0] = 1;
                c[1] = (wantHighlight ? 216.0 : 100.0) / 255.0;
                c[2] = 0;
                c[3] = 70.0 / 255.0;
                gl.uniform4fv(shader[gltf._colorName], c);
                c[0] = 0;
                c[1] = 0;
                c[2] = 0;
                c[3] = 0;
                gl.uniform4fv(shader[gltf._clipName], c);
            } if (clip) {
                gl.uniformMatrix4fv(shader[gltf._objMatrixName], false, gltf._uModel);
                if (wantCap) {
                    gl.uniform4fv(shader[gltf._colorName], mat.solidColor);
                    gl.uniform4fv(shader[gltf._clipName], gltf._clip.glClip1);
                } else
                    gl.uniform4fv(shader[gltf._clipName], gltf._clip.glClip0);
            }
            // set GL state
            if (peelPass < 0) {
                if (!wantCap)
                    gl.depthFunc(mat.depthFunc.data);
                else
                    gl.depthFunc(gl.LESS);
                if ((mat.depthTestEnable.data || wantCap) && !wantHighlight && !wantSelection)
                    gl.enable(gl.DEPTH_TEST);   // !2D
                else
                    gl.disable(gl.DEPTH_TEST);  // 2D
                if (wantHighlight || wantSelection) {
                    gl.depthMask(false);
                    gl.enable(gl.BLEND);
                } else if (!isPickAny && !wantCap) {
                    gl.depthMask(mat.depthMask.data);    // true for non-transparent, false for transparent
                    if (mat.blendEnable.data) {
                        gl.enable(gl.BLEND);
                        // these are the only ones that work properly with the webgl context
                        //                        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    } else
                        gl.disable(gl.BLEND);
                }
            }
            if (this._hasLineWidthSupport)
                gl.lineWidth(mat.lineWidth.data);
            gl.frontFace(mat.frontFace.data);
            if (mat.polygonOffsetFillEnable.data && !wantCap) {
                gl.enable(gl.POLYGON_OFFSET_FILL);
                gl.polygonOffset(mat.polygonOffsetFactor.data, mat.polygonOffsetUnits.data);
            } else
                gl.disable(gl.POLYGON_OFFSET_FILL);
            // draw
            if (!isPickAny && (mat.blendEnable.data || wantHighlight || wantSelection) && this.mode !== 0 && !wantCap && peelPass < 0) {
                // draw back then front in attempt to draw object from back to front (poor mans draw back to front elements)
                gl.enable(gl.CULL_FACE);
                if (!mat.cullFaceEnable.data || (mat.cullFace.data !== 1029 && mat.cullFace.data !== 1032)) {
                    gl.cullFace(gl.FRONT);
                    if (this.indices)
                        gl.drawElements(this.mode, this.indices.count, gl.UNSIGNED_SHORT, 0);
                    else
                        gl.drawArrays(this.mode, 0, numAttributes);
                    gltf._anyRendered = true;
                }
                if (!mat.cullFaceEnable.data || (mat.cullFace.data !== 1028 && mat.cullFace.data !== 1032)) {
                    gl.cullFace(gl.BACK);
                    if (this.indices)
                        gl.drawElements(this.mode, this.indices.count, gl.UNSIGNED_SHORT, 0);
                    else
                        gl.drawArrays(this.mode, 0, numAttributes);
                    gltf._anyRendered = true;
                }
                gl.disable(gl.CULL_FACE);
            } else {
                if (!mat.cullFaceEnable.data || this.mode === 0 || wantCap || wantHighlight || wantSelection) {
                    if (this.indices)
                        gl.drawElements(this.mode, this.indices.count, gl.UNSIGNED_SHORT, 0);
                    else
                        gl.drawArrays(this.mode, 0, numAttributes);
                    gltf._anyRendered = true;
                } else {
                    if (mat.cullFace.data !== 1032) {
                        gl.enable(gl.CULL_FACE);
                        gl.cullFace(mat.cullFace.data);
                        if (this.indices)
                            gl.drawElements(this.mode, this.indices.count, gl.UNSIGNED_SHORT, 0);
                        else
                            gl.drawArrays(this.mode, 0, numAttributes);
                        gl.disable(gl.CULL_FACE);
                        gltf._anyRendered = true;
                    }
                }
            }
            // reset GL State
            if (peelPass < 0) {
                gl.depthFunc(gl.LESS);
                gl.disable(gl.DEPTH_TEST);
                if ((!isPickAny && !wantCap) || wantHighlight || wantSelection) {
                    gl.depthMask(true);
                    gl.disable(gl.BLEND);
                }
            }
            if (this._hasLineWidthSupport)
                gl.lineWidth(1);
            gl.frontFace(gl.CCW);
            if (mat.polygonOffsetFillEnable.data && !wantCap)
                gl.disable(gl.POLYGON_OFFSET_FILL);
            // reset uniforms
            while (this.activeTexture > 0) {
                --this.activeTexture;
                gl.activeTexture(gl.TEXTURE0 + this.activeTexture);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }
            // reset attributes
            if (this.indices)
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.LegendItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
    this.ID = ID;
    this.title = [];
    this.other = [];
};
GLTFViewer.Utils.FileGLTF.LegendItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.LegendItem },
    //
    x: { writable: true, value: 0 },
    y: { writable: true, value: 0 },
    // RLTB bits
    //  bits 0,1(TB)                bits 2,3(RL)
    //      0: use y                    0: use x
    //      1: Bottom aligned           1: Left aligned
    //      2: Top aligned              2: Right aligned
    //      3: VerticalCenter aligned   3: Horizontal Center aligned
    attachment: { writable: true, value: 15 }, // defaults 15=center 
    size: { writable: true, value: 0.5 }, // fraction of height for vertical, width for horizontal orientation
    vertical: { writable: true, value: true },
    border: { writable: true, value: false },
    foreground: { writable: true, value: null },
    background: { writable: true, value: null },
    title: { writable: true, value: null },
    units: { writable: true, value: null },
    other: { writable: true, value: null },
    image: { writable: true, value: null }, // ImageItem
    min: { writable: true, value: 0 },
    max: { writable: true, value: 1 },
    ticks: { writable: true, value: null },
    valueLocation: { writable: true, value: null },
    logarithmic: { writable: true, value: false },
    //
    _legend: { writable: true, value: null },
    //
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            if (this.image)
                this.image.Reset();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            var gltf = this.gltf;
            var ID = this.ID;
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            this.foreground = null;
            this.background = null;
            this.title = null;
            this.units = null;
            this.other = null;
            if (this.image) {
                this.image.Clear();
                this.image = null;
            }
            this.ticks = null;
            this.valueLocation = null;
        }
    },
    Render: {
        value: function (how) {
            if (how !== GLTFViewer.Utils.FileGLTF._renderType.RENDER2DOVERLAY)
                return;
            if (GLTFViewer.Utils.IsNull(this._legend))
                this._legend = new GLTFViewer.Utils.Legend(this.gltf._scene, this.vertical, this.x, this.y, this.size, this.attachment, this.border, this.foreground, this.background, this.title, this.min, this.max, this.ticks, this.valueLocation, this.logarithmic, this.image.image, this.units, this.other);

            this.gltf._anyRendered = true;
            this._legend.Render();
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.MeshItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
    this.primitives = [];
};
GLTFViewer.Utils.FileGLTF.MeshItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.MeshItem },
    //
    primitives: { writable: true, value: null }, // array of PrimitiveItems
    //
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            for (var i = 0; i < this.primitives.length; ++i)
                this.primitives[i].Reset();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            for (var i = 0; i < this.primitives.length; ++i)
                this.primitives[i].Clear();
            this.primitives = null;
        }
    },
    AddPrimitive: {
        value: function (primitive) {
            this.primitives.push(primitive);
        }
    },
    BoundingBox: {
        value: function (matrix) {
            var box = new GLTFViewer.Utils.Box();
            if (this.primitives) {
                for (var i = 0; i < this.primitives.length; ++i)
                    box.Unite(this.primitives[i].BoundingBox(matrix));
            }
            return box;
        }
    },
    Render: {
        value: function (name, index, how, w, h, peelPass, texture, shader) {
            if (!this.primitives || this.primitives.length === 0)
                return;
            var gl = this.gltf._gl;
            // to get capping working, we need to render all of the primitives in several passes
            var wantCap = (how === GLTFViewer.Utils.FileGLTF._renderType.RENDEROPAQUECAP || how === GLTFViewer.Utils.FileGLTF._renderType.RENDERTRANSPARENTCAP);
            if (wantCap) {
                // this really slows things down, it takes 2 passes through primitives to create cap, plus there will be another pass to render the object
                gl.enable(gl.CULL_FACE);

                // Step 1: clear depth buffer or set depth buffer to back face of bounding box
                gl.clear(gl.DEPTH_BUFFER_BIT);

                // Step 2: Set depth buffer of front faces (this will stop cap from covering front faces)
                gl.enable(gl.POLYGON_OFFSET_FILL);
                gl.polygonOffset(0, -1);
                gl.colorMask(false, false, false, false);
                gl.cullFace(gl.BACK);
                for (var i = 0; i < this.primitives.length; ++i) {
                    var primitiveItem = this.primitives[i];
                    primitiveItem.Render(name, index, how, w, h, peelPass, texture, shader);
                }
                gl.colorMask(true, true, true, true);
                gl.disable(gl.POLYGON_OFFSET_FILL);

                // Step 3: Draw back faces in solid color
                gl.cullFace(gl.FRONT);
                for (var i = 0; i < this.primitives.length; ++i) {
                    var primitiveItem = this.primitives[i];
                    primitiveItem.Render(name, index, how, w, h, peelPass, texture, shader);
                }

                gl.disable(gl.CULL_FACE);
            } else {
                for (var i = 0; i < this.primitives.length; ++i) {
                    var primitiveItem = this.primitives[i];
                    primitiveItem.Render(name, index, how, w, h, peelPass, texture, shader);
                }
            }
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.NodeItem = function (gltf, ID, fileInfo, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
    this.ID = ID;
    this.fileInfo = fileInfo;
    this.meshIDList = [];
    this.meshList = [];
    this.childIDList = [];
    this.childList = {};
    this.sceneNodeItems = [];
};
GLTFViewer.Utils.FileGLTF.NodeItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.NodeItem },
    //
    legendID: { writable: true, value: null },
    legend: { writable: true, value: null }, // legendItem
    meshIDList: { writable: true, value: null }, // array of MeshIDs
    meshList: { writable: true, value: null }, // array of MeshItems
    childIDList: { writable: true, value: null }, // array of NodeIDs
    childList: { writable: true, value: null }, // object of NodeItems
    sceneNodeItems: { writable: true, value: null }, // list of sceneNodeItems that contain this nodeItem
    //
    fileInfo: { writable: true, value: null },
    name: { writable: true, value: null },
    visible: { writable: true, value: true },
    matrix: { writable: true, value: null },
    cameraID: { writable: true, value: null },
    crc: { writable: true, value: null },
    //
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            if (this.legend)
                this.legend.Reset();
            for (var i = 0; i < this.meshList.length; ++i)
                this.meshList[i].Reset();
            for (var key in this.childList)
                this.childList[key].Reset();
            if (this.matrix)
                this.matrix.Reset();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            var gltf = this.gltf;
            var ID = this.ID;
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            if (this.legend)
                this.legend.Clear();
            this.legend = null;
            this.legendID = null;
            for (var i = 0; i < this.meshList.length; ++i)
                this.meshList[i].Clear();
            this.meshList = null;
            this.meshIDList = null;
            for (var key in this.childList)
                this.childList[key].Clear();
            this.childList = null;
            this.childIDList = null;
            this.sceneNodeItems = null;
            this.fileInfo = null;
            this.name = null;
            if (this.matrix) {
                this.matrix.Clear();
                this.matrix = null;
            }
            this.cameraID = null;
            for (var key in gltf._nodeCacheNameMap) {
                if (this === gltf._nodeCacheNameMap[key])
                    delete gltf._nodeCacheNameMap[key];
            }
            //delete gltf._idMap[ID];
            for (var key in gltf._idMap) {
                if (gltf._idMap[key] === ID)
                    delete gltf._idMap[key];
            }
        }
    },
    AddLegend: {
        value: function (legend) {
            this.legend = legend;
        }
    },
    AddMesh: {
        value: function (mesh) {
            this.meshList.push(mesh);
        }
    },
    AddChild: {
        value: function (child) {
            this.childList[child.ID] = child;
        }
    },
    HasName: {
        value: function () {
            return !GLTFViewer.Utils.IsNull(this.name) && (typeof this.name === 'string') && this.name.length > 0;
        }
    },
    SetVisibility: {
        value: function (val) {
            // this is only for use by animation
            for (var i = 0; i < this.sceneNodeItems.length; ++i) {
                var sceneNodeItem = this.sceneNodeItems[i];
                if (sceneNodeItem.visible.value !== val) {
                    if (sceneNodeItem.visList)
                        sceneNodeItem.visList.ToggleFunc();
                    else
                        sceneNodeItem.SetVisibility(val);
                }
            }
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.SceneNodeItem = function (gltf, parentSceneNodeItem, nodeItem) {
    this.nodeItem = (nodeItem instanceof GLTFViewer.Utils.FileGLTF.SceneNodeItem) ? nodeItem.nodeItem : nodeItem;
    var parentVisible = GLTFViewer.Utils.IsNull(parentSceneNodeItem) ? 1 : parentSceneNodeItem.visible.value;
    var parentDisconnect = GLTFViewer.Utils.IsNull(parentSceneNodeItem) ? 0 : parentSceneNodeItem.disconnect;
    this.disconnect = !this.nodeItem.HasName() || parentDisconnect;
    var visible = this.disconnect ? parentVisible : this.nodeItem.visible;
    this.gltf = gltf;
    this.parent = parentSceneNodeItem;
    this.childList = {};
    this.visible = new GLTFViewer.Utils.FileGLTF.ValueItem(gltf, visible ? 1 : 0);
    this.SetVisibility = gltf.SetNodeVisibility.bind(gltf, this);
    this.EditProperties = this._EditProperties.bind(this);

    for (var key in nodeItem.childList)
        this.childList[key] = new GLTFViewer.Utils.FileGLTF.SceneNodeItem(gltf, this, nodeItem.childList[key]);
    this.nodeItem.sceneNodeItems.push(this);

    this.index = gltf._sceneNodeIndexToSceneNode.length; // this is where it will go in _sceneNodeIndexToSceneNode
    gltf._sceneNodeIndexToSceneNode.push(this);
};
GLTFViewer.Utils.FileGLTF.SceneNodeItem.prototype = Object.create(null, {
    gltf: { writable: true, value: null },
    nodeItem: { writable: true, value: null },
    childList: { writable: true, value: null }, // object of sceneNodeItems
    parent: { writable: true, value: null },
    visible: { writable: true, value: null },
    visList: { writable: true, value: null }, // array of visibilityLists
    index: { writable: true, value: 0 },
    disconnect: { writable: true, value: false }, // if disconnect, parent visibility controls this one
    SetVisibility: { writable: true, value: null },
    EditProperties: { writable: true, value: null },
    // private members
    _GetEditableNodeIDs: {
        value: function (curList) {
            if (GLTFViewer.Utils.IsNull(curList)) {
                // first time called
                curList = [];
            } else if (this.disconnect) { // only add nodeItem if disconnected
                var idx = curList.indexOf(this.nodeItem.ID);
                if (idx >= 0)
                    return curList;
            } else
                return curList;

            // do this one
            curList.push(this.nodeItem.ID);
            // do children
            for (var key in this.childList) {
                var childSceneNodeItem = this.childList[key];
                childSceneNodeItem._GetEditableNodeIDs(curList);
            }

            return curList;
        }
    },
    _GetEditableMeshIDs: {
        value: function () {
            // get list of all nodes that are editable
            var nodeIDs = this._GetEditableNodeIDs();
            // from this get list of all meshes
            var meshIDs = [];
            for (var i = 0; i < nodeIDs.length; ++i) {
                var nodeItem = this.gltf._nodeCache[nodeIDs[i]];
                var meshList = nodeItem.meshList;
                // append to meshIDs
                for (var j = 0; j < meshList.length; ++j) {
                    var meshID = meshList[j].ID;
                    if (meshIDs.indexOf(meshID) < 0)
                        meshIDs.push(meshID);
                }
            }
            return meshIDs;
        }
    },
    _GetEditableMaterialIDs: {
        value: function () {
            // get list of all editable meshes
            var meshIDs = this._GetEditableMeshIDs();
            // from this get list of all materials
            var materialIDs = [];
            for (var i = 0; i < meshIDs.length; ++i) {
                var meshItem = this.gltf._meshCache[meshIDs[i]];
                var primitives = meshItem.primitives;
                // append to primitive materialID to materialIDs
                for (var j = 0; j < primitives.length; ++j) {
                    var primitive = primitives[j];
                    var materialItem = primitive.material;
                    var materialID = materialItem.ID;
                    if (materialIDs.indexOf(materialID) < 0) {
                        var valueUniforms = materialItem.valueUniforms;
                        var keys = Object.keys(valueUniforms);
                        if (keys.length)
                            materialIDs.push(materialID);
                    }
                }
            }
            return materialIDs;
        }
    },
    _EditProperties: {
        value: function () {
            // get list of all editable materials
            var materialIDs = this._GetEditableMaterialIDs();

            // from this get list of materials/valueUniforms
            var materialValues = [];
            for (var i = 0; i < materialIDs.length; ++i) {
                var materialItem = this.gltf._materialCache[materialIDs[i]];
                var valueUniforms = materialItem.valueUniforms;
                var keys = Object.keys(valueUniforms);
                for (var j = 0; j < keys.length; ++j) {
                    valueName = keys[j];
                    var valueItem = materialItem.values[valueName];
                    var shaderParam = valueUniforms[valueName];
                    var defaultValue = valueItem ? valueItem.valueInitial : shaderParam.defaultData;
                    materialValues.push({ name: valueName, materialItem: materialItem, defaultValue: defaultValue, shaderParam: shaderParam });
                }
                materialValues.push({ name: "lineWidth", materialItem: materialItem, defaultValue: materialItem.lineWidth.defaultValue, shaderParam: materialItem.lineWidth });
                materialValues.push({ name: "cullFaceEnable", materialItem: materialItem, defaultValue: materialItem.cullFaceEnable.defaultValue, shaderParam: materialItem.cullFaceEnable });
                materialValues.push({ name: "cullFace", materialItem: materialItem, defaultValue: materialItem.cullFace.defaultValue, shaderParam: materialItem.cullFace });
                materialValues.push({ name: "depthTestEnable", materialItem: materialItem, defaultValue: materialItem.depthTestEnable.defaultValue, shaderParam: materialItem.depthTestEnable });
                materialValues.push({ name: "depthMask", materialItem: materialItem, defaultValue: materialItem.depthMask.defaultValue, shaderParam: materialItem.depthMask });
                materialValues.push({ name: "depthFunc", materialItem: materialItem, defaultValue: materialItem.depthFunc.defaultValue, shaderParam: materialItem.depthFunc });
                materialValues.push({ name: "blendEnable", materialItem: materialItem, defaultValue: materialItem.blendEnable.defaultValue, shaderParam: materialItem.blendEnable });
                materialValues.push({ name: "frontFace", materialItem: materialItem, defaultValue: materialItem.frontFace.defaultValue, shaderParam: materialItem.frontFace });
                materialValues.push({ name: "polygonOffsetFillEnable", materialItem: materialItem, defaultValue: materialItem.polygonOffsetFillEnable.defaultValue, shaderParam: materialItem.polygonOffsetFillEnable });
                materialValues.push({ name: "polygonOffset/factor", materialItem: materialItem, defaultValue: materialItem.polygonOffsetFactor.defaultValue, shaderParam: materialItem.polygonOffsetFactor });
                materialValues.push({ name: "polygonOffset/units", materialItem: materialItem, defaultValue: materialItem.polygonOffsetUnits.defaultValue, shaderParam: materialItem.polygonOffsetUnits });
            }

            function ApplyCallback(nodeItem, mVs, ok, data) {
                if (!ok)
                    return;

                // do node properties
                var matrix = new GLTFViewer.Utils.Transformation(data[1]);
                if (!matrix.IsIdentity() || nodeItem.matrix.value)
                    nodeItem.matrix.value = matrix;

                var curMaterialID = null;
                var key = 2;
                for (var i = 0; i < mVs.length; ++i, ++key) {
                    function DoHeader() {
                        if (GLTFViewer.Utils.IsNull(curMaterialID) || curMaterialID !== materialID) {
                            curMaterialID = materialID;
                            ++key;
                        }
                    }
                    var name = mVs[i].name;
                    var materialItem = mVs[i].materialItem;
                    var materialID = GLTFViewer.Utils.FileGLTF.FileInfo.RealID(materialItem.ID);
                    var shaderParam = mVs[i].shaderParam;

                    switch (shaderParam.type) {
                        case "LIST":
                            switch (name) {
                                case "cullFace":
                                    DoHeader();
                                    shaderParam.data = data[key] === "FRONT" ? 1028 : (data[key] === "FRONT_AND_BACK" ? 1032 : 1029);
                                    break;
                                case "depthFunc":
                                    DoHeader();
                                    var v = 513; // LESS
                                    if (data[key] === "NEVER")
                                        v = 512;
                                    else if (data[key] === "EQUAL")
                                        v = 514;
                                    else if (data[key] === "LEQUAL")
                                        v = 515;
                                    else if (data[key] === "GREATER")
                                        v = 516;
                                    else if (data[key] === "NOTEQUAL")
                                        v = 517;
                                    else if (data[key] === "GEQUAL")
                                        v = 518;
                                    else if (data[key] === "ALWAYS")
                                        v = 519;
                                    shaderParam.data = v;
                                    break;
                                case "frontFace":
                                    DoHeader();
                                    shaderParam.data = data[key] === "CW" ? 2304 : 2305;
                                    break;
                            }
                            break;
                        case 5124: // 1i int
                        case 5126: // 1f float
                        case 35670: // 1i bool
                            DoHeader();
                            if (!isNaN(data[key]))
                                shaderParam.data = data[key];
                            break;
                        case 35678: // sampler2D
                            --key;
                            break;
                        default: // vector
                            DoHeader();
                            for (var j = 0; j < data[key].length; ++j) {
                                if (!isNaN(data[key][j]))
                                    shaderParam.data[j] = data[key][j];
                            }
                            break;
                    }
                }

                this.gltf._anyTransparent = null;
                this.gltf._anyOpaque = null;

                this.gltf._scene.Invalidate(true);
            }

            function reset(nodeItem, mVs, resetCallback) {
                if (resetCallback) {
                    var data = ConstructData(nodeItem, mVs, true);
                    resetCallback(data);
                }
            }

            function ConstructData(nodeItem, mVs, wantDefault) {
                var data = [];
                data.push([nodeItem.name, GLTFViewer.Utils.Dialog.DATALABEL]);
                var value;
                if (nodeItem.matrix.value) {
                    var v = wantDefault ? nodeItem.matrix.valueInitial : nodeItem.matrix.value;
                    if (!GLTFViewer.Utils.IsNull(v)) {
                        value = [];
                        v.ToArray(value);
                    }
                }
                if (GLTFViewer.Utils.IsNull(value))
                    value = [1, 0, 0, 0,
                             0, 1, 0, 0,
                             0, 0, 1, 0,
                             0, 0, 0, 1];
                data.push(["matrix", GLTFViewer.Utils.Dialog.DATANUMBERVEC, value]);

                var curMaterialID = null;
                for (var i = 0; i < mVs.length; ++i) {
                    function DoHeader() {
                        if (GLTFViewer.Utils.IsNull(curMaterialID) || curMaterialID !== materialID) {
                            curMaterialID = materialID;
                            data.push([materialID, GLTFViewer.Utils.Dialog.DATALABEL]);
                        }
                    }
                    var name = mVs[i].name;
                    var materialItem = mVs[i].materialItem;
                    var materialID = GLTFViewer.Utils.FileGLTF.FileInfo.RealID(materialItem.ID);
                    var defaultValue = mVs[i].defaultValue;
                    var shaderParam = mVs[i].shaderParam;

                    var value = wantDefault ? defaultValue : shaderParam.data;

                    switch (shaderParam.type) {
                        case "LIST":
                            switch (name) {
                                case "cullFace":
                                    DoHeader();
                                    data.push([name, GLTFViewer.Utils.Dialog.DATALIST, value === 1028 ? "FRONT" : (value === 1032 ? "FRONT_AND_BACK" : "BACK"), ["BACK", "FRONT", "FRONT_AND_BACK"]]);
                                    break;
                                case "depthFunc":
                                    DoHeader();
                                    var v = "LESS"; // 513
                                    if (value === 512)
                                        v = "NEVER";
                                    else if (value === 514)
                                        v = "EQUAL";
                                    else if (value === 515)
                                        v = "LEQUAL";
                                    else if (value === 516)
                                        v = "GREATER";
                                    else if (value === 517)
                                        v = "NOTEQUAL";
                                    else if (value === 518)
                                        v = "GEQUAL";
                                    else if (value === 519)
                                        v = "ALWAYS";
                                    data.push([name, GLTFViewer.Utils.Dialog.DATALIST, v, ["ALWAYS", "EQUAL", "GEQUAL", "GREATER", "LEQUAL", "LESS", "NEVER", "NOTEQUAL"]]);
                                    break;
                                case "frontFace":
                                    DoHeader();
                                    data.push([name, GLTFViewer.Utils.Dialog.DATALIST, value === 2304 ? "CW" : "CCW", ["CCW", "CW"]]);
                                    break;
                            }
                            break;
                        case 5124: // 1i int
                            DoHeader();
                            data.push([name, GLTFViewer.Utils.Dialog.DATAINTEGER, value]);
                            break;
                        case 5126: // 1f float
                            DoHeader();
                            data.push([name, GLTFViewer.Utils.Dialog.DATANUMBER, value]);
                            break;
                        case 35670: // 1i bool
                            DoHeader();
                            data.push([name, GLTFViewer.Utils.Dialog.DATACHECKBOX, value]);
                            break;
                        case 35678: // sampler2D
                            break;
                        default: // vector
                            DoHeader();
                            data.push([name, GLTFViewer.Utils.Dialog.DATANUMBERVEC, value]);
                            break;
                    }
                }
                return data;
            }

            var data = ConstructData(this.nodeItem, materialValues, false);
            if (data.length)
                var dialog = new GLTFViewer.Utils.Dialog("Properties", data, true, ApplyCallback.bind(this, this.nodeItem, materialValues), reset.bind(this, this.nodeItem, materialValues));
        }
    },
    //
    Reset: { // clear to initial state
        value: function () {
            if (this.nodeItem)
                this.nodeItem.Reset();
            for (var key in this.childList)
                this.childList[key].Reset();
            if (this.visible.value !== this.visible.valueInitial && this.visList)
                this.visList.ToggleFunc();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            delete this.gltf._sceneNodeIndexToSceneNode[this.index];
            // remove this from nodeItem
            if (this.nodeItem.sceneNodeItems) {
                for (var i = 0; i < this.nodeItem.sceneNodeItems.length; ++i) {
                    if (this.nodeItem.sceneNodeItems[i] === this) {
                        this.nodeItem.sceneNodeItems.splice(i, 1);
                        break;
                    }
                }
            }
            if (GLTFViewer.Utils.IsNull(this.parent))
                this.nodeItem.Clear(); // node created by AddNode or Clone
            this.nodeItem = null;
            for (var key in this.childList)
                this.childList[key].Clear();
            this.childList = null;
            if (this.visList) {
                this.gltf._viewer.DeleteEntryVisibilityList(this.visList);
                this.visList = null;
            }
            this.visible.Clear();
            this.visible = null;
            this.parent = null;
            this.SetVisibility = null;
            this.EditProperties = null;
            this.gltf = null;
        }
    },
    IsHit: {
        value: function () {
            var hitIndex = this.gltf.HitIndx();
            if (GLTFViewer.Utils.IsNull(hitIndex))
                return false;
            var hitSceneNodeItem = this.gltf._sceneNodeIndexToSceneNode[hitIndex];
            if (GLTFViewer.Utils.IsNull(hitSceneNodeItem))
                return false;
            return this.GetIndex() === hitSceneNodeItem.GetIndex();
        }
    },
    IsSelected: {
        value: function () {
            var selection = this.gltf._selection;
            if (GLTFViewer.Utils.IsNull(selection) || Object.keys(selection).length === 0)
                return false;
            var indx = this.GetIndex();
            for (key in selection) {
                var hitIndex = selection[key].indx;
                var hitSceneNodeItem = this.gltf._sceneNodeIndexToSceneNode[hitIndex];
                if (!GLTFViewer.Utils.IsNull(hitSceneNodeItem)) {
                    if (indx === hitSceneNodeItem.GetIndex())
                        return true;
                }
            }

            return false;
        }
    },
    Clone: {
        value: function () {
            var sceneNodeItem = new GLTFViewer.Utils.FileGLTF.SceneNodeItem(this.gltf, null, this);
            ++sceneNodeItem.nodeItem.refCount;
            return sceneNodeItem;
        }
    },
    IsVisible: {
        value: function () {
            return this.nodeItem.state === GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK &&
                (!this.disconnect ? this.visible.value : (!this.parent ? true : this.parent.IsVisible()));
        }
    },
    GetName: {
        value: function () {
            var name = this.parent ? this.parent.GetName() : "";
            if (!this.disconnect)
                name += (name.length ? "~" : "") + this.nodeItem.name;
            return name;
        }
    },
    // get the sceneNodeItem that controls this one
    GetFirstNonDisconnected: {
        value: function () {
            if (!this.disconnect)
                return this;
            return this.parent.GetFirstNonDisconnected();
        }
    },
    GetIndex: {
        value: function () {
            if (!this.disconnect)
                return this.index;
            if (this.parent)
                return this.parent.GetIndex();
            return null;
        }
    },
    GetVisibility: {
        value: function () {
            //if (this.disconnect)
            //    return null;
            var obj = { visible: this.visible.value };
            var children = {};
            for (var key in this.childList) {
                var nodeID = GLTFViewer.Utils.FileGLTF.FileInfo.RealID(key);
                children[nodeID] = this.childList[key].GetVisibility();
            }
            obj.children = children;
            return obj;
        }
    },
    AccumulatedMatrix: {
        value: function () {
            var nodes = [];
            // find top level parent
            var parent = this.parent;
            while (parent) {
                if (parent.nodeItem.matrix.value)
                    nodes.push(parent.nodeItem);
                parent = parent.parent;
            }
            var matrix = GLTFViewer.Utils.Transformation.Identity;
            for (var i = nodes.length - 1; i >= 0; --i) {
                var nodeItem = nodes[i];
                matrix.Multiply(nodeItem.matrix.value);
            }
            return matrix;
        }
    },
    // works like render, except calculates bounding box
    BoundingBox: {
        value: function (center, explosion, meshOnly, curMatrix) {
            var matrix = curMatrix ? curMatrix.Clone() : GLTFViewer.Utils.Transformation.Identity;
            var visible = this.IsVisible();
            var nodeItem = this.nodeItem;
            if (nodeItem.matrix.value)
                matrix.Multiply(nodeItem.matrix.value);

            var box = GLTFViewer.Utils.Box.empty;
            if (visible && nodeItem.meshList && nodeItem.meshList.length) {
                // do meshes
                for (var i = 0; i < nodeItem.meshList.length; ++i)
                    box.Unite(nodeItem.meshList[i].BoundingBox(matrix));
                if (!box.IsEmpty() && explosion)
                    box.Multiply(GLTFViewer.Utils.ExplosionMatrix(center, box.GetCenter(), explosion));
            }
            // do children
            if (!meshOnly) {
                for (var key in this.childList) {
                    var childSceneNodeItem = this.childList[key];
                    if (!childSceneNodeItem.disconnect || visible)
                        box.Unite(childSceneNodeItem.BoundingBox(center, explosion, meshOnly, matrix));
                }
            }
            return box;
        }
    },
    Render: {
        value: function (curMatrix, how, w, h, peelPass, texture, shader) {
            var gltf = this.gltf;
            var isHit = false;
            var isSelected = false;
            var nodeItem = this.nodeItem;
            var visible = this.IsVisible();
            var navigator = gltf._navigator;

            var objectTM = curMatrix;
            if (nodeItem.matrix.value && !nodeItem.matrix.value.IsIdentity())
                objectTM = objectTM.Clone().Multiply(nodeItem.matrix.value);
            var modelViewTM = navigator.modelViewTM;
            var modelViewInvTrpTM = navigator.modelViewInvTrp;

            var explodeObjectTM = objectTM;
            if (how !== GLTFViewer.Utils.FileGLTF._renderType.RENDER2D) {
                isHit = how !== GLTFViewer.Utils.FileGLTF._renderType.RENDERHIT ? false : this.IsHit();
                isSelected = how !== GLTFViewer.Utils.FileGLTF._renderType.RENDERSELECTION ? false : this.IsSelected();
                // explode
                if (gltf.GetExplosion() > 0) {
                    var sceneCenter = gltf.GetSceneBox(true).GetCenter();
                    var sceneNodeItemCenter = this.BoundingBox(null, 0, true).GetCenter().TransformCreate(curMatrix);
                    var matrix = GLTFViewer.Utils.ExplosionMatrix(sceneCenter, sceneNodeItemCenter, gltf.GetExplosion());
                    explodeObjectTM = matrix.Multiply(objectTM);
                }

                if (!explodeObjectTM.IsIdentity()) {
                    modelViewTM = modelViewTM.Clone().Multiply(explodeObjectTM);
                    modelViewInvTrpTM = modelViewTM.Clone().Invert().Transpose();
                }
            }

            // set shader matrices
            explodeObjectTM.ToArray(gltf._uModel);
            modelViewTM.ToArray(gltf._uModelView);
            modelViewInvTrpTM.ToArray3x3(gltf._uModelViewInvTrp);

            // render meshes
            if (visible && nodeItem.meshList && how !== GLTFViewer.Utils.FileGLTF._renderType.RENDER2DOVERLAY) {
                if ((how !== GLTFViewer.Utils.FileGLTF._renderType.RENDERHIT && how != GLTFViewer.Utils.FileGLTF._renderType.RENDERSELECTION) || isHit || isSelected) {
                    for (var i = 0; i < nodeItem.meshList.length; ++i)
                        nodeItem.meshList[i].Render(this.nodeItem.name, this.index, how, w, h, peelPass, texture, shader);
                }
            }
            // render children
            for (var key in this.childList) {
                var childSceneNodeItem = this.childList[key];
                if (!childSceneNodeItem.disconnect || visible)
                    childSceneNodeItem.Render(objectTM, how, w, h, peelPass, texture, shader);
            }
            // render legend
            if (visible && nodeItem.legend && how === GLTFViewer.Utils.FileGLTF._renderType.RENDER2DOVERLAY)
                nodeItem.legend.Render(how);
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.SceneItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
    this.sceneNodeItems = {};
    this.name = ID;

    this.markup = new GLTFViewer.Utils.Markup(gltf._scene);
};
GLTFViewer.Utils.FileGLTF.SceneItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.SceneItem },
    //
    camera: { writable: true, value: null }, // camera Node
    cameraMatrix: { writable: true, value: null },
    name: { writable: true, value: null },
    sceneNodeItems: { writable: true, value: null }, // object of SceneNodeItems    
    visibility: { writable: true, value: null },
    sceneLI: { writable: true, value: null },
    //
    _box: { writable: true, value: null },
    _explodeBox: { writable: true, value: null },
    explosion: { writable: true, value: 0 },
    background: { writable: true, value: null },
    rulerUnits: { writable: true, value: null },
    rulerScale: { writable: true, value: 1 },
    navigatorState: { writable: true, value: null },
    clipState: { writable: true, value: null },
    markup: { writable: true, value: null },
    markupVis: { writable: true, value: null },
    markupVisEditable: { writable: true, value: null },
    clipP0: { writable: true, value: null },
    clipP1: { writable: true, value: null },
    clipP2: { writable: true, value: null },
    update: { writable: true, value: false },
    //
    _BoundingBox: {
        value: function (explode) {
            var center = explode ? this._box.GetCenter() : null;
            var explosion = explode ? this.gltf.GetExplosion() : 0;
            var box = GLTFViewer.Utils.Box.empty;
            for (var key in this.sceneNodeItems)
                box.Unite(this.sceneNodeItems[key].BoundingBox(center, explosion));
            return box;
        }
    },
    //
    GetBoundingBox: {
        value: function (dontExplode) {
            if (GLTFViewer.Utils.IsNull(this._box))
                this.UpdateBoundingBox();
            if (dontExplode)
                return this._box;
            return this._explodeBox;
        }
    },
    UpdateBoundingBox: {
        value: function () {
            this._box = this._BoundingBox(false);
            if (!this.gltf.GetExplosion())
                this._explodeBox = this._box.Clone();
            else
                this._explodeBox = this._BoundingBox(true);
            if (this.gltf._curScene === this) {
                if (this.gltf._scene.ClipViewState === GLTFViewer.Utils.Clip.VIEWSTATE_PLANE)
                    this.gltf._clip.UpdateClip();
            }
        }
    },
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            for (var key in this.sceneNodeItems)
                this.sceneNodeItems[key].Reset();
            if (this.camera)
                this.camera.Reset();
            this._box = null;
            this._explodeBox = null;
            this.explosion = 0;
            this.navigatorState = null;
            this.clipState = null;

            this.markup.ResetSelection();

            // set visibility
            this.SetVisibility();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            var gltf = this.gltf;
            var ID = this.ID;
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            if (gltf._curScene == this)
                gltf._curScene = null;
            if (this.camera) {
                this.camera.Clear();
                this.camera = null;
            }
            this.cameraMatrix = null;
            this.name = null;
            for (var key in this.sceneNodeItems)
                this.sceneNodeItems[key].Clear();
            this.sceneNodeItems = null;
            if (this.sceneLI) {
                gltf._viewer.DeleteEntrySceneList(this.sceneLI);
                this.sceneLI = null;
            }
            this.visibility = null;
            this._box = null;
            this._explodeBox = null;
            this.background = null;
            this.rulerUnits = null;
            this.navigatorState = null;
            this.clipP0 = null;
            this.clipP1 = null;
            this.clipP2 = null;
            this.clipState = null;
            var markups = this.markup.GetLineKeys();
            for (var i = 0; i < markups.length; ++i)
                gltf.DeleteMarkupLine(this, markups[i]);
            this.markup = null;
            // clear any markups in _markupCache
            if (gltf._markupCache) {
                for (var key in gltf._markupCache) {
                    var markup = gltf._markupCache[key];
                    if (gltf.IDMap(ID) === gltf.IDMap(markup.sceneID))
                        gltf._markupCache[key].Clear();
                }
            }
            for (var key in this.gltf._sceneCacheNameMap) {
                if (this === this.gltf._sceneCacheNameMap[key])
                    delete this.gltf._sceneCacheNameMap[key];
            }
            //delete gltf._idMap[ID];
            for (var key in gltf._idMap) {
                if (gltf._idMap[key] === ID)
                    delete gltf._idMap[key];
            }
        }
    },
    DeleteNode: {
        value: function (nodeID) {
            var sceneNodeItem = this.sceneNodeItems[nodeID];
            if (!GLTFViewer.Utils.IsNull(sceneNodeItem)) {
                sceneNodeItem.Clear();
                delete this.sceneNodeItems[nodeID];
                this.UpdateBoundingBox();
                return true;
            }

            return false;
        }
    },
    DeleteNodeByName: {
        value: function (name) {
            for (var key in this.sceneNodeItems) {
                var sceneNodeItem = this.sceneNodeItems[key];
                if (!GLTFViewer.Utils.IsNull(sceneNodeItem) && sceneNodeItem.nodeItem.name === name)
                    return this.DeleteNode(key);
            }

            return false;
        }
    },
    AddNode: {
        value: function (nodeItem) {
            var nodeID = nodeItem.ID;

            // if replacing a node, use the original nodes visibility
            var visible = nodeItem.visible;
            var sceneNodeItem = this.sceneNodeItems[nodeID];
            if (!GLTFViewer.Utils.IsNull(sceneNodeItem))
                visible = sceneNodeItem.IsVisible();
            else {
                var nodeName = nodeItem.name;
                for (var key in this.sceneNodeItems) {
                    var sceneNodeItem = this.sceneNodeItems[key];
                    if (!GLTFViewer.Utils.IsNull(sceneNodeItem) && sceneNodeItem.nodeItem.name === nodeName) {
                        visible = this.sceneNodeItems[sceneNodeItem.nodeItem.ID].IsVisible();
                        break;
                    }
                }
            }
            nodeItem.visible = visible;

            if (!this.DeleteNode(nodeID) && (typeof nodeItem.name === 'string') && nodeItem.name.length)
                this.DeleteNodeByName(nodeItem.name);
            var nI = new GLTFViewer.Utils.FileGLTF.SceneNodeItem(this.gltf, null, nodeItem);
            this.sceneNodeItems[nodeID] = nI;
            this.UpdateBoundingBox();
        }
    },
    GetVisibility: {
        value: function () {
            var children = {};
            for (var key in this.sceneNodeItems) {
                var nodeID = GLTFViewer.Utils.FileGLTF.FileInfo.RealID(key);
                children[nodeID] = this.sceneNodeItems[key].GetVisibility();
            }
            return children;
        }
    },
    SetVisibility: {
        value: function () {
            if (GLTFViewer.Utils.IsNull(this.visibility))
                return;

            function Process(sceneNodeItem, visItem) {
                if (GLTFViewer.Utils.IsNull(sceneNodeItem) || GLTFViewer.Utils.IsNull(visItem))
                    return;

                if (visItem.visible !== sceneNodeItem.visible.value) {
                    if (sceneNodeItem.visList)
                        sceneNodeItem.visList.ToggleFunc();
                    else
                        sceneNodeItem.SetVisibility(visItem.visible);
                }

                for (var key in visItem.children)
                    Process(sceneNodeItem.childList[key], visItem.children[key]);
            }

            for (var key in this.visibility)
                Process(this.sceneNodeItems[key], this.visibility[key]);
        }
    },
    SetRuler: {
        value: function (ruler) {
            this.rulerScale = ruler.scale;
            this.rulerUnits = ruler.units;
        }
    },
    Render: {
        value: function (how, w, h, peelPass, texture, shader) {
            for (var key in this.sceneNodeItems)
                this.sceneNodeItems[key].Render(GLTFViewer.Utils.Transformation.Identity, how, w, h, peelPass, texture, shader, false);
        }
    },
    Clone: {
        value: function (name) {
            var gltf = this.gltf;
            var projectionTM;
            var clipState;
            if (this === gltf._curScene) {
                projectionTM = gltf._navigator.projectionTM;
                clipState = gltf._clip.state;
            } else {
                projectionTM = this.navigatorState ? this.navigatorState.projectionTM : this.cameraMatrix;
                clipState = this.clipState;
            }

            // generate unique sceneID
            var ID = GLTFViewer.Utils.FileGLTF.GenerateUniqueID(gltf._sceneCache, this.ID);
            var sceneItem = new GLTFViewer.Utils.FileGLTF.SceneItem(gltf, ID, gltf._sceneCache);
            gltf._sceneCacheNameMap[name] = sceneItem;
            sceneItem.refCount = 1;
            sceneItem.editable = true;
            sceneItem.name = GLTFViewer.Utils.FileGLTF.GenerateUniqueName(gltf._sceneCache, name);
            sceneItem.cameraMatrix = projectionTM.Clone();
            if (this.camera) {
                sceneItem.camera = this.camera;
                ++this.camera.refCount;
            }
            if (this.background) {
                sceneItem.background = { type: this.background.type };
                if (this.background.color1)
                    sceneItem.background.color1 = [this.background.color1[0], this.background.color1[1], this.background.color1[2]];
                if (this.background.color2)
                    sceneItem.background.color2 = [this.background.color2[0], this.background.color2[1], this.background.color2[2]];
            }
            if (this.rulerScale)
                sceneItem.SetRuler({ scale: this.rulerScale, units: this.rulerUnits });
            if (clipState && clipState.clipPlane) {
                sceneItem.clipState = {};
                sceneItem.clipState.clipState = clipState.clipState;
                sceneItem.clipState.clipPlane = clipState.clipPlane.Clone();
                var pts = GLTFViewer.Utils.Clip.GetClipPointsFromPlane(clipState.clipPlane);
                sceneItem.clipP0 = pts.p0;
                sceneItem.clipP1 = pts.p1;
                sceneItem.clipP2 = pts.p2;
            }
            sceneItem.explosion = this.explosion;
            // add all nodes and childnodes, have to copy
            for (var key in this.sceneNodeItems)
                sceneItem.sceneNodeItems[key] = this.sceneNodeItems[key].Clone();
            sceneItem.state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;

            // copy markups
            var markups = this.markup.GetLineKeys();
            for (var i = 0; i < markups.length; ++i) {
                var key = markups[i];
                var line = this.markup.GetLine(key);
                sceneItem.markup.CreateMarkupLine(line);
            }

            return sceneItem;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.CameraItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
};
GLTFViewer.Utils.FileGLTF.CameraItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.CameraItem },
    //
    type: { writable: true, value: null },
    xmag: { writable: true, value: 1 },
    ymag: { writable: true, value: 1 },
    yfov: { writable: true, value: 0 },
    aspectRatio: { writable: true, value: 1 },
    zfar: { writable: true, value: 0 },
    znear: { writable: true, value: 0 },
    //
    Clear: { // clear for deletion
        value: function () {
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            this.type = null;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.MarkupItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
};
GLTFViewer.Utils.FileGLTF.MarkupItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.MarkupItem },
    //
    type: { writable: true, value: null },
    sceneID: { writable: true, value: null },
    position: { writable: true, value: null },
    index: { writable: true, value: null },
    lineColor: { writable: true, value: null },
    lineShape: { writable: true, value: 0 },
    text: { writable: true, value: null },
    textOffset: { writable: true, value: null },
    textAttach: { writable: true, value: 0 },
    textSize: { writable: true, value: 10 },
    textFont: { writable: true, value: null },
    textColor: { writable: true, value: null },
    backgroundColor: { writable: true, value: null },
    //
    _key: { writable: true, value: null },
    //
    Clear: { // clear for deletion
        value: function () {
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            this.type = null;
            this.sceneID = null;
            this.position = null;
            this.lineColor = null;
            this.text = null;
            this.textOffset = null;
            this.textFont = null;
            this.textColor = null;
            this.backgroundColor = null;
            this._key = null;
        }
    },
    Create: {
        value: function (sceneItem) {
            if (this.state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK)
                return;
            var gltf = this.gltf;
            if (gltf.IDMap(sceneItem.ID) === gltf.IDMap(this.sceneID)) {
                if (this._key)
                    gltf.DeleteMarkupLine(sceneItem, this._key);
                this._key = gltf.CreateMarkupLine(sceneItem, this.editable, this.type, this.position, this.index,
                                                  this.lineColor, this.lineShape,
                                                  this.text, this.textOffset, this.textAttach, this.textSize,
                                                  this.textFont, this.textColor, this.backgroundColor);
            }
        }
    },
    Destroy: {
        value: function (sceneItem) {
            if (GLTFViewer.Utils.IsNull(this._key))
                return;
            var gltf = this.gltf;
            if (gltf.IDMap(sceneItem.ID) === gltf.IDMap(this.sceneID)) {
                gltf.DeleteMarkupLine(sceneItem, this._key);
                this._key = null;
            }
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.AnimationSamplerItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
};
GLTFViewer.Utils.FileGLTF.AnimationSamplerItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.AnimationSamplerItem },
    //
    interpolation: { writable: true, value: null },
    input: { writable: true, value: null }, // AttributeItem
    output: { writable: true, value: null }, // AttributeItem
    //
    minTime: {
        get: function () {
            if (!this.input)
                return 0;
            return this.input.mn;
        }
    },
    maxTime: {
        get: function () {
            if (!this.input)
                return -1;
            return this.input.mx;
        }
    },
    //
    GetValue: {
        value: function (time) {
            var input = this.input;
            var output = this.output;
            var b = null;
            var a = null;
            var f;

            if (input.count < 2) {
                b = 0;
                a = 0;
                f = 0;
            } else if (time < this.minTime) {
                b = null;
                a = 0;
                f = null;
            } else if (time >= this.maxTime) {
                b = input.count - 1;
                a = null;
                f = 0;
            } else {
                var lastTime = input.data[0];
                for (var i = 1; i < input.count; ++i) {
                    var thisTime = input.data[i];
                    if (time <= thisTime) {
                        // between lastTime and thisTime
                        b = i - 1;
                        a = i;
                        f = (time - lastTime) / (thisTime - lastTime);
                        break;
                    }
                    lastTime = thisTime;
                }
            }

            var before = GLTFViewer.Utils.IsNull(b) ? null : [];
            var value = null;
            var after = GLTFViewer.Utils.IsNull(a) ? null : []; ;
            for (var j = 0; j < output.size; ++j) {
                if (!GLTFViewer.Utils.IsNull(b))
                    before[j] = output.data[b * output.size + j];
                if (!GLTFViewer.Utils.IsNull(a))
                    after[j] = output.data[a * output.size + j];
            }
            if (!GLTFViewer.Utils.IsNull(f))
                value = GLTFViewer.Utils.Interpolate(before, after, f);

            return { value: value, before: before, after: after };
        }
    },
    //
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            if (this.input)
                this.input.Reset();
            if (this.output)
                this.output.Reset();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            this.interpolation = null;
            if (this.input) {
                this.input.Clear();
                this.input = null;
            }
            if (this.output) {
                this.output.Clear();
                this.output = null;
            }
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.AnimationChannelItem = function (gltf) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf);
};
GLTFViewer.Utils.FileGLTF.AnimationChannelItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.AnimationChannelItem },
    //
    sampler: { writable: true, value: null }, // AnimationSamplerItem
    targetID: { writable: true, value: null }, // nodeID or materialID
    targetPath: { writable: true, value: null }, // name of property to animate
    //
    minTime: {
        get: function () {
            if (!this.sampler)
                return 0;
            return this.sampler.minTime;
        }
    },
    maxTime: {
        get: function () {
            if (!this.sampler)
                return -1;
            return this.sampler.maxTime;
        }
    },
    // public functions
    TargetNodeItem: {
        value: function () {
            return this.gltf._nodeCache[this.targetID];
        }
    },
    Show: {
        value: function (time) {
            var v = this.sampler.GetValue(time);
            if (GLTFViewer.Utils.IsNull(v.value))
                return;
            var gltf = this.gltf;
            var value = v.value;
            var node = gltf._nodeCache[this.targetID];
            var material = gltf._materialCache[this.targetID];
            if (node) {
                // targetID is node
                if (this.targetPath === "matrix" && value.length === 16)
                    node.matrix.value = new GLTFViewer.Utils.Transformation(value);
                else if (this.targetPath === "visible" && value.length === 1) {
                    if (parseInt(value[0]) !== value[0])
                        value = v.before;
                    node.SetVisibility(value[0]);
                }
            } else {
                var material = gltf._materialCache[this.targetID];
                if (material) {
                    // targetID is material
                    if (material.valueUniforms && material.valueUniforms[this.targetPath]) {
                        var valueUniform = material.valueUniforms[this.targetPath];
                        if (!GLTFViewer.Utils.IsNull(valueUniform.data.length) && value.length === valueUniform.data.length) {
                            for (var i = 0; i < value.length; ++i)
                                valueUniform.data[i] = value[i];
                        } else if (typeof valueUniform.data === "number" && value.length === 1)
                            valueUniform.data = value[0];
                    }
                }
            }
        }
    },
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            if (this.sampler)
                this.sampler.Reset();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            if (this.sampler) {
                this.sampler.Clear();
                this.sampler = null;
            }
            this.targetID = null;
            this.targetPath = null;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.AnimationItem = function (gltf, ID, cache) {
    GLTFViewer.Utils.FileGLTF.ItemBaseClass.call(this, gltf, ID, cache);
    this.channelList = [];
};
GLTFViewer.Utils.FileGLTF.AnimationItem.prototype = Object.create(GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileGLTF.AnimationItem },
    //
    channelList: { writable: true, value: null }, // array of AnimationChannelItems
    _minTime: { writable: true, value: 0 },
    minTime: {
        get: function () {
            if (this._maxTime >= this._minTime)
                return this._minTime;
            this._CalculateTimes();
            return this._minTime;
        }
    },
    _maxTime: { writable: true, value: -1 },
    maxTime: {
        get: function () {
            if (this._maxTime >= this._minTime)
                return this._maxTime;
            this._CalculateTimes();
            return this._maxTime;
        }
    },
    //
    _CalculateTimes: {
        value: function () {
            for (var i = 0; i < this.channelList.length; ++i) {
                var channel = this.channelList[i];
                if (i === 0) {
                    this._minTime = channel.minTime;
                    this._maxTime = channel.maxTime;
                } else {
                    this._minTime = Math.min(channel.minTime, this._minTime);
                    this._maxTime = Math.max(channel.maxTime, this._maxTime);
                }
            }
        }
    },
    // public functions
    GetRequiredUnloadedNodes: {
        value: function () {
            var nodes = [];
            for (var i = 0; i < this.channelList.length; ++i) {
                var nodeItem = this.channelList[i].TargetNodeItem();
                if (nodeItem && nodeItem.state === GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_PARTIAL_OK)
                    nodes.push(nodeItem.ID);
            }
            return nodes;
        }
    },
    Show: {
        value: function (time) {
            for (var i = 0; i < this.channelList.length; ++i) {
                var channel = this.channelList[i];
                channel.Show(time);
            }
        }
    },
    Reset: { // clear to initial state
        value: function () {
            GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Reset.call(this);
            for (var i = 0; i < this.channelList.length; ++i)
                this.channelList[i].Reset();
        }
    },
    Clear: { // clear for deletion
        value: function () {
            // should really be at end, but check reference count
            if (!GLTFViewer.Utils.FileGLTF.ItemBaseClass.prototype.Clear.call(this))
                return;
            for (var i = 0; i < this.channelList.length; ++i)
                this.channelList[i].Clear();
            this.channelList = null;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.AnimationInfo = function (gltf, fileInfo) {
    this.gltf = gltf;
    this._fileInfo = fileInfo;

    this._CalculateTimes();
};
GLTFViewer.Utils.FileGLTF.AnimationInfo.prototype = Object.create(null, {
    gltf: { writable: true, value: null },
    //
    _fileInfo: { writable: true, value: null },
    _state: { writable: true, value: 2 }, // -1:BAD, 0:OK, 1:LOADING, 2:NOT_LOADING
    _minTime: { writable: true, value: 0 },
    minTime: {
        get: function () {
            if (this._maxTime >= this._minTime)
                return this._minTime;
            this._CalculateTimes();
            return this._minTime;
        }
    },
    _maxTime: { writable: true, value: -1 },
    maxTime: {
        get: function () {
            if (this._maxTime >= this._minTime)
                return this._maxTime;
            this._CalculateTimes();
            return this._maxTime;
        }
    },
    //
    _CalculateTimes: {
        value: function () {
            for (var key in this.gltf._animationCache) {
                var animationItem = this.gltf._animationCache[key];
                if (this._maxTime < this._minTime) {
                    this._minTime = animationItem.minTime;
                    this._maxTime = animationItem.maxTime;
                } else {
                    this._minTime = Math.min(animationItem.minTime, this._minTime);
                    this._maxTime = Math.max(animationItem.maxTime, this._maxTime);
                }
            }
        }
    },
    _LoadNodes: {
        value: function () {
            if (this._state === GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING || this._state === GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK)
                return;
            this._state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_LOADING;

            var gltf = this.gltf;

            var nodeIDs = [];
            for (var key in gltf._animationCache) {
                var animationItem = gltf._animationCache[key];
                var nodes = animationItem.GetRequiredUnloadedNodes();
                nodeIDs = nodeIDs.concat(nodes);
            }

            nodeIDs = GLTFViewer.Utils.RemoveDuplicates(nodeIDs);
            var numNodes = nodeIDs.length;
            if (numNodes === 0) {
                this._state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
                return;
            }

            // need to look through scenegraph and calculate load sizes
            gltf._totalGLTFBytes = gltf._ComputeLoadSizes(this._fileInfo, nodeIDs, true);
            if (!this._progressTotal)
                gltf._progressBar.Start(gltf._totalGLTFBytes);

            function Callback(loadItem, nodeItem) {
                if (--loadItem.numNodes > 0)
                    return;
                this.gltf._progressBar.Stop();
                this._state = GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK;
            }

            var loadItem = {
                numNodes: numNodes
            };
            for (var i = 0; i < numNodes; ++i) {
                var nodeItem = gltf._nodeCache[nodeIDs[i]];
                gltf._ReadNode(nodeItem.fileInfo, nodeIDs[i], Callback.bind(this, loadItem), true);
            }
        }
    },
    // public functions
    Show: {
        value: function (time) {
            this._LoadNodes();
            if (this._state !== GLTFViewer.Utils.FileGLTF.ItemBaseClass.STATE_OK)
                return false;
            var gltf = this.gltf;
            for (var key in gltf._animationCache) {
                var animationItem = gltf._animationCache[key];
                animationItem.Show(time);
            }
            gltf._curScene.UpdateBoundingBox();
            gltf.UpdateScene();
            return true;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.ShaderParams = function (type, data, setter, name) {
    this.type = type;
    this.data = data;
    if (!(typeof data === "string") && !GLTFViewer.Utils.IsNull(data.length)) {
        this.defaultData = [];
        for (var i = 0; i < data.length; ++i)
            this.defaultData[i] = data[i];
    } else if (typeof data === "number")
        this.defaultData = data;
    this.setter = setter;
    this.name = name;
};
GLTFViewer.Utils.FileGLTF.ShaderParams.prototype = Object.create(null, {
    name: { writable: true, value: null },
    type: { writable: true, value: 0 },
    data: { writable: true, value: null },
    defaultData: { writable: true, value: null },
    setter: { writable: true, value: null },
    //
    Clear: { // clear for deletion
        value: function () {
            this.data = null;
            this.defaultData = null;
            this.setter = null;
            this.name = null;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.Loader = function () {
    this.Reset();
};
GLTFViewer.Utils.FileGLTF.Loader.prototype = Object.create(null, {
    // private properties
    _sizes: { writable: true, value: null },
    _loads: { writable: true, value: null },
    _fails: { writable: true, value: null },
    _imagesCB: { writable: true, value: null },
    _textsCB: { writable: true, value: null },
    _binaryCB: { writable: true, value: null },
    // public methods
    Reset: { // clear to just created state
        value: function () {
            this._loads = {};
            this._fails = {};
            this._sizes = {};
            this._imagesCB = {};
            this._textsCB = {};
            this._binaryCB = {};
        }
    },
    Clear: { // clear for deletion
        value: function () {
        }
    },
    FileLoad: {
        value: function (url, file, fileType, type, delegate) {
            function ProgressCallBack(delegate) {
                return function (e) {
                    if (e.lengthComputable)
                        delegate.HandleProgress(url, e.total, e.loaded);
                };
            }
            function LoadCallBack(delegate, url) {
                return function (e) {
                    delegate.HandleData(url, e.target.result);
                };
            }

            if (type !== "arraybuffer" && type !== "text" && type !== "img") {
                delegate.HandleError(url, "Invalid stream type " + type);
                return;
            }
            if (fileType === GLTFViewer.Utils.FileGLTF.FILE_TYPE_UNZIP_TO_MEMORY) {
                if (type === "arraybuffer")
                    delegate.HandleData(url, file);
                else if (type === "text")
                    delegate.HandleData(url, file);
                else
                    delegate.HandleData(url, "data:image/png;base64," + GLTFViewer.Utils.Base64EncArr(new Uint8Array(file)));
                return;
            }
            if (fileType === GLTFViewer.Utils.FileGLTF.FILE_TYPE_UNZIP_TO_DISK) {
                try {
                    var fs = require("fs");
                    fs.readFile(file + "/" + url, type === "text" ? 'utf8' : null, function (err, data) {
                        if (err) {
                            delegate.HandleError(url, "Can't load file " + file + "/" + url);
                            return;
                        }

                        if (type === "text") {
                            delegate.HandleData(url, data);
                            return;
                        }
                        var ab = new ArrayBuffer(data.length);
                        var view = new Uint8Array(ab);
                        for (var i = 0; i < data.length; ++i)
                            view[i] = data[i];
                        if (type === "arraybuffer")
                            delegate.HandleData(url, ab);
                        else
                            delegate.HandleData(url, "data:image/png;base64," + GLTFViewer.Utils.Base64EncArr(view));
                    });
                } catch (err) {
                    delegate.HandleError(url, "Can't load file " + url);
                }
                return;
            }
            if (!file) {
                delegate.HandleError(url, "Can't load file " + url);
                return;
            }
            var reader = new FileReader();
            reader.onload = LoadCallBack(delegate, url);
            if (delegate.HandleProgress)
                reader.onprogress = ProgressCallBack(delegate);
            if (type === "arraybuffer")
                reader.readAsArrayBuffer(file);
            else if (type === "text")
                reader.readAsText(file);
            else
                reader.readAsDataURL(file);
        }
    },
    _LoadSuccess: {
        value: function (url, success, progressCallBack) {
            this._fails[url] = !success;
            if (this._loads[url])
                this._loads[url].loaded = this._loads[url].total;
            if (progressCallBack)
                progressCallBack(this._loads);
        }
    },
    SetSize: {
        value: function (url, size) {
            this._sizes[url] = size;
        }
    },
    GetSize: {
        value: function (url) {
            return this._sizes[url] ? this._sizes[url] : 0;
        }
    },
    LoadImage: {
        value: function (url, file, fileType, callback, progressCallBack) {
            var delegate = Object.create(this, {
                HandleError: {
                    value: function (path, errorString) {
                        GLTFViewer.Utils.WriteErr("ERROR(LoadImage:" + path + "): " + errorString);
                        this.HandleData(path, null);
                    }
                },
                HandleProgress: {
                    value: function (path, totalBytes, loadedBytes) {
                        this._loads[path].total = this._sizes[path];
                        this._loads[path].loaded = this._sizes[path] * loadedBytes / (totalBytes ? totalBytes : 1);
                        if (progressCallBack)
                            progressCallBack(this._loads);
                    }
                },
                HandleData: {
                    value: function (path, data) {
                        this._loads[path].total = this._loads[path].loaded = this._sizes[path];
                        if (data === null) {
                            this._LoadSuccess(path, false, progressCallBack);
                            this._imagesCB[path].callback.forEach(function (cb) {
                                cb(null);
                            }, this);
                            delete this._imagesCB[path];
                            return;
                        }
                        var image = new Image();
                        image.onerror = (function (e) {
                            delegate.HandleError(path, "The image could not be loaded");
                        }).bind(this);
                        image.onload = (function (e) {
                            this._LoadSuccess(path, true, progressCallBack);
                            this._imagesCB[path].callback.forEach(function (cb) {
                                cb(image);
                            }, this);
                            delete this._imagesCB[path];
                            var urls = Object.keys(this._imagesCB);
                            if (urls.length > 0) {
                                var url = urls[0];
                                var imageCB = this._imagesCB[url];
                                var file = imageCB.file;
                                var fileType = imageCB.fileType;
                                if (fileType !== GLTFViewer.Utils.FileGLTF.FILE_TYPE_URL)
                                    this.FileLoad(url, file, fileType, "img", delegate);
                                else
                                    delegate.HandleData(url, url);
                            }
                        }).bind(this);
                        image.src = data;
                    }
                }
            });

            if (this._fails[url]) {
                callback(null);
                return;
            }
            if (this._imagesCB[url]) {
                // already being loaded
                this._imagesCB[url].callback.push(callback);
            } else {
                this._loads[url] = { total: 0, loaded: 0 };
                this._imagesCB[url] = { file: file, fileType: fileType, callback: [callback] };
                var urls = Object.keys(this._imagesCB);
                if (urls.length === 1) {
                    if (fileType !== GLTFViewer.Utils.FileGLTF.FILE_TYPE_URL)
                        this.FileLoad(url, file, fileType, "img", delegate);
                    else
                        delegate.HandleData(url, url);
                }
            }
        }
    },
    LoadText: {
        value: function (url, file, fileType, callback, progressCallBack) {
            var delegate = Object.create(this, {
                HandleError: {
                    value: function (path, errorString) {
                        GLTFViewer.Utils.WriteErr("ERROR(LoadText:" + path + "): " + errorString);
                        this.HandleData(path, null);
                    }
                },
                HandleProgress: {
                    value: function (path, totalBytes, loadedBytes) {
                        this._loads[path].total = this._sizes[path];
                        this._loads[path].loaded = this._sizes[path] * loadedBytes / (totalBytes ? totalBytes : 1);
                        if (progressCallBack)
                            progressCallBack(this._loads);
                    }
                },
                HandleData: {
                    value: function (path, data) {
                        this._loads[path].total = this._loads[path].loaded = this._sizes[path];
                        this._LoadSuccess(path, data !== null, progressCallBack);
                        this._textsCB[path].callback.forEach(function (cb) {
                            setTimeout(cb(data), 0);
                        }, this);
                        delete this._textsCB[path];
                        var urls = Object.keys(this._textsCB);
                        if (urls.length > 0) {
                            var url = urls[0];
                            var textCB = this._textsCB[url];
                            var file = textCB.file;
                            var fileType = textCB.fileType;
                            if (fileType !== GLTFViewer.Utils.FileGLTF.FILE_TYPE_URL)
                                this.FileLoad(url, file, fileType, "text", delegate);
                            else
                                GLTFViewer.Utils.FileGLTF.LoadStream(url, "text", delegate);
                        }
                    }
                }
            });

            if (this._fails[url]) {
                callback(null);
                return;
            }
            if (this._textsCB[url]) {
                // already being loaded
                this._textsCB[url].callback.push(callback);
            } else {
                this._loads[url] = { total: 0, loaded: 0 };
                this._textsCB[url] = { file: file, fileType: fileType, callback: [callback] };
                var urls = Object.keys(this._textsCB);
                if (urls.length === 1) {
                    if (fileType !== GLTFViewer.Utils.FileGLTF.FILE_TYPE_URL)
                        this.FileLoad(url, file, fileType, "text", delegate);
                    else
                        GLTFViewer.Utils.FileGLTF.LoadStream(url, "text", delegate);
                }
            }
        }
    },
    LoadBinary: {
        value: function (url, file, fileType, callback, progressCallBack) {
            var delegate = Object.create(this, {
                HandleError: {
                    value: function (path, errorString) {
                        GLTFViewer.Utils.WriteErr("ERROR(LoadBinary:" + path + "): " + errorString);
                        this.HandleData(path, null);
                    }
                },
                HandleProgress: {
                    value: function (path, totalBytes, loadedBytes) {
                        this._loads[path].total = this._sizes[path];
                        this._loads[path].loaded = this._sizes[path] * loadedBytes / (totalBytes ? totalBytes : 1);
                        if (progressCallBack)
                            progressCallBack(this._loads);
                    }
                },
                HandleData: {
                    value: function (path, data) {
                        this._loads[path].total = this._loads[path].loaded = this._sizes[path];
                        this._LoadSuccess(path, data !== null, progressCallBack);
                        this._binaryCB[path].callback.forEach(function (cb) {
                            setTimeout(cb(data), 0);
                        }, this);
                        delete this._binaryCB[path];
                        var urls = Object.keys(this._binaryCB);
                        if (urls.length > 0) {
                            var url = urls[0];
                            var binaryCB = this._binaryCB[url];
                            var file = binaryCB.file;
                            var fileType = binaryCB.fileType;
                            if (fileType !== GLTFViewer.Utils.FileGLTF.FILE_TYPE_URL)
                                this.FileLoad(url, file, fileType, "arraybuffer", delegate);
                            else
                                GLTFViewer.Utils.FileGLTF.LoadStream(url, "arraybuffer", delegate);
                        }
                    }
                }
            });

            if (this._fails[url]) {
                callback(null);
                return;
            }
            if (this._binaryCB[url]) {
                // already being loaded
                this._binaryCB[url].callback.push(callback);
            } else {
                this._loads[url] = { total: 0, loaded: 0 };
                this._binaryCB[url] = { file: file, fileType: fileType, callback: [callback] };
                var urls = Object.keys(this._binaryCB);
                if (urls.length === 1) {
                    if (fileType !== GLTFViewer.Utils.FileGLTF.FILE_TYPE_URL)
                        this.FileLoad(url, file, fileType, "arraybuffer", delegate);
                    else
                        GLTFViewer.Utils.FileGLTF.LoadStream(url, "arraybuffer", delegate);
                }
            }
        }
    }
});
///////////////////////////////////////
// Static data
Object.defineProperties(GLTFViewer.Utils.FileGLTF, {
    // private members
    FILE_TYPE_LOCAL: { value: 0 },
    FILE_TYPE_SECONDARY: { value: 1 },
    FILE_TYPE_URL: { value: 2 },
    FILE_TYPE_UNZIP_TO_MEMORY: { value: 3 },
    FILE_TYPE_UNZIP_TO_DISK: { value: 4 },
    _hitTestIndxVs: {
        value: "uniform mat4 uTWd;\n" +
               "uniform mat4 uTVP;\n" +
               "attribute vec3 aPos;\n" +
               "uniform bool uHasTexture;\n" +
               "attribute float aTexCoord0;\n" +
               "varying float vTexCoord0;\n" +
               "varying vec3 vPos;\n" +
               "void main() {\n" +
                   "vec4 pos = uTVP * uTWd * vec4(aPos, 1.0);\n" +
                   "vPos = pos.xyz / pos.w;\n" +
                   "if (uHasTexture) vTexCoord0 = aTexCoord0; else vTexCoord0 = 0.0;\n" +
                   "gl_PointSize = 1.0;\n" + // in case we have points
                   "gl_Position = pos;\n" +
               "}"
    },
    _hitTestIndxFs: {
        value: "uniform vec4 uCry[2];\n" +
               "uniform vec2 uSze;\n" +
               "uniform float uIdx;\n" +
               "uniform bool uHasTexture;\n" +
               "varying float vTexCoord0;\n" +
               "varying vec3 vPos;\n" +
               "void main() {\n" +
                   "vec2 xy = floor((1.0 + vec2(vPos.x, -vPos.y)) * uSze + .5);\n" +
                   "float w = length(vec2(uCry[0].w, uCry[1].w) - xy);\n" +
                   "if (w >= 3.0) discard;\n" +
                   "gl_FragColor = vec4(-(w + 1.0), float(uHasTexture), uIdx, vTexCoord0);\n" + // 0 -> no object, [-1 to -4) means object
               "}"
    },
    _hitTestPosVs: {
        value: "uniform mat4 uTWd;\n" +
               "uniform mat4 uTVP;\n" +
               "attribute vec3 aPos;\n" +
               "varying vec3 vPos;\n" +
               "void main() {\n" +
                   "vec4 pos = uTWd * vec4(aPos, 1.0);\n" +
                   "vPos = pos.xyz;\n" + // does not seem to matter that this is not divided by pos.w
                   "gl_PointSize = 1.0;\n" + // in case we have points
                   "gl_Position = uTVP * pos;\n" +
               "}"
    },
    _hitTestPosFs: {
        value: "uniform vec4 uCry[2];\n" +
               "varying vec3 vPos;\n" +
               "void main() {\n" +
                   "float d = length(cross(uCry[1].xyz, vPos - uCry[0].xyz));\n" +
                   "gl_FragColor = vec4(-(d + 1.0), vPos);\n" +
               "}"
    },
    _glType: {
        value: { 5120: { type: Int8Array, baseGLType: 5120, size: 1 }, // BYTE
            5121: { type: Uint8Array, baseGLType: 5121, size: 1 }, // UNSIGNED_BYTE
            5122: { type: Int16Array, baseGLType: 5122, size: 1 }, // SHORT
            5123: { type: Uint16Array, baseGLType: 5123, size: 1 }, // UNSIGNED_SHORT
            5124: { type: Int32Array, baseGLType: 5124, size: 1 }, // INT
            5125: { type: Uint32Array, baseGLType: 5125, size: 1 }, // UNSIGNED_INT
            5126: { type: Float32Array, baseGLType: 5126, size: 1 }, // FLOAT
            35664: { type: Float32Array, baseGLType: 5126, size: 2 }, // FLOAT VEC2
            35665: { type: Float32Array, baseGLType: 5126, size: 3 }, // FLOAT VEC3
            35666: { type: Float32Array, baseGLType: 5126, size: 4 }, // FLOAT VEC4
            35667: { type: Int32Array, baseGLType: 5124, size: 2 }, // INT VEC2
            35668: { type: Int32Array, baseGLType: 5124, size: 3 }, // INT VEC3
            35669: { type: Int32Array, baseGLType: 5124, size: 4 }, // INT VEC4
            35675: { type: Float32Array, baseGLType: 5126, size: 9 }, // FLOAT MAT3
            35676: { type: Float32Array, baseGLType: 5126, size: 16} // FLOAT MAT4
        }
    },
    _renderType: {
        value: { RENDEROPAQUE: 1,
            RENDERTRANSPARENT: 2,
            RENDER2D: 3,
            RENDER2DOVERLAY: 4,
            RENDEROPAQUECAP: 5,
            RENDERTRANSPARENTCAP: 6,
            RENDERPICKPOS: 7,
            RENDERPICKIDX: 8,
            RENDERHIT: 9,
            RENDERSELECTION: 10
        }
    },
    // static methods
    _Uniform1i: {
        value: function (x) {
            return x;
        }
    },
    _Uniform1f: {
        value: function (x) {
            return x;
        }
    },
    _Uniform2fv: {
        value: function (x) {
            return new Float32Array(x);
        }
    },
    _Uniform3fv: {
        value: function (x) {
            return new Float32Array(x);
        }
    },
    _Uniform4fv: {
        value: function (x) {
            return new Float32Array(x);
        }
    },
    _Uniform2iv: {
        value: function (x) {
            return new Int32Array(x);
        }
    },
    _Uniform3iv: {
        value: function (x) {
            return new Int32Array(x);
        }
    },
    _Uniform4iv: {
        value: function (x) {
            return new Int32Array(x);
        }
    },
    _UniformMatrix3fv: {
        value: function (x) {
            return new Float32Array(x);
        }
    },
    _UniformMatrix4fv: {
        value: function (x) {
            return new Float32Array(x);
        }
    },
    _Sampler2D: {
        value: function (x) {
            return x;
        }
    },
    _SetUniform1i: {
        value: function (gl, id, x) {
            gl.uniform1i(id, x);
        }
    },
    _SetUniform1f: {
        value: function (gl, id, x) {
            gl.uniform1f(id, x);
        }
    },
    _SetUniform2fv: {
        value: function (gl, id, x) {
            gl.uniform2fv(id, x);
        }
    },
    _SetUniform3fv: {
        value: function (gl, id, x) {
            gl.uniform3fv(id, x);
        }
    },
    _SetUniform4fv: {
        value: function (gl, id, x) {
            gl.uniform4fv(id, x);
        }
    },
    _SetUniform2iv: {
        value: function (gl, id, x) {
            gl.uniform2iv(id, x);
        }
    },
    _SetUniform3iv: {
        value: function (gl, id, x) {
            gl.uniform3iv(id, x);
        }
    },
    _SetUniform4iv: {
        value: function (gl, id, x) {
            gl.uniform4iv(id, x);
        }
    },
    _SetUniformMatrix3fv: {
        value: function (gl, id, x) {
            gl.uniformMatrix3fv(id, false, x);
        }
    },
    _SetUniformMatrix4fv: {
        value: function (gl, id, x) {
            gl.uniformMatrix4fv(id, false, x);
        }
    },
    _SetSampler2D: {
        value: function (gl, id, x, primitive) {
            gl.activeTexture(gl.TEXTURE0 + primitive.activeTexture);
            gl.bindTexture(gl.TEXTURE_2D, x);
            gl.uniform1i(id, primitive.activeTexture++);
        }
    },
    LoadStream: {
        value: function (url, type, delegate) {
            function ProgressCallBack(delegate) {
                return function (e) {
                    if (e.lengthComputable)
                        delegate.HandleProgress(url, e.total, e.loaded);
                };
            }
            function LoadCallBack(delegate, url) {
                return function (e) {
                    if ((this.status === 200) || (this.status === 206)) {
                        try {
                            delegate.HandleData(url, this.response);
                        } catch (err) {
                            delegate.HandleError(url, "XMLHttpRequest " + (err.message ? err.message : err));
                        };
                    } else
                        delegate.HandleError(url, "XMLHttpRequest " + this.status);
                };
            }
            function LoadFileCallBack(delegate, url, xhr) {
                return function (e) {
                    if (xhr.readyState === 4) {
                        try {
                            var data = new Uint8Array(xhr.responseBody.toArray());
                            delegate.HandleData(url, data);
                        } catch (err) {
                            delegate.HandleError(url, "XMLHttpRequest " + (err.message ? err.message : err));
                        };
                    }
                };
            }

            if (type === "FILE") {
                if (!("ActiveXObject" in window)) {
                    delegate.HandleError(url, "Local files not supported");
                    return;
                }
                var xhr = new ActiveXObject('MSXML2.XMLHttp.3.0'); // 'MSXML2.XMLHTTP'
                xhr.open('GET', url, true);
                xhr.setRequestHeader('Accept-Charset', 'x-user-defined');
                xhr.onreadystatechange = LoadFileCallBack(delegate, url, xhr);
                xhr.send(null);

                return;
            }
            if (type !== "arraybuffer" && type !== "text") {
                delegate.HandleError(url, "Invalid stream type " + type);
                return;
            }
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.responseType = type;
            // get data unprocessed as binary string
            if (type === "arraybuffer")
                xhr.overrideMimeType("text/plain; charset=x-user-defined");
            //if this is not specified, 1 "big blob" scenes fails to load. I think this breaks caching, at least on IE
            //            xhr.setRequestHeader("If-Modified-Since", "Sat, 01 Jan 1970 00:00:00 GMT");
            if (delegate.HandleProgress)
                xhr.onprogress = ProgressCallBack(delegate);
            xhr.onload = LoadCallBack(delegate, url);
            xhr.send(null);
        }
    },
    LoadJSON: {
        value: function (url, ignoreError, callback) {
            var delegate = Object.create(this, {
                HandleError: {
                    value: function (path, errorString) {
                        if (!ignoreError)
                            GLTFViewer.Utils.WriteErr("ERROR(LoadJSON:" + path + "): " + errorString);
                        callback(null);
                    }
                },
                HandleData: {
                    value: function (path, data) {
                        function ResolvePathsForCategories(ekmUrlParamNameContextIdValue, pathBase, categories) {
                            categories.forEach(function (category) {
                                var descriptions = jsonData[category];
                                if (descriptions) {
                                    var descriptionKeys = Object.keys(descriptions);
                                    descriptionKeys.forEach(function (descriptionKey) {
                                        var description = descriptions[descriptionKey];
                                        if (description.path) {
                                            description.path = GLTFViewer.Utils.ResolveEKMPath(ekmUrlParamNameContextIdValue, pathBase, description.path);
                                        }
                                    }, this);
                                }
                            }, this);
                        }

                        var jsonData;
                        try {
                            jsonData = JSON.parse(data);
                        } catch (err) {
                            this.HandleError(path, err.message ? err.message : err);
                            return;
                        }
                        // EKM Specific url param value
                        var res = GLTFViewer.Utils.GetEKMBasePath(path);
                        var ekmUrlParamNameContextIdValue = res.ekmUrlParamNameContextIdValue;
                        var pathBase = res.pathBase;
                        // this fixes the "path" of all json objects
                        ResolvePathsForCategories(ekmUrlParamNameContextIdValue, pathBase, ["buffers", "shaders", "images"]);
                        callback(jsonData);
                    }
                }
            });

            GLTFViewer.Utils.FileGLTF.LoadStream(url, "text", delegate);
        }
    },
    CameraToProjection: {
        value: function (cameraType, cameraMatrix, sceneBox) {
            if (!cameraMatrix)
                return null;

            // projection matrix is inverse of camera matrix
            var proj = cameraMatrix.Clone().Invert();

            // need to make proj matrix such that scale is at proj.a33
            var scale = Math.sqrt(proj.a00 * proj.a00 + proj.a01 * proj.a01 + proj.a02 * proj.a02);
            var scaleInv = GLTFViewer.Utils.Transformation.Identity;
            scaleInv.a00 = 1 / scale;
            scaleInv.a11 = 1 / scale;
            scaleInv.a22 = 1 / scale;
            // unscaled proj
            proj.Multiply(scaleInv);
            proj.a30 /= scale; // these get scaled when set a33 to scale.
            proj.a31 /= scale;
            proj.a32 = 0;
            if (cameraType === "orthographic")
                proj.a33 = 2 / scale;
            else
                proj.a33 = 0.70710678 / scale; // this only works with the bad persp camera

            // now center at origin
            var box = sceneBox.Clone().Multiply(proj);
            var z = box.GetCenter().z;
            // we must have the object centered at the origin
            if (z)
                proj.a32 = -z * proj.a33;

            return proj;
        }
    },
    ProjectionToCamera: {
        value: function (cameraType, projectionTM) {
            if (!projectionTM)
                return null;
            var proj = projectionTM.Clone();

            var scale;
            if (cameraType === "orthographic")
                scale = 2 / proj.a33;
            else
                scale = 0.70710678 / proj.a33; // this only works with the bad persp camera
            proj.a33 = 1;
            proj.a32 *= scale;
            proj.a31 *= scale;
            proj.a30 *= scale;

            var scaleMat = GLTFViewer.Utils.Transformation.Identity;
            scaleMat.a00 = scale;
            scaleMat.a11 = scale;
            scaleMat.a22 = scale;
            proj.Multiply(scaleMat);

            proj.Invert(); // camera

            return proj;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileGLTF.Hit = function (targt) {
    if (targt) {
        this.indx = targt.indx;
        if (targt.pnt)
            this.pnt = targt.pnt.Clone();
        this.texture = targt.texture;
    }
};
GLTFViewer.Utils.FileGLTF.Hit.prototype = Object.create(null, {
    // private members
    // public members
    indx: { writable: true, value: null },
    pnt: { writable: true, value: null },
    texture: { writable: true, value: null },
    // private methods
    // public methods
    Reset: { // clear to just created state
        value: function () {
            this.indx = null;
            this.texture = null;
            this.pnt = null;
        }
    },
    Clear: { // clear for deletion
        value: function () {
            GLTFViewer.Utils.FileGLTF.Hit.prototype.Reset.call(this);
        }
    },
    SetPnt: {
        value: function (x, y, z) {
            if (GLTFViewer.Utils.IsNull(this.pnt))
                this.pnt = new GLTFViewer.Utils.Vec3();
            this.pnt.Set(x, y, z);
        }
    }
});
//
// GLTFViewer.Utils.FileGLTF
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// GLTFViewer.Utils.FileSpaceClaim
//
/** @constructor */
GLTFViewer.Utils.FileSpaceClaim = function (scene, fileType, data, other) {
    var gl = scene.gl;
    GLTFViewer.Utils.FileBaseClass.call(this, scene, fileType, data, other);
    this._visTree = {};
    this._namedSelections = [];
    this._idToName = {};
    this._pathToPart = {};
    this._parts = [];
    this._bodies = [];
    this._bodiesNameToIndex = {};
    this._bodiesOpaque = [];
    this._bodiesTransparent = [];
    this._bodiesData = {};
    this.hit = new GLTFViewer.Utils.FileSpaceClaim.Hit();
    try {
        this._hitTestIndexShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.FileSpaceClaim._vsHitTest, GLTFViewer.Utils.FileSpaceClaim._fsHitTest);
        this._hitTestPositionShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.FileSpaceClaim._vsHitTestPos, GLTFViewer.Utils.FileSpaceClaim._fsHitTestPos);
        this._phongShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.FileSpaceClaim._vsPhong, GLTFViewer.Utils.FileSpaceClaim._fsPhong);
        this._flatShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.FileSpaceClaim._vsFlat, GLTFViewer.Utils.FileSpaceClaim._fsFlat);
    } catch (err) {
        GLTFViewer.Utils.WriteErr(err);
        if (this._hitTestIndexShader) {
            this._hitTestIndexShader.DeleteProgram();
            this._hitTestIndexShader = null;
        }
        if (this._hitTestPositionShader) {
            this._hitTestPositionShader.DeleteProgram();
            this._hitTestPositionShader = null;
        }
        if (this._phongShader) {
            this._phongShader.DeleteProgram();
            this._phongShader = null;
        }
        if (this._flatShader) {
            this._flatShader.DeleteProgram();
            this._flatShader = null;
        }
        throw err;
    }
    this.CanClip = true;
    try {
        this._hitTestIndexClipShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.FileSpaceClaim._vsHitTestClip, GLTFViewer.Utils.FileSpaceClaim._fsHitTestClip);
        this._hitTestPositionClipShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.FileSpaceClaim._vsHitTestPosClip, GLTFViewer.Utils.FileSpaceClaim._fsHitTestPosClip);
        this._phongClipShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.FileSpaceClaim._vsPhongClip, GLTFViewer.Utils.FileSpaceClaim._fsPhongClip);
        this._flatClipShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.FileSpaceClaim._vsFlatClip, GLTFViewer.Utils.FileSpaceClaim._fsFlatClip);
    } catch (err) {
        GLTFViewer.Utils.WriteErr(err);
        this.CanClip = false;
    }
    if (!this._hitTestIndexClipShader || !this._hitTestPositionClipShader || !this._phongClipShader || !this._flatClipShader || !this.CanClip) {
        if (this._hitTestIndexClipShader) {
            this._hitTestIndexClipShader.DeleteProgram();
            this._hitTestIndexClipShader = null;
        }
        if (this._hitTestPositionClipShader) {
            this._hitTestPositionClipShader.DeleteProgram();
            this._hitTestPositionClipShader = null;
        }
        if (this._phongClipShader) {
            this._phongClipShader.DeleteProgram();
            this._phongClipShader = null;
        }
        if (this._flatClipShader) {
            this._flatClipShader.DeleteProgram();
            this._flatClipShader = null;
        }
        this.CanClip = false;
    }
    this.CanPeel = true;
    try {
        this._phongPeelShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.FileSpaceClaim._vsPhong, GLTFViewer.Utils.FileSpaceClaim._fsPhongPeel);
        this._flatPeelShader = new GLTFViewer.Utils.ShaderProgram(gl, GLTFViewer.Utils.ShaderProgram.precision, GLTFViewer.Utils.FileSpaceClaim._vsFlat, GLTFViewer.Utils.FileSpaceClaim._fsFlatPeel);
    } catch (err) {
        GLTFViewer.Utils.WriteErr(err);
        this.CanPeel = false;
    }
    if (!this._phongPeelShader || !this._flatPeelShader || !this.CanPeel) {
        if (this._phongPeelShader) {
            this._phongPeelShader.DeleteProgram();
            this._phongPeelShader = null;
        }
        if (this._flatPeelShader) {
            this._flatPeelShader.DeleteProgram();
            this._flatPeelShader = null;
        }
        this.CanPeel = false;
    }
    this._htp0 = new GLTFViewer.Utils.Vec3();
    this._htp1 = new GLTFViewer.Utils.Vec3();
    this._htp2 = new GLTFViewer.Utils.Vec3();
    this._uMtl = new Float32Array(16);
    this._glColor = new Float32Array(4);
    this._gfx = new GLTFViewer.Utils.FileSpaceClaim.Graphics(gl);
    this._uTWd = new Float32Array(16);
    this._glCursorRay = new Float32Array(4 * 2);
    this._tmpVtxDat = new Float32Array(1048576);
    this._clipPlaneBuf = this._tmpVtxDat.subarray(0, 15);
    this._tmpVtxBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this._tmpVtxBuf);
    gl.bufferData(gl.ARRAY_BUFFER, this._tmpVtxDat.subarray(0, 1000), gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
};
GLTFViewer.Utils.FileSpaceClaim.prototype = Object.create(GLTFViewer.Utils.FileBaseClass.prototype, {
    constructor: { value: GLTFViewer.Utils.FileSpaceClaim },
    //private members
    _dsg_session: { writable: true, value: null },
    _gfx: { writable: true, value: null },
    _flatColor: { writable: true, value: false },
    _bodyColor: { writable: true, value: 0 },
    _visTree: { writable: true, value: null },
    _namedSelections: { writable: true, value: null },
    _idToName: { writable: true, value: null },
    _pathToPart: { writable: true, value: null },
    _parts: { writable: true, value: null },
    _bodies: { writable: true, value: null },
    _bodiesNameToIndex: { writable: true, value: null },
    _bodiesOpaque: { writable: true, value: null },
    _bodiesTransparent: { writable: true, value: null },
    _bodiesData: { writable: true, value: null },
    _hitTestIndexShader: { writable: true, value: null },
    _hitTestIndexClipShader: { writable: true, value: null },
    _hitTestPositionShader: { writable: true, value: null },
    _hitTestPositionClipShader: { writable: true, value: null },
    _phongShader: { writable: true, value: null },
    _phongPeelShader: { writable: true, value: null },
    _phongClipShader: { writable: true, value: null },
    _flatShader: { writable: true, value: null },
    _flatPeelShader: { writable: true, value: null },
    _flatClipShader: { writable: true, value: null },
    _htp0: { writable: true, value: null },
    _htp1: { writable: true, value: null },
    _htp2: { writable: true, value: null },
    _clipPlaneBuf: { writable: true, value: null },
    _tmpVtxDat: { writable: true, value: null },
    _tmpVtxBuf: { writable: true, value: null },
    _glColor: { writable: true, value: null },
    _sceneBox: { writable: true, value: null },
    // private methods
    _GetName: {
        value: function (id) {
            var name = this._idToName[id];
            if (GLTFViewer.Utils.IsNull(name) || name === "")
                return "UNKNOWN";
            return name;
        }
    },
    _BuildBodyBox: {
        value: function () {
            if (this._bodiesData === null)
                return;
            var gl = this._gl;
            var vc = 0;
            var indx = 0;
            var cnt = 0;
            var ma = Math.floor(this._tmpVtxDat.byteLength / 108) * 108 / 4;
            var boxBuffers = [];
            var t = this._tmpVtxDat;
            for (var bodyId in this._bodiesData) {
                if (bodyId != null) {
                    var bd = this._bodiesData[bodyId];
                    bd.boxIndex = indx;
                    bd.boxOffset = vc / 3;

                    t[vc++] = bd.max; t[vc++] = bd.miy; t[vc++] = bd.maz; t[vc++] = bd.mix; t[vc++] = bd.miy; t[vc++] = bd.maz; t[vc++] = bd.max; t[vc++] = bd.miy; t[vc++] = bd.miz;
                    t[vc++] = bd.max; t[vc++] = bd.miy; t[vc++] = bd.miz; t[vc++] = bd.mix; t[vc++] = bd.miy; t[vc++] = bd.maz; t[vc++] = bd.mix; t[vc++] = bd.miy; t[vc++] = bd.miz;

                    t[vc++] = bd.mix; t[vc++] = bd.miy; t[vc++] = bd.maz; t[vc++] = bd.mix; t[vc++] = bd.may; t[vc++] = bd.maz; t[vc++] = bd.mix; t[vc++] = bd.miy; t[vc++] = bd.miz;
                    t[vc++] = bd.mix; t[vc++] = bd.miy; t[vc++] = bd.miz; t[vc++] = bd.mix; t[vc++] = bd.may; t[vc++] = bd.maz; t[vc++] = bd.mix; t[vc++] = bd.may; t[vc++] = bd.miz;

                    t[vc++] = bd.mix; t[vc++] = bd.may; t[vc++] = bd.maz; t[vc++] = bd.max; t[vc++] = bd.may; t[vc++] = bd.maz; t[vc++] = bd.mix; t[vc++] = bd.may; t[vc++] = bd.miz;
                    t[vc++] = bd.mix; t[vc++] = bd.may; t[vc++] = bd.miz; t[vc++] = bd.max; t[vc++] = bd.may; t[vc++] = bd.maz; t[vc++] = bd.max; t[vc++] = bd.may; t[vc++] = bd.miz;

                    t[vc++] = bd.max; t[vc++] = bd.may; t[vc++] = bd.maz; t[vc++] = bd.max; t[vc++] = bd.miy; t[vc++] = bd.maz; t[vc++] = bd.max; t[vc++] = bd.may; t[vc++] = bd.miz;
                    t[vc++] = bd.max; t[vc++] = bd.may; t[vc++] = bd.miz; t[vc++] = bd.max; t[vc++] = bd.miy; t[vc++] = bd.maz; t[vc++] = bd.max; t[vc++] = bd.miy; t[vc++] = bd.miz;

                    t[vc++] = bd.max; t[vc++] = bd.miy; t[vc++] = bd.maz; t[vc++] = bd.max; t[vc++] = bd.may; t[vc++] = bd.maz; t[vc++] = bd.mix; t[vc++] = bd.miy; t[vc++] = bd.maz;
                    t[vc++] = bd.mix; t[vc++] = bd.miy; t[vc++] = bd.maz; t[vc++] = bd.max; t[vc++] = bd.may; t[vc++] = bd.maz; t[vc++] = bd.mix; t[vc++] = bd.may; t[vc++] = bd.maz;

                    t[vc++] = bd.max; t[vc++] = bd.may; t[vc++] = bd.miz; t[vc++] = bd.max; t[vc++] = bd.miy; t[vc++] = bd.miz; t[vc++] = bd.mix; t[vc++] = bd.may; t[vc++] = bd.miz;
                    t[vc++] = bd.mix; t[vc++] = bd.may; t[vc++] = bd.miz; t[vc++] = bd.max; t[vc++] = bd.miy; t[vc++] = bd.miz; t[vc++] = bd.mix; t[vc++] = bd.miy; t[vc++] = bd.miz;

                    if (vc >= ma) {
                        var buffer = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                        gl.bufferData(gl.ARRAY_BUFFER, t.subarray(0, vc), gl.STATIC_DRAW);
                        boxBuffers[indx] = buffer;
                        indx++;
                        vc = 0;
                    }
                }
            }

            if (vc > 0) {
                var buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, t.subarray(0, vc), gl.STATIC_DRAW);
                boxBuffers[indx] = buffer;
                indx++;
            }

            if (indx > 0)
                this._gfx.boxBuffers = boxBuffers;
        }
    },
    _BuildBodyMesh: {
        value: function () {
            if (this._bodiesData === null)
                return;
            var gl = this._gl;
            var vc = 0;
            var indx = 0;
            var cnt = 0;
            var ma = Math.floor(this._tmpVtxDat.byteLength / 96) * 96 / 4;

            var faceBuffers = [];
            var faceBuffersNumElements = [];

            var t = this._tmpVtxDat;
            for (var bodyId in this._bodiesData) {
                var bd = this._bodiesData[bodyId];
                bd.faceBufferIndex = indx;
                bd.faceBufferOffset = vc / 8;
                bd.faceBufferNumIndices = 0;
                for (var faceId in bd.faceDatas) {
                    var fd = bd.faceDatas[faceId];
                    var indices = fd.indices;
                    var vertices = fd.vertices;

                    fd.faceBufferIndex = indx;
                    fd.faceBufferOffset = vc / 8;
                    fd.faceBufferNumIndices = indices.length;
                    for (var j = 0, l = 0; j < indices.length; l++) {
                        var ll = Math.floor(l / 65536);
                        var hl = l & 0xffff;

                        var k = indices[j++] * 8;
                        // pos
                        t[vc++] = vertices[k++];
                        t[vc++] = vertices[k++];
                        t[vc++] = vertices[k++];
                        // nor
                        t[vc++] = vertices[k++];
                        t[vc++] = vertices[k++];
                        t[vc++] = vertices[k++];
                        t[vc++] = ll;
                        t[vc++] = hl;

                        k = indices[j++] * 8;
                        // pos
                        t[vc++] = vertices[k++];
                        t[vc++] = vertices[k++];
                        t[vc++] = vertices[k++];
                        // nor
                        t[vc++] = vertices[k++];
                        t[vc++] = vertices[k++];
                        t[vc++] = vertices[k++];
                        t[vc++] = ll;
                        t[vc++] = hl;

                        k = indices[j++] * 8;
                        // pos
                        t[vc++] = vertices[k++];
                        t[vc++] = vertices[k++];
                        t[vc++] = vertices[k++];
                        // nor
                        t[vc++] = vertices[k++];
                        t[vc++] = vertices[k++];
                        t[vc++] = vertices[k++];
                        t[vc++] = ll;
                        t[vc++] = hl;

                        if (vc >= ma) {
                            var buffer = gl.createBuffer();
                            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                            gl.bufferData(gl.ARRAY_BUFFER, t.subarray(0, vc), gl.STATIC_DRAW);
                            faceBuffers[indx] = buffer;
                            faceBuffersNumElements[indx] = vc / 8;
                            indx++;
                            vc = 0;
                        }
                    }
                    cnt += indices.length;
                    bd.faceBufferNumIndices += indices.length;
                }
            }

            if (vc > 0) {
                var buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, t.subarray(0, vc), gl.STATIC_DRAW);
                faceBuffers[indx] = buffer;
                faceBuffersNumElements[indx] = vc / 8;
                indx++;
            }

            if (indx > 0) {
                this._gfx.faceBuffers = faceBuffers;
                this._gfx.faceBuffersNumElements = faceBuffersNumElements;
            }
        }
    },
    _BuildBodyWire: {
        value: function () {
            if (Object.keys(this._bodiesData).length === 0)
                return;
            var gl = this._gl;
            var vc = 0;
            var indx = 0;
            var cnt = 0;
            var ma = Math.floor(this._tmpVtxDat.byteLength / 24) * 24 / 4;

            var edgeBuffers = [];
            var edgeBuffersNumElements = [];

            var x, y, z;
            var mix, miy, miz, max, may, maz;

            var t = this._tmpVtxDat;
            for (var bodyId in this._bodiesData) {
                var bd = this._bodiesData[bodyId];
                if (!bd || !bd.edgeDatas)
                    continue;
                bd.edgeBufferIndex = indx;
                bd.edgeBufferOffset = vc / 3;
                bd.edgeBufferNumIndices = 0;
                for (var edgeId in bd.edgeDatas) {
                    var ed = bd.edgeDatas[edgeId];
                    var fd = ed.faceData;
                    var vertices = fd.vertices;
                    var indices = fd.edgeIndices;
                    var ranges = fd.edgeRanges;

                    ed.edgeBufferIndex = indx;
                    ed.edgeBufferOffset = vc / 3;

                    var indexOffset = ranges[ed.rangesIndex + 1];
                    var numIndices = ranges[ed.rangesIndex + 2];

                    mix = GLTFViewer.Utils.maxValue;
                    miy = GLTFViewer.Utils.maxValue;
                    miz = GLTFViewer.Utils.maxValue;
                    max = -GLTFViewer.Utils.maxValue;
                    may = -GLTFViewer.Utils.maxValue;
                    maz = -GLTFViewer.Utils.maxValue;

                    for (var j = 0; j < numIndices; ++j) {
                        var k = indices[indexOffset++] * 8;
                        t[vc++] = x = vertices[k++];
                        t[vc++] = y = vertices[k++];
                        t[vc++] = z = vertices[k++];

                        if (mix > x) mix = x;
                        if (max < x) max = x;
                        if (miy > y) miy = y;
                        if (may < y) may = y;
                        if (miz > z) miz = z;
                        if (maz < z) maz = z;

                        k = indices[indexOffset++] * 8;
                        t[vc++] = x = vertices[k++];
                        t[vc++] = y = vertices[k++];
                        t[vc++] = z = vertices[k++];

                        if (mix > x) mix = x;
                        if (max < x) max = x;
                        if (miy > y) miy = y;
                        if (may < y) may = y;
                        if (miz > z) miz = z;
                        if (maz < z) maz = z;

                        if (vc >= ma) {
                            var buffer = gl.createBuffer();
                            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                            gl.bufferData(gl.ARRAY_BUFFER, t.subarray(0, vc), gl.STATIC_DRAW);
                            edgeBuffers[indx] = buffer;
                            edgeBuffersNumElements[indx] = vc / 3;
                            indx++;
                            vc = 0;
                        }
                    }
                    numIndices *= 2;
                    cnt += numIndices;

                    ed.edgeBufferNumIndices = numIndices;
                    ed.mix = mix;
                    ed.miy = miy;
                    ed.miz = miz;
                    ed.max = max;
                    ed.may = may;
                    ed.maz = maz;

                    bd.edgeBufferNumIndices += numIndices;
                }
            }

            if (vc > 0) {
                var buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, t.subarray(0, vc), gl.STATIC_DRAW);
                edgeBuffers[indx] = buffer;
                edgeBuffersNumElements[indx] = vc / 3;
                indx++;
            }

            if (indx > 0) {
                this._gfx.edgeBuffers = edgeBuffers;
                this._gfx.edgeBuffersNumElements = edgeBuffersNumElements;
            }
        }
    },
    _BuildGraphics: {
        value: function () {
            try {
                var gl = this._gl;
                this._BuildBodyBox();
                this._BuildBodyMesh();
                this._BuildBodyWire();

                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                this._empty = false;
            }
            catch (err) {
            }
        }
    },
    _ReadMeshData: {
        value: function (reader) {
            var indx = 0;
            var id = 1;
            var faceId = indx + ":" + id;
            var vertices = GLTFViewer.Utils.tEmptyArray;
            var indices = GLTFViewer.Utils.tEmptyArray;
            try {
                var flags = reader.readInt32();

                // box
                var mix = reader.readFloat();
                var miy = reader.readFloat();
                var miz = reader.readFloat();
                var max = reader.readFloat();
                var may = reader.readFloat();
                var maz = reader.readFloat();

                // angles min/max
                var minEdgeAngle = reader.readFloat();
                var maxEdgeAngle = reader.readFloat();
                var minVertexAngle = reader.readFloat();
                var maxVertexAngle = reader.readFloat();

                var edgeIndexSize = reader.readInt32();
                var faceIndexSize = reader.readInt32();

                var _vertices = null;
                var numVertices = reader.readInt32();
                if (numVertices > 0) {
                    var _vertices = new Float32Array(numVertices * 3);

                    for (var i = 0, j = 0; i < numVertices; i++) {
                        var x = reader.readFloat();
                        var y = reader.readFloat();
                        var z = reader.readFloat();

                        _vertices[j++] = x;
                        _vertices[j++] = y;
                        _vertices[j++] = z;
                    }
                }

                // triangle vertices
                var tvCount = reader.readInt32();
                for (var i = 0; i < tvCount; i++) {
                    reader.readFloat(); //tv.m_VertexAngle = 
                    reader.readFloat(); //tv.m_VertexMinAngle = 
                    reader.readFloat(); //tv.m_VertexMaxAngle = 
                    reader.readFloat(); //tv.m_Normal.X = 
                    reader.readFloat(); //tv.m_Normal.Y = 
                    reader.readFloat(); //tv.m_Normal.Z = 

                    var size = reader.readInt32(); //tv.m_Size = 
                    //tv.m_Edges = ptEdges;
                    for (var j = 0; j < size; j++)
                        reader.readInt32(); //tv.m_Edges[j] = 
                    //ptEdges += tv.m_Size;
                }

                // triangle edges ->
                var teCount = reader.readInt32();
                for (var i = 0; i < teCount; i++) {
                    reader.readInt32(); //te.m_StartIndex = 
                    reader.readInt32(); //te.m_EndIndex = 
                    reader.readFloat(); //te.m_Angle = 

                    var size = reader.readInt32(); //te.m_Size = 
                    for (var j = 0; j < size; j++)
                        reader.readInt32(); // te.m_Faces[j] = 
                    //ptFaces += te.m_Size;
                }

                // faces ->
                var fCount = reader.readInt32();
                if (fCount > 0) {
                    var indexCount = fCount * 3;
                    if (indexCount < 65536)
                        indices = new Uint16Array(indexCount);
                    else
                        indices = new Uint32Array(indexCount);

                    vertices = new Float32Array(indexCount * 8);

                    var j = 0, k = 0;
                    for (var i = 0; i < fCount; i++) {
                        var x = reader.readFloat();
                        var y = reader.readFloat();
                        var z = reader.readFloat();

                        var v0 = reader.readInt32() * 3;
                        var v1 = reader.readInt32() * 3;
                        var v2 = reader.readInt32() * 3;

                        reader.readInt32(); //tf.m_Edges[0] = 
                        reader.readInt32(); //tf.m_Edges[1] = 
                        reader.readInt32(); //tf.m_Edges[2] = 

                        indices[k] = k++;
                        indices[k] = k++;
                        indices[k] = k++;

                        vertices[j++] = _vertices[v0++];
                        vertices[j++] = _vertices[v0++];
                        vertices[j++] = _vertices[v0++];
                        vertices[j++] = x;
                        vertices[j++] = y;
                        vertices[j++] = z;
                        vertices[j++] = 0;
                        vertices[j++] = 0;

                        vertices[j++] = _vertices[v1++];
                        vertices[j++] = _vertices[v1++];
                        vertices[j++] = _vertices[v1++];
                        vertices[j++] = x;
                        vertices[j++] = y;
                        vertices[j++] = z;
                        vertices[j++] = 0;
                        vertices[j++] = 0;

                        vertices[j++] = _vertices[v2++];
                        vertices[j++] = _vertices[v2++];
                        vertices[j++] = _vertices[v2++];
                        vertices[j++] = x;
                        vertices[j++] = y;
                        vertices[j++] = z;
                        vertices[j++] = 0;
                        vertices[j++] = 0;
                    }
                }
            }
            catch (err) {
                mix = GLTFViewer.Utils.maxValue;
                miy = GLTFViewer.Utils.maxValue;
                miz = GLTFViewer.Utils.maxValue;
                max = -GLTFViewer.Utils.maxValue;
                may = -GLTFViewer.Utils.maxValue;
                maz = -GLTFViewer.Utils.maxValue;

                vertices = GLTFViewer.Utils.tEmptyArray;
                indices = GLTFViewer.Utils.tEmptyArray;
            }

            return new GLTFViewer.Utils.FileSpaceClaim.FaceData(faceId, mix, miy, miz, max, may, maz, vertices, indices, GLTFViewer.Utils.tEmptyArray, GLTFViewer.Utils.tEmptyArray);
        }
    },
    _ReadFaceData: {
        value: function (reader) {
            var indx = reader.readInt32();
            var id = reader.readInt32();
            var faceId = indx + ":" + id;
            var vertices = GLTFViewer.Utils.tEmptyArray;
            var indices = GLTFViewer.Utils.tEmptyArray;
            var edgeIndices = GLTFViewer.Utils.tEmptyArray;
            var edgeRanges = GLTFViewer.Utils.tEmptyArray;

            var mix = GLTFViewer.Utils.maxValue;
            var miy = GLTFViewer.Utils.maxValue;
            var miz = GLTFViewer.Utils.maxValue;
            var max = -GLTFViewer.Utils.maxValue;
            var may = -GLTFViewer.Utils.maxValue;
            var maz = -GLTFViewer.Utils.maxValue;

            try {
                indx = reader.readInt32();
                id = reader.readInt32();

                var numVertices = reader.readInt32();
                if (numVertices > 0) {
                    vertices = new Float32Array(numVertices * 8);
                    for (var i = 0, j = 0; i < numVertices; i++) {
                        var x = reader.readFloat();
                        var y = reader.readFloat();
                        var z = reader.readFloat();

                        if (mix > x) mix = x;
                        if (max < x) max = x;
                        if (miy > y) miy = y;
                        if (may < y) may = y;
                        if (miz > z) miz = z;
                        if (maz < z) maz = z;

                        vertices[j++] = x;
                        vertices[j++] = y;
                        vertices[j++] = z;
                        vertices[j++] = reader.readFloat();
                        vertices[j++] = reader.readFloat();
                        vertices[j++] = reader.readFloat();
                        vertices[j++] = reader.readFloat();
                        vertices[j++] = reader.readFloat();
                    }
                }

                var indexCount = reader.readInt32();
                if (indexCount > 0) {
                    if (numVertices < 65536) {
                        indices = new Uint16Array(indexCount);
                        for (var i = 0; i < indexCount; i++)
                            indices[i] = reader.readInt16();
                        if (indexCount % 2 != 0)
                            reader.readInt16();
                    } else {
                        indices = new Uint32Array(indexCount);
                        for (var i = 0; i < indexCount; i++)
                            indices[i] = reader.readInt32();
                    }
                }

                var edgeIndicesCount = reader.readInt32();
                if (edgeIndicesCount > 0) {
                    if (edgeIndicesCount < 65536) {
                        edgeIndices = new Uint16Array(edgeIndicesCount);
                        for (var i = 0; i < edgeIndicesCount; i++)
                            edgeIndices[i] = reader.readInt16();
                    } else {
                        edgeIndices = new Uint32Array(edgeIndicesCount);
                        for (var i = 0; i < edgeIndicesCount; i++)
                            edgeIndices[i] = reader.readInt32();
                    }
                }

                var edgeTableCount = reader.readInt32();
                if (edgeTableCount > 0) {
                    edgeRanges = new Uint32Array(edgeTableCount * 3);
                    for (var i = 0, j = 0; i < edgeTableCount; i++) {
                        edgeRanges[j++] = reader.readInt32();
                        var start = reader.readUInt32();
                        var cnt = reader.readUInt32();
                        edgeRanges[j++] = start & ~(3 << 30);
                        edgeRanges[j++] = cnt & ~(3 << 30);
                    }
                }
            }
            catch (err) {
                mix = GLTFViewer.Utils.maxValue;
                miy = GLTFViewer.Utils.maxValue;
                miz = GLTFViewer.Utils.maxValue;
                max = -GLTFViewer.Utils.maxValue;
                may = -GLTFViewer.Utils.maxValue;
                maz = -GLTFViewer.Utils.maxValue;

                vertices = GLTFViewer.Utils.tEmptyArray;
                indices = GLTFViewer.Utils.tEmptyArray;
                edgeIndices = GLTFViewer.Utils.tEmptyArray;
                edgeRanges = GLTFViewer.Utils.tEmptyArray;
            }

            return new GLTFViewer.Utils.FileSpaceClaim.FaceData(faceId, mix, miy, miz, max, may, maz, vertices, indices, edgeIndices, edgeRanges);
        }
    },
    _ReadBodyData: {
        value: function (bodyId, flags, reader) {
            var isUVReady = (flags & 1) != 0;
            var isMesh = (flags & 6) != 0;
            var bd = new GLTFViewer.Utils.FileSpaceClaim.BodyData(this, bodyId);
            bd.faceDatas = {};
            if ((flags & 4) != 0) {
                var fd = this._ReadMeshData(reader);
                if (fd.vertices.length > 0) {
                    bd.mix = fd.mix;
                    bd.max = fd.max;
                    bd.miy = fd.miy;
                    bd.may = fd.may;
                    bd.miz = fd.miz;
                    bd.maz = fd.maz;
                }
                bd.faceDatas[fd.id] = fd;
            } else {
                var edgeDatas = {};
                var peic = 0;
                var mix = GLTFViewer.Utils.maxValue;
                var miy = GLTFViewer.Utils.maxValue;
                var miz = GLTFViewer.Utils.maxValue;
                var max = -GLTFViewer.Utils.maxValue;
                var may = -GLTFViewer.Utils.maxValue;
                var maz = -GLTFViewer.Utils.maxValue;
                var numFaces = reader.readInt32();
                for (var i = 0; i < numFaces; i++) {
                    var fd = this._ReadFaceData(reader);
                    if (fd.vertices.length > 0) {
                        if (mix > fd.mix) mix = fd.mix;
                        if (max < fd.max) max = fd.max;
                        if (miy > fd.miy) miy = fd.miy;
                        if (may < fd.may) may = fd.may;
                        if (miz > fd.miz) miz = fd.miz;
                        if (maz < fd.maz) maz = fd.maz;
                    }
                    bd.faceDatas[fd.id] = fd;
                    for (var j = 0; j < fd.edgeRanges.length; j += 3) {
                        if (fd.edgeRanges[j + 2] > 0) {
                            var key = fd.edgeRanges[j];
                            if (edgeDatas[key] === undefined) {
                                edgeDatas[key] = new GLTFViewer.Utils.FileSpaceClaim.EdgeData(key, fd, j);
                                peic++;
                            }
                        }
                    }
                }
                bd.mix = mix;
                bd.miy = miy;
                bd.miz = miz;
                bd.max = max;
                bd.may = may;
                bd.maz = maz;
                var numEdges = reader.readInt32();
                for (var i = 0; i < numEdges; i++) {
                    var key = reader.readInt32();
                    indx = reader.readInt32();
                    id = reader.readInt32();
                    var edgeId = indx + ":" + id;
                    edgeDatas[key].id = edgeId;
                    edgeDatas[edgeId] = edgeDatas[key];
                    delete edgeDatas[key];
                }
                if (peic > 0)
                    bd.edgeDatas = edgeDatas;
            }
            return bd;
        }
    },
    _ReadFacets: {
        value: function (reader) {
            reader.readInt32(); // face
            reader.readInt32(); // ts\b\b

            var version = reader.readInt32();

            var mix = GLTFViewer.Utils.maxValue;
            var miy = GLTFViewer.Utils.maxValue;
            var miz = GLTFViewer.Utils.maxValue;
            var max = -GLTFViewer.Utils.maxValue;
            var may = -GLTFViewer.Utils.maxValue;
            var maz = -GLTFViewer.Utils.maxValue;

            if (version >= 11) {
                var c = reader.readInt32();
                if (c > 0) {
                    var bd;
                    var flags = 0;
                    var indx;
                    var id;
                    var bodyId;
                    for (; c > 0; c--) {
                        bd = null;
                        if (version >= 13)
                            flags = reader.readInt32();
                        indx = reader.readInt32();
                        id = reader.readInt32();
                        if (indx < 0 || id < 0)
                            GLTFViewer.Utils.WriteErr("ERROR(ReadFacets): Invalid file format");

                        bodyId = indx + ":" + id;
                        indx = reader.readInt32();
                        id = reader.readInt32();
                        if ((flags & 8) != 0) {
                            bd = new GLTFViewer.Utils.FileSpaceClaim.BodyData(this, bodyId);
                            bd.id = indx + ":" + id;
                        } else {
                            if (indx < 0 || id < 0)
                                GLTFViewer.Utils.WriteErr("ERROR(ReadFacets): Invalid file format");
                            var tq = reader.readInt32();
                            if (version < 13)
                                flags = reader.readInt32();
                            else if (version >= 14) {
                                if (tq === 11) {
                                    reader.readDouble(); // surface tolerance
                                    reader.readDouble(); // normal tolerance
                                    reader.readDouble(); // max edge length
                                    reader.readDouble(); // aspect ratio
                                }
                            }

                            bd = this._ReadBodyData(bodyId, flags, reader);

                            if (mix > bd.mix) mix = bd.mix;
                            if (max < bd.max) max = bd.max;
                            if (miy > bd.miy) miy = bd.miy;
                            if (may < bd.may) may = bd.may;
                            if (miz > bd.miz) miz = bd.miz;
                            if (maz < bd.maz) maz = bd.maz;
                        }

                        this._bodiesData[bodyId] = bd;
                    }
                }
            } else
                GLTFViewer.Utils.WriteErr("ERROR(ReadFacets): Unable to read this version");
        }
    },
    _ReadRenderListXml: {
        value: function (renderListXML) {
            var ecolr = new GLTFViewer.Utils.RGBA(0, 0, 0, 50);
            var xcolr = new GLTFViewer.Utils.RGBA();
            var viewsXML = renderListXML.childNodes[0];
            var view0XML = viewsXML.childNodes[0];
            var itemsXML = view0XML.childNodes;
            var numItems = itemsXML.length;
            if (numItems === 0)
                return;
            this._parts = [];
            this._bodies = [];
            this._bodiesTransparent = [];
            this._bodiesOpaque = [];
            this._pathToPart = {};
            this._sceneBox = GLTFViewer.Utils.Box.empty;
            for (var i = 0; i < numItems; i++) {
                var itemXML = itemsXML[i];
                var partId = itemXML.attributes["Id"].value;
                var numBodies = itemXML.attributes["Bodies"].value;
                var partPath = itemXML.attributes["Path"].value;
                if (partPath === "")
                    this._pathToPart["ROOT"] = partId;
                else {
                    var paths = partPath.split(",");
                    var n = paths.length - 1;
                    this._pathToPart[paths[n]] = partId;
                }
                var partTransform = itemXML.attributes["Transform"].value;
                var m = partTransform.split(",");
                var partMatrix = GLTFViewer.Utils.Transformation.Identity;
                if (m.length == 16 && partTransform != "1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1")
                    partMatrix = new GLTFViewer.Utils.Transformation(m).Transpose();
                else if (m.length == 10 && partTransform != "1,0,0,0,1,0,0,0,0,1") {
                    var a00 = m[0] * 1;
                    var a01 = m[1] * 1;
                    var a03 = m[2] * 1;
                    var a10 = m[3] * 1;
                    var a11 = m[4] * 1;
                    var a13 = m[5] * 1;
                    var a20 = m[6] * 1;
                    var a21 = m[7] * 1;
                    var a23 = m[8] * 1;
                    var a30 = 0;
                    var a31 = 0;
                    var a32 = 0;
                    var a33 = m[9] * 1;

                    var a02 = a10 * a21 - a11 * a20;
                    var a12 = a01 * a20 - a00 * a21;
                    var a22 = a00 * a11 - a01 * a10;
                    partMatrix = new GLTFViewer.Utils.Transformation(a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33).Transpose();
                }
                var part = new GLTFViewer.Utils.FileSpaceClaim.Part(partId, this._GetName(partId), partPath, partMatrix);
                this._parts.push(part);

                var bodiesXML = itemXML.childNodes;
                var numChildren = bodiesXML.length;
                // there can be components in itemXML.childNodes, what are components?, are bodies always before components?
                for (var j = 0; numBodies > 0 && j < numChildren; j++) {
                    var bodyXML = bodiesXML[j];
                    if (bodyXML.localName !== "Body")
                        continue;
                    --numBodies;
                    var bodyId = bodyXML.attributes["Id"].value;
                    var bodyData = this._bodiesData[bodyId];
                    if (bodyData && bodyId != bodyData.id) {
                        bodyId = bodyData.id;
                        bodyData = this._bodiesData[bodyId];
                    }
                    var bodyVisible = bodyXML.attributes["Visible"].value == 1;
                    var bodyColor = parseInt(bodyXML.attributes["Color"].value) >>> 0;
                    var bodyFillStyle = parseInt(bodyXML.attributes["FillStyle"].value);
                    if (((bodyColor >> 24) & 0xff) < 255)
                        bodyFillStyle = GLTFViewer.Utils.Fill.Transparent;
                    var bodyType = parseInt(bodyXML.attributes["BodyType"].value);
                    var bodyMatrix = null;
                    var bodyTransform = bodyXML.attributes["Transform"];
                    if (bodyTransform) {
                        bodyTransform = bodyTransform.value;
                        var m = bodyTransform.split(",");
                        if (m.length > 16)
                            m.length = 16;
                        bodyMatrix = new GLTFViewer.Utils.Transformation(m).Transpose();
                    }
                    xcolr.SetRawARGB(bodyColor);
                    GLTFViewer.Utils.HSL.XColor(xcolr);
                    ecolr.SetRawARGB(bodyColor);
                    GLTFViewer.Utils.HSL.EColor(ecolr);
                    var body = new GLTFViewer.Utils.FileSpaceClaim.Body(this, bodyId, this._GetName(bodyId), part, bodyData, bodyVisible, bodyColor, ecolr.GetARGB(), xcolr.GetARGB(), bodyFillStyle, bodyType, bodyMatrix);
                    this._bodies.push(body);
                    part.bodies.push(body);
                    if (bodyFillStyle == GLTFViewer.Utils.Fill.Transparent)
                        this._bodiesTransparent.push(body);
                    else
                        this._bodiesOpaque.push(body);
                    if (bodyVisible) {
                        var bodyBox = new GLTFViewer.Utils.Box(bodyData.mix, bodyData.miy, bodyData.miz, bodyData.max, bodyData.may, bodyData.maz);
                        bodyBox.Multiply(partMatrix);
                        if (bodyMatrix)
                            bodyBox.Multiply(bodyMatrix);
                        this._sceneBox.Unite(bodyBox);
                    }
                }
            }
            this._BuildGraphics();
            this.UpdateWorldScale();
        }
    },
    _ReadDocumentXml: {
        value: function (documentXML) {
            var doc = $(documentXML); // need to be jquery element so can search

            // get mapping from id to name
            this._idToName = {};
            var elems = doc.find("RootCaptionDef").add(doc.find("CaptionDef"));
            for (var ei = 0; ei < elems.length; ++ei) {
                var elem = $(elems[ei]);
                var subjectId = elem.find("subjectId");
                if (subjectId.length && subjectId[0].textContent) {
                    subjectId = subjectId[0].textContent;
                    var name = elem.find("name");
                    if (name.length && name[0].textContent) {
                        name = name[0].textContent;
                        this._idToName[subjectId] = name;
                    }
                }
            }

            // get named selections (Regions)
            this._namedSelections = [];
            var nsDefs = doc.find("NamedSelectionDef");
            for (var nsdi = 0; nsdi < nsDefs.length; ++nsdi) {
                var elem = $(nsDefs[nsdi]);
                var name = elem.find("name");
                if (name.length && name[0].textContent)
                    this._namedSelections.push(name[0].textContent);
            }
        }
    },
    _BuildVisibilitySelector: {
        value: function () {
            function VisibleCallback(body, visible) {
                body.visibl = visible;
                this._scene.Invalidate(true);
                this.UpdateWorldScale();
            }

            function ProcessNode(node, parentNode, parentVisList) {
                var children = node.children;
                var part = node.part;
                node.parent = parentNode;
                if (part) {
                    part.parentPart = parentNode ? parentNode.part : null;
                    var bodies = part.bodies;
                    if (Object.keys(children).length === 0 && bodies.length === 0)
                        return;
                    var name = part.nme;
                    var piList = this._viewer.AddEntryVisibilityList(name, true, null, null, parentVisList, true);
                    for (var j = 0; j < bodies.length; ++j) {
                        var body = bodies[j];
                        if (!body)
                            continue;
                        this._viewer.AddEntryVisibilityList(body.nme, body.visibl, VisibleCallback.bind(this, body), null, piList, true);
                    }
                    for (var key in children)
                        ProcessNode.call(this, children[key], node, piList);
                }
            }

            this._visTree = {};
            this._visTree["root"] = {part: null, parent: null, children: {}};
            for (var i = 0; i < this._parts.length; ++i) {
                var part = this._parts[i];
                var paths = part.path.split(",");
                var ptr = this._visTree["root"];
                if (paths.length > 1 || paths[0] !== "") {
                    for (var j = 0; j < paths.length; ++j) {
                        var path = paths[j];
                        if (!ptr.children[path])
                            ptr.children[path] = {part: null, parent: null, children: {}};
                        ptr = ptr.children[path];
                    }
                }
                ptr.part = part;
            }

            var LI = this._viewer.AddEntrySceneList("SCENE", null);

            if (GLTFViewer.Utils.IsNull(this._visTree["root"].part)) {
                for (var key in this._visTree["root"].children)
                    ProcessNode.call(this, this._visTree["root"].children[key], null, null);
            } else
                ProcessNode.call(this, this._visTree["root"], null, null);

            this._viewer.SetSelectionSceneList(LI);

            // Let folks know we have (potentially) new objects
            const parts_event = new CustomEvent('parts-changed', {bubbles: true, detail: {}});
            this._scene.canvas.dispatchEvent(parts_event);
        }
    },
    _Readdsgz_parse_body_from_dsg_part_node: {
        value: function (part, part_node) {
            // console.log("_Readdsgz_parse_body_from_dsg_part_node", part_node.name);
            // Get the variable objects
            let color_var = this._dsg_session.find_node_by_id(part_node.color_variableid);
            let alpha_var = this._dsg_session.find_node_by_id(part_node.alpha_variableid);
            let displacement_var = this._dsg_session.find_node_by_id(part_node.displacement_variableid);
            let node_size_var = this._dsg_session.find_node_by_id(part_node.node_size_variableid);
            let texture = this._dsg_session.find_node_by_id(part_node.texture_id);
            // the DSG "part" object has DSG "geom" children
            let arr_coordinates = null;
            let arr_conn_lines = null;
            let arr_conn_tris = null;
            let arr_var_elem = null;
            let arr_var_node = null;
            let arr_norm_elem = null;
            let arr_norm_node = null;
            let arr_tex_coordinates = null;
            let mesh_id = null;
            let bodydata_id = null;
            for (let i = 0; i < part_node.children.length; i++) {
                let geom_node = part_node.children[i];
                // All the arrays pointed to by these geom_node nodes make up the "body" mesh
                switch (geom_node.typestring()) {
                    case "COORDINATES":
                        mesh_id = geom_node.id;
                        arr_coordinates = geom_node.data;
                        break;
                    case "TRIANGLES":
                        bodydata_id = geom_node.id;
                        arr_conn_tris = geom_node.data;
                        break;
                    case "LINES":
                        bodydata_id = geom_node.id;
                        arr_conn_lines = geom_node.data;
                        break;
                    case "ELEM_VARIABLE":
                        arr_var_elem = geom_node.data;
                        break;
                    case "NODE_VARIABLE":
                        arr_var_node = geom_node.data;
                        break;
                    case "ELEM_NORMALS":
                        arr_norm_elem = geom_node.data;
                        break;
                    case "NODE_NORMALS":
                        arr_norm_node = geom_node.data;
                        break;
                    case "TEX_COORDINATES":
                        arr_tex_coordinates = geom_node.data;
                        break;
                }
            }
            // If no geometry, return
            if ((arr_conn_tris === null) && (arr_conn_lines === null)) return;
            
            // Construct Spaceclaim style mesh arrays
            let mesh = new NodalMesh(arr_coordinates, arr_conn_tris, arr_conn_lines,
                    arr_norm_node, arr_norm_elem, color_var, arr_var_node, arr_var_elem);

            // Build the BodyData (mesh object) from the geom arrays (see _ReadFacets())
            let bodyData = new GLTFViewer.Utils.FileSpaceClaim.BodyData(this, bodydata_id);
            // Build the FaceData from the mesh data (see _ReadMeshData())
            let edge_info = GLTFViewer.Utils.tEmptyArray;
            if (mesh.line_indices.length > 0) {
                edge_info = [mesh_id, 0, mesh.line_indices.length/2]
            }
            let faceData = new GLTFViewer.Utils.FileSpaceClaim.FaceData(mesh_id,
                    mesh.minx, mesh.miny, mesh.minz,
                    mesh.maxx, mesh.maxy, mesh.maxz,
                    mesh.vertices, mesh.tri_indices,
                    mesh.line_indices, edge_info);
            if (edge_info.length > 0) {
                // Add edge data (for the triangle empty faceData)
                let edgeData = new GLTFViewer.Utils.FileSpaceClaim.EdgeData(mesh_id, faceData, 0);
                bodyData.edgeDatas = {};
                bodyData.edgeDatas[mesh_id] = edgeData;
            }

            // Common bodyData fields
            bodyData.mix = faceData.mix;
            bodyData.miy = faceData.miy;
            bodyData.miz = faceData.miz;
            bodyData.max = faceData.max;
            bodyData.may = faceData.may;
            bodyData.maz = faceData.maz;
            bodyData.faceDatas = {};
            bodyData.faceDatas[faceData.id] = faceData;
            this._bodiesData[bodydata_id] = bodyData;

            // Build a SpaceClaim body from the mesh block
            let bodyId = part_node.id;
            let ecolr = this._Readdsgz_color(part_node.line_color);
            let xcolr = new GLTFViewer.Utils.RGBA();
            let bodyColor = this._Readdsgz_color(part_node.fill_color);
            let bodyVisible = true;
            let bodyFillStyle = GLTFViewer.Utils.Fill.Opaque;
            if (part_node.fill_color[3] < 1.) {
                bodyFillStyle = GLTFViewer.Utils.Fill.Transparent;
            }
            let bodyType = GLTFViewer.Utils.FileSpaceClaim.Body.OpenForm;
            let bodyMatrix = GLTFViewer.Utils.Transformation.Identity;
            let body = new GLTFViewer.Utils.FileSpaceClaim.Body(this, bodyId, this._GetName(bodyId),
                part, bodyData, bodyVisible, bodyColor.GetARGB(), ecolr.GetARGB(), xcolr.GetARGB(),
                bodyFillStyle, bodyType, bodyMatrix);
            this._bodies.push(body);
            part.bodies.push(body);
            if (bodyFillStyle === GLTFViewer.Utils.Fill.Transparent)
                this._bodiesTransparent.push(body);
            else
                this._bodiesOpaque.push(body);
            if (bodyVisible) {
                let bodyBox = new GLTFViewer.Utils.Box(bodyData.mix, bodyData.miy, bodyData.miz,
                    bodyData.max, bodyData.may, bodyData.maz);
                bodyBox.Multiply(part.tx);
                if (bodyMatrix)
                    bodyBox.Multiply(bodyMatrix);
                this._sceneBox.Unite(bodyBox);
            }
        }
    },
    _Readdsgz_color: {
        value: function (rgba) {
            return new GLTFViewer.Utils.RGBA(255 * rgba[0], 255 * rgba[1],
                255 * rgba[2], 255 * rgba[3]);
        }
    },
    _Readdsgz_find_bodies: {
        value: function (part, node, path) {
            // console.log("_Readdsgz_find_bodies", node.name, path);
            for (let i = 0; i < node.children.length; i++) {
                let child = node.children[i];
                let local_path = path + "," + String(child.id);
                if (child.nodetype === "part") {
                    // The DSG "part" node is a mesh block inside the EnSight part
                    this._Readdsgz_parse_body_from_dsg_part_node(part, child);
                } else {
                    // Groups in the path
                    let mat = GLTFViewer.Utils.Transformation.Identity;
                    let local_part = new GLTFViewer.Utils.FileSpaceClaim.Part(child.id, this._GetName(child.id), local_path, mat);
                    this._parts.push(local_part);
                    let paths = local_path.split(",");
                    let n = paths.length - 1;
                    this._pathToPart[paths[n]] = String(child.id);
                    this._Readdsgz_find_bodies(local_part, child, local_path);
                }
            }
        }
    },
    _Readdsgz_find_cases: {
        value: function (node, path) {
            for (let i = 0; i < node.children.length; i++) {
                let child = node.children[i];
                let local_path = path + "," + String(child.id);
                if (path.length === 0) local_path = String(child.id);
                // ENS_CASE -> Part object
                if (child.ens_obj_type() === "ENS_CASE") {
                    // console.log("_Readdsgz_find_cases", child.name);
                    let mat = GLTFViewer.Utils.Transformation.Identity;
                    let part = new GLTFViewer.Utils.FileSpaceClaim.Part(child.id, this._GetName(child.id), local_path, mat);
                    this._parts.push(part);
                    let paths = local_path.split(",");
                    let n = paths.length - 1;
                    this._pathToPart[paths[n]] = String(child.id);
                    this._Readdsgz_find_bodies(part, child, local_path);
                } else if (child.nodetype === "view") {
                    // In DSG, "view" objects have "case" children
                    // This entity combines a camera view and a notion of timestep limits
                    // TODO: capture view information here (time and camera data)
                    let mat = GLTFViewer.Utils.Transformation.Identity;
                    let part = new GLTFViewer.Utils.FileSpaceClaim.Part(child.id, this._GetName(child.id), local_path, mat);
                    this._parts.push(part);
                    let paths = local_path.split(",");
                    let n = paths.length - 1;
                    this._pathToPart[paths[n]] = String(child.id);
                    this._Readdsgz_find_cases(child, local_path);
                }
            }
        }
    },
    _Readdsgz: {
        value: function (ReadCallback) {
            // create a DSG session if needed
            if (this._dsg_session === null) {
                this._dsg_session = new DSGSession();
                // this._dsg_session.debug = 2;
            }
            // reset session
            this._dsg_session.reset();
            // parse the zip data
            this._dsg_session.parse_zip(this._data);
            try {
                this._parts = [];
                this._bodies = [];
                this._bodiesTransparent = [];
                this._bodiesOpaque = [];
                this._pathToPart = {};
                this._sceneBox = GLTFViewer.Utils.Box.empty;

                // id to name mapping table (we use DSG ids) (_ReadDocumentXml)
                this._idToName = {};
                for(const key in this._dsg_session.nodemap) {
                    let name = this._dsg_session.nodemap[key].name;
                    if (this._dsg_session.nodemap[key].nodetype === "part") {
                        name = "Mesh";
                    }
                    this._idToName[key] = name;
                }
                this._idToName["root"] = "Scene";

                // Build the part object tree (_ReadRenderListXml)
                // There is a root object
                let mat = GLTFViewer.Utils.Transformation.Identity;
                let root = new GLTFViewer.Utils.FileSpaceClaim.Part("root", "Scene", "", mat);
                this._parts.push(root);
                this._pathToPart["ROOT"] = "root";

                // Walk the DSG tree, starting at the root, looking for cases
                let node = this._dsg_session.find_node_by_id(this._dsg_session.root_id);
                this._Readdsgz_find_cases(node, "");

                // bind the graphics bits
                this._BuildGraphics();
                this.UpdateWorldScale();

                // Update the UI elements
                this._BuildVisibilitySelector();

                // Build _bodiesNameToIndex
                for (let b = 0; b < this._bodies.length; b++) {
                    let body = this._bodies[b];
                    let name = body.GetName()
                    this._bodiesNameToIndex[name] = b;
                }

            } catch (err) {
                this.Reset();
                GLTFViewer.Utils.WriteErr(err);
                ReadCallback(false);
            }
            ReadCallback(true);
        }
    },
    _Readscdoc: {
        value: function (ReadCallback) {
            function callBack(xmlParser, Callback) {
                var data = unzip.entries['SpaceClaim/Graphics/facets.bin'];
                if (data) {
                    try {
                        var reader = new GLTFViewer.Utils.FileSpaceClaim.BinReader(data.buffer, data.byteOffset, data.byteLength);
                        this._ReadFacets(reader);
                        data = unzip.entries['SpaceClaim/document.xml'];
                        if (data && data !== "") {
                            this._ReadDocumentXml(xmlParser(data));
                            data = unzip.entries['SpaceClaim/Graphics/renderlist.xml'];
                            if (data && data !== "") {
                                this._ReadRenderListXml(xmlParser(data));
                                this._BuildVisibilitySelector();
                                // at this point can build _bodiesNameToIndex
                                for (var b = 0; b < this._bodies.length; b++) {
                                    var body = this._bodies[b];
                                    var name = body.GetName()
                                    this._bodiesNameToIndex[name] = b;
                                }
                                Callback(true);
                            } else {
                                GLTFViewer.Utils.WriteErr("ERROR(Readscdoc): No document found");
                                Callback(false);
                            }
                        } else {
                            GLTFViewer.Utils.WriteErr("ERROR(Readscdoc): No renderlist found");
                            Callback(false);
                        }
                    } catch (err) {
                        GLTFViewer.Utils.WriteErr(err);
                        Callback(false);
                    }
                } else {
                    GLTFViewer.Utils.WriteErr("ERROR(Readscdoc): No facets found");
                    Callback(false);
                }
            }

            var parseXML;
            if (typeof window.DOMParser != "undefined") {
                parseXML = function (xmlStr) {
                    return (new window.DOMParser()).parseFromString(xmlStr, "text/xml");
                };
            } else if (typeof window.ActiveXObject != "undefined" && new window.ActiveXObject("Microsoft.XMLDOM")) {
                parseXML = function (xmlStr) {
                    var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
                    xmlDoc.async = "false";
                    xmlDoc.loadXML(xmlStr);
                    return xmlDoc;
                };
            } else {
                GLTFViewer.Utils.WriteErr("ERROR(Readscdoc): No XML parser found");
                ReadCallback(false);
                return;
            }

            var unzip = new JSUnzip(this._data);
            if (unzip.isZipFile() == true) {
                try {
                    unzip.readEntries(callBack.bind(this, parseXML, ReadCallback));
                } catch (err) {
                    this.Reset();
                    GLTFViewer.Utils.WriteErr(err);
                    ReadCallback(false);
                }
            } else {
                GLTFViewer.Utils.WriteErr("ERROR(Readscdoc): Invalid file");
                ReadCallback(false);
            }
        }
    },
    // main render entry points
    _RenderFindClosest: {
        value: function (TVP, w, h, index, cursorRay) {
            if (this._bodiesOpaque.length === 0 && this._bodiesTransparent.length === 0)
                return false;
            var gl = this._gl;
            this._flatColor = true;
            var clip = this.ClipViewState === GLTFViewer.Utils.Clip.VIEWSTATE_PLANE;
            var shader = index ? (clip ? this._hitTestIndexClipShader : this._hitTestIndexShader) : (clip ? this._hitTestPositionClipShader : this._hitTestPositionShader);
            if (!shader.StartProgram())
                return false;
            gl.uniformMatrix4fv(shader.uTWd, false, GLTFViewer.Utils.glMtxIdentity);
            gl.uniformMatrix4fv(shader.uTVP, false, TVP);
            if (clip)
                gl.uniform4fv(shader.uCut, this._glClip);
            cursorRay.ToArray(this._glCursorRay);
            gl.uniform4fv(shader.uCry, this._glCursorRay);
            if (index)
                gl.uniform2f(shader.uSze, w / 2, h / 2);
            if (this._bodiesOpaque.length)
                this._RenderOpaqueBodies(gl, shader, false, this._bodiesOpaque);
            if (this._bodiesTransparent.length)
                this._RenderOpaqueBodies(gl, shader, false, this._bodiesTransparent);
            return true;
        }
    },
    _RenderBodiesClipCap: {
        value: function (TVP, eye, lighting, w, h) {
            var gl = this._gl;
            this._glClip = this._clip.glClip1;
            this._flatColor = true;
            var shader = this._flatClipShader;
            if (!shader.StartProgram())
                return;
            gl.uniformMatrix4fv(shader.uTWd, false, GLTFViewer.Utils.glMtxIdentity);
            gl.uniformMatrix4fv(shader.uTVP, false, TVP);
            gl.uniform4fv(shader.uCut, this._glClip);
            gl.enable(gl.POLYGON_OFFSET_FILL);
            gl.enable(gl.CULL_FACE);
            if (this._bodiesOpaque.length)
                this._RenderOpaqueBodies(gl, shader, true, this._bodiesOpaque);
            if (this._bodiesTransparent.length) {
                gl.enable(gl.BLEND);
                this._RenderOpaqueBodies(gl, shader, true, this._bodiesTransparent);
                gl.disable(gl.BLEND);
            }
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.POLYGON_OFFSET_FILL);
            this._glClip = this._clip.glClip0;
        }
    },
    _RenderBodies: {
        value: function (TVP, eye, lighting, w, h, peelPass, texture) {
            var gl = this._gl;
            var clip = this.ClipViewState === GLTFViewer.Utils.Clip.VIEWSTATE_PLANE;
            this._flatColor = false;
            var shader = (peelPass > 0) ? this._phongPeelShader : (clip ? this._phongClipShader : this._phongShader);
            if (!shader.StartProgram())
                return;
            if (peelPass > 0) {
                gl.uniform2f(shader.uSze, w, h);
                gl.uniform1i(shader.uPass, peelPass);

                if (peelPass > 1) {
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.uniform1i(shader.DepthTex, 0);
                }
            }
            var tClr = new GLTFViewer.Utils.RGBA(0, 255, 0, 255);
            GLTFViewer.Utils.HSV.TransformColor(tClr);
            var tMat = new GLTFViewer.Utils.Material(tClr);
            tMat.ToArray(this._uMtl, 0);
            gl.uniformMatrix4fv(shader.uTWd, false, GLTFViewer.Utils.glMtxIdentity);
            gl.uniformMatrix4fv(shader.uTVP, false, TVP);
            gl.uniform3fv(shader.uEye, eye);
            gl.uniformMatrix4fv(shader.uLit, false, lighting);
            gl.uniformMatrix4fv(shader.uMtl, false, this._uMtl);
            if (clip)
                gl.uniform4fv(shader.uCut, this._glClip);
            if (this._bodiesOpaque.length) {
                gl.enable(gl.POLYGON_OFFSET_FILL);
                gl.polygonOffset(.5, 0);
                this._RenderOpaqueBodies(gl, shader, false, this._bodiesOpaque);
                gl.polygonOffset(0, 0);
                gl.disable(gl.POLYGON_OFFSET_FILL);
            }
            if (this._bodiesTransparent.length) {
                if (peelPass < 0) {
                    gl.depthMask(false);
                    gl.enable(gl.BLEND);
                    this._RenderTransparentBodies(gl, shader, this._bodiesTransparent);
                    gl.disable(gl.BLEND);
                    gl.depthMask(true);
                } else {
                    gl.enable(gl.POLYGON_OFFSET_FILL);
                    gl.polygonOffset(.5, 0);
                    this._RenderOpaqueBodies(gl, shader, false, this._bodiesTransparent);
                    gl.polygonOffset(0, 0);
                    gl.disable(gl.POLYGON_OFFSET_FILL);
                }
            }
        }
    },
    _RenderOpaqueBodies: {
        value: function (gl, shader, wantCap, bodies) {
            var indx = -1;
            var part = null;
            this._bodyColor = 0;
            var buffers = this._gfx.faceBuffers;
            var vs = this._gfx.faceBuffersNumElements;
            var uTWd = new GLTFViewer.Utils.Transformation();
            var uTWdChanged = false;
            for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (!body || !body.IsVisible())
                    continue;
                if (part !== body.part) {
                    part = body.part;
                    uTWd.Set(part.tx);
                    uTWdChanged = true;
                }
                if (body.tx) {
                    uTWd.Multiply(body.tx);
                    uTWdChanged = true;
                    part = null;
                }
                if (uTWdChanged) {
                    uTWd.ToArray(this._uTWd);
                    gl.uniformMatrix4fv(shader.uTWd, false, this._uTWd);
                    uTWdChanged = false;
                }
                if (wantCap) {
                    if (body.typ === GLTFViewer.Utils.FileSpaceClaim.Body.Solid) {
                        gl.colorMask(false, false, false, false);
                        // set depth buffer to back face of bounding box
                        gl.polygonOffset(1, 0);
                        gl.depthFunc(gl.ALWAYS);
                        gl.cullFace(gl.FRONT);
                        body.RenderBox(gl, shader, this._gfx.boxBuffers);
                        gl.polygonOffset(0, 0);
                        // set depth buffer of front faces (this will stop cap from covering front faces)
                        gl.depthFunc(gl.LEQUAL);
                        gl.cullFace(gl.BACK);
                        indx = body.Render(gl, shader, this._bodyColor, buffers, vs, -1); // don't care what color is, so use current color
                        // now draw back faces in solid color
                        gl.cullFace(gl.FRONT);
                        gl.colorMask(true, true, true, true);
                        indx = body.Render(gl, shader, body.xcolr, buffers, vs, indx);
                    }
                } else
                    indx = body.Render(gl, shader, body.bcolr, buffers, vs, indx);
            }
        }
    },
    _RenderTransparentBodies: {
        value: function (gl, shader, bodies) {
            var indx = -1;
            var part = null;
            this._bodyColor = 0;
            var buffers = this._gfx.faceBuffers;
            var vs = this._gfx.faceBuffersNumElements;
            gl.enable(gl.CULL_FACE);
            var uTWd = new GLTFViewer.Utils.Transformation();
            var uTWdChanged = false;
            for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (!body || !body.IsVisible())
                    continue;
                if (part !== body.part) {
                    part = body.part;
                    uTWd.Set(part.tx);
                    uTWdChanged = true;
                }
                if (body.tx) {
                    uTWd.Multiply(body.tx);
                    uTWdChanged = true;
                    part = null;
                }
                if (uTWdChanged) {
                    uTWd.ToArray(this._uTWd);
                    gl.uniformMatrix4fv(shader.uTWd, false, this._uTWd);
                    uTWdChanged = false;
                }
                gl.cullFace(gl.FRONT);
                indx = body.Render(gl, shader, body.bcolr, buffers, vs, indx);
                gl.cullFace(gl.BACK);
                indx = body.Render(gl, shader, body.bcolr, buffers, vs, indx);
            }
            gl.disable(gl.CULL_FACE);
        }
    },
    _RenderEdges: {
        value: function (TVP, w, h, peelPass, texture) {
            var buffers = this._gfx.edgeBuffers;
            if (buffers === null)
                return;
            var gl = this._gl;
            var sizes = this._gfx.edgeBuffersNumElements;
            gl.depthMask(false);
            gl.enable(gl.BLEND);
            var clip = this.ClipViewState === GLTFViewer.Utils.Clip.VIEWSTATE_PLANE;
            this._flatColor = true;
            var shader = (peelPass > 0) ? this._flatPeelShader : (clip ? this._flatClipShader : this._flatShader);
            if (!shader.StartProgram())
                return;
            if (peelPass > 0) {
                gl.uniform2f(shader.uSze, w, h);
                gl.uniform1i(shader.uPass, peelPass);

                if (peelPass > 1) {
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.uniform1i(shader.DepthTex, 0);
                }
            }
            gl.uniformMatrix4fv(shader.uTWd, false, GLTFViewer.Utils.glMtxIdentity);
            gl.uniformMatrix4fv(shader.uTVP, false, TVP);
            if (clip)
                gl.uniform4fv(shader.uCut, this._glClip);
            var indx = -1;
            var part = null;
            var ecolr = 0;
            var uTWd = new GLTFViewer.Utils.Transformation();
            var uTWdChanged = false;
            for (var b = 0; b < this._bodies.length; b++) {
                var body = this._bodies[b];
                if (!body || !body.IsVisible())
                    continue;
                var bd = body.data;
                if (bd.edgeBufferNumIndices > 0) {
                    if (part !== body.part) {
                        part = body.part;
                        uTWd.Set(part.tx);
                        uTWdChanged = true;
                    }
                    if (body.tx) {
                        uTWd.Multiply(body.tx);
                        uTWdChanged = true;
                        part = null;
                    }
                    if (uTWdChanged) {
                        uTWd.ToArray(this._uTWd);
                        gl.uniformMatrix4fv(shader.uTWd, false, this._uTWd);
                        uTWdChanged = false;
                    }
                    if (indx != bd.edgeBufferIndex) {
                        indx = bd.edgeBufferIndex;
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffers[indx]);
                        gl.vertexAttribPointer(shader.aPos, 3, gl.FLOAT, false, 12, 0);
                    }
                    if (ecolr != body.ecolr) {
                        ecolr = body.ecolr;
                        GLTFViewer.Utils.FlatColor(ecolr, this._glColor);
                        gl.uniform4fv(shader.uClr, this._glColor);
                    }
                    indx = bd.RenderEdge(gl, shader, buffers, sizes, indx, bd.edgeBufferIndex, bd.edgeBufferOffset, bd.edgeBufferNumIndices);
                }
            }
            gl.depthMask(true);
            gl.disable(gl.BLEND);
        }
    },
    _RenderSelectionEdge: {
        value: function (TVP, targt, colr) {
            var gl = this._gl;
            var body = targt.body;
            var bd = body.data;
            var buffers = this._gfx.edgeBuffers;
            var sizes = this._gfx.edgeBuffersNumElements;
            this._flatColor = true;
            var clip = this.ClipViewState === GLTFViewer.Utils.Clip.VIEWSTATE_PLANE;
            var shader = clip ? this._flatClipShader : this._flatShader;
            if (!shader.StartProgram())
                return;
            gl.uniformMatrix4fv(shader.uTWd, false, GLTFViewer.Utils.glMtxIdentity);
            gl.uniformMatrix4fv(shader.uTVP, false, TVP);
            if (clip)
                gl.uniform4fv(shader.uCut, this._glClip);
            gl.disable(gl.DEPTH_TEST);
            gl.depthMask(false);
            gl.enable(gl.BLEND);
            colr.a = 100;
            colr.ToArray(this._glColor, 0);
            gl.uniform4fv(shader.uClr, this._glColor);
            var uTWd = body.part.tx.Clone();
            if (body.tx)
                uTWd.Multiply(body.tx);
            uTWd.ToArray(this._uTWd);
            gl.uniformMatrix4fv(shader.uTWd, false, this._uTWd);
            var ed = targt.itm;
            var indx = -1;
            for (var i = 0; i < 2; i++) {
                indx = bd.RenderEdge(gl, shader, buffers, sizes, indx, ed.edgeBufferIndex, ed.edgeBufferOffset, ed.edgeBufferNumIndices);
                colr.a = 200;
                colr.ToArray(this._glColor, 0);
                gl.uniform4fv(shader.uClr, this._glColor);
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LEQUAL);
            }
            gl.depthMask(true);
            gl.disable(gl.BLEND);
            gl.depthFunc(gl.LESS);
        }
    },
    _RenderSelectionFace: {
        value: function (TVP, targt, colr) {
            var gl = this._gl;
            var body = targt.body;
            var bd = body.data;
            var p = this._gfx.faceBuffers;
            var sizes = this._gfx.faceBuffersNumElements;
            this._flatColor = true;
            var clip = this.ClipViewState === GLTFViewer.Utils.Clip.VIEWSTATE_PLANE;
            var shader = clip ? this._flatClipShader : this._flatShader;
            if (!shader.StartProgram())
                return;
            gl.uniformMatrix4fv(shader.uTWd, false, GLTFViewer.Utils.glMtxIdentity);
            gl.uniformMatrix4fv(shader.uTVP, false, TVP);
            if (clip)
                gl.uniform4fv(shader.uCut, this._glClip);
            gl.disable(gl.DEPTH_TEST);
            gl.depthMask(false);
            gl.enable(gl.BLEND);
            colr.a = 64;
            colr.ToArray(this._glColor, 0);
            gl.uniform4fv(shader.uClr, this._glColor);
            var uTWd = body.part.tx.Clone();
            if (body.tx)
                uTWd.Multiply(body.tx);
            uTWd.ToArray(this._uTWd);
            gl.uniformMatrix4fv(shader.uTWd, false, this._uTWd);
            if (body.fil != GLTFViewer.Utils.Fill.Transparent) {
                gl.enable(gl.POLYGON_OFFSET_FILL);
                gl.polygonOffset(.5, 0);
            }
            var fd = targt.itm;
            var indx = -1;
            for (var i = 0; i < 2; i++) {
                indx = bd.Render(gl, shader, p, sizes, indx, fd.faceBufferIndex, fd.faceBufferOffset, fd.faceBufferNumIndices);
                colr.a = 128;
                colr.ToArray(this._glColor, 0);
                gl.uniform4fv(shader.uClr, this._glColor);
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LEQUAL);
            }
            if (body.fil != GLTFViewer.Utils.Fill.Transparent) {
                gl.polygonOffset(0, 0);
                gl.disable(gl.POLYGON_OFFSET_FILL);
            }
            gl.depthMask(true);
            gl.disable(gl.BLEND);
            gl.depthFunc(gl.LESS);
        }
    },
    _RenderSelectionBody: {
        value: function (TVP, target, colr) {
            var gl = this._gl;
            var body = target.body;
            var bd = body.data;
            var buffers = this._gfx.faceBuffers;
            var faceBuffersNumElements = this._gfx.faceBuffersNumElements;
            this._flatColor = true;
            var clip = this.ClipViewState === GLTFViewer.Utils.Clip.VIEWSTATE_PLANE;
            var shader = clip ? this._flatClipShader : this._flatShader;
            if (!shader.StartProgram())
                return;
            gl.uniformMatrix4fv(shader.uTWd, false, GLTFViewer.Utils.glMtxIdentity);
            gl.uniformMatrix4fv(shader.uTVP, false, TVP);
            if (clip)
                gl.uniform4fv(shader.uCut, this._glClip);
            gl.disable(gl.DEPTH_TEST);
            gl.depthMask(false);
            gl.enable(gl.BLEND);
            colr.a = 52;
            colr.ToArray(this._glColor, 0);
            gl.uniform4fv(shader.uClr, this._glColor);
            var uTWd = body.part.tx.Clone();
            if (body.tx)
                uTWd.Multiply(body.tx);
            uTWd.ToArray(this._uTWd);
            gl.uniformMatrix4fv(shader.uTWd, false, this._uTWd);
            if (body.fil != GLTFViewer.Utils.Fill.Transparent) {
                gl.enable(gl.POLYGON_OFFSET_FILL);
                gl.polygonOffset(.5, 0);
            }
            var indx = -1;
            for (var i = 0; i < 2; i++) {
                indx = bd.Render(gl, shader, buffers, faceBuffersNumElements, indx, bd.faceBufferIndex, bd.faceBufferOffset, bd.faceBufferNumIndices);
                colr.a = 105;
                colr.ToArray(this._glColor, 0);
                gl.uniform4fv(shader.uClr, this._glColor);
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LEQUAL);
            }
            if (body.fil != GLTFViewer.Utils.Fill.Transparent)
                gl.disable(gl.POLYGON_OFFSET_FILL);
            gl.depthMask(true);
            gl.disable(gl.BLEND);
            gl.depthFunc(gl.LESS);
        }
    },
    // public members
    hit: { writable: true, value: null },
    // public methods
    GetSceneBox: {
        value: function (dontExplode) {
            return this._sceneBox;
        }
    },
    GetClipPlane: {
        value: function () {
            var p = this.hit;
            var p0 = new GLTFViewer.Utils.Vec3();
            var p1 = new GLTFViewer.Utils.Vec3();
            var p2 = new GLTFViewer.Utils.Vec3();
            var v0 = new GLTFViewer.Utils.Vec3();
            var v1 = new GLTFViewer.Utils.Vec3();
            var part = p.targt.body.part;
            var fd = p.targt.itm;
            var n = p.indx;
            var k = fd.indices[n++] * 8;
            p0.x = fd.vertices[k++];
            p0.y = fd.vertices[k++];
            p0.z = fd.vertices[k++];
            k = fd.indices[n++] * 8;
            p1.x = fd.vertices[k++];
            p1.y = fd.vertices[k++];
            p1.z = fd.vertices[k++];
            k = fd.indices[n++] * 8;
            p2.x = fd.vertices[k++];
            p2.y = fd.vertices[k++];
            p2.z = fd.vertices[k++];
            v0.Set(p2.x - p0.x, p2.y - p0.y, p2.z - p0.z);
            v1.Set(p1.x - p0.x, p1.y - p0.y, p1.z - p0.z);
            v0.Cross(v1);
            v1 = v0.TransformCreate(part.tx.GetRotationTransformation());
            return new GLTFViewer.Utils.Plane(p.pnt, v1.GetDirection());
        }
    },
    RenderClipCap: {
        value: function (TVP, eye, lighting, w, h) {
            if (this._bodiesOpaque.length || this._bodiesTransparent.length) {
                this._RenderBodiesClipCap(TVP, eye, lighting, w, h);
            }
        }
    },
    Render3D: {
        value: function (TVP, eye, lighting, w, h, peelPass, texture) {
            if (this._bodiesOpaque.length || this._bodiesTransparent.length) {
                this._RenderBodies(TVP, eye, lighting, w, h, peelPass, texture);
                this._RenderEdges(TVP, w, h, peelPass, texture);
            }
        }
    },
    ResetHit: {
        value: function () {
            this.hit.Reset();
        }
    },
    AnyHit: {
        value: function () {
            return !this.hit.IsEmpty();
        }
    },
    HitPoint: {
        value: function () {
            return this.hit.pnt;
        }
    },
    CanSelect: {
        value: function () {
            return true;
        }
    },
    AnySelection: {
        value: function () {
            return this._selection && Object.keys(this._selection).length;
        }
    },
    UpdateSelection: {
        value: function (ctrlKey, altKey) {
            return false; // disable selection

            if (this._selectionMode === GLTFViewer.SELECTION_NONE)
                return false;
            var targt = this.hit.targt;
            var changed = false;
            if (!ctrlKey && targt.IsEmpty()) {
                if (this._selection) {
                    this._selection = null;
                    changed = true;
                }
            } else {
                if (!this._selection)
                    this._selection = {};

                if (!targt.IsEmpty()) {
                    var key = targt.Key();
                    var tmp = this._selection[key];
                    if (ctrlKey) {
                        if (tmp) {
                            delete this._selection[key];
                            return true;
                        }
                    } else if (!tmp)
                        this._selection = {};

                    if (!tmp) {
                        this._selection[key] = new GLTFViewer.Utils.FileSpaceClaim.HitTarget(targt);
                        changed = true;
                    }
                }
            }
            return changed;
        }
    },
    ResetSelection: {
        value: function () {
            var retVal = this.AnySelection();
            this._selection = null;
            return retVal;
        }
    },
    RenderSelection: {
        value: function (TVP, w, h) {
            if (!this.AnySelection() && !this.AnyHit())
                return;
            var gl = this._gl;
            var lw = 3;
            if (this._hasLineWidthSupport)
                gl.lineWidth(lw);
            if (this.AnySelection()) {
                var tClr = new GLTFViewer.Utils.RGBA(255, 100, 0, 255);
                for (key in this._selection) {
                    var targt = this._selection[key];
                    if (!targt.body.IsVisible()) {
                        continue;
                    }
                    if (targt.itm instanceof GLTFViewer.Utils.FileSpaceClaim.FaceData)
                        this._RenderSelectionFace(TVP, targt, tClr);
                    else if (targt.itm instanceof GLTFViewer.Utils.FileSpaceClaim.EdgeData)
                        this._RenderSelectionEdge(TVP, targt, tClr);
                    else
                        this._RenderSelectionBody(TVP, targt, tClr);
                }
            }
            if (this._selectionMode !== GLTFViewer.SELECTION_NONE && this.AnyHit()) {
                var tClr = new GLTFViewer.Utils.RGBA(255, 216, 0, 255);
                if (this.hit.targt.itm instanceof GLTFViewer.Utils.FileSpaceClaim.FaceData)
                    this._RenderSelectionFace(TVP, this.hit.targt, tClr);
                else if (this.hit.targt.itm instanceof GLTFViewer.Utils.FileSpaceClaim.EdgeData)
                    this._RenderSelectionEdge(TVP, this.hit.targt, tClr);
                else
                    this._RenderSelectionBody(TVP, this.hit.targt, tClr);
            }
            if (this._hasLineWidthSupport)
                gl.lineWidth(1);
            if (this.AnyHit()) {
                if (this.ClipViewState === GLTFViewer.Utils.Clip.VIEWSTATE_PREVIEW && this.ClipDrawMode === GLTFViewer.Utils.Clip.DRAWMODE_1_PT) {
                    var plane = this.GetClipPlane();
                    this._clip.RenderPreview(TVP, w, h, this.hit, plane);
                }
            }
        }
    },
    Reset: { // clear to just created state
        value: function () {
            this._bodyColor = 0;
            this._visTree = {};
            this._namedSelections = [];
            this._idToName = {};
            this._pathToPart = {};
            this._parts = [];
            this._bodies = [];
            this._bodiesOpaque = [];
            this._bodiesTransparent = [];
            this._bodiesData = {};
            this.hit.Reset();
            this._gfx.Reset();
            GLTFViewer.Utils.FileBaseClass.prototype.Reset.call(this);
        }
    },
    Clear: { // clear for deletion
        value: function () {
            GLTFViewer.Utils.FileSpaceClaim.prototype.Reset.call(this);
            var gl = this._gl;
            if (this._hitTestIndexShader !== null) {
                this._hitTestIndexShader.DeleteProgram();
                this._hitTestIndexShader = null;
            }
            if (this._hitTestIndexClipShader !== null) {
                this._hitTestIndexClipShader.DeleteProgram();
                this._hitTestIndexClipShader = null;
            }
            if (this._hitTestPositionShader !== null) {
                this._hitTestPositionShader.DeleteProgram();
                this._hitTestPositionShader = null;
            }
            if (this._hitTestPositionClipShader !== null) {
                this._hitTestPositionClipShader.DeleteProgram();
                this._hitTestPositionClipShader = null;
            }
            if (this._phongShader !== null) {
                this._phongShader.DeleteProgram();
                this._phongShader = null;
            }
            if (this._phongPeelShader !== null) {
                this._phongPeelShader.DeleteProgram();
                this._phongPeelShader = null;
            }
            if (this._phongClipShader !== null) {
                this._phongClipShader.DeleteProgram();
                this._phongClipShader = null;
            }
            if (this._flatShader !== null) {
                this._flatShader.DeleteProgram();
                this._flatShader = null;
            }
            if (this._flatPeelShader !== null) {
                this._flatPeelShader.DeleteProgram();
                this._flatPeelShader = null;
            }
            if (this._flatClipShader !== null) {
                this._flatClipShader.DeleteProgram();
                this._flatClipShader = null;
            }
            this._htp0 = null;
            this._htp1 = null;
            this._htp2 = null;
            this.hit.Clear();
            this.hit = null;
            this._glCursorRay = null;
            this._uTWd = null;
            this._clipPlaneBuf = null;
            this._tmpVtxDat = null;
            this._tmpVtxBuf = null;
            this._glColor = null;
            this._uMtl = null;
            this._glClip = null;
            this._sceneBox = null;
            GLTFViewer.Utils.FileBaseClass.prototype.Clear.call(this);
        }
    },
    ReadFile: {
        value: function (callback) {
            this.Reset();
            if (this._fileType === GLTFViewer.FT_SCDOC) {
                this._Readscdoc(callback);
            } else if (this._fileType === GLTFViewer.FT_DSGZ) {
                this._Readdsgz(callback);
            }
        }
    },
    GetTopParts: {
        value: function () {
            if (GLTFViewer.Utils.IsNull(this._visTree["root"].part))
                return this._visTree["root"].children;
            return { "0:0": this._visTree["root"] };
        }
    },
    GetBodies: {
        value: function () {
            return Object.keys(this._bodiesNameToIndex);
        }
    },
    SetHighlightBodyState: {
        value: function (name, on) {
            var index = this._bodiesNameToIndex[name];
            if (index == undefined) {
                return;
            }
            var body = this._bodies[index];
            if (!body) {
                return;
            }
            var key = body.Key();
            if (!on) {
                // turning highlight off
                if (this._selection) {
                    delete this._selection[key];
                }
            } else {
                // turning highlight on
                if (!this._selection) {
                    this._selection = {};
                }
                if (!this._selection[key]) {
                    var targt = new GLTFViewer.Utils.FileSpaceClaim.HitTarget();
                    targt.Set(body, null);
                    this._selection[key] = new GLTFViewer.Utils.FileSpaceClaim.HitTarget(targt);
                }
            }
        }
    },
    GetPartName: {
        value: function (node) {
            if (!node || !node.part)
                return null;
            return node.part.nme;
        }
    },
    GetPartParent: {
        value: function (node) {
            if (!node)
                return null;
            return node.parent;
        }
    },
    GetPartParts: {
        value: function (node) {
            if (!node)
                return null;
            return node.children;
        }
    },
    GetPartBodys: {
        value: function (node) {
            if (!node || !node.part)
                return null;
            return node.part.bodies;
        }
    },
    GetBodyName: {
        value: function (body) {
            if (!body)
                return null;
            return body.nme;
        }
    },
    GetRegions: {
        value: function () {
            return this._namedSelections;
        }
    },
    GetRegionName: {
        value: function (region) {
            return region;
        }
    },
    GetSelections: {
        value: function () {
            if (!this.AnySelection())
                return null;
            var selections = [];
            for (key in this._selection) {
                var targt = this._selection[key];
                var s = targt.Key(); // this.KeyToIds(targt.Key());
                if (!GLTFViewer.Utils.IsNull(s))
                    selections.push(s);
            }
            return selections;
        }
    },
    _GetChildParts: {
        value: function (parent, pathname, parts) {
            // name of the parent node
            let prefix = pathname + ":" + parent.part.nme;
            // children of parent node
            if (Object.keys(parent.children).length) {
                for( const node of Object.values(parent.children)) {
                    // Recurse "Group" node
                    this._GetChildParts(node, prefix, parts);
                }
            }
            // Add bodies
            for( const body of parent.part.bodies) {
                parts.push(prefix + ":" + body.nme);
            }
        }
    },
    GetParts: {
        value: function () {
            let parts = []
            if ("root" in this._visTree) {
                let pathname = this._visTree["root"].part.nme;
                for (const node of Object.values(this._visTree["root"].children)) {
                    // Child nodes
                    this._GetChildParts(node, pathname, parts);
                }
            }
            return parts;
        }
    },
    HitIndexTip: {
        value: function () {
            var targt = this.hit.targt;
            if (!targt.IsEmpty() && targt.body) {
                var tip = targt.body.GetName();
                if (targt.itm)
                    tip = tip + "~" + targt.itm.id;
                // Event: hover bubble callback
                const event = new CustomEvent('gltfviewer-spaceclaim-showhover', {bubbles: true, detail: {tip: tip} } );
                this._scene.container.dispatchEvent(event);
                return tip;
            }
            return null;
        }
    },
    BuildPickDetails: {
      value: function (part_name, pick_value) {
          if (part_name === null) return { name: '', path: '', type: 'SELECTION_NONE' };
          let details = { name: part_name.split(":").pop(), path: part_name, type: "SELECTION_NONE"};
          if (this._selectionMode === GLTFViewer.SELECTION_EDGE) {
                details.type = "SELECTION_EDGE";
                details.bounds = {max: [pick_value.itm.max, pick_value.itm.may, pick_value.itm.maz],
                                  min: [pick_value.itm.mix, pick_value.itm.miy, pick_value.itm.miz]};
                // Ok, the edge is specified by an offset into the faceData ranges array
                // That array is basically an [id, starting_offset, count]
                const edge_base = pick_value.itm.rangesIndex;
                const index_offset = pick_value.itm.faceData.edgeRanges[edge_base + 1];
                const num_verts = pick_value.itm.faceData.edgeRanges[edge_base + 2] * 2;
                let vertices = []
                for (let i = 0; i < num_verts; i++ ) {
                    let vertex_idx = pick_value.itm.faceData.edgeIndices[index_offset + i] * 8;
                    let point = new Float32Array(3);
                    point[0] = pick_value.itm.faceData.vertices[vertex_idx++];
                    point[1] = pick_value.itm.faceData.vertices[vertex_idx++];
                    point[2] = pick_value.itm.faceData.vertices[vertex_idx++];
                    vertices.push(point)
                }
                details.vertices = vertices;
          }
          else if (this._selectionMode === GLTFViewer.SELECTION_FACE) {
                details.type = "SELECTION_FACE";
                details.bounds = {max: [pick_value.itm.max, pick_value.itm.may, pick_value.itm.maz],
                                  min: [pick_value.itm.mix, pick_value.itm.miy, pick_value.itm.miz]};
                const num_verts = pick_value.itm.vertices.length / 8;
                let vertices = []
                for (let i = 0; i < num_verts; i++ ) {
                    let point = new Float32Array(3);
                    point[0] = pick_value.itm.vertices[i * 8];
                    point[1] = pick_value.itm.vertices[i * 8 + 1];
                    point[2] = pick_value.itm.vertices[i * 8 + 2];
                    vertices.push(point)
                }
                details.vertices = vertices;
          }
          else if (this._selectionMode === GLTFViewer.SELECTION_BODY) {
                details.type = "SELECTION_BODY";
                details.bounds = {max: [pick_value.body.data.max, pick_value.body.data.may, pick_value.body.data.maz],
                                  min: [pick_value.body.data.mix, pick_value.body.data.miy, pick_value.body.data.miz]};
                details.vertices = [];
          }
          return details;
      }
    },
    GetIndexSelection: {
        value: function () {
            var targt = this.hit.targt;
            if (!targt.IsEmpty() && targt.body) {
                var partName = targt.body.GetName();
                if (targt.itm) {
                    partName = partName + "~" + targt.itm.id;
                    if (this._selectionMode !== GLTFViewer.SELECTION_EDGE) {
                        var cf = this.GetClipPlane().orgn;
                        // Event: face point pick callback
                        const event = new CustomEvent('gltfviewer-spaceclaim-showfacepoint',
                            {bubbles: true, detail: {x: cf.x, y: cf.y, z: cf.z}});
                        this._scene.container.dispatchEvent(event);
                    }
                }
                // Event: picking callback (was part/face/edge separate functions)
                const face_event = new CustomEvent('gltfviewer-spaceclaim-pick',
                        { bubbles: true, detail: this.BuildPickDetails(partName, targt) } );
                this._scene.container.dispatchEvent(face_event);
                return partName;
            }
            // Event: picking callback
            const face_event = new CustomEvent('gltfviewer-spaceclaim-pick',
                    { bubbles: true, detail: this.BuildPickDetails(null, null) } );
            this._scene.container.dispatchEvent(face_event);
            return null;
        }
    },
    HitTestFindClosestPos: {
        value: function (b) {
            if (b) {
                this.hit.pnt.Set(b[1], b[2], b[3]);
                return this.HitPoint();
            }
            return null;
        }
    },
    KeyToIds: {
        value: function (key) {
            var pathPartItem = key.split(";");
            if (pathPartItem.length !== 3)
                return null; // has to be 3
            var paths = pathPartItem[0].split(",");
            var n = paths.length;
            var str = this._pathToPart["ROOT"];
            for (var i = 0; i < n; ++i) {
                if ((i === 0 && paths[i] !== "") || i)
                    str += "," + this._pathToPart[paths[i]];
            }
            str += "," + pathPartItem[1] + "," + pathPartItem[2];
            return str;
        }
    },
    HitTest: {
        value: function (TVP, w, h, tCursorRay, dontIncludeMarkup) {
            var navigator = this._navigator;
            var cursorRay = tCursorRay;
            var mi, ma;
            var part = null;
            var ori;
            var nor;
            var clip = false;
            var s = 0;
            if (this.ClipViewState === GLTFViewer.Utils.Clip.VIEWSTATE_PLANE) {
                clip = true;
                ori = this._clip.clipO;
                nor = this._clip.clipD;
            }
            // calculate hit radius
            var pnt1 = new GLTFViewer.Utils.Vec3();
            navigator.UnProject(pnt1);
            var pnt2 = new GLTFViewer.Utils.Vec3(3, 0, 0); // 3 pixels
            navigator.UnProject(pnt2);
            var hrs = GLTFViewer.Utils.Vec3.Create(pnt1, pnt2).GetMagnitudeSquared();
            var hr = Math.sqrt(hrs);

            function qr(dir, ray, hr, mix, miy, miz, max, may, maz) {
                if (dir.x > 0) {
                    mi = mix * dir.x;
                    ma = max * dir.x;
                } else {
                    ma = mix * dir.x;
                    mi = max * dir.x;
                }
                if (dir.y > 0) {
                    mi += miy * dir.y;
                    ma += may * dir.y;
                } else {
                    ma += miy * dir.y;
                    mi += may * dir.y;
                }
                if (dir.z > 0) {
                    mi += miz * dir.z;
                    ma += maz * dir.z;
                } else {
                    ma += miz * dir.z;
                    mi += maz * dir.z;
                }
                if (mi > ray + hr || ma < ray - hr)
                    return true;
                return false;
            }

            var faceBodyHit = null;
            var edgeBodyHit = null;
            var faceHit = null;
            var edgeHit = null;
            var faceHitIndex = 0;
            var edgeHitIndex = 0;
            var faceDist = GLTFViewer.Utils.maxValue;
            var edgeDist = GLTFViewer.Utils.maxValue;
            var p0 = new GLTFViewer.Utils.Vec3();
            var p1 = new GLTFViewer.Utils.Vec3();
            var p2 = new GLTFViewer.Utils.Vec3();
            var p = new GLTFViewer.Utils.Vec3();
            var facePnt = new GLTFViewer.Utils.Vec3();
            var edgePnt = new GLTFViewer.Utils.Vec3();
            var v0 = new GLTFViewer.Utils.Vec3();
            var v1 = new GLTFViewer.Utils.Vec3();
            var v2 = new GLTFViewer.Utils.Vec3();
            var k, vertices, indices;
            var d, dx, dy, dz;

            function inside(a) {
                var tVec = new GLTFViewer.Utils.Vec3(a.x - ori.x, a.y - ori.y, a.z - ori.z);
                var d = tVec.Dot(nor);
                return d >= 0;
            }

            function checkEndPoint(a, m) {
                v0.Set(a.x - ro.x, a.y - ro.y, a.z - ro.z);
                d = v0.x * rd.x + v0.y * rd.y + v0.z * rd.z;
                p.Set(ro.x + d * rd.x, ro.y + d * rd.y, ro.z + d * rd.z);
                dx = p.x - a.x;
                dy = p.y - a.y;
                dz = p.z - a.z;
                d = dx * dx + dy * dy + dz * dz;
                if (d < hrs) {
                    dx = a.x - ro.x;
                    dy = a.y - ro.y;
                    dz = a.z - ro.z;
                    d = dx * dx + dy * dy + dz * dz;
                    if (d < edgeDist && (!clip || inside(a))) {
                        edgeDist = d;
                        edgeBodyHit = body;
                        edgeHit = ed;
                        edgeHitIndex = m - 2;
                        edgePnt.Set(a.x, a.y, a.z);
                    }
                }
            }

            var cr0 = null;
            var ori0 = null;
            var nor0 = null;
            for (var i = this._bodies.length - 1; i >= 0; i--) {
                var body = this._bodies[i];
                if (!body || !body.IsVisible())
                    continue;
                var bd = body.data;
                if (part !== body.part) {
                    cr0 = null;
                    part = body.part;
                    cursorRay = tCursorRay.TransformCreate(part.ti);
                    if (clip) {
                        ori0 = null;
                        nor0 = null;
                        ori = this._clip.clipO.TransformCreate(part.ti);
                        nor = this._clip.clipD.TransformCreate(part.ti);
                    }
                } else if (cr0) {
                    cursorRay = cr0;
                    ori = ori0;
                    nor = nor0;
                }
                if (body.tx) {
                    cr0 = cursorRay;
                    cursorRay = cursorRay.TransformCreate(body.ti);
                    if (clip) {
                        ori0 = ori;
                        nor0 = nor;
                        ori = ori.TransformCreate(body.ti);
                        nor = nor.TransformCreate(body.ti);
                    }
                }
                if (qr(cursorRay.dix, cursorRay.rx, hr, bd.mix, bd.miy, bd.miz, bd.max, bd.may, bd.maz))
                    continue;
                if (qr(cursorRay.diy, cursorRay.ry, hr, bd.mix, bd.miy, bd.miz, bd.max, bd.may, bd.maz))
                    continue;
                var rd = cursorRay.ray.dir;
                var ro = cursorRay.ray.orgn;
                if (this._clip.clipDrawMode !== GLTFViewer.Utils.Clip.DRAWMODE_1_PT && this._selectionMode !== GLTFViewer.SELECTION_FACE) {
                    for (var edgeId in bd.edgeDatas) {
                        var ed = bd.edgeDatas[edgeId];
                        if (qr(cursorRay.dix, cursorRay.rx, hr, ed.mix, ed.miy, ed.miz, ed.max, ed.may, ed.maz))
                            continue;
                        if (qr(cursorRay.diy, cursorRay.ry, hr, ed.mix, ed.miy, ed.miz, ed.max, ed.may, ed.maz))
                            continue;
                        var fd = ed.faceData;
                        vertices = fd.vertices;
                        indices = fd.edgeIndices;
                        var ranges = fd.edgeRanges;
                        var m = ranges[ed.rangesIndex + 1];
                        var c = ranges[ed.rangesIndex + 2];
                        for (var l = 0; l < c; l++) {
                            k = indices[m++] * 8;
                            p0.x = vertices[k++];
                            p0.y = vertices[k++];
                            p0.z = vertices[k++];
                            k = indices[m++] * 8;
                            p1.x = vertices[k++];
                            p1.y = vertices[k++];
                            p1.z = vertices[k++];
                            checkEndPoint(p0, m);
                            checkEndPoint(p1, m);
                            v0.Set(p0.x - ro.x, p0.y - ro.y, p0.z - ro.z);
                            v1.Set(p1.x - p0.x, p1.y - p0.y, p1.z - p0.z);
                            var d0 = v1.x * v1.x + v1.y * v1.y + v1.z * v1.z;
                            var d1 = rd.x * v1.x + rd.y * v1.y + rd.z * v1.z;
                            var d2 = v0.x * v1.x + v0.y * v1.y + v0.z * v1.z;
                            d = d0 - d1 * d1;
                            if (d != 0) {
                                var d3 = v0.x * rd.x + v0.y * rd.y + v0.z * rd.z;
                                var a = (d3 * d1 - d2) / d;
                                var b = d3 + d1 * a;
                                if (a >= 0 && a <= 1) {
                                    p.Set(p0.x + a * v1.x, p0.y + a * v1.y, p0.z + a * v1.z);
                                    d0 = ro.x + b * rd.x - p.x;
                                    d1 = ro.y + b * rd.y - p.y;
                                    d2 = ro.z + b * rd.z - p.z;
                                    d = d0 * d0 + d1 * d1 + d2 * d2;
                                    if (d <= hrs) {
                                        dx = p.x - ro.x;
                                        dy = p.y - ro.y;
                                        dz = p.z - ro.z;
                                        d = dx * dx + dy * dy + dz * dz;
                                        if (d < edgeDist && (!clip || inside(p))) {
                                            edgeDist = d;
                                            edgeBodyHit = body;
                                            edgeHit = ed;
                                            edgeHitIndex = m - 2;
                                            edgePnt.Set(p.x, p.y, p.z);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (this._selectionMode !== GLTFViewer.SELECTION_EDGE) {
                    for (var faceId in bd.faceDatas) {
                        var fd = bd.faceDatas[faceId];
                        if (qr(cursorRay.dix, cursorRay.rx, hr, fd.mix, fd.miy, fd.miz, fd.max, fd.may, fd.maz))
                            continue;
                        if (qr(cursorRay.diy, cursorRay.ry, hr, fd.mix, fd.miy, fd.miz, fd.max, fd.may, fd.maz))
                            continue;
                        indices = fd.indices;
                        vertices = fd.vertices;
                        for (var n = 0; n < indices.length; ) {
                            k = indices[n++] * 8;
                            p0.x = vertices[k++];
                            p0.y = vertices[k++];
                            p0.z = vertices[k++];
                            k = indices[n++] * 8;
                            p1.x = vertices[k++];
                            p1.y = vertices[k++];
                            p1.z = vertices[k++];
                            k = indices[n++] * 8;
                            p2.x = vertices[k++];
                            p2.y = vertices[k++];
                            p2.z = vertices[k++];
                            v0.Set(p2.x - p0.x, p2.y - p0.y, p2.z - p0.z);
                            v1.Set(p1.x - p0.x, p1.y - p0.y, p1.z - p0.z);
                            v2.Set(v0.x, v0.y, v0.z);
                            v2.Cross(v1).Normalize();
                            var tPlane = new GLTFViewer.Utils.Plane(p0, new GLTFViewer.Utils.Direction(v2));
                            if (tPlane.GetPoint(cursorRay.ray, p)) {
                                v2.Set(p.x - p0.x, p.y - p0.y, p.z - p0.z);
                                var d00 = v0.Dot(v0);
                                var d01 = v0.Dot(v1);
                                var d02 = v0.Dot(v2);
                                var d11 = v1.Dot(v1);
                                var d12 = v1.Dot(v2);
                                d = (d00 * d11 - d01 * d01);
                                if (d != 0) {
                                    var u = (d11 * d02 - d01 * d12);
                                    var v = (d00 * d12 - d01 * d02);
                                    if (u >= 0 && v >= 0 && (u + v) < d) {
                                        dx = p.x - ro.x;
                                        dy = p.y - ro.y;
                                        dz = p.z - ro.z;
                                        d = dx * dx + dy * dy + dz * dz;
                                        if (d < faceDist && (!clip || inside(p))) {
                                            faceDist = d;
                                            faceBodyHit = body;
                                            faceHit = fd;
                                            faceHitIndex = n - 3;
                                            facePnt.Set(p.x, p.y, p.z);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (edgeHit !== null || faceHit !== null) {
                var body;
                var itm;
                var indx;
                if (edgeHit === null) {
                    body = faceBodyHit;
                    itm = faceHit;
                    indx = faceHitIndex;
                    p = facePnt;
                } else if (faceHit === null || edgeDist <= faceDist) {
                    body = edgeBodyHit;
                    itm = edgeHit;
                    indx = edgeHitIndex;
                    p = edgePnt;
                } else {
                    dx = facePnt.x - edgePnt.x;
                    dy = facePnt.y - edgePnt.y;
                    dz = facePnt.z - edgePnt.z;
                    d = dx * dx + dy * dy + dz * dz;
                    if (d < hrs) {
                        body = edgeBodyHit;
                        itm = edgeHit;
                        indx = edgeHitIndex;
                        p = edgePnt;
                    } else {
                        body = faceBodyHit;
                        itm = faceHit;
                        indx = faceHitIndex;
                        p = facePnt;
                    }
                }
                p.Transform(body.part.tx);
                if (body.tx)
                    p.Transform(body.tx);
                return this.hit.Set(body, (this._selectionMode === GLTFViewer.SELECTION_NONE || this._selectionMode === GLTFViewer.SELECTION_BODY) ? null : itm, indx, p.x, p.y, p.z);
            }
            else {
                // Event: hover bubble (empty) callback
                const event = new CustomEvent('gltfviewer-spaceclaim-showhover', {bubbles: true, detail: {tip: ''} } );
                this._scene.container.dispatchEvent(event);
            }
            return this.hit.Reset();
        }
    }
});
///////////////////////////////////////
// Static data
Object.defineProperties(GLTFViewer.Utils.FileSpaceClaim, {
    // private members
    _vsHitTest: {
        value: "uniform mat4 uTWd;\n" +
               "uniform mat4 uTVP;\n" +
               "attribute vec3 aPos;\n" +
               "attribute vec2 aFid;\n" +
               "varying vec3 vPos;\n" +
               "varying vec2 vFid;\n" +
               "void main() {\n" +
                   "vec4 pos = uTVP * uTWd * vec4(aPos, 1.0);\n" +
                   "vPos = pos.xyz / pos.w;\n" +
                   "vFid = aFid;\n" +
                   "gl_Position = pos;\n" +
               "}"
    },
    _fsHitTest: {
        value: "uniform vec4 uCry[2];\n" +
               "uniform vec2 uSze;\n" +
               "varying vec3 vPos;\n" +
               "varying vec2 vFid;\n" +
               "void main() {\n" +
                    "vec2 xy = floor((1.0 + vec2(vPos.x, -vPos.y)) * uSze + .5);\n" +
                    "float w = length(vec2(uCry[0].w, uCry[1].w) - xy);\n" +
                    "if (w >= 3.0) discard;\n" +
                    "gl_FragColor = vec4(-(w + 1.0), vFid, 0.0);\n" + // 0 -> no object, [-1 to -4) means object
               "}"
    },
    _vsHitTestClip: {
        value: "uniform mat4 uTWd;\n" +
               "uniform mat4 uTVP;\n" +
               "attribute vec3 aPos;\n" +
               "attribute vec2 aFid;\n" +
               "varying vec3 vPos;\n" +
               "varying vec4 vPos2;\n" +
               "varying vec2 vFid;\n" +
               "void main() {\n" +
                   "vPos2 = uTWd * vec4(aPos, 1.0);\n" +
                   "vec4 pos = uTVP * vPos2;\n" +
                   "vPos = pos.xyz / pos.w;\n" +
                   "vFid = aFid;\n" +
                   "gl_Position = pos;\n" +
               "}"
    },
    _fsHitTestClip: {
        value: "uniform vec4 uCry[2];\n" +
               "uniform vec2 uSze;\n" +
               "uniform vec4 uCut;\n" +
               "varying vec3 vPos;\n" +
               "varying vec2 vFid;\n" +
               "varying vec4 vPos2;\n" +
               "void main() {\n" +
                    "if(dot(vPos2, uCut) < 0.0) discard;\n" +
                    "vec2 xy = floor((1.0 + vec2(vPos.x, -vPos.y)) * uSze + .5);\n" +
                    "float w = length(vec2(uCry[0].w, uCry[1].w) - xy);\n" +
                    "if (w >= 3.0) discard;\n" +
                    "gl_FragColor = vec4(-(w + 1.0), vFid, 0.0);\n" + // 0 -> no object, [-1 to -4) means object
               "}"
    },
    _vsHitTestPos: {
        value: "uniform mat4 uTWd;\n" +
               "uniform mat4 uTVP;\n" +
               "attribute vec3 aPos;\n" +
               "varying vec3 vPos;\n" +
               "void main() {\n" +
                   "vec4 pos = uTWd * vec4(aPos, 1.0);\n" +
                   "vPos = pos.xyz / pos.w;\n" +
                   "gl_Position = uTVP * pos;\n" +
               "}"
    },
    _fsHitTestPos: {
        value: "uniform vec4 uCry[2];\n" +
               "varying vec3 vPos;\n" +
               "void main() {\n" +
                   "float d = length(cross(uCry[1].xyz, vPos - uCry[0].xyz));\n" +
                   "gl_FragColor = vec4(-(d + 1.0), vPos);\n" +
               "}"
    },
    _vsHitTestPosClip: {
        value: "uniform mat4 uTWd;\n" +
               "uniform mat4 uTVP;\n" +
               "attribute vec3 aPos;\n" +
               "varying vec3 vPos;\n" +
               "varying vec4 vPos2;\n" +
               "varying vec2 vFid;\n" +
               "void main() {\n" +
                   "vPos2 = uTWd * vec4(aPos, 1.0);\n" +
                   "vPos = vPos2.xyz / vPos2.w;\n" +
                   "gl_Position = uTVP * vPos2;\n" +
               "}"
    },
    _fsHitTestPosClip: {
        value: "uniform vec4 uCry[2];\n" +
               "uniform vec4 uCut;\n" +
               "varying vec3 vPos;\n" +
               "varying vec4 vPos2;\n" +
               "void main() {\n" +
                   "if(dot(vPos2, uCut) < 0.0) discard;\n" +
                   "float d = length(cross(uCry[1].xyz, vPos - uCry[0].xyz));\n" +
                   "gl_FragColor = vec4(-(d + 1.0), vPos);\n" +
               "}"
    },
    _vsPhong: { 
        value: "uniform mat4 uTWd;\n" +
               "uniform mat4 uTVP;\n" +
               "uniform vec3 uEye;\n" +
               "attribute vec3 aPos;\n" +
               "attribute vec3 aNor;\n" +
               "varying vec3 vNor;\n" +
               "varying vec3 vDir;\n" +
               "varying vec4 vPos;\n" +
               "void main() {\n" +
                   "vec4 pos = uTWd * vec4(aPos, 1.0);\n" +
                   "vNor = (uTWd * vec4(aNor, 0.0)).xyz;\n" +
                   "vDir = normalize(pos.xyz - uEye);\n" +
                   "gl_Position = uTVP * pos;\n" +
               "}"
    },
    _fsPhong: {
        value: "uniform mat4 uLit[2];\n" +
               "uniform mat4 uMtl;\n" +
               "varying vec3 vNor;\n" +
               "varying vec3 vDir;\n" +
               "void main() {\n" +
                   "vec3 rgb = vec3(0);\n" +
                   "vec3 nor = normalize(vNor);\n" +
                   "nor *= -sign(dot(vDir, nor));\n" +
                   "vec3 r = reflect(uLit[0][3].xyz, nor);\n" +
                   "float s = pow(max(dot(r, vDir), 0.0), uMtl[3].x);\n" +
                   "float d = max(dot(uLit[0][3].xyz, nor), 0.0);\n" +
                   "vec3 sp = s * uMtl[2].rgb * uLit[0][2].rgb;\n" +
                   "vec3 di = d * uMtl[1].rgb * uLit[0][1].rgb;\n" +
                   "vec3 am = uMtl[0].rgb * uLit[0][0].rgb;\n" +
                   "rgb = am + di + sp;\n" +
                   "r = reflect(uLit[1][3].xyz, nor);\n" +
                   "s = pow(max(dot(r, vDir), 0.0), uMtl[3].x);\n" +
                   "d = max(dot(uLit[1][3].xyz, nor), 0.0);\n" +
                   "sp = s * uMtl[2].rgb * uLit[1][2].rgb;\n" +
                   "di = d * uMtl[1].rgb * uLit[1][1].rgb;\n" +
                   "am = uMtl[0].rgb * uLit[1][0].rgb;\n" +
                   "rgb = rgb + am + di + sp;\n" +
                   "gl_FragColor = vec4(rgb, uMtl[1].a);\n" +
               "}"
    },
    _fsPhongPeel: {
        value: "uniform mat4 uLit[2];\n" +
               "uniform mat4 uMtl;\n" +
               "varying vec3 vNor;\n" +
               "varying vec3 vDir;\n" +
               "uniform vec2 uSze;\n" +
               "uniform int uPass;\n" +
               "const float fAcc = 0.00001;\n" +
               "uniform sampler2D DepthTex;\n" +
               "void main() {\n" +
                   "vec3 rgb = vec3(0);\n" +
                   "vec3 nor = normalize(vNor);\n" +
                   "nor *= -sign(dot(vDir, nor));\n" +
                   "vec3 r = reflect(uLit[0][3].xyz, nor);\n" +
                   "float s = pow(max(dot(r, vDir), 0.0), uMtl[3].x);\n" +
                   "float d = max(dot(uLit[0][3].xyz, nor), 0.0);\n" +
                   "vec3 sp = s * uMtl[2].rgb * uLit[0][2].rgb;\n" +
                   "vec3 di = d * uMtl[1].rgb * uLit[0][1].rgb;\n" +
                   "vec3 am = uMtl[0].rgb * uLit[0][0].rgb;\n" +
                   "rgb = am + di + sp;\n" +
                   "r = reflect(uLit[1][3].xyz, nor);\n" +
                   "s = pow(max(dot(r, vDir), 0.0), uMtl[3].x);\n" +
                   "d = max(dot(uLit[1][3].xyz, nor), 0.0);\n" +
                   "sp = s * uMtl[2].rgb * uLit[1][2].rgb;\n" +
                   "di = d * uMtl[1].rgb * uLit[1][1].rgb;\n" +
                   "am = uMtl[0].rgb * uLit[1][0].rgb;\n" +
                   "rgb = rgb + am + di + sp;\n" +
                   "gl_FragColor = vec4(rgb, uMtl[1].a);\n" +

                   "\nif (uPass == 1) {\n" +
                   "gl_FragColor.r = gl_FragCoord.z;\n" +
                   "} else if (uPass == 2) {\n" +
                   "float d = texture2D(DepthTex, gl_FragCoord.xy / uSze).r;\n" +
                   "if (d == 0.0 || abs(d - gl_FragCoord.z) > fAcc) discard;\n" +
                   "} else if (uPass == 3) {\n" +
                   "float d = texture2D(DepthTex, gl_FragCoord.xy / uSze).r;\n" +
                   "if (d == 0.0 || d - gl_FragCoord.z >= -fAcc) discard;\n" +
                   "gl_FragColor.r = gl_FragCoord.z;\n" +
                   "}\n" +
               "}"
    },
    _vsPhongClip: { 
        value: "uniform mat4 uTWd;\n" +
               "uniform mat4 uTVP;\n" +
               "uniform vec3 uEye;\n" +
               "attribute vec3 aPos;\n" +
               "attribute vec3 aNor;\n" +
               "varying vec3 vNor;\n" +
               "varying vec3 vDir;\n" +
               "varying vec4 vPos;\n" +
               "void main() {\n" +
                   "vPos = uTWd * vec4(aPos, 1.0);\n" +
                   "vNor = (uTWd * vec4(aNor, 0.0)).xyz;\n" +
                   "vDir = normalize(vPos.xyz - uEye);\n" +
                   "gl_Position = uTVP * vPos;\n" +
               "}"
    },
    _fsPhongClip: {
        value: "uniform mat4 uLit[2];\n" +
               "uniform mat4 uMtl;\n" +
               "uniform vec4 uCut;\n" +
               "varying vec3 vNor;\n" +
               "varying vec3 vDir;\n" +
               "varying vec4 vPos;\n" +
               "void main() {\n" +
                   "if(dot(vPos, uCut) < 0.0) discard;\n" +
                   "vec3 rgb = vec3(0);\n" +
                   "vec3 nor = normalize(vNor);\n" +
                   "nor *= -sign(dot(vDir, nor));\n" +
                   "vec3 r = reflect(uLit[0][3].xyz, nor);\n" +
                   "float s = pow(max(dot(r, vDir), 0.0), uMtl[3].x);\n" +
                   "float d = max(dot(uLit[0][3].xyz, nor), 0.0);\n" +
                   "vec3 sp = s * uMtl[2].rgb * uLit[0][2].rgb;\n" +
                   "vec3 di = d * uMtl[1].rgb * uLit[0][1].rgb;\n" +
                   "vec3 am = uMtl[0].rgb * uLit[0][0].rgb;\n" +
                   "rgb = am + di + sp;\n" +
                   "r = reflect(uLit[1][3].xyz, nor);\n" +
                   "s = pow(max(dot(r, vDir), 0.0), uMtl[3].x);\n" +
                   "d = max(dot(uLit[1][3].xyz, nor), 0.0);\n" +
                   "sp = s * uMtl[2].rgb * uLit[1][2].rgb;\n" +
                   "di = d * uMtl[1].rgb * uLit[1][1].rgb;\n" +
                   "am = uMtl[0].rgb * uLit[1][0].rgb;\n" +
                   "rgb = rgb + am + di + sp;\n" +
                   "gl_FragColor = vec4(rgb, uMtl[1].a);\n" +
               "}"
    },
    _vsFlat: {
        value: "uniform mat4 uTWd;\n" +
               "uniform mat4 uTVP;\n" +
               "attribute vec3 aPos;\n" +
               "void main() {\n" +
                   "gl_Position = uTVP * uTWd * vec4(aPos, 1.0);\n" +
               "}"
    },
    _fsFlat: {
        value: "uniform vec4 uClr;\n" +
               "void main() {\n" +
                   "gl_FragColor = uClr;\n" +
               "}"
    },
    _fsFlatPeel: {
        value: "uniform vec4 uClr;\n" +
               "uniform vec2 uSze;\n" +
               "uniform int uPass;\n" +
               "const float fAcc = 0.00001;\n" +
               "uniform sampler2D DepthTex;\n" +
               "void main() {\n" +
                   "gl_FragColor = uClr;\n" +

                   "\nif (uPass == 1) {\n" +
                   "gl_FragColor.r = gl_FragCoord.z;\n" +
                   "} else if (uPass == 2) {\n" +
                   "float d = texture2D(DepthTex, gl_FragCoord.xy / uSze).r;\n" + 
                   "if (d == 0.0 || abs(d - gl_FragCoord.z) > fAcc) discard;\n" +
                   "} else if (uPass == 3) {\n" +
                   "float d = texture2D(DepthTex, gl_FragCoord.xy / uSze).r;\n" + 
                   "if (d == 0.0 || d - gl_FragCoord.z >= -fAcc) discard;\n" +
                   "gl_FragColor.r = gl_FragCoord.z;\n" +
                   "}\n" +
               "}"
    },
    _vsFlatClip: {
        value: "uniform mat4 uTWd;\n" +
               "uniform mat4 uTVP;\n" +
               "attribute vec3 aPos;\n" +
               "varying vec4 vPos;\n" +
               "void main() {\n" +
                   "vPos = uTWd * vec4(aPos, 1.0);\n" +
                   "gl_Position = uTVP * vPos;\n" +
               "}"
    },
    _fsFlatClip: {
        value: "uniform vec4 uClr;\n" +
               "uniform vec4 uCut;\n" +
               "varying vec4 vPos;\n" +
               "void main() {\n" +
                   "if(dot(vPos, uCut) < 0.0) discard;\n" +
                   "gl_FragColor = uClr;\n" +
               "}"
    }
    // public methods
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileSpaceClaim.Graphics = function (gl) {
    this._gl = gl;
};
GLTFViewer.Utils.FileSpaceClaim.Graphics.prototype = Object.create(null, {
    // private members
    _gl: { writable: true, value: null },
    // public members
    boxBuffers: { writable: true, value: null },
    faceBuffers: { writable: true, value: null },
    faceBuffersNumElements: { writable: true, value: null },
    edgeBuffers: { writable: true, value: null },
    edgeBuffersNumElements: { writable: true, value: null },
    Reset: {
        value: function () { // clear to just created state
            function deletebuffers(gl, b) {
                for (var i = b.length - 1; i >= 0; --i)
                    gl.deleteBuffer(b[i]);
            }
            if (this.boxBuffers) {
                deletebuffers(this._gl, this.boxBuffers);
                this.boxBuffers = null;
            }
            if (this.faceBuffers) {
                deletebuffers(this._gl, this.faceBuffers);
                this.faceBuffers = null;
            }
            this.faceBuffersNumElements = null;
            if (this.edgeBuffers) {
                deletebuffers(this._gl, this.edgeBuffers);
                this.edgeBuffers = null;
            }
            this.edgeBuffersNumElements = null;
        }
    },
    Clear: {
        value: function () { // clear for deletion
            GLTFViewer.Utils.FileSpaceClaim.Graphics.prototype.Reset.call(this);
            this._gl = null;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileSpaceClaim.FaceData = function (id, mix, miy, miz, max, may, maz, vertices, indices, edgeIndices, edgeRanges) {
    this.id = id;
    this.mix = mix;
    this.miy = miy;
    this.miz = miz;
    this.max = max;
    this.may = may;
    this.maz = maz;
    this.vertices = vertices;
    this.indices = indices;
    this.edgeIndices = edgeIndices;
    this.edgeRanges = edgeRanges;
};
GLTFViewer.Utils.FileSpaceClaim.FaceData.prototype = Object.create(null, {
    id: { writable: true, value: null },
    mix: { writable: true, value: 0 },
    miy: { writable: true, value: 0 },
    miz: { writable: true, value: 0 },
    max: { writable: true, value: 0 },
    may: { writable: true, value: 0 },
    maz: { writable: true, value: 0 },
    faceBufferIndex: { writable: true, value: 0 },
    faceBufferOffset: { writable: true, value: 0 },
    faceBufferNumIndices: { writable: true, value: 0 },
    edgeBufferIndex: { writable: true, value: 0 },
    edgeBufferOffset: { writable: true, value: 0 },
    edgeBufferNumIndices: { writable: true, value: 0 },
    vertices: { writable: true, value: null },
    faceIndices: { writable: true, value: null },
    edgeIndices: { writable: true, value: null },
    edgeRanges: { writable: true, value: null }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileSpaceClaim.EdgeData = function (id, faceData, i) {
    this.id = id;
    this.faceData = faceData;
    this.rangesIndex = i;
};
GLTFViewer.Utils.FileSpaceClaim.EdgeData.prototype = Object.create(null, {
    id: { writable: true, value: null },
    faceData: { writable: true, value: null },
    rangesIndex: { writable: true, value: 0 },
    mix: { writable: true, value: 0 },
    miy: { writable: true, value: 0 },
    miz: { writable: true, value: 0 },
    max: { writable: true, value: 0 },
    may: { writable: true, value: 0 },
    maz: { writable: true, value: 0 },
    edgeBufferIndex: { writable: true, value: 0 },
    edgeBufferOffset: { writable: true, value: 0 },
    edgeBufferNumIndices: { writable: true, value: 0 }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileSpaceClaim.BodyData = function (handler, id) {
    this._handler = handler;
    this.id = id;
};
GLTFViewer.Utils.FileSpaceClaim.BodyData.prototype = Object.create(null, {
    // private members
    _handler: { writable: true, value: null },
    // public members
    id: { writable: true, value: null },
    mix: { writable: true, value: 0 },
    miy: { writable: true, value: 0 },
    miz: { writable: true, value: 0 },
    max: { writable: true, value: 0 },
    may: { writable: true, value: 0 },
    maz: { writable: true, value: 0 },
    boxIndex: { writable: true, value: 0 },
    boxOffset: { writable: true, value: 0 },
    faceBufferIndex: { writable: true, value: 0 },
    faceBufferOffset: { writable: true, value: 0 },
    faceBufferNumIndices: { writable: true, value: 0 },
    edgeBufferIndex: { writable: true, value: 0 },
    edgeBufferOffset: { writable: true, value: 0 },
    edgeBufferNumIndices: { writable: true, value: 0 },
    faceDatas: { writable: true, value: null },
    edgeDatas: { writable: true, value: null },
    Render: {
        value: function (gl, shader, buffers, vs, bufferIndex, faceBufferIndex, faceBufferOffset, faceBufferNumIndices) {
            if (bufferIndex !== faceBufferIndex) {
                bufferIndex = faceBufferIndex;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers[bufferIndex]);
                gl.vertexAttribPointer(shader.aPos, 3, gl.FLOAT, false, 32, 0);
                if (shader.aNor !== undefined)
                    gl.vertexAttribPointer(shader.aNor, 3, gl.FLOAT, false, 32, 12);
                if (shader.aFid !== undefined)
                    gl.vertexAttribPointer(shader.aFid, 2, gl.FLOAT, false, 32, 24);
            }

            var t = faceBufferNumIndices;
            var start = faceBufferOffset;
            while (true) {
                var c = vs[bufferIndex] - start;
                if (c >= t) {
                    gl.drawArrays(gl.TRIANGLES, start, t);
                    break;
                } else {
                    gl.drawArrays(gl.TRIANGLES, start, c);
                    start = 0; t -= c;
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers[++bufferIndex]);
                    gl.vertexAttribPointer(shader.aPos, 3, gl.FLOAT, false, 32, 0);
                    if (shader.aNor !== undefined)
                        gl.vertexAttribPointer(shader.aNor, 3, gl.FLOAT, false, 32, 12);
                    if (shader.aFid !== undefined)
                        gl.vertexAttribPointer(shader.aFid, 2, gl.FLOAT, false, 32, 24);
                }
            }
            return bufferIndex;
        }
    },
    RenderBox: {
        value: function (gl, shader, buffer, offset) {
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(shader.aPos, 3, gl.FLOAT, false, 12, 0);
            gl.drawArrays(gl.TRIANGLES, offset, 36);
        }
    },
    RenderEdge: {
        value: function (gl, shader, buffers, sizes, bufferIndex, edgeBufferIndex, edgeBufferOffset, edgeBufferNumIndices) {
            if (bufferIndex !== edgeBufferIndex) {
                bufferIndex = edgeBufferIndex;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers[bufferIndex]);
                gl.vertexAttribPointer(shader.aPos, 3, gl.FLOAT, false, 12, 0);
            }
            var numIndices = edgeBufferNumIndices;
            var offset = edgeBufferOffset;
            while (true) {
                var cnt = sizes[bufferIndex] - offset;
                if (cnt >= numIndices) {
                    gl.drawArrays(gl.LINES, offset, numIndices);
                    break;
                } else {
                    gl.drawArrays(gl.LINES, offset, cnt);
                    offset = 0; numIndices -= cnt;
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers[++bufferIndex]);
                    gl.vertexAttribPointer(shader.aPos, 3, gl.FLOAT, false, 12, 0);
                }
            }
            return bufferIndex;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileSpaceClaim.Body = function (handler, id, nme, part, data, visibl, bcolr, ecolr, xcolr, fil, typ, trans) {
    this._handler = handler;
    this.id = id;
    this.nme = nme;
    this.part = part;
    this.data = data;
    this.visibl = visibl;
    this.bcolr = bcolr;
    this.ecolr = ecolr;
    this.xcolr = xcolr;
    this.fil = fil;
    this.typ = typ;
    if (trans) {
        this.tx = trans;
        this.ti = trans.Clone().Invert();
    }
};
GLTFViewer.Utils.FileSpaceClaim.Body.prototype = Object.create(null, {
    // private members
    _handler: { writable: true, value: null },
    // public members
    id: { writable: true, value: null },
    nme: { writable: true, value: null },
    part: { writable: true, value: null },
    data: { writable: true, value: null },
    visibl: { writable: true, value: 0 },
    bcolr: { writable: true, value: 0 }, // body color
    ecolr: { writable: true, value: 0 }, // edge color
    xcolr: { writable: true, value: 0 }, // xcut color
    fil: { writable: true, value: 0 },
    typ: { writable: true, value: 0 },
    tx: { writable: true, value: null },
    ti: { writable: true, value: null },
    IsVisible: {
        value: function () {
            return /* (this.part ? this.part.IsVisible() : 1) && */this.visibl;
        }
    },
    GetName: {
        value: function () {
            return (this.part ? (this.part.GetName() + ":") : "") + this.nme;
        }
    },
    Key: {
        value: function () {
            return this.part.path + ';' + this.id;
        }
    },
    Render: {
        value: function (gl, shader, colr, buffers, vs, i) {
            if (!this.IsVisible())
                return -1;
            var handler = this._handler;
            if (handler._bodyColor !== colr) {
                handler._bodyColor = colr;
                if (this._handler._flatColor) {
                    var tmpColor = new Float32Array(4);
                    GLTFViewer.Utils.FlatColor(colr, tmpColor);
                    gl.uniform4fv(shader.uClr, tmpColor);
                } else {
                    var tClr = new GLTFViewer.Utils.RGBA();
                    tClr.SetRawARGB(colr);
                    var tMat = new GLTFViewer.Utils.Material(tClr);
                    tMat.ToArray(handler._uMtl, 0);
                    gl.uniformMatrix4fv(shader.uMtl, false, handler._uMtl);
                }
            }
            return this.data.Render(gl, shader, buffers, vs, i, this.data.faceBufferIndex, this.data.faceBufferOffset, this.data.faceBufferNumIndices);
        }
    },
    RenderBox: {
        value: function (gl, shader, buffers) {
            if (this.IsVisible())
                this.data.RenderBox(gl, shader, buffers[this.data.boxIndex], this.data.boxOffset);
        }
    }
});
Object.defineProperties(GLTFViewer.Utils.FileSpaceClaim.Body, {
    Solid: { value: 0 },
    OpenForm: { value: 1 }
});
///////////////////////////////////////
// really Item in scdoc file
/** @constructor */
GLTFViewer.Utils.FileSpaceClaim.Part = function (id, nme, path, trans) {
    this.id = id;
    this.path = path;
    this.nme = nme;
    this.bodies = [];
    this.tx = trans;
    this.ti = trans.Clone().Invert();
};
GLTFViewer.Utils.FileSpaceClaim.Part.prototype = Object.create(null, {
    id: { writable: true, value: null },
    path: { writable: true, value: null },
    nme: { writable: true, value: null }, //name
    parentPart: { writable: true, value: null }, // parent
    tx: { writable: true, value: null },  //trans
    ti: { writable: true, value: null },  //trans inv
    bodies: { writable: true, value: null },
    GetName: {
        value: function () {
            return (this.parentPart ? (this.parentPart.GetName() + ":") : "") + this.nme;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileSpaceClaim.BinReader = function (buffer, offst, size) {
    this.dataView = new DataView(buffer, offst, size);
    this.pos = 0;
};
GLTFViewer.Utils.FileSpaceClaim.BinReader.prototype = Object.create(null, {
    dataView: { writable: true, value: null },
    pos: { writable: true, value: 0 },
    readInt8: {
        value: function () {
            var r = this.dataView.getInt8(this.pos, true);
            this.pos += 1;
            return r;
        }
    },
    readUInt8: {
        value: function () {
            var r = this.dataView.getUint8(this.pos, true);
            this.pos += 1;
            return r;
        }
    },
    readInt16: {
        value: function () {
            var r = this.dataView.getInt16(this.pos, true);
            this.pos += 2;
            return r;
        }
    },
    readUInt16: {
        value: function () {
            var r = this.dataView.getUint16(this.pos, true);
            this.pos += 2;
            return r;
        }
    },
    readInt32: {
        value: function () {
            var r = this.dataView.getInt32(this.pos, true);
            this.pos += 4;
            return r;
        }
    },
    readUInt32: {
        value: function () {
            var r = this.dataView.getUint32(this.pos, true);
            this.pos += 4;
            return r;
        }
    },
    readFloat: {
        value: function () {
            var r = this.dataView.getFloat32(this.pos, true);
            this.pos += 4;
            return r;
        }
    },
    readDouble: {
        value: function () {
            var r = this.dataView.getFloat64(this.pos, true);
            this.pos += 8;
            return r;
        }
    },
    getSize: {
        value: function () {
            return this.dataView.byteLength - this.dataView.byteOffset;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileSpaceClaim.HitTarget = function (targt) {
    if (targt) {
        this.body = targt.body || null;
        this.itm = targt.itm || null;
    }
};
GLTFViewer.Utils.FileSpaceClaim.HitTarget.prototype = Object.create(null, {
    body: { writable: true, value: null },
    itm: { writable: true, value: null },
    Set: {
        value: function (body, itm) {
            this.body = body || null;
            this.itm = itm || null;
        }
    },
    IsEmpty: {
        value: function () {
            return this.itm === null && this.body === null;
        }
    },
    Key: {
        value: function () {
            var key = "";
            if (!this.IsEmpty()) {
                key = this.body.Key() + ";";
                if (this.itm instanceof GLTFViewer.Utils.FileSpaceClaim.FaceData)
                    key += "F:" + this.itm.id;
                else if (this.itm instanceof GLTFViewer.Utils.FileSpaceClaim.EdgeData)
                    key += "E:" + this.itm.id;
            }
            return key;
        }
    }
});
///////////////////////////////////////
/** @constructor */
GLTFViewer.Utils.FileSpaceClaim.Hit = function () {
    this.targt = new GLTFViewer.Utils.FileSpaceClaim.HitTarget();
    this.pnt = new GLTFViewer.Utils.Vec3();
    this.dist = -1;
};
GLTFViewer.Utils.FileSpaceClaim.Hit.prototype = Object.create(null, {
    targt: { writable: true, value: null },
    indx: { writable: true, value: 0 },
    pnt: { writable: true, value: 0 },
    Reset: { // clear to just created state
        value: function () {
            var change = this.targt.body !== null ||
                         this.targt.itm !== null;
            this.targt.Set();

            return change;
        }
    },
    Clear: { // clear for deletion
        value: function () {
            GLTFViewer.Utils.FileSpaceClaim.Hit.prototype.Reset.call(this);
            this.pnt = null;
        }
    },
    Set: {
        value: function (body, itm, i, x, y, z) {
            var change = body !== this.targt.body ||
                         itm !== this.targt.itm ||
                         i !== this.indx ||
                         x !== this.pnt.x || y !== this.pnt.y || z !== this.pnt.z;

            this.targt.Set(body, itm);
            this.indx = i;
            this.pnt.Set(x, y, z);

            return change;
        }
    },
    IsEmpty: {
        value: function () {
            return this.targt.body === null;
        }
    }
});
//
// GLTFViewer.Utils.FileSpaceClaim
//
///////////////////////////////////////////////////////////////////////////////
function webgl_support() { 
   try {
     let canvas = document.createElement('canvas'); 
     return !!window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
   } catch(e) {
     return false;
   }
 };
GLTFViewer_About={"build_date": "2024-02-26T13:11:08+0000", "extern_release_id": "2024 R1"};
