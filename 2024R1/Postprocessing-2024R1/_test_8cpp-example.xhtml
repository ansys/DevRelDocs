<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Veronica: Test.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="veronica_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Veronica
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.xhtml');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Introduction</span></a></li>
      <li><a href="modules.xhtml"><span>Modules</span></a></li>
      <li><a href="annotated.xhtml"><span>Classes</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
      <li><a href="examples.xhtml"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Test.cpp</div></div>
</div><!--header-->
<div class="contents">
<p>Helper functions for example tests.</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Copyright 2018-2021 ANSYS, Inc. Unauthorized use, distribution, or duplication is prohibited.</span></div>
<div class="line"><span class="comment"> * </span></div>
<div class="line"><span class="comment"> * Restricted Rights Legend</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Use, duplication, or disclosure of this</span></div>
<div class="line"><span class="comment"> * software and its documentation by the</span></div>
<div class="line"><span class="comment"> * Government is subject to restrictions as</span></div>
<div class="line"><span class="comment"> * set forth in subdivision [(b)(3)(ii)] of</span></div>
<div class="line"><span class="comment"> * the Rights in Technical Data and Computer</span></div>
<div class="line"><span class="comment"> * Software clause at 52.227-7013.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;GLTFWriter.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;test.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>ANSYS::Nexus;</div>
<div class="line"> </div>
<div class="line"><a id="_a0" name="_a0"></a><a class="code hl_class" href="class_a_n_s_y_s_1_1_nexus_1_1_g_l_t_f_writer_1_1_texture.xhtml">GLTFWriter::Texture</a> *</div>
<div class="line">GLTFWriter::Test::CreateTexture(GLTF *gltf,</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> *fileName)</div>
<div class="line">{</div>
<div class="line">    Image *image = Image::Create(gltf, fileName, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (!image)</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    Sampler *sampler = Sampler::Create(gltf, Sampler::FT_LINEAR, Sampler::FT_LINEAR, Sampler::WT_CLAMP_TO_EDGE, Sampler::WT_CLAMP_TO_EDGE);</div>
<div class="line">    <span class="keywordflow">if</span> (!sampler)</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    <span class="keywordflow">return</span> Texture::Create(gltf, Texture::TF_RGBA, Texture::TT_TEXTURE_2D, sampler, image);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a id="_a1" name="_a1"></a><a class="code hl_class" href="class_a_n_s_y_s_1_1_nexus_1_1_g_l_t_f_writer_1_1_material.xhtml">GLTFWriter::Material</a> *</div>
<div class="line">GLTFWriter::Test::CreateSolidColoredMaterial(GLTF *gltf,</div>
<div class="line">                                 <span class="keywordtype">float</span> r,</div>
<div class="line">                                 <span class="keywordtype">float</span> g,</div>
<div class="line">                                 <span class="keywordtype">float</span> b,</div>
<div class="line">                                 <span class="keywordtype">float</span> a)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// TECHNIQUE</span></div>
<div class="line">    Technique *technique = Technique::Create(gltf);</div>
<div class="line">    <span class="keywordflow">if</span> (!technique)</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// TECHNIQUE STATES</span></div>
<div class="line">    <span class="keywordflow">if</span> (!technique-&gt;AppendState(State::Create(gltf, State::ST_DEPTHTESTENABLE, 1)))</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    <span class="keywordflow">if</span> (a != 1.0) {</div>
<div class="line">        <span class="keywordflow">if</span> (!technique-&gt;AppendState(State::Create(gltf, State::ST_BLENDENABLE, 1)) || !technique-&gt;AppendState(State::Create(gltf, State::ST_DEPTHMASK, 0)))</div>
<div class="line">            <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// MATERIAL</span></div>
<div class="line">    Material *material = Material::Create(gltf, technique);</div>
<div class="line">    <span class="keywordflow">if</span> (!material)</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// MATERIAL UNIFORM VALUES</span></div>
<div class="line">    <span class="keywordflow">if</span> (!material-&gt;AppendValue(Value::Create(gltf, <span class="stringliteral">&quot;color&quot;</span>, r, g, b, a))) <span class="comment">// color name is used to auto-generate a solid colored object</span></div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> material;</div>
<div class="line">}</div>
<div class="line"><a class="code hl_class" href="class_a_n_s_y_s_1_1_nexus_1_1_g_l_t_f_writer_1_1_material.xhtml">GLTFWriter::Material</a> *</div>
<div class="line">GLTFWriter::Test::CreateTexturedMaterial(GLTF *gltf,</div>
<div class="line">    Texture *texture)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// TECHNIQUE</span></div>
<div class="line">    Technique *technique = Technique::Create(gltf);</div>
<div class="line">    <span class="keywordflow">if</span> (!technique)</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// TECHNIQUE STATES</span></div>
<div class="line">    <span class="keywordflow">if</span> (!technique-&gt;AppendState(State::Create(gltf, State::ST_DEPTHTESTENABLE, 1)) &amp;&amp; !technique-&gt;AppendState(State::Create(gltf, State::ST_BLENDENABLE, 1)))</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// MATERIAL</span></div>
<div class="line">    Material *material = Material::Create(gltf, technique);</div>
<div class="line">    <span class="keywordflow">if</span> (!material)</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// MATERIAL UNIFORM VALUES</span></div>
<div class="line">    <span class="keywordflow">if</span> (!material-&gt;AppendValue(Value::Create(gltf, <span class="stringliteral">&quot;texture0&quot;</span>, texture-&gt;GetID()))) <span class="comment">// texture0 name is auto-generated from Attribute TEXCOORD0</span></div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> material;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// will creaete flat shaded box</span></div>
<div class="line"><span class="comment">// all lines are formed from top and bottom vertices</span></div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">GLTFWriter::Test::MakeBox(<span class="keywordtype">float</span> x,</div>
<div class="line">    <span class="keywordtype">float</span> y,</div>
<div class="line">    <span class="keywordtype">float</span> z,</div>
<div class="line">    <span class="keywordtype">float</span> w,</div>
<div class="line">    <span class="keywordtype">float</span> h,</div>
<div class="line">    <span class="keywordtype">float</span> d,</div>
<div class="line">    std::vector&lt;float&gt; &amp;vertices,</div>
<div class="line">    std::vector&lt;unsigned short&gt; &amp;lineIndices,</div>
<div class="line">    std::vector&lt;unsigned short&gt; &amp; triangleIndices)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// VERTICES</span></div>
<div class="line">    vertices.clear();</div>
<div class="line">    <span class="comment">// bottom</span></div>
<div class="line">    vertices.push_back(-w / 2 + x); vertices.push_back(-h / 2 + y); vertices.push_back(-d / 2 + z);</div>
<div class="line">    vertices.push_back( w / 2 + x); vertices.push_back(-h / 2 + y); vertices.push_back(-d / 2 + z);</div>
<div class="line">    vertices.push_back( w / 2 + x); vertices.push_back(-h / 2 + y); vertices.push_back( d / 2 + z);</div>
<div class="line">    vertices.push_back(-w / 2 + x); vertices.push_back(-h / 2 + y); vertices.push_back( d / 2 + z);</div>
<div class="line">    <span class="comment">// top</span></div>
<div class="line">    vertices.push_back(-w / 2 + x); vertices.push_back( h / 2 + y); vertices.push_back(-d / 2 + z);</div>
<div class="line">    vertices.push_back(-w / 2 + x); vertices.push_back( h / 2 + y); vertices.push_back( d / 2 + z);</div>
<div class="line">    vertices.push_back( w / 2 + x); vertices.push_back( h / 2 + y); vertices.push_back( d / 2 + z);</div>
<div class="line">    vertices.push_back( w / 2 + x); vertices.push_back( h / 2 + y); vertices.push_back(-d / 2 + z);</div>
<div class="line">    <span class="comment">// front</span></div>
<div class="line">    vertices.push_back(-w / 2 + x); vertices.push_back(-h / 2 + y); vertices.push_back( d / 2 + z);</div>
<div class="line">    vertices.push_back( w / 2 + x); vertices.push_back(-h / 2 + y); vertices.push_back( d / 2 + z);</div>
<div class="line">    vertices.push_back( w / 2 + x); vertices.push_back( h / 2 + y); vertices.push_back( d / 2 + z);</div>
<div class="line">    vertices.push_back(-w / 2 + x); vertices.push_back( h / 2 + y); vertices.push_back( d / 2 + z);</div>
<div class="line">    <span class="comment">// back</span></div>
<div class="line">    vertices.push_back( w / 2 + x); vertices.push_back(-h / 2 + y); vertices.push_back(-d / 2 + z);</div>
<div class="line">    vertices.push_back(-w / 2 + x); vertices.push_back(-h / 2 + y); vertices.push_back(-d / 2 + z);</div>
<div class="line">    vertices.push_back(-w / 2 + x); vertices.push_back( h / 2 + y); vertices.push_back(-d / 2 + z);</div>
<div class="line">    vertices.push_back( w / 2 + x); vertices.push_back( h / 2 + y); vertices.push_back(-d / 2 + z);</div>
<div class="line">    <span class="comment">// left</span></div>
<div class="line">    vertices.push_back(-w / 2 + x); vertices.push_back(-h / 2 + y); vertices.push_back(-d / 2 + z);</div>
<div class="line">    vertices.push_back(-w / 2 + x); vertices.push_back(-h / 2 + y); vertices.push_back( d / 2 + z);</div>
<div class="line">    vertices.push_back(-w / 2 + x); vertices.push_back( h / 2 + y); vertices.push_back( d / 2 + z);</div>
<div class="line">    vertices.push_back(-w / 2 + x); vertices.push_back( h / 2 + y); vertices.push_back(-d / 2 + z);</div>
<div class="line">    <span class="comment">// right</span></div>
<div class="line">    vertices.push_back( w / 2 + x); vertices.push_back(-h / 2 + y); vertices.push_back( d / 2 + z);</div>
<div class="line">    vertices.push_back( w / 2 + x); vertices.push_back(-h / 2 + y); vertices.push_back(-d / 2 + z);</div>
<div class="line">    vertices.push_back( w / 2 + x); vertices.push_back( h / 2 + y); vertices.push_back(-d / 2 + z);</div>
<div class="line">    vertices.push_back( w / 2 + x); vertices.push_back( h / 2 + y); vertices.push_back( d / 2 + z);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// LINE INDICES</span></div>
<div class="line">    lineIndices.clear();</div>
<div class="line">    <span class="comment">//bottom</span></div>
<div class="line">    lineIndices.push_back(0); lineIndices.push_back(1); </div>
<div class="line">    lineIndices.push_back(1); lineIndices.push_back(2);</div>
<div class="line">    lineIndices.push_back(2); lineIndices.push_back(3);</div>
<div class="line">    lineIndices.push_back(3); lineIndices.push_back(0);</div>
<div class="line">    <span class="comment">// top</span></div>
<div class="line">    lineIndices.push_back(4); lineIndices.push_back(7); </div>
<div class="line">    lineIndices.push_back(7); lineIndices.push_back(6);</div>
<div class="line">    lineIndices.push_back(6); lineIndices.push_back(5);</div>
<div class="line">    lineIndices.push_back(5); lineIndices.push_back(4);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// sides</span></div>
<div class="line">    lineIndices.push_back(0); lineIndices.push_back(4); </div>
<div class="line">    lineIndices.push_back(1); lineIndices.push_back(7);</div>
<div class="line">    lineIndices.push_back(2); lineIndices.push_back(6);</div>
<div class="line">    lineIndices.push_back(3); lineIndices.push_back(5);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// TRIANGLE INDICES</span></div>
<div class="line">    triangleIndices.clear();</div>
<div class="line">    triangleIndices.push_back(0); triangleIndices.push_back(1); triangleIndices.push_back(2);</div>
<div class="line">        triangleIndices.push_back(0); triangleIndices.push_back(2); triangleIndices.push_back(3);</div>
<div class="line">    triangleIndices.push_back(4); triangleIndices.push_back(5); triangleIndices.push_back(6);</div>
<div class="line">        triangleIndices.push_back(4); triangleIndices.push_back(6); triangleIndices.push_back(7);</div>
<div class="line">    triangleIndices.push_back(8); triangleIndices.push_back(9); triangleIndices.push_back(10);</div>
<div class="line">        triangleIndices.push_back(8); triangleIndices.push_back(10); triangleIndices.push_back(11);</div>
<div class="line">    triangleIndices.push_back(12); triangleIndices.push_back(13); triangleIndices.push_back(14);</div>
<div class="line">        triangleIndices.push_back(12); triangleIndices.push_back(14); triangleIndices.push_back(15);</div>
<div class="line">    triangleIndices.push_back(16); triangleIndices.push_back(17); triangleIndices.push_back(18);</div>
<div class="line">        triangleIndices.push_back(16); triangleIndices.push_back(18); triangleIndices.push_back(19);</div>
<div class="line">    triangleIndices.push_back(20); triangleIndices.push_back(21); triangleIndices.push_back(22);</div>
<div class="line">        triangleIndices.push_back(20); triangleIndices.push_back(22); triangleIndices.push_back(23);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span></div>
<div class="line">GLTFWriter::Test::MakeSphere(<span class="keywordtype">float</span> x,</div>
<div class="line">    <span class="keywordtype">float</span> y,</div>
<div class="line">    <span class="keywordtype">float</span> z,</div>
<div class="line">    <span class="keywordtype">float</span> radius,</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> resolution,</div>
<div class="line">    std::vector&lt;float&gt; &amp;vertices,</div>
<div class="line">    std::vector&lt;T&gt; &amp;lineIndices,</div>
<div class="line">    std::vector&lt;T&gt; &amp;triangleIndices)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> i,</div>
<div class="line">        j;</div>
<div class="line">    <span class="keywordtype">float</span> ud, <span class="comment">/* up/down and left/right angles */</span></div>
<div class="line">        lr;</div>
<div class="line">    <span class="keywordtype">int</span> scale;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* number of facets about 1/2 of circumference */</span></div>
<div class="line">    <span class="keywordflow">if</span> ((scale = (<span class="keywordtype">int</span>)resolution / 2) &lt; 2)</div>
<div class="line">        scale = 2;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> numVertices = 2 * scale * (scale - 1) + 2;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numLineSegs = 6 * scale * (scale - 1);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriangles = 4 * scale * (scale - 1);</div>
<div class="line"> </div>
<div class="line">    vertices.resize(3 * numVertices);</div>
<div class="line">    lineIndices.resize(2 * numLineSegs);</div>
<div class="line">    triangleIndices.resize(3 * numTriangles);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">float</span> *pVertex = &amp;vertices[0];</div>
<div class="line">    T *pLine = &amp;lineIndices[0];</div>
<div class="line">    T *pTriangle = &amp;triangleIndices[0];</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> v = 0;</div>
<div class="line">    <span class="keywordtype">int</span> l = 0;</div>
<div class="line">    <span class="keywordtype">int</span> t = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (ud = (<span class="keywordtype">float</span>)(PI / 2), i = 0; i &lt;= scale; i++, ud -= (float)(PI / scale)) {</div>
<div class="line">        <span class="keywordflow">for</span> (lr = 0, j = 0; j &lt; 2 * scale; j++, lr -= (float)(PI / scale)) {</div>
<div class="line">            <span class="keywordflow">if</span> ((i == 0 &amp;&amp; j == 0) || (i != 0 &amp;&amp; i != scale) || (i == scale &amp;&amp; j == 0)) {</div>
<div class="line">                <span class="keywordtype">float</span> fLen = (float)(radius * std::cos(ud));</div>
<div class="line">                *pVertex++ = (float)(fLen * std::cos(lr) + x);</div>
<div class="line">                *pVertex++ = (float)(radius * std::sin(ud) + y);</div>
<div class="line">                *pVertex++ = (float)(fLen * std::sin(lr) + z);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (i &lt; scale) {</div>
<div class="line">                <span class="keywordflow">if</span> (i == 0) {</div>
<div class="line">                    *pTriangle++ = 0;</div>
<div class="line">                    *pTriangle++ = j + 1;</div>
<div class="line">                    <span class="keywordflow">if</span> (j &lt; 2 * scale - 1)</div>
<div class="line">                        *pTriangle++ = j + 2;</div>
<div class="line">                    <span class="keywordflow">else</span></div>
<div class="line">                        *pTriangle++ = 1;</div>
<div class="line"> </div>
<div class="line">                    *pLine++ = 0;</div>
<div class="line">                    *pLine++ = j + 1;</div>
<div class="line"> </div>
<div class="line">                    *pLine++ = j + 1;</div>
<div class="line">                    <span class="keywordflow">if</span> (j &lt; 2 * scale - 1)</div>
<div class="line">                        *pLine++ = j + 2;</div>
<div class="line">                    <span class="keywordflow">else</span></div>
<div class="line">                        *pLine++ = 1;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i &lt; scale - 1) {</div>
<div class="line">                    <span class="keywordtype">int</span> v = (i - 1) * 2 * scale + j + 1;</div>
<div class="line"> </div>
<div class="line">                    *pTriangle++ = v;</div>
<div class="line">                    *pTriangle++ = v + 2 * scale;</div>
<div class="line">                    <span class="keywordflow">if</span> (j &lt; 2 * scale - 1)</div>
<div class="line">                        *pTriangle++ = v + 1;</div>
<div class="line">                    <span class="keywordflow">else</span></div>
<div class="line">                        *pTriangle++ = v - 2 * scale + 1;</div>
<div class="line"> </div>
<div class="line">                    *pTriangle++ = v + 2 * scale;</div>
<div class="line">                    <span class="keywordflow">if</span> (j &lt; 2 * scale - 1) {</div>
<div class="line">                        *pTriangle++ = v + 2 * scale + 1;</div>
<div class="line">                        *pTriangle++ = v + 1;</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span> {</div>
<div class="line">                        *pTriangle++ = v + 1;</div>
<div class="line">                        *pTriangle++ = v - 2 * scale + 1;</div>
<div class="line">                    }</div>
<div class="line"> </div>
<div class="line">                    *pLine++ = v;</div>
<div class="line">                    *pLine++ = v + 2 * scale;</div>
<div class="line"> </div>
<div class="line">                    *pLine++ = v + 2 * scale;</div>
<div class="line">                    <span class="keywordflow">if</span> (j &lt; 2 * scale - 1) {</div>
<div class="line">                        *pLine++ = v + 2 * scale + 1;</div>
<div class="line"> </div>
<div class="line">                        *pLine++ = v + 2 * scale;</div>
<div class="line">                        *pLine++ = v + 1;</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span> {</div>
<div class="line">                        *pLine++ = v + 1;</div>
<div class="line"> </div>
<div class="line">                        *pLine++ = v + 2 * scale;</div>
<div class="line">                        *pLine++ = v - 2 * scale + 1;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == scale - 1) {</div>
<div class="line">                    <span class="keywordtype">int</span> v = (i - 1) * 2 * scale + j + 1;</div>
<div class="line"> </div>
<div class="line">                    *pTriangle++ = v;</div>
<div class="line">                    *pTriangle++ = numVertices - 1;</div>
<div class="line">                    <span class="keywordflow">if</span> (j &lt; 2 * scale - 1)</div>
<div class="line">                        *pTriangle++ = v + 1;</div>
<div class="line">                    <span class="keywordflow">else</span></div>
<div class="line">                        *pTriangle++ = v - 2 * scale + 1;</div>
<div class="line"> </div>
<div class="line">                    *pLine++ = v;</div>
<div class="line">                    *pLine++ = numVertices - 1;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="comment">// explicit instantiations</span></div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">void</span> GLTFWriter::Test::MakeSphere&lt;unsigned short&gt;(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y, <span class="keywordtype">float</span> z, <span class="keywordtype">float</span> radius, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> resolution, std::vector&lt;float&gt; &amp;vertices, std::vector&lt;unsigned short&gt; &amp;lineIndices, std::vector&lt;unsigned short&gt; &amp;triangleIndices);</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">void</span> GLTFWriter::Test::MakeSphere&lt;unsigned int&gt;(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y, <span class="keywordtype">float</span> z, <span class="keywordtype">float</span> radius, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> resolution, std::vector&lt;float&gt; &amp;vertices, std::vector&lt;unsigned int&gt; &amp;lineIndices, std::vector&lt;unsigned int&gt; &amp;triangleIndices);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span></div>
<div class="line">GLTFWriter::Test::MakeTexturedSphere(<span class="keywordtype">float</span> x,</div>
<div class="line">    <span class="keywordtype">float</span> y,</div>
<div class="line">    <span class="keywordtype">float</span> z,</div>
<div class="line">    <span class="keywordtype">float</span> radius,</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> resolution,</div>
<div class="line">    std::vector&lt;float&gt; &amp;vertices,</div>
<div class="line">    std::vector&lt;float&gt; &amp;normals,</div>
<div class="line">    std::vector&lt;float&gt; &amp;texCoords,</div>
<div class="line">    std::vector&lt;T&gt; &amp;triangleIndices)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numVertices = (resolution + 1) * (resolution + 1);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriangles = 2 * resolution * resolution;</div>
<div class="line">    vertices.resize(3 * numVertices);</div>
<div class="line">    normals.resize(3 * numVertices);</div>
<div class="line">    texCoords.resize(2 * numVertices);</div>
<div class="line">    triangleIndices.resize(3 * numTriangles);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">float</span> *pVertex = &amp;vertices[0];</div>
<div class="line">    <span class="keywordtype">float</span> *pNormal = &amp;normals[0];</div>
<div class="line">    <span class="keywordtype">float</span> *pTexCoord = &amp;texCoords[0];</div>
<div class="line">    T *pTriangle = &amp;triangleIndices[0];</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> fLatInc = PI / resolution;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> fLongInc = 2 * PI / resolution;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// top to bottom</span></div>
<div class="line">    <span class="keywordtype">double</span> fLat, fLong;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iLat, iLong;</div>
<div class="line">    <span class="keywordflow">for</span> (fLat = PI, iLat = 0; iLat &lt;= resolution; ++iLat, fLat -= fLatInc) {</div>
<div class="line">        <span class="comment">// left to right</span></div>
<div class="line">        <span class="keywordflow">for</span> (fLong = 2 * PI, iLong = 0; iLong &lt;= resolution; ++iLong, fLong -= fLongInc) {</div>
<div class="line">            <span class="keywordtype">float</span> fLen = (float)(radius * sin(fLat));</div>
<div class="line">            <span class="keywordtype">double</span> X = fLen * cos(fLong);</div>
<div class="line">            <span class="keywordtype">double</span> Y = radius * cos(fLat);</div>
<div class="line">            <span class="keywordtype">double</span> Z = fLen * sin(fLong);</div>
<div class="line"> </div>
<div class="line">            *pVertex++ = (float)X + x;</div>
<div class="line">            *pVertex++ = (float)Y + y;</div>
<div class="line">            *pVertex++ = (float)Z + z;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordtype">double</span> d = X * X + Y * Y + Z * Z;</div>
<div class="line">            <span class="keywordflow">if</span> (d != 0 &amp;&amp; d != 1) {</div>
<div class="line">                d = std::sqrt(d);</div>
<div class="line">                X /= d;</div>
<div class="line">                Y /= d;</div>
<div class="line">                Z /= d;</div>
<div class="line">            }</div>
<div class="line">            *pNormal++ = (float)X;</div>
<div class="line">            *pNormal++ = (float)Y;</div>
<div class="line">            *pNormal++ = (float)Z;</div>
<div class="line"> </div>
<div class="line">            *pTexCoord++ = (float)((2 * PI - fLong) / (2 * PI));</div>
<div class="line">            *pTexCoord++ = (float)((PI - fLat) / PI);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (iLat &gt; 0 &amp;&amp; iLong &gt; 0) {</div>
<div class="line">                *pTriangle++ = (iLat - 1) * (resolution + 1) + iLong;</div>
<div class="line">                *pTriangle++ = iLat * (resolution + 1) + iLong - 1;</div>
<div class="line">                *pTriangle++ = (iLat - 1) * (resolution + 1) + iLong - 1;</div>
<div class="line"> </div>
<div class="line">                *pTriangle++ = (iLat - 1) * (resolution + 1) + iLong;</div>
<div class="line">                *pTriangle++ = iLat * (resolution + 1) + iLong;</div>
<div class="line">                *pTriangle++ = iLat * (resolution + 1) + iLong - 1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="comment">// explicit instantiations</span></div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">void</span> GLTFWriter::Test::MakeTexturedSphere&lt;unsigned short&gt;(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y, <span class="keywordtype">float</span> z, <span class="keywordtype">float</span> radius, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> resolution, std::vector&lt;float&gt; &amp;vertices, std::vector&lt;float&gt; &amp;normals, std::vector&lt;float&gt; &amp;texCoords, std::vector&lt;unsigned short&gt; &amp;triangleIndices);</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">void</span> GLTFWriter::Test::MakeTexturedSphere&lt;unsigned int&gt;(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y, <span class="keywordtype">float</span> z, <span class="keywordtype">float</span> radius, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> resolution, std::vector&lt;float&gt; &amp;vertices, std::vector&lt;float&gt; &amp;normals, std::vector&lt;float&gt; &amp;texCoords, std::vector&lt;unsigned int&gt; &amp;triangleIndices);</div>
<div class="line"> </div>
<div class="line">GLTFWriter::Test::PrimMat</div>
<div class="line">GLTFWriter::Test::CreateSolidColoredBoxPrimitive(GLTF *gltf,</div>
<div class="line">    <span class="keywordtype">float</span> x,</div>
<div class="line">    <span class="keywordtype">float</span> y,</div>
<div class="line">    <span class="keywordtype">float</span> z,</div>
<div class="line">    <span class="keywordtype">float</span> w,</div>
<div class="line">    <span class="keywordtype">float</span> h,</div>
<div class="line">    <span class="keywordtype">float</span> d,</div>
<div class="line">    <span class="keywordtype">float</span> r,</div>
<div class="line">    <span class="keywordtype">float</span> g,</div>
<div class="line">    <span class="keywordtype">float</span> b,</div>
<div class="line">    <span class="keywordtype">float</span> a)</div>
<div class="line">{</div>
<div class="line">    Primitive *primitive = 0;</div>
<div class="line">    Material *material = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// MATERIAL</span></div>
<div class="line">    Material *mat = Test::CreateSolidColoredMaterial(gltf, r, g, b, a);</div>
<div class="line">    <span class="keywordflow">if</span> (mat) {</div>
<div class="line">        <span class="comment">// BOX</span></div>
<div class="line">        std::vector&lt;float&gt; vertices;</div>
<div class="line">        std::vector&lt;unsigned short&gt; lineIndices;</div>
<div class="line">        std::vector&lt;unsigned short&gt; indices;</div>
<div class="line">        Test::MakeBox(x, y, z, w, h, d, vertices, lineIndices, indices);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// NORMALS</span></div>
<div class="line">        std::vector&lt;float&gt; normals(vertices.size());</div>
<div class="line">        Utils::ComputeVertexNormals3((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vertices.size() / 3, &amp;vertices[0], (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)indices.size() / 3, 3, &amp;indices[0], &amp;normals[0]);</div>
<div class="line"> </div>
<div class="line">        Attribute *vertex = 0;</div>
<div class="line">        Index *index = 0;</div>
<div class="line">        Attribute *normal = 0;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> ((vertex = Attribute::CreatePosition(gltf, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vertices.size() / 3, &amp;vertices[0])) != 0 &amp;&amp; <span class="comment">// POSITION ATTRIBUTE</span></div>
<div class="line">            (index = Index::Create(gltf, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)indices.size(), &amp;indices[0])) != 0 &amp;&amp; <span class="comment">// INDICES</span></div>
<div class="line">            (normal = Attribute::CreateNormal(gltf, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vertices.size() / 3, &amp;normals[0])) != 0) { <span class="comment">// NORMAL ATTRIBUTE</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment">// PRIMITIVE</span></div>
<div class="line">            Primitive *prim = Primitive::Create(gltf, Primitive::PT_TRIANGLES, mat, index);</div>
<div class="line">            <span class="keywordflow">if</span> (prim &amp;&amp; prim-&gt;AppendAttribute(vertex) &amp;&amp; prim-&gt;AppendAttribute(normal)) {</div>
<div class="line">                material = mat;</div>
<div class="line">                primitive = prim;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(primitive, material);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">GLTFWriter::Test::PrimMat</div>
<div class="line">GLTFWriter::Test::CreateColoredBoxPrimitive(GLTF *gltf,</div>
<div class="line">    <span class="keywordtype">float</span> x,</div>
<div class="line">    <span class="keywordtype">float</span> y,</div>
<div class="line">    <span class="keywordtype">float</span> z,</div>
<div class="line">    <span class="keywordtype">float</span> w,</div>
<div class="line">    <span class="keywordtype">float</span> h,</div>
<div class="line">    <span class="keywordtype">float</span> d)</div>
<div class="line">{</div>
<div class="line">    Material *material = 0;</div>
<div class="line">    Primitive *primitive = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// TECHNIQUE</span></div>
<div class="line">    Technique *technique = Technique::Create(gltf);</div>
<div class="line">    <span class="keywordflow">if</span> (technique &amp;&amp; </div>
<div class="line">        technique-&gt;AppendState(State::Create(gltf, State::ST_DEPTHTESTENABLE, 1)) &amp;&amp; <span class="comment">// TECHNIQUE STATES</span></div>
<div class="line">        technique-&gt;AppendState(State::Create(gltf, State::ST_BLENDENABLE, 1))) {</div>
<div class="line">        <span class="comment">// MATERIAL</span></div>
<div class="line">        Material *mat = Material::Create(gltf, technique);</div>
<div class="line">        <span class="keywordflow">if</span> (mat) {</div>
<div class="line">            <span class="comment">// BOX</span></div>
<div class="line">            std::vector&lt;float&gt; vertices;</div>
<div class="line">            std::vector&lt;unsigned short&gt; lineIndices;</div>
<div class="line">            std::vector&lt;unsigned short&gt; indices;</div>
<div class="line">            Test::MakeBox(x, y, z, w, h, d, vertices, lineIndices, indices);</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numVertices = (<span class="keywordtype">unsigned</span> int)vertices.size() / 3;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// COLORS</span></div>
<div class="line">            std::vector&lt;float&gt; colors;</div>
<div class="line">            <span class="keywordtype">double</span> colorInc = 1.0 / std::ceil(std::pow(numVertices, 1.0 / 3.75) - 1);</div>
<div class="line">            std::vector&lt;double&gt; c(4, 1);</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numVertices; ++i) {</div>
<div class="line">                colors.push_back((<span class="keywordtype">float</span>)c[0]); colors.push_back((<span class="keywordtype">float</span>)c[1]); colors.push_back((<span class="keywordtype">float</span>)c[2]); colors.push_back((<span class="keywordtype">float</span>)c[3]);</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 4; ++j) {</div>
<div class="line">                    c[j] -= colorInc;</div>
<div class="line">                    <span class="keywordflow">if</span> (c[j] &gt;= 0.0)</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    c[j] = 1;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// NORMALS</span></div>
<div class="line">            std::vector&lt;float&gt; normals(vertices.size());</div>
<div class="line">            Utils::ComputeVertexNormals3((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vertices.size() / 3, &amp;vertices[0], (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)indices.size() / 3, 3, &amp;indices[0], &amp;normals[0]);</div>
<div class="line"> </div>
<div class="line">            Attribute *vertex = 0;</div>
<div class="line">            Index *index = 0;</div>
<div class="line">            Attribute *color = 0;</div>
<div class="line">            Attribute *normal = 0;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> ((vertex = Attribute::CreatePosition(gltf, numVertices, &amp;vertices[0])) != 0 &amp;&amp; <span class="comment">// POSITION ATTRIBUTE            </span></div>
<div class="line">                (index = Index::Create(gltf, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)indices.size(), &amp;indices[0])) != 0 &amp;&amp;  <span class="comment">// INDICES</span></div>
<div class="line">                (color = Attribute::CreateColor(gltf, Attribute::AT_FLOAT_VEC4, numVertices, &amp;colors[0])) != 0 &amp;&amp;  <span class="comment">// COLOR ATTRIBUTE</span></div>
<div class="line">                (normal = Attribute::CreateNormal(gltf, numVertices, &amp;normals[0]))) { <span class="comment">// NORMAL ATTRIBUTE</span></div>
<div class="line"> </div>
<div class="line">                <span class="comment">// PRIMITIVE</span></div>
<div class="line">                Primitive *prim = Primitive::Create(gltf, Primitive::PT_TRIANGLES, mat, index);</div>
<div class="line">                <span class="keywordflow">if</span> (prim &amp;&amp; prim-&gt;AppendAttribute(vertex) &amp;&amp; prim-&gt;AppendAttribute(normal) &amp;&amp; prim-&gt;AppendAttribute(color)) {</div>
<div class="line">                    primitive = prim;</div>
<div class="line">                    material = mat;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(primitive, material);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">GLTFWriter::Test::PrimMat</div>
<div class="line">GLTFWriter::Test::CreateTexturedBoxPrimitive(GLTF *gltf,</div>
<div class="line">    Texture *texture,</div>
<div class="line">    <span class="keywordtype">float</span> x,</div>
<div class="line">    <span class="keywordtype">float</span> y,</div>
<div class="line">    <span class="keywordtype">float</span> z,</div>
<div class="line">    <span class="keywordtype">float</span> w,</div>
<div class="line">    <span class="keywordtype">float</span> h,</div>
<div class="line">    <span class="keywordtype">float</span> d)</div>
<div class="line">{</div>
<div class="line">    Primitive *primitive = 0;</div>
<div class="line">    Material *material = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// MATERIAL</span></div>
<div class="line">    Material *mat = Test::CreateTexturedMaterial(gltf, texture);</div>
<div class="line">    <span class="keywordflow">if</span> (mat) {</div>
<div class="line">        <span class="comment">// BOX</span></div>
<div class="line">        std::vector&lt;float&gt; vertices;</div>
<div class="line">        std::vector&lt;unsigned short&gt; lineIndices;</div>
<div class="line">        std::vector&lt;unsigned short&gt; indices;</div>
<div class="line">        Test::MakeBox(x, y, z, w, h, d, vertices, lineIndices, indices);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numVertices = (<span class="keywordtype">unsigned</span> int)vertices.size() / 3;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// TEXCOORDS</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> coordMin = -5;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> coordMax = 5;</div>
<div class="line">        std::vector&lt;float&gt; texCoords;</div>
<div class="line">        <span class="keywordtype">double</span> coordInc = 1.0 / (numVertices - 1);</div>
<div class="line">        <span class="keywordtype">double</span> c = 0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numVertices; ++i) {</div>
<div class="line">            texCoords.push_back((<span class="keywordtype">float</span>)(coordMin + c * (coordMax - coordMin)));</div>
<div class="line">            c += coordInc;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// NORMALS</span></div>
<div class="line">        std::vector&lt;float&gt; normals(vertices.size());</div>
<div class="line">        Utils::ComputeVertexNormals3((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vertices.size() / 3, &amp;vertices[0], (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)indices.size() / 3, 3, &amp;indices[0], &amp;normals[0]);</div>
<div class="line"> </div>
<div class="line">        Attribute *vertex = 0;</div>
<div class="line">        Index *index = 0;</div>
<div class="line">        Attribute *texCoord = 0;</div>
<div class="line">        Attribute *normal = 0;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> ((vertex = Attribute::CreatePosition(gltf, numVertices, &amp;vertices[0])) != 0 &amp;&amp; <span class="comment">// POSITION ATTRIBUTE</span></div>
<div class="line">            (index = Index::Create(gltf, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)indices.size(), &amp;indices[0])) != 0 &amp;&amp; <span class="comment">// INDICES</span></div>
<div class="line">            (texCoord = Attribute::CreateTextureCoord(gltf, 0, numVertices, &amp;texCoords[0])) &amp;&amp; <span class="comment">// TEXCOORD ATTRIBUTE</span></div>
<div class="line">            (normal = Attribute::CreateNormal(gltf, numVertices, &amp;normals[0]))) { <span class="comment">// NORMAL ATTRIBUTE</span></div>
<div class="line">            <span class="keywordtype">float</span> mn;</div>
<div class="line">            <span class="keywordtype">float</span> mx;</div>
<div class="line">            mn = (float)coordMin;</div>
<div class="line">            mx = (float)coordMax;</div>
<div class="line">            <span class="keywordflow">if</span> (texCoord-&gt;SetMinMax(Attribute::AT_FLOAT, &amp;mn, &amp;mx)) {</div>
<div class="line">                Primitive *prim = Primitive::Create(gltf, Primitive::PT_TRIANGLES, mat, index);</div>
<div class="line">                <span class="keywordflow">if</span> (prim &amp;&amp; prim-&gt;AppendAttribute(vertex) &amp;&amp; prim-&gt;AppendAttribute(normal) &amp;&amp; prim-&gt;AppendAttribute(texCoord)) {</div>
<div class="line">                    primitive = prim;</div>
<div class="line">                    material = mat;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(primitive, material);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">GLTFWriter::Test::PrimMat</div>
<div class="line">GLTFWriter::Test::CreateSolidColoredSpherePrimitive(GLTF *gltf,</div>
<div class="line">    <span class="keywordtype">float</span> x,</div>
<div class="line">    <span class="keywordtype">float</span> y,</div>
<div class="line">    <span class="keywordtype">float</span> z,</div>
<div class="line">    <span class="keywordtype">float</span> radius,</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> resolution,</div>
<div class="line">    <span class="keywordtype">float</span> r,</div>
<div class="line">    <span class="keywordtype">float</span> g,</div>
<div class="line">    <span class="keywordtype">float</span> b,</div>
<div class="line">    <span class="keywordtype">float</span> a)</div>
<div class="line">{</div>
<div class="line">    Material *material = 0;</div>
<div class="line">    Primitive *primitive = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// MATERIAL</span></div>
<div class="line">    Material *mat = Test::CreateSolidColoredMaterial(gltf, r, g, b, a);</div>
<div class="line">    <span class="keywordflow">if</span> (mat) {</div>
<div class="line">        <span class="comment">// SPHERE</span></div>
<div class="line">        std::vector&lt;float&gt; vertices;</div>
<div class="line">        std::vector&lt;unsigned short&gt; lineIndices;</div>
<div class="line">        std::vector&lt;unsigned short&gt; indices;</div>
<div class="line">        Test::MakeSphere(x, y, z, radius, resolution, vertices, lineIndices, indices);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// NORMALS</span></div>
<div class="line">        std::vector&lt;float&gt; normals(vertices.size());</div>
<div class="line">        Utils::ComputeVertexNormals3((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vertices.size() / 3, &amp;vertices[0], (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)indices.size() / 3, 3, &amp;indices[0], &amp;normals[0]);</div>
<div class="line"> </div>
<div class="line">        Attribute *vertex = 0;</div>
<div class="line">        Index *index = 0;</div>
<div class="line">        Attribute *normal = 0;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> ((vertex = Attribute::CreatePosition(gltf, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vertices.size() / 3, &amp;vertices[0])) != 0 &amp;&amp; <span class="comment">// POSITION ATTRIBUTE</span></div>
<div class="line">            (index = Index::Create(gltf, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)indices.size(), &amp;indices[0])) != 0 &amp;&amp; <span class="comment">// INDICES</span></div>
<div class="line">            (normal = Attribute::CreateNormal(gltf, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vertices.size() / 3, &amp;normals[0])) != 0) { <span class="comment">// NORMAL ATTRIBUTE</span></div>
<div class="line">            <span class="comment">// PRIMITIVE</span></div>
<div class="line">            Primitive *prim = Primitive::Create(gltf, Primitive::PT_TRIANGLES, mat, index);</div>
<div class="line">            <span class="keywordflow">if</span> (prim &amp;&amp; prim-&gt;AppendAttribute(vertex) &amp;&amp; prim-&gt;AppendAttribute(normal)) {</div>
<div class="line">                material = mat;</div>
<div class="line">                primitive = prim;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(primitive, material);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">GLTFWriter::Test::PrimMat</div>
<div class="line">GLTFWriter::Test::CreateColoredSpherePrimitive(GLTF *gltf,</div>
<div class="line">    <span class="keywordtype">float</span> x,</div>
<div class="line">    <span class="keywordtype">float</span> y,</div>
<div class="line">    <span class="keywordtype">float</span> z,</div>
<div class="line">    <span class="keywordtype">float</span> radius,</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> resolution)</div>
<div class="line">{</div>
<div class="line">    Material *material = 0;</div>
<div class="line">    Primitive *primitive = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// TECHNIQUE</span></div>
<div class="line">    Technique *technique = Technique::Create(gltf);</div>
<div class="line">    <span class="keywordflow">if</span> (technique &amp;&amp;</div>
<div class="line">        technique-&gt;AppendState(State::Create(gltf, State::ST_DEPTHTESTENABLE, 1)) &amp;&amp; <span class="comment">// TECHNIQUE STATES</span></div>
<div class="line">        technique-&gt;AppendState(State::Create(gltf, State::ST_BLENDENABLE, 1))) {</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// MATERIAL</span></div>
<div class="line">        Material *mat = Material::Create(gltf, technique);</div>
<div class="line">        <span class="keywordflow">if</span> (mat) {</div>
<div class="line">            <span class="comment">// SPHERE</span></div>
<div class="line">            std::vector&lt;float&gt; vertices;</div>
<div class="line">            std::vector&lt;unsigned short&gt; lineIndices;</div>
<div class="line">            std::vector&lt;unsigned short&gt; indices;</div>
<div class="line">            Test::MakeSphere(x, y, z, radius, resolution, vertices, lineIndices, indices);</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numVertices = (<span class="keywordtype">unsigned</span> int)vertices.size() / 3;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// COLORS</span></div>
<div class="line">            std::vector&lt;float&gt; colors;</div>
<div class="line">            <span class="keywordtype">double</span> colorInc = 1.0 / std::ceil(std::pow(numVertices, 1.0 / 3.75) - 1);</div>
<div class="line">            std::vector&lt;double&gt; c(4, 1);</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numVertices; ++i) {</div>
<div class="line">                colors.push_back((<span class="keywordtype">float</span>)c[0]); colors.push_back((<span class="keywordtype">float</span>)c[1]); colors.push_back((<span class="keywordtype">float</span>)c[2]); colors.push_back((<span class="keywordtype">float</span>)c[3]);</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 4; ++j) {</div>
<div class="line">                    c[j] -= colorInc;</div>
<div class="line">                    <span class="keywordflow">if</span> (c[j] &gt;= 0.0)</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    c[j] = 1;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// NORMALS</span></div>
<div class="line">            std::vector&lt;float&gt; normals(vertices.size());</div>
<div class="line">            Utils::ComputeVertexNormals3((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vertices.size() / 3, &amp;vertices[0], (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)indices.size() / 3, 3, &amp;indices[0], &amp;normals[0]);</div>
<div class="line"> </div>
<div class="line">            Attribute *vertex = 0;</div>
<div class="line">            Index *index = 0;</div>
<div class="line">            Attribute *color = 0;</div>
<div class="line">            Attribute *normal = 0;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> ((vertex = Attribute::CreatePosition(gltf, numVertices, &amp;vertices[0])) != 0 &amp;&amp; <span class="comment">// POSITION ATTRIBUTE            </span></div>
<div class="line">                (index = Index::Create(gltf, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)indices.size(), &amp;indices[0])) != 0 &amp;&amp;  <span class="comment">// INDICES</span></div>
<div class="line">                (color = Attribute::CreateColor(gltf, Attribute::AT_FLOAT_VEC4, numVertices, &amp;colors[0])) != 0 &amp;&amp;  <span class="comment">// COLOR ATTRIBUTE</span></div>
<div class="line">                (normal = Attribute::CreateNormal(gltf, numVertices, &amp;normals[0]))) { <span class="comment">// NORMAL ATTRIBUTE</span></div>
<div class="line">                <span class="comment">// PRIMITIVE</span></div>
<div class="line">                Primitive *prim = Primitive::Create(gltf, Primitive::PT_TRIANGLES, mat, index);</div>
<div class="line">                <span class="keywordflow">if</span> (prim &amp;&amp; prim-&gt;AppendAttribute(vertex) &amp;&amp; prim-&gt;AppendAttribute(normal) &amp;&amp; prim-&gt;AppendAttribute(color)) {</div>
<div class="line">                    material = mat;</div>
<div class="line">                    primitive = prim;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(primitive, material);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">GLTFWriter::Test::Vector3::Vector3(<span class="keyword">const</span> GLTFWriter::Test::Vector4 &amp;v)</div>
<div class="line">    : VectorBase&lt;3&gt;()</div>
<div class="line">{</div>
<div class="line">    (*this)[0] = v[0];</div>
<div class="line">    (*this)[1] = v[1];</div>
<div class="line">    (*this)[2] = v[2];</div>
<div class="line">    <span class="keywordflow">if</span> (v[3] != 0 &amp;&amp; v[3] != 1) {</div>
<div class="line">        (*this)[0] /= v[3];</div>
<div class="line">        (*this)[1] /= v[3];</div>
<div class="line">        (*this)[2] /= v[3];</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">double</span></div>
<div class="line">GLTFWriter::Test::Vector3::Length()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordtype">double</span> d = (*this)[0] * (*this)[0] + (*this)[1] * (*this)[1] + (*this)[2] * (*this)[2];</div>
<div class="line">    <span class="keywordflow">if</span> (d != 0 &amp;&amp; d != 1)</div>
<div class="line">        d = std::sqrt(d);</div>
<div class="line">    <span class="keywordflow">return</span> d;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::Vector3</div>
<div class="line">GLTFWriter::Test::Vector3::Normalize()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    Vector3 tmp = *<span class="keyword">this</span>;</div>
<div class="line">    <span class="keywordtype">double</span> d = tmp[0] * tmp[0] + tmp[1] * tmp[1] + tmp[2] * tmp[2];</div>
<div class="line">    <span class="keywordflow">if</span> (d != 0 &amp;&amp; d != 1) {</div>
<div class="line">        d = std::sqrt(d);</div>
<div class="line">        tmp[0] /= d;</div>
<div class="line">        tmp[1] /= d;</div>
<div class="line">        tmp[2] /= d;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> tmp;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::Vector3 &amp;</div>
<div class="line">GLTFWriter::Test::Vector3::operator+=(<span class="keyword">const</span> Vector3 &amp;v)</div>
<div class="line">{</div>
<div class="line">    (*this)[0] += v[0];</div>
<div class="line">    (*this)[1] += v[1];</div>
<div class="line">    (*this)[2] += v[2];</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::Vector3 &amp;</div>
<div class="line">GLTFWriter::Test::Vector3::operator-=(<span class="keyword">const</span> Vector3 &amp;v)</div>
<div class="line">{</div>
<div class="line">    (*this)[0] -= v[0];</div>
<div class="line">    (*this)[1] -= v[1];</div>
<div class="line">    (*this)[2] -= v[2];</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::Vector3 &amp;</div>
<div class="line">GLTFWriter::Test::Vector3::operator*=(<span class="keywordtype">double</span> d)</div>
<div class="line">{</div>
<div class="line">    (*this)[0] *= d;</div>
<div class="line">    (*this)[1] *= d;</div>
<div class="line">    (*this)[2] *= d;</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::Vector3</div>
<div class="line">GLTFWriter::Test::Vector3::Cross(<span class="keyword">const</span> Vector3 &amp;v)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    Vector3 tmp;</div>
<div class="line">    tmp[0] = (*this)[1] * v[2] - v[1] * (*this)[2];</div>
<div class="line">    tmp[1] = (*this)[2] * v[0] - v[2] * (*this)[0];</div>
<div class="line">    tmp[2] = (*this)[0] * v[1] - v[0] * (*this)[1];</div>
<div class="line">    <span class="keywordflow">return</span> tmp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">GLTFWriter::Test::Quaternion::Quaternion(<span class="keyword">const</span> Vector3 &amp;axis,</div>
<div class="line">    <span class="keywordtype">double</span> angle)</div>
<div class="line">    : VectorBase&lt;4&gt;()</div>
<div class="line">{</div>
<div class="line">    Vector3 tmp = axis.Normalize();</div>
<div class="line">    <span class="keywordtype">double</span> s = std::sin(angle / 2);</div>
<div class="line">    (*this)[0] = tmp[0] * s;</div>
<div class="line">    (*this)[1] = tmp[1] * s;</div>
<div class="line">    (*this)[2] = tmp[2] * s;</div>
<div class="line">    (*this)[3] = std::cos(angle / 2);</div>
<div class="line">    *<span class="keyword">this</span> = Normalize(); <span class="comment">// rotation quaternions must be normalized</span></div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::Quaternion::Quaternion(<span class="keyword">const</span> Matrix4 &amp;m)</div>
<div class="line">    : VectorBase&lt;4&gt;()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// is this the same as Matrix.GetQuaternion???</span></div>
<div class="line">    <span class="keywordtype">double</span> tr = m[0] + m[5] + m[10];</div>
<div class="line">    <span class="keywordflow">if</span> (tr &gt; 0) {</div>
<div class="line">        <span class="keywordtype">double</span> s = std::sqrt(tr + 1) * 2;</div>
<div class="line">        (*this)[0] = (m[6] - m[9]) / s;</div>
<div class="line">        (*this)[1] = (-m[2] - m[8]) / s;</div>
<div class="line">        (*this)[2] = (m[1] - m[4]) / s;</div>
<div class="line">        (*this)[3] = 0.25 * s;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m[0] &gt; m[5] &amp;&amp; m[0] &gt; m[10]) {</div>
<div class="line">        <span class="keywordtype">double</span> s = std::sqrt(m[0] - m[5] - m[10] + 1) * 2;</div>
<div class="line">        (*this)[0] = 0.25 * s;</div>
<div class="line">        (*this)[1] = (m[1] + m[4]) / s;</div>
<div class="line">        (*this)[2] = (m[2] + m[8]) / s;</div>
<div class="line">        (*this)[3] = (m[6] - m[9]) / s;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m[5] &gt; m[10]) {</div>
<div class="line">        <span class="keywordtype">double</span> s = std::sqrt(-m[0] + m[5] - m[10] + 1) * 2;</div>
<div class="line">        (*this)[0] = (m[1] + m[4]) / s;</div>
<div class="line">        (*this)[1] = 0.25 * s;</div>
<div class="line">        (*this)[2] = (m[6] + m[9]) / s;</div>
<div class="line">        (*this)[3] = (-m[2] + m[8]) / s;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordtype">double</span> s = std::sqrt(-m[0] - m[5] + m[10] + 1) * 2;</div>
<div class="line">        (*this)[0] = (m[2] + m[8]) / s;</div>
<div class="line">        (*this)[1] = (m[6] + m[9]) / s;</div>
<div class="line">        (*this)[2] = 0.25 * s;</div>
<div class="line">        (*this)[3] = (m[1] - m[4]) / s;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span></div>
<div class="line">GLTFWriter::Test::Quaternion::Norm()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;Dot(*<span class="keyword">this</span>);</div>
<div class="line">    <span class="comment">//    return (*this)[0] * (*this)[0] + (*this)[1] * (*this)[1] + (*this)[2] * (*this)[2] + (*this)[3] * (*this)[3];</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">double</span></div>
<div class="line">GLTFWriter::Test::Quaternion::Magnitude()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordtype">double</span> d = Norm();</div>
<div class="line">    <span class="keywordflow">if</span> (d != 0 &amp;&amp; d != 1)</div>
<div class="line">        <span class="keywordflow">return</span> std::sqrt(d);</div>
<div class="line">    <span class="keywordflow">return</span> d;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::Quaternion</div>
<div class="line">GLTFWriter::Test::Quaternion::Normalize()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    Quaternion tmp = *<span class="keyword">this</span>;</div>
<div class="line">    <span class="keywordtype">double</span> d = Magnitude();</div>
<div class="line">    <span class="keywordflow">if</span> (d != 0 &amp;&amp; d != 1) {</div>
<div class="line">        tmp[0] /= d;</div>
<div class="line">        tmp[1] /= d;</div>
<div class="line">        tmp[2] /= d;</div>
<div class="line">        tmp[3] /= d;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> tmp;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::Quaternion</div>
<div class="line">GLTFWriter::Test::Quaternion::Slerp(<span class="keyword">const</span> Quaternion &amp;q,</div>
<div class="line">    <span class="keywordtype">double</span> t)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    Quaternion a = Normalize(); <span class="comment">// rotation quaternions must be normalized</span></div>
<div class="line">    Quaternion b = q.Normalize(); <span class="comment">// rotation quaternions must be normalized</span></div>
<div class="line">    <span class="keywordtype">double</span> cosHalfTheta = a.Dot(b);</div>
<div class="line">    <span class="keywordflow">if</span> (std::abs(cosHalfTheta) &gt;= 1.0)</div>
<div class="line">        <span class="keywordflow">return</span> a;</div>
<div class="line">    <span class="keywordtype">double</span> sinHalfTheta = std::sqrt(1.0 - cosHalfTheta * cosHalfTheta);</div>
<div class="line">    <span class="keywordflow">if</span> (std::abs(sinHalfTheta) &lt; 0.001)</div>
<div class="line">        <span class="keywordflow">return</span> ((a + b) * 0.5).Normalize(); <span class="comment">// rotation quaternions must be normalized</span></div>
<div class="line">    <span class="keywordtype">double</span> halfTheta = std::acos(cosHalfTheta);</div>
<div class="line">    <span class="keywordtype">double</span> ratioA = std::sin((1 - t) * halfTheta) / sinHalfTheta;</div>
<div class="line">    <span class="keywordtype">double</span> ratioB = std::sin(t * halfTheta) / sinHalfTheta;</div>
<div class="line">    <span class="keywordflow">return</span> (a * ratioA + b * ratioB).Normalize(); <span class="comment">// rotation quaternions must be normalized</span></div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::Quaternion &amp;</div>
<div class="line">GLTFWriter::Test::Quaternion::operator+=(<span class="keyword">const</span> Quaternion &amp;q)</div>
<div class="line">{</div>
<div class="line">    (*this)[0] += q[0];</div>
<div class="line">    (*this)[1] += q[1];</div>
<div class="line">    (*this)[2] += q[2];</div>
<div class="line">    (*this)[3] += q[3];</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::Quaternion &amp;</div>
<div class="line">GLTFWriter::Test::Quaternion::operator-=(<span class="keyword">const</span> Quaternion &amp;q)</div>
<div class="line">{</div>
<div class="line">    (*this)[0] -= q[0];</div>
<div class="line">    (*this)[1] -= q[1];</div>
<div class="line">    (*this)[2] -= q[2];</div>
<div class="line">    (*this)[3] -= q[3];</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::Quaternion &amp;</div>
<div class="line">GLTFWriter::Test::Quaternion::operator*=(<span class="keyword">const</span> Quaternion &amp;q)</div>
<div class="line">{</div>
<div class="line">    Quaternion tmp;</div>
<div class="line">    tmp[0] = (*this)[3] * q[0] + (*this)[0] * q[3] + (*this)[1] * q[2] - (*this)[2] * q[1];</div>
<div class="line">    tmp[1] = (*this)[3] * q[1] - (*this)[0] * q[2] + (*this)[1] * q[3] + (*this)[2] * q[0];</div>
<div class="line">    tmp[2] = (*this)[3] * q[2] + (*this)[0] * q[1] - (*this)[1] * q[0] + (*this)[2] * q[3];</div>
<div class="line">    tmp[3] = (*this)[3] * q[3] - (*this)[0] * q[0] - (*this)[1] * q[1] - (*this)[2] * q[2];</div>
<div class="line">    *<span class="keyword">this</span> = tmp;</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::Quaternion &amp;</div>
<div class="line">GLTFWriter::Test::Quaternion::operator*=(<span class="keywordtype">double</span> d)</div>
<div class="line">{</div>
<div class="line">    (*this)[0] *= d;</div>
<div class="line">    (*this)[1] *= d;</div>
<div class="line">    (*this)[2] *= d;</div>
<div class="line">    (*this)[3] *= d;</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">GLTFWriter::Test::DualQuaternion::DualQuaternion(<span class="keyword">const</span> <span class="keywordtype">double</span> angle, <span class="comment">// rotation</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d, <span class="comment">// pitch</span></div>
<div class="line">    <span class="keyword">const</span> Vector3 &amp;l,</div>
<div class="line">    <span class="keyword">const</span> Vector3 &amp;m)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> s2 = std::sin(angle / 2); <span class="comment">// = 1 / vrd</span></div>
<div class="line">    <span class="keywordtype">double</span> wr = std::cos(angle / 2);</div>
<div class="line">    Vector3 vr = l * s2;</div>
<div class="line">    <span class="keywordtype">double</span> wd = -d / 2 * s2;</div>
<div class="line">    Vector3 vd = m * s2 + l * (d / 2 * wr);</div>
<div class="line"> </div>
<div class="line">    rotation[0] = vr[0];</div>
<div class="line">    rotation[1] = vr[1];</div>
<div class="line">    rotation[2] = vr[2];</div>
<div class="line">    rotation[3] = wr;</div>
<div class="line"> </div>
<div class="line">    translation[0] = vd[0];</div>
<div class="line">    translation[1] = vd[1];</div>
<div class="line">    translation[2] = vd[2];</div>
<div class="line">    translation[3] = wd;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::DualQuaternion</div>
<div class="line">GLTFWriter::Test::DualQuaternion::Conjugate()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    DualQuaternion tmp;</div>
<div class="line">    tmp.rotation = rotation.Conjugate();</div>
<div class="line">    tmp.translation = translation.Conjugate();</div>
<div class="line">    <span class="keywordflow">return</span> tmp;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::DualQuaternion</div>
<div class="line">GLTFWriter::Test::DualQuaternion::Inverse()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    DualQuaternion tmp;</div>
<div class="line">    tmp.rotation = rotation.Conjugate(); <span class="comment">// really should be Inverse</span></div>
<div class="line">    tmp.translation = tmp.rotation * translation * tmp.rotation * -1;</div>
<div class="line">    <span class="keywordflow">return</span> tmp;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::DualQuaternion &amp;</div>
<div class="line">GLTFWriter::Test::DualQuaternion::operator+=(<span class="keyword">const</span> DualQuaternion &amp;q)</div>
<div class="line">{</div>
<div class="line">    rotation = (rotation + q.rotation).Normalize(); <span class="comment">// rotation quaternions must be normalized</span></div>
<div class="line">    translation += q.translation;</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::DualQuaternion &amp;</div>
<div class="line">GLTFWriter::Test::DualQuaternion::operator-=(<span class="keyword">const</span> DualQuaternion &amp;q)</div>
<div class="line">{</div>
<div class="line">    rotation = (rotation - q.rotation).Normalize(); <span class="comment">// rotation quaternions must be normalized</span></div>
<div class="line">    translation -= q.translation;</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::DualQuaternion &amp;</div>
<div class="line">GLTFWriter::Test::DualQuaternion::operator*=(<span class="keyword">const</span> DualQuaternion &amp;q)</div>
<div class="line">{</div>
<div class="line">    DualQuaternion tmp;</div>
<div class="line">    tmp.rotation = (rotation * q.rotation).Normalize(); <span class="comment">// rotation quaternions must be normalized</span></div>
<div class="line">    tmp.translation = rotation * q.translation + translation * q.rotation;</div>
<div class="line">    *<span class="keyword">this</span> = tmp;</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::DualQuaternion &amp;</div>
<div class="line">GLTFWriter::Test::DualQuaternion::operator*=(<span class="keywordtype">double</span> d)</div>
<div class="line">{</div>
<div class="line">    this-&gt;rotation = (this-&gt;rotation * d).Normalize();</div>
<div class="line">    this-&gt;translation *= d;</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">GLTFWriter::Test::DualQuaternion::GetPluckerCoordinates(<span class="keywordtype">double</span> &amp;angle, <span class="comment">// rotation</span></div>
<div class="line">    <span class="keywordtype">double</span> &amp;d, <span class="comment">// pitch</span></div>
<div class="line">    Vector3 &amp;l,</div>
<div class="line">    Vector3 &amp;m)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> wr = rotation[3];</div>
<div class="line">    Vector3 vr(rotation[0], rotation[1], rotation[2]);</div>
<div class="line">    <span class="keywordtype">double</span> wd = translation[3];</div>
<div class="line">    Vector3 vd(translation[0], translation[1], translation[2]);</div>
<div class="line">    <span class="keywordtype">double</span> vrd = 1.0 / std::sqrt(vr.Dot(vr));</div>
<div class="line"> </div>
<div class="line">    angle = 2 * std::acos(wr);</div>
<div class="line">    d = -2 * wd * vrd;</div>
<div class="line">    l = vr * vrd;</div>
<div class="line">    m = (vd - l * (d * wr / 2)) * vrd;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::DualQuaternion</div>
<div class="line">GLTFWriter::Test::DualQuaternion::Pow(<span class="keywordtype">double</span> t)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> angle;</div>
<div class="line">    <span class="keywordtype">double</span> d;</div>
<div class="line">    Vector3 l;</div>
<div class="line">    Vector3 m;</div>
<div class="line">    GetPluckerCoordinates(angle, d, l, m);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> s = std::sin(t * angle / 2);</div>
<div class="line">    <span class="keywordtype">double</span> c = std::cos(t * angle / 2);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// there is dual angle and dual number calculations going on </span></div>
<div class="line">    <span class="keywordtype">double</span> wr = c;</div>
<div class="line">    Vector3 vr = l * s;</div>
<div class="line">    <span class="keywordtype">double</span> wd = -t * d / 2 * s;</div>
<div class="line">    Vector3 vd = l * (t * d / 2 * c) + m * s;</div>
<div class="line"> </div>
<div class="line">    DualQuaternion tmp;</div>
<div class="line">    tmp.rotation[0] = vr[0];</div>
<div class="line">    tmp.rotation[1] = vr[1];</div>
<div class="line">    tmp.rotation[2] = vr[2];</div>
<div class="line">    tmp.rotation[3] = wr;</div>
<div class="line">    tmp.translation[0] = vd[0];</div>
<div class="line">    tmp.translation[1] = vd[1];</div>
<div class="line">    tmp.translation[2] = vd[2];</div>
<div class="line">    tmp.translation[3] = wd;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> tmp;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::DualQuaternion</div>
<div class="line">GLTFWriter::Test::DualQuaternion::Sclerp(<span class="keyword">const</span> DualQuaternion &amp;q,</div>
<div class="line">    <span class="keywordtype">double</span> t)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordtype">double</span> d = this-&gt;GetRotation().Dot(q.GetRotation());</div>
<div class="line">    DualQuaternion tmp = this-&gt;Inverse() * (q * (d &lt; 0 ? -1.0 : 1.0));</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span> * tmp.Pow(t);</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::Matrix4::Matrix4(<span class="keyword">const</span> Quaternion &amp;q)</div>
<div class="line">    : VectorBase&lt;16&gt;()</div>
<div class="line">{</div>
<div class="line">    Quaternion t = q.Normalize(); <span class="comment">// rotation quaternions must be normalized</span></div>
<div class="line"> </div>
<div class="line">    (*this)[0] = 1 - 2 * t[1] * t[1] - 2 * t[2] * t[2];</div>
<div class="line">    (*this)[1] = 2 * t[0] * t[1] + 2 * t[2] * t[3];</div>
<div class="line">    (*this)[2] = 2 * t[0] * t[2] - 2 * t[1] * t[3];</div>
<div class="line"> </div>
<div class="line">    (*this)[4] = 2 * t[0] * t[1] - 2 * t[2] * t[3];</div>
<div class="line">    (*this)[5] = 1 - 2 * t[0] * t[0] - 2 * t[2] * t[2];</div>
<div class="line">    (*this)[6] = 2 * t[1] * t[2] + 2 * t[0] * t[3];</div>
<div class="line"> </div>
<div class="line">    (*this)[8] = 2 * t[0] * t[2] + 2 * t[1] * t[3];</div>
<div class="line">    (*this)[9] = 2 * t[1] * t[2] - 2 * t[0] * t[3];</div>
<div class="line">    (*this)[10] = 1 - 2 * t[0] * t[0] - 2 * t[1] * t[1];</div>
<div class="line"> </div>
<div class="line">    (*this)[15] = 1;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::Matrix4::Matrix4(<span class="keyword">const</span> DualQuaternion &amp;q)</div>
<div class="line">    : VectorBase&lt;16&gt;()</div>
<div class="line">{</div>
<div class="line">    Quaternion qr = q.GetRotation();</div>
<div class="line"> </div>
<div class="line">    (*this)[0] = 1 - 2 * qr[1] * qr[1] - 2 * qr[2] * qr[2];</div>
<div class="line">    (*this)[1] = 2 * qr[0] * qr[1] + 2 * qr[2] * qr[3];</div>
<div class="line">    (*this)[2] = 2 * qr[0] * qr[2] - 2 * qr[1] * qr[3];</div>
<div class="line"> </div>
<div class="line">    (*this)[4] = 2 * qr[0] * qr[1] - 2 * qr[2] * qr[3];</div>
<div class="line">    (*this)[5] = 1 - 2 * qr[0] * qr[0] - 2 * qr[2] * qr[2];</div>
<div class="line">    (*this)[6] = 2 * qr[1] * qr[2] + 2 * qr[0] * qr[3];</div>
<div class="line"> </div>
<div class="line">    (*this)[8] = 2 * qr[0] * qr[2] + 2 * qr[1] * qr[3];</div>
<div class="line">    (*this)[9] = 2 * qr[1] * qr[2] - 2 * qr[0] * qr[3];</div>
<div class="line">    (*this)[10] = 1 - 2 * qr[0] * qr[0] - 2 * qr[1] * qr[1];</div>
<div class="line"> </div>
<div class="line">    Vector3 vt = q.GetTranslation();</div>
<div class="line"> </div>
<div class="line">    (*this)[12] = vt[0];</div>
<div class="line">    (*this)[13] = vt[1];</div>
<div class="line">    (*this)[14] = vt[2];</div>
<div class="line"> </div>
<div class="line">    (*this)[15] = 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">GLTFWriter::Test::Matrix4 &amp;</div>
<div class="line">GLTFWriter::Test::Matrix4::operator*=(<span class="keyword">const</span> Matrix4 &amp;m)</div>
<div class="line">{</div>
<div class="line">    Matrix4 tmp;</div>
<div class="line"> </div>
<div class="line">    tmp[0] = (*this)[0] * m[0] + (*this)[4] * m[1] + (*this)[8] * m[2] + (*this)[12] * m[3];</div>
<div class="line">    tmp[1] = (*this)[1] * m[0] + (*this)[5] * m[1] + (*this)[9] * m[2] + (*this)[13] * m[3];</div>
<div class="line">    tmp[2] = (*this)[2] * m[0] + (*this)[6] * m[1] + (*this)[10] * m[2] + (*this)[14] * m[3];</div>
<div class="line">    tmp[3] = (*this)[3] * m[0] + (*this)[7] * m[1] + (*this)[11] * m[2] + (*this)[15] * m[3];</div>
<div class="line"> </div>
<div class="line">    tmp[4] = (*this)[0] * m[4] + (*this)[4] * m[5] + (*this)[8] * m[6] + (*this)[12] * m[7];</div>
<div class="line">    tmp[5] = (*this)[1] * m[4] + (*this)[5] * m[5] + (*this)[9] * m[6] + (*this)[13] * m[7];</div>
<div class="line">    tmp[6] = (*this)[2] * m[4] + (*this)[6] * m[5] + (*this)[10] * m[6] + (*this)[14] * m[7];</div>
<div class="line">    tmp[7] = (*this)[3] * m[4] + (*this)[7] * m[5] + (*this)[11] * m[6] + (*this)[15] * m[7];</div>
<div class="line"> </div>
<div class="line">    tmp[8] = (*this)[0] * m[8] + (*this)[4] * m[9] + (*this)[8] * m[10] + (*this)[12] * m[11];</div>
<div class="line">    tmp[9] = (*this)[1] * m[8] + (*this)[5] * m[9] + (*this)[9] * m[10] + (*this)[13] * m[11];</div>
<div class="line">    tmp[10] = (*this)[2] * m[8] + (*this)[6] * m[9] + (*this)[10] * m[10] + (*this)[14] * m[11];</div>
<div class="line">    tmp[11] = (*this)[3] * m[8] + (*this)[7] * m[9] + (*this)[11] * m[10] + (*this)[15] * m[11];</div>
<div class="line"> </div>
<div class="line">    tmp[12] = (*this)[0] * m[12] + (*this)[4] * m[13] + (*this)[8] * m[14] + (*this)[12] * m[15];</div>
<div class="line">    tmp[13] = (*this)[1] * m[12] + (*this)[5] * m[13] + (*this)[9] * m[14] + (*this)[13] * m[15];</div>
<div class="line">    tmp[14] = (*this)[2] * m[12] + (*this)[6] * m[13] + (*this)[10] * m[14] + (*this)[14] * m[15];</div>
<div class="line">    tmp[15] = (*this)[3] * m[12] + (*this)[7] * m[13] + (*this)[11] * m[14] + (*this)[15] * m[15];</div>
<div class="line"> </div>
<div class="line">    *<span class="keyword">this</span> = tmp;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">GLTFWriter::Test::Vector4</div>
<div class="line">GLTFWriter::Test::Matrix4::operator*(<span class="keyword">const</span> Vector4 &amp;v)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    Vector4 tmp;</div>
<div class="line"> </div>
<div class="line">    tmp[0] = (*this)[0] * v[0] + (*this)[4] * v[1] + (*this)[8] * v[2] + (*this)[12] * v[3];</div>
<div class="line">    tmp[1] = (*this)[1] * v[0] + (*this)[5] * v[1] + (*this)[9] * v[2] + (*this)[13] * v[3];</div>
<div class="line">    tmp[2] = (*this)[2] * v[0] + (*this)[6] * v[1] + (*this)[10] * v[2] + (*this)[14] * v[3];</div>
<div class="line">    tmp[3] = (*this)[3] * v[0] + (*this)[7] * v[1] + (*this)[11] * v[2] + (*this)[15] * v[3];</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> tmp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">GLTFWriter::Test::Matrix4::LoadIdentity()</div>
<div class="line">{</div>
<div class="line">    Clear();</div>
<div class="line">    (*this)[0] = (*this)[5] = (*this)[10] = (*this)[15] = 1;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">bool</span></div>
<div class="line">GLTFWriter::Test::Matrix4::IsIdentity()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> (*<span class="keyword">this</span>)[0] == 1 &amp;&amp; (*this)[1] == 0 &amp;&amp; (*this)[2] == 0 &amp;&amp; (*this)[3] == 0 &amp;&amp;</div>
<div class="line">        (*this)[4] == 0 &amp;&amp; (*this)[5] == 1 &amp;&amp; (*this)[6] == 0 &amp;&amp; (*this)[7] == 0 &amp;&amp;</div>
<div class="line">        (*this)[8] == 0 &amp;&amp; (*this)[9] == 0 &amp;&amp; (*this)[10] == 1 &amp;&amp; (*this)[11] == 0 &amp;&amp;</div>
<div class="line">        (*this)[12] == 0 &amp;&amp; (*this)[13] == 0 &amp;&amp; (*this)[14] == 0 &amp;&amp; (*this)[15] == 1;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">GLTFWriter::Test::Matrix4::LoadScale(<span class="keyword">const</span> Vector3 &amp;v)</div>
<div class="line">{</div>
<div class="line">    LoadIdentity();</div>
<div class="line">    (*this)[0] = v[0];</div>
<div class="line">    (*this)[5] = v[1];</div>
<div class="line">    (*this)[10] = v[2];</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">GLTFWriter::Test::Matrix4::LoadTranslate(<span class="keyword">const</span> Vector3 &amp;v)</div>
<div class="line">{</div>
<div class="line">    LoadIdentity();</div>
<div class="line">    (*this)[12] = v[0];</div>
<div class="line">    (*this)[13] = v[1];</div>
<div class="line">    (*this)[14] = v[2];</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">GLTFWriter::Test::Matrix4::LoadRotation(<span class="keyword">const</span> Vector3 &amp;l1,</div>
<div class="line">    <span class="keyword">const</span> Vector3 &amp;l2,</div>
<div class="line">    <span class="keywordtype">double</span> angle)</div>
<div class="line">{</div>
<div class="line">    Vector3 vec(l2[0] - l1[0], l2[1] - l1[1], l2[2] - l1[2]);</div>
<div class="line">    vec.Normalize();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> a = l1[0];</div>
<div class="line">    <span class="keywordtype">double</span> b = l1[1];</div>
<div class="line">    <span class="keywordtype">double</span> c = l1[2];</div>
<div class="line">    <span class="keywordtype">double</span> u = vec[0];</div>
<div class="line">    <span class="keywordtype">double</span> v = vec[1];</div>
<div class="line">    <span class="keywordtype">double</span> w = vec[2];</div>
<div class="line">    <span class="keywordtype">double</span> u2 = u * u;</div>
<div class="line">    <span class="keywordtype">double</span> v2 = v * v;</div>
<div class="line">    <span class="keywordtype">double</span> w2 = w * w;</div>
<div class="line">    <span class="keywordtype">double</span> sinA = std::sin(angle);</div>
<div class="line">    <span class="keywordtype">double</span> cosA = std::cos(angle);</div>
<div class="line"> </div>
<div class="line">    LoadIdentity();</div>
<div class="line">    (*this)[0] = u2 * (1 - cosA) + cosA;</div>
<div class="line">    (*this)[1] = u * v * (1 - cosA) + w * sinA;</div>
<div class="line">    (*this)[2] = u * w * (1 - cosA) - v * sinA;</div>
<div class="line"> </div>
<div class="line">    (*this)[4] = u * v * (1 - cosA) - w * sinA;</div>
<div class="line">    (*this)[5] = v2 * (1 - cosA) + cosA;</div>
<div class="line">    (*this)[6] = v * w * (1 - cosA) + u * sinA;</div>
<div class="line"> </div>
<div class="line">    (*this)[8] = u * w * (1 - cosA) + v * sinA;</div>
<div class="line">    (*this)[9] = v * w * (1 - cosA) - u * sinA;</div>
<div class="line">    (*this)[10] = w2 * (1 - cosA) + cosA;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//    (*this)[12] = (a * (v2 + w2) - u * (b * v + c * w)) * (1 - cosA) + (b * w - c * v) * sinA;</span></div>
<div class="line">    (*this)[12] = a - (*this)[0] * a - (*this)[4] * b - (*this)[8] * c;</div>
<div class="line">    <span class="comment">//    (*this)[13] = (b * (u2 + w2) - v * (a * u + c * w)) * (1 - cosA) + (c * u - a * w) * sinA;</span></div>
<div class="line">    (*this)[13] = b - (*this)[1] * a - (*this)[5] * b - (*this)[9] * c;</div>
<div class="line">    <span class="comment">//    (*this)[14] = (c * (u2 + v2) - w * (a * u + b * v)) * (1 - cosA) + (a * v - b * u) * sinA;</span></div>
<div class="line">    (*this)[14] = c - (*this)[2] * a - (*this)[6] * b - (*this)[10] * c;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">GLTFWriter::Test::Vector3</div>
<div class="line">GLTFWriter::Test::Matrix4::GetScale()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    Vector3 tmp;</div>
<div class="line"> </div>
<div class="line">    tmp[0] = std::sqrt((*<span class="keyword">this</span>)[0] * (*<span class="keyword">this</span>)[0] + (*<span class="keyword">this</span>)[1] * (*<span class="keyword">this</span>)[1] + (*<span class="keyword">this</span>)[2] * (*<span class="keyword">this</span>)[2]);</div>
<div class="line">    tmp[1] = std::sqrt((*<span class="keyword">this</span>)[4] * (*<span class="keyword">this</span>)[4] + (*<span class="keyword">this</span>)[5] * (*<span class="keyword">this</span>)[5] + (*<span class="keyword">this</span>)[6] * (*<span class="keyword">this</span>)[6]);</div>
<div class="line">    tmp[2] = std::sqrt((*<span class="keyword">this</span>)[8] * (*<span class="keyword">this</span>)[8] + (*<span class="keyword">this</span>)[9] * (*<span class="keyword">this</span>)[9] + (*<span class="keyword">this</span>)[10] * (*<span class="keyword">this</span>)[10]);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> tmp;</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::Vector3</div>
<div class="line">GLTFWriter::Test::Matrix4::GetTranslate()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> Vector3((*<span class="keyword">this</span>)[12], (*<span class="keyword">this</span>)[13], (*<span class="keyword">this</span>)[14]);</div>
<div class="line">}</div>
<div class="line">GLTFWriter::Test::Quaternion</div>
<div class="line">GLTFWriter::Test::Matrix4::GetQuaternion()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    Vector3 scale = GetScale();</div>
<div class="line">    <span class="keywordtype">double</span> v0 = (*this)[0] / scale[0];</div>
<div class="line">    <span class="keywordtype">double</span> v1 = (*this)[1] / scale[0];</div>
<div class="line">    <span class="keywordtype">double</span> v2 = (*this)[2] / scale[0];</div>
<div class="line">    <span class="keywordtype">double</span> v4 = (*this)[4] / scale[1];</div>
<div class="line">    <span class="keywordtype">double</span> v5 = (*this)[5] / scale[1];</div>
<div class="line">    <span class="keywordtype">double</span> v6 = (*this)[6] / scale[1];</div>
<div class="line">    <span class="keywordtype">double</span> v8 = (*this)[8] / scale[2];</div>
<div class="line">    <span class="keywordtype">double</span> v9 = (*this)[9] / scale[2];</div>
<div class="line">    <span class="keywordtype">double</span> v10 = (*this)[10] / scale[2];</div>
<div class="line">    <span class="keywordtype">bool</span> t1 = v0 + v5 + v10 &gt; 0;</div>
<div class="line">    <span class="keywordtype">bool</span> t2 = v0 &gt; v5 &amp;&amp; v0 &gt; v10;</div>
<div class="line">    <span class="keywordtype">bool</span> t3 = v5 &gt; v10;</div>
<div class="line">    <span class="keywordtype">double</span> t4 = 2 * (t1 ? (std::sqrt(1 + v0 + v5 + v10))</div>
<div class="line">        : (t2 ? (std::sqrt(1 + v0 - v5 - v10))</div>
<div class="line">            : (t3 ? (std::sqrt(1 - v0 + v5 - v10))</div>
<div class="line">                : (std::sqrt(1 - v0 - v5 + v10)))));</div>
<div class="line">    <span class="keywordtype">double</span> x = t1 ? ((v6 - v9) / t4)</div>
<div class="line">        : (t2 ? (0.25 * t4)</div>
<div class="line">            : (t3 ? ((v4 + v1) / t4)</div>
<div class="line">                : ((v8 + v2) / t4)));</div>
<div class="line">    <span class="keywordtype">double</span> y = t1 ? ((v8 - v2) / t4)</div>
<div class="line">        : (t2 ? ((v4 + v1) / t4)</div>
<div class="line">            : (t3 ? (0.25 * t4)</div>
<div class="line">                : ((v9 + v6) / t4)));</div>
<div class="line">    <span class="keywordtype">double</span> z = t1 ? ((v1 - v4) / t4)</div>
<div class="line">        : (t2 ? ((v8 + v2) / t4)</div>
<div class="line">            : (t3 ? ((v9 + v6) / t4)</div>
<div class="line">                : (0.25 * t4)));</div>
<div class="line">    <span class="keywordtype">double</span> w = t1 ? (0.25 * t4)</div>
<div class="line">        : (t2 ? ((v6 - v9) / t4)</div>
<div class="line">            : (t3 ? ((v8 - v2) / t4)</div>
<div class="line">                : ((v1 - v4) / t4)));</div>
<div class="line">    <span class="keywordflow">return</span> Quaternion(x, y, z, w).Normalize(); <span class="comment">// rotation quaternions must be normalized</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">GLTFWriter::Test::Matrix4</div>
<div class="line">GLTFWriter::Test::Matrix4::Transpose()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    Matrix4 tmp;</div>
<div class="line"> </div>
<div class="line">    tmp[0] = (*this)[0];</div>
<div class="line">    tmp[1] = (*this)[4];</div>
<div class="line">    tmp[2] = (*this)[8];</div>
<div class="line">    tmp[3] = (*this)[12];</div>
<div class="line">    tmp[4] = (*this)[1];</div>
<div class="line">    tmp[5] = (*this)[5];</div>
<div class="line">    tmp[6] = (*this)[9];</div>
<div class="line">    tmp[7] = (*this)[13];</div>
<div class="line">    tmp[8] = (*this)[2];</div>
<div class="line">    tmp[9] = (*this)[6];</div>
<div class="line">    tmp[10] = (*this)[10];</div>
<div class="line">    tmp[11] = (*this)[14];</div>
<div class="line">    tmp[12] = (*this)[3];</div>
<div class="line">    tmp[13] = (*this)[7];</div>
<div class="line">    tmp[14] = (*this)[11];</div>
<div class="line">    tmp[15] = (*this)[15];</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> tmp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span></div>
<div class="line">GLTFWriter::Test::Matrix4::Determinant()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span>   (*<span class="keyword">this</span>)[12] * (*this)[9] * (*this)[6] * (*this)[3]</div>
<div class="line">        - (*this)[8] * (*this)[13] * (*this)[6] * (*this)[3]</div>
<div class="line">        - (*this)[12] * (*this)[5] * (*this)[10] * (*this)[3]</div>
<div class="line">        + (*this)[4] * (*this)[13] * (*this)[10] * (*this)[3]</div>
<div class="line">        + (*this)[8] * (*this)[5] * (*this)[14] * (*this)[3]</div>
<div class="line">        - (*this)[4] * (*this)[9] * (*this)[14] * (*this)[3]</div>
<div class="line">        - (*this)[12] * (*this)[9] * (*this)[2] * (*this)[7]</div>
<div class="line">        + (*this)[8] * (*this)[13] * (*this)[2] * (*this)[7]</div>
<div class="line">        + (*this)[12] * (*this)[1] * (*this)[10] * (*this)[7]</div>
<div class="line">        - (*this)[0] * (*this)[13] * (*this)[10] * (*this)[7]</div>
<div class="line">        - (*this)[8] * (*this)[1] * (*this)[14] * (*this)[7]</div>
<div class="line">        + (*this)[0] * (*this)[9] * (*this)[14] * (*this)[7]</div>
<div class="line">        + (*this)[12] * (*this)[5] * (*this)[2] * (*this)[11]</div>
<div class="line">        - (*this)[4] * (*this)[13] * (*this)[2] * (*this)[11]</div>
<div class="line">        - (*this)[12] * (*this)[1] * (*this)[6] * (*this)[11]</div>
<div class="line">        + (*this)[0] * (*this)[13] * (*this)[6] * (*this)[11]</div>
<div class="line">        + (*this)[4] * (*this)[1] * (*this)[14] * (*this)[11]</div>
<div class="line">        - (*this)[0] * (*this)[5] * (*this)[14] * (*this)[11]</div>
<div class="line">        - (*this)[8] * (*this)[5] * (*this)[2] * (*this)[15]</div>
<div class="line">        + (*this)[4] * (*this)[9] * (*this)[2] * (*this)[15]</div>
<div class="line">        + (*this)[8] * (*this)[1] * (*this)[6] * (*this)[15]</div>
<div class="line">        - (*this)[0] * (*this)[9] * (*this)[6] * (*this)[15]</div>
<div class="line">        - (*this)[4] * (*this)[1] * (*this)[10] * (*this)[15]</div>
<div class="line">        + (*this)[0] * (*this)[5] * (*this)[10] * (*this)[15];</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">GLTFWriter::Test::Matrix4</div>
<div class="line">GLTFWriter::Test::Matrix4::Inverse()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    Matrix4 tmp;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> det = Determinant();</div>
<div class="line">    assert(det != 0);</div>
<div class="line"> </div>
<div class="line">    tmp[0] = ((*this)[9] * (*this)[14] * (*this)[7] - (*this)[13] * (*this)[10] * (*this)[7] + (*this)[13] * (*this)[6] * (*this)[11] - (*this)[5] * (*this)[14] * (*this)[11] - (*this)[9] * (*this)[6] * (*this)[15] + (*this)[5] * (*this)[10] * (*this)[15]) / det;</div>
<div class="line">    tmp[1] = ((*this)[13] * (*this)[10] * (*this)[3] - (*this)[9] * (*this)[14] * (*this)[3] - (*this)[13] * (*this)[2] * (*this)[11] + (*this)[1] * (*this)[14] * (*this)[11] + (*this)[9] * (*this)[2] * (*this)[15] - (*this)[1] * (*this)[10] * (*this)[15]) / det;</div>
<div class="line">    tmp[2] = ((*this)[5] * (*this)[14] * (*this)[3] - (*this)[13] * (*this)[6] * (*this)[3] + (*this)[13] * (*this)[2] * (*this)[7] - (*this)[1] * (*this)[14] * (*this)[7] - (*this)[5] * (*this)[2] * (*this)[15] + (*this)[1] * (*this)[6] * (*this)[15]) / det;</div>
<div class="line">    tmp[3] = ((*this)[9] * (*this)[6] * (*this)[3] - (*this)[5] * (*this)[10] * (*this)[3] - (*this)[9] * (*this)[2] * (*this)[7] + (*this)[1] * (*this)[10] * (*this)[7] + (*this)[5] * (*this)[2] * (*this)[11] - (*this)[1] * (*this)[6] * (*this)[11]) / det;</div>
<div class="line">    tmp[4] = ((*this)[12] * (*this)[10] * (*this)[7] - (*this)[8] * (*this)[14] * (*this)[7] - (*this)[12] * (*this)[6] * (*this)[11] + (*this)[4] * (*this)[14] * (*this)[11] + (*this)[8] * (*this)[6] * (*this)[15] - (*this)[4] * (*this)[10] * (*this)[15]) / det;</div>
<div class="line">    tmp[5] = ((*this)[8] * (*this)[14] * (*this)[3] - (*this)[12] * (*this)[10] * (*this)[3] + (*this)[12] * (*this)[2] * (*this)[11] - (*this)[0] * (*this)[14] * (*this)[11] - (*this)[8] * (*this)[2] * (*this)[15] + (*this)[0] * (*this)[10] * (*this)[15]) / det;</div>
<div class="line">    tmp[6] = ((*this)[12] * (*this)[6] * (*this)[3] - (*this)[4] * (*this)[14] * (*this)[3] - (*this)[12] * (*this)[2] * (*this)[7] + (*this)[0] * (*this)[14] * (*this)[7] + (*this)[4] * (*this)[2] * (*this)[15] - (*this)[0] * (*this)[6] * (*this)[15]) / det;</div>
<div class="line">    tmp[7] = ((*this)[4] * (*this)[10] * (*this)[3] - (*this)[8] * (*this)[6] * (*this)[3] + (*this)[8] * (*this)[2] * (*this)[7] - (*this)[0] * (*this)[10] * (*this)[7] - (*this)[4] * (*this)[2] * (*this)[11] + (*this)[0] * (*this)[6] * (*this)[11]) / det;</div>
<div class="line">    tmp[8] = ((*this)[8] * (*this)[13] * (*this)[7] - (*this)[12] * (*this)[9] * (*this)[7] + (*this)[12] * (*this)[5] * (*this)[11] - (*this)[4] * (*this)[13] * (*this)[11] - (*this)[8] * (*this)[5] * (*this)[15] + (*this)[4] * (*this)[9] * (*this)[15]) / det;</div>
<div class="line">    tmp[9] = ((*this)[12] * (*this)[9] * (*this)[3] - (*this)[8] * (*this)[13] * (*this)[3] - (*this)[12] * (*this)[1] * (*this)[11] + (*this)[0] * (*this)[13] * (*this)[11] + (*this)[8] * (*this)[1] * (*this)[15] - (*this)[0] * (*this)[9] * (*this)[15]) / det;</div>
<div class="line">    tmp[10] = ((*this)[4] * (*this)[13] * (*this)[3] - (*this)[12] * (*this)[5] * (*this)[3] + (*this)[12] * (*this)[1] * (*this)[7] - (*this)[0] * (*this)[13] * (*this)[7] - (*this)[4] * (*this)[1] * (*this)[15] + (*this)[0] * (*this)[5] * (*this)[15]) / det;</div>
<div class="line">    tmp[11] = ((*this)[8] * (*this)[5] * (*this)[3] - (*this)[4] * (*this)[9] * (*this)[3] - (*this)[8] * (*this)[1] * (*this)[7] + (*this)[0] * (*this)[9] * (*this)[7] + (*this)[4] * (*this)[1] * (*this)[11] - (*this)[0] * (*this)[5] * (*this)[11]) / det;</div>
<div class="line">    tmp[12] = ((*this)[12] * (*this)[9] * (*this)[6] - (*this)[8] * (*this)[13] * (*this)[6] - (*this)[12] * (*this)[5] * (*this)[10] + (*this)[4] * (*this)[13] * (*this)[10] + (*this)[8] * (*this)[5] * (*this)[14] - (*this)[4] * (*this)[9] * (*this)[14]) / det;</div>
<div class="line">    tmp[13] = ((*this)[8] * (*this)[13] * (*this)[2] - (*this)[12] * (*this)[9] * (*this)[2] + (*this)[12] * (*this)[1] * (*this)[10] - (*this)[0] * (*this)[13] * (*this)[10] - (*this)[8] * (*this)[1] * (*this)[14] + (*this)[0] * (*this)[9] * (*this)[14]) / det;</div>
<div class="line">    tmp[14] = ((*this)[12] * (*this)[5] * (*this)[2] - (*this)[4] * (*this)[13] * (*this)[2] - (*this)[12] * (*this)[1] * (*this)[6] + (*this)[0] * (*this)[13] * (*this)[6] + (*this)[4] * (*this)[1] * (*this)[14] - (*this)[0] * (*this)[5] * (*this)[14]) / det;</div>
<div class="line">    tmp[15] = ((*this)[4] * (*this)[9] * (*this)[2] - (*this)[8] * (*this)[5] * (*this)[2] + (*this)[8] * (*this)[1] * (*this)[6] - (*this)[0] * (*this)[9] * (*this)[6] - (*this)[4] * (*this)[1] * (*this)[10] + (*this)[0] * (*this)[5] * (*this)[10]) / det;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> tmp;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_a_n_s_y_s_1_1_nexus_1_1_g_l_t_f_writer_1_1_material_xhtml"><div class="ttname"><a href="class_a_n_s_y_s_1_1_nexus_1_1_g_l_t_f_writer_1_1_material.xhtml">ANSYS::Nexus::GLTFWriter::Material</a></div><div class="ttdoc">Materials describe how primitives are rendered.</div><div class="ttdef"><b>Definition:</b> <a href="_g_l_t_f_material_8h_source.xhtml#l00029">GLTFMaterial.h:30</a></div></div>
<div class="ttc" id="aclass_a_n_s_y_s_1_1_nexus_1_1_g_l_t_f_writer_1_1_texture_xhtml"><div class="ttname"><a href="class_a_n_s_y_s_1_1_nexus_1_1_g_l_t_f_writer_1_1_texture.xhtml">ANSYS::Nexus::GLTFWriter::Texture</a></div><div class="ttdoc">Textures are images that can be used to color a primitive.</div><div class="ttdef"><b>Definition:</b> <a href="_g_l_t_f_texture_8h_source.xhtml#l00027">GLTFTexture.h:28</a></div></div>
</div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/>
<small>&#160;&#160;&copy; <script type="text/javascript">document.write(new Date().getFullYear());</script> ANSYS Inc. All rights reserved.</small>
 <span style="float:right"><small>Generated by <a href="http://www.doxygen.org/index.html">doxygen</a>&nbsp;&nbsp;</small></span>
